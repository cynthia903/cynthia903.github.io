<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> Qida's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="学习笔记 知识总结 思考感悟"><meta name="keywords"><meta name="author" content="Qida's Blog"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://qidawu.github.io/atom.xml" title="Qida's Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><a href="/" class="title-link">Qida's Blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/30/javascript-dynamic-scripts/" class="post-title-link">Javascript 动态加载脚本</a></h2><div class="post-info">2016-04-30<a href="/tags/前端/" title="前端" class="post-demo">前端</a></div><div class="post-content"><p>本文演示如何动态加载脚本。即脚本在页面加载时不存在，但将来的某一时刻通过修改 DOM 动态添加脚本，从而实现按需加载脚本。</p>
<h1 id="加载脚本文件"><a href="#加载脚本文件" class="headerlink" title="加载脚本文件"></a>加载脚本文件</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptFile</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    script.src = url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行到这行代码将 &lt;script&gt; 元素添加到页面之前，不会下载指定外部文件</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="内联脚本代码"><a href="#内联脚本代码" class="headerlink" title="内联脚本代码"></a>内联脚本代码</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    script.text = code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行到这行代码将 &lt;script&gt; 元素添加到页面之前，不会下载指定外部文件</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以这种方式加载的代码会在全局作用域中执行，而且当脚本执行后将立即可用。实际上，这样执行代码与在全局作用域中把相同的字符串传递给 <code>eval()</code> 是一样的。</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/05/git-branch-in-action/" class="post-title-link">Git 实战系列（十三）Git 分支模型实践</a></h2><div class="post-info">2016-04-05<a href="/tags/Git/" title="Git" class="post-demo">Git</a></div><div class="post-content"><p>有了一套成熟的<a href="/2016/04/03/git-branch/">分支模型</a>以及配套的<a href="/2016/04/04/git-permissions/">权限控制</a>之后，接下来我们以一个例子来演示如何实践这套流程。</p>
<h1 id="分支模型实践"><a href="#分支模型实践" class="headerlink" title="分支模型实践"></a>分支模型实践</h1><h2 id="创建版本分支"><a href="#创建版本分支" class="headerlink" title="创建版本分支"></a>创建版本分支</h2><p>首先，项目管理员（Master）从 <code>master</code> 分支中创建出版本分支 <code>release-*</code> 进行新版本的开发，<code>*</code> 为发布日期：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b release-20190101</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> something and commit...</span><br><span class="line"></span><br><span class="line">$ git push origin release-20190101</span><br></pre></td></tr></table></figure>

<p>版本分支 <code>release-*</code> 一般是锁起来的，不允许随便提交代码。</p>
<h2 id="创建特性分支"><a href="#创建特性分支" class="headerlink" title="创建特性分支"></a>创建特性分支</h2><p>然后，开发人员（Developer）从版本分支中创建出特性分支，并在其上进行特性开发：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-test</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> something and commit...</span><br><span class="line"></span><br><span class="line">$ git push origin feature-test</span><br></pre></td></tr></table></figure>

<p>由于特性分支可能会跨版本开发，因此需要定期维护：主要的工作就是定期将 <code>master</code> 分支或版本分支合并进来，保持同步，代码够新。使用命令：<a href="https://qidawu.github.io/2015/08/20/git-rebase/">rebase</a>。</p>
<h2 id="Merge-Request"><a href="#Merge-Request" class="headerlink" title="Merge Request"></a>Merge Request</h2><p>开发完毕后，开发人员（Developer）需要<strong>整理特性分支</strong>——例如从中挑选出能够发版的提交，剔除掉不能发版的提交。如果想要筛选出将要被合并的提交有哪些，可以参考<a href="/2015/08/04/git-log/#筛选提交历史">这里</a>。</p>
<p>整理完毕后，给项目管理员（Master）发起一个 MR，请求合并到版本分支。</p>
<h2 id="标记新版本"><a href="#标记新版本" class="headerlink" title="标记新版本"></a>标记新版本</h2><p>当版本分支发布完毕，Master 打 Tag 标记该新版本，以便后续回顾：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag tag-20190101 -m <span class="string">"XX 项目 v1.0 版本"</span></span><br><span class="line">$ git push origin tag-20190101</span><br></pre></td></tr></table></figure>

<p>注意，在默认情况下，<code>git push</code> 并不会把标签（tag）推送到远端仓库上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 <code>git push origin [tagname]</code> 即可。如果要一次推送所有本地新增的标签上去，可以使用 <code>--tags</code> 选项。</p>
<h2 id="清理分支"><a href="#清理分支" class="headerlink" title="清理分支"></a>清理分支</h2><p>最后是一些清理工作，Master 需要删除已完成开发的版本分支、特性分支，避免分支越来越多导致不好管理。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d release-20190101</span><br><span class="line">$ git push --delete origin release-20190101</span><br></pre></td></tr></table></figure>

<p>最后，列出所有远程和本地分支确认下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="代码提交指南"><a href="#代码提交指南" class="headerlink" title="代码提交指南"></a>代码提交指南</h2><ul>
<li>请不要在更新中提交多余的白字符（whitespace）。Git 有种检查此类问题的方法，在提交之前，先运行 <code>git diff --check</code> ，会把可能的多余白字符修正列出来。</li>
<li>请将每次提交限定于完成一次逻辑功能。并且可能的话，适当地分解为多次小更新，以便每次小型提交都更易于理解。</li>
<li>最后需要谨记的是提交说明的撰写。可以理解为第一行的简要描述将用作邮件标题，其余部分作为邮件正文。</li>
</ul>
<h2 id="分支管理指南"><a href="#分支管理指南" class="headerlink" title="分支管理指南"></a>分支管理指南</h2><ul>
<li>主分支 <code>master</code> 一般不提交代码，只合并代码。</li>
<li>各特性分支要定期将 <code>master</code> 分支合并进来，避免后续处理合并请求时产生冲突，以减轻项目管理员的工作负担。</li>
<li>发版之后，项目管理员要记得打 tag 。</li>
</ul>
<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h2><p>查看本地分支和远程分支的跟踪关系：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line"></span><br><span class="line">* feature-modify-remit-recon f898c3c [origin/feature-modify-remit-recon: ahead 2, behind 6] chore:xxx</span><br><span class="line">  feature-recon-history      cfbf905 [origin/feature-recon-history] Merge branch master into feature-recon-history</span><br><span class="line">  master                     e1f5e67 [origin/master] chore:xxx</span><br></pre></td></tr></table></figure>

<p>设置本地分支 <code>master</code> 跟踪远程分支 <code>origin/&lt;branch&gt;</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream-to=origin/&lt;branch&gt; master</span><br></pre></td></tr></table></figure>

<h2 id="删除本地远程分支"><a href="#删除本地远程分支" class="headerlink" title="删除本地远程分支"></a>删除本地远程分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r</span><br><span class="line">--remotes</span><br><span class="line">List or delete (if used with -d) the remote-tracking branches.</span><br></pre></td></tr></table></figure>

<p>删除本地远程分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r -d origin/branch-name</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《<a href="https://git-scm.com/book/zh/v1/%E5%88%86%E5%B8%83%E5%BC%8F-Git" target="_blank" rel="noopener">分布式 Git</a>》</li>
</ul>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/04/git-permissions/" class="post-title-link">Git 实战系列（十二）Git 权限控制</a></h2><div class="post-info">2016-04-04<a href="/tags/Git/" title="Git" class="post-demo">Git</a></div><div class="post-content"><p>除了 Git 命令，权限控制也是 Git 中极为重要的组成部分，本文主要介绍 GitLab 系统提供的最常用的权限控制功能。</p>
<h1 id="分配成员角色"><a href="#分配成员角色" class="headerlink" title="分配成员角色"></a>分配成员角色</h1><p>首先来了解下，Git 中的五种角色：</p>
<table>
<thead>
<tr>
<th>角色</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Owner</td>
<td>Git 系统管理员</td>
</tr>
<tr>
<td>Master</td>
<td>Git 项目管理员</td>
</tr>
<tr>
<td>Developer</td>
<td>Git 项目开发人员</td>
</tr>
<tr>
<td>Reporter</td>
<td>Git 项目测试人员</td>
</tr>
<tr>
<td>Guest</td>
<td>访客</td>
</tr>
</tbody></table>
<p>每一种角色所拥有的权限都不同，如下图：</p>
<p><img src="/img/git/git_permissions.png" alt="Git 权限控制"></p>
<p>我们需要做的是，为项目成员分配恰当的角色，以限制其权限。</p>
<h1 id="Protected-Branches"><a href="#Protected-Branches" class="headerlink" title="Protected Branches"></a>Protected Branches</h1><p>在对 Git 不熟悉的时候，时常苦恼于各个分支不受约束，任何开发人员都可以向任何分支直接推送任何提交，各种未经审查的代码、花样百出的 Bug 就这样流窜在预发布分支上。</p>
<p>其实我们可以通过 GitLab 的<strong>受保护分支（Protected Branches）</strong>功能解决该问题，该功能可用于：</p>
<blockquote>
<p>Keep stable branches secure and force developers to use <strong>merge requests</strong>.</p>
<p>By default, protected branches are designed to:</p>
<ul>
<li>prevent their creation, if not already created, from everybody except Masters</li>
<li>prevent pushes from everybody except Masters</li>
<li>prevent <strong>anyone</strong> from force pushing to the branch</li>
<li>prevent <strong>anyone</strong> from deleting the branch</li>
</ul>
</blockquote>
<p>接下来我们就使用这项功能，锁定我们的受保护分支——主分支 <code>master</code> 和预发布分支 <code>release-*</code>，以阻止 Developer 直接向这两类分支中推送代码：</p>
<p><img src="/img/git/git_protected_branches.png" alt="Git 受保护分支"></p>
<p>锁定后，Developer 推送代码将会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">Counting objects: 4, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2&#x2F;2), done.</span><br><span class="line">Writing objects: 100% (3&#x2F;3), 283 bytes | 0 bytes&#x2F;s, done.</span><br><span class="line">Total 3 (delta 1), reused 1 (delta 0)</span><br><span class="line">remote: GitLab: You are not allowed to access master!</span><br><span class="line">remote: error: hook declined to update refs&#x2F;heads&#x2F;master</span><br><span class="line">To git@website:project.git</span><br><span class="line"> ! [remote rejected] master -&gt; master (hook declined)</span><br><span class="line">error: failed to push some refs to &#39;git@website:project.git&#39;</span><br></pre></td></tr></table></figure>

<h1 id="Merge-Requests"><a href="#Merge-Requests" class="headerlink" title="Merge Requests"></a>Merge Requests</h1><p>锁定受保护分支后，要么 Master 需要时刻、主动关注各特性分支的进度，要么 Developer 需要线下、口头向 Master 汇报其特性分支的进度，这两种做法都非常不便于 Master 管理每个预发布分支的合并，尤其在团队大、分支多的情况。</p>
<p>我们可以通过 GitLab 的<strong>发起合并请求（Merge Request）</strong>功能解决该问题，这样既可以让 Developer 更自如的掌控自己分支进度，在必要的时候才主动发起合并请求；又可以减轻 Master 的合并工作量和沟通成本，可谓一举两得。</p>
<h2 id="新建-MR"><a href="#新建-MR" class="headerlink" title="新建 MR"></a>新建 MR</h2><p>第一步，按表单要求填写合并请求。注意，对于 Developer 而言：</p>
<ul>
<li><code>Source branch</code> 是你的特性分支 <code>feature-*</code>；</li>
<li><code>Tagget branch</code> 只可能是预发布分支 <code>release-*</code>；</li>
<li><code>Title</code> 和 <code>Description</code> 要填写恰当的分支描述；</li>
<li><code>Assignee</code> 是该项目的 Master。</li>
</ul>
<p><img src="/img/git/git_new_merge_request.png" alt="新建合并请求"></p>
<h2 id="审查-MR"><a href="#审查-MR" class="headerlink" title="审查 MR"></a>审查 MR</h2><p>第二步，Master 收到合并请求后，进行代码审查。逐一查看 <code>Commits</code> 或 <code>Changes</code> 一栏提交的内容即可，对于需要改进的代码，可以直接在该行添加注释，非常方便。</p>
<p>如果对整个请求还有疑问的地方，还可以通过 <code>Discussion</code> 功能进行线上讨论。</p>
<h2 id="处理-MR"><a href="#处理-MR" class="headerlink" title="处理 MR"></a>处理 MR</h2><p>第三步，针对审查结果进行相应处理：</p>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>对于完全不合格的垃圾代码、或者废弃的特性分支的合并请求，Master 点击右上角的 <code>Close</code> 按钮即可。合并请求将被关闭，相当于扔进回收站。</p>
<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>对于分支内需改进的代码，Developer 直接修正并推送即可，合并请求将会自动包含最新的推送提交。</p>
<h3 id="接受"><a href="#接受" class="headerlink" title="接受"></a>接受</h3><p>Master 审查无误后，可以接受该次合并请求。点击 <code>Accept Merge Request</code> 按钮将自动合并分支，勾选 <code>Remove source-branch</code> 将同时删除该特性分支。</p>
<p>整个自动合并过程如果以命令形式手工执行的话，步骤如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Step 1. Update the repo and checkout the branch we are going to merge </span></span><br><span class="line">git fetch origin</span><br><span class="line">git checkout -b <span class="built_in">test</span> origin/feature-test</span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 2. Merge the branch and push the changes to GitLab </span></span><br><span class="line">git checkout release-2016.4.7</span><br><span class="line">git merge --no-ff feature-test</span><br><span class="line">git push origin release-2016.4.7</span><br></pre></td></tr></table></figure>

<p>以<a href="/2015/08/17/git-merge/#非快进式合并">非快进式合并</a>完成后，祖先图谱（graph）的展现结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   be512fa (HEAD, origin&#x2F;release-2016.4.7, release-2016.4.7)  Merge branch &#39;test&#39; into &#39;release-2016.4.7&#39;</span><br><span class="line">|\</span><br><span class="line">| * 1f52adf 测试</span><br><span class="line">|&#x2F;</span><br><span class="line">*   a4febbb (tag: 1.0.0, origin&#x2F;master) 格式化货币保留两位小数</span><br></pre></td></tr></table></figure>

<p>最后需要注意的是，只有 <code>Assignee</code> 才能够接受合并请求，其它人只会被通知：</p>
<blockquote>
<p>You don’t have permission to merge this MR</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>GitLab 提供的上述功能非常实用，为项目的源码管理提供了有力的支持。</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/03/git-branch/" class="post-title-link">Git 实战系列（十一）Git 分支模型总结</a></h2><div class="post-info">2016-04-03<a href="/tags/Git/" title="Git" class="post-demo">Git</a></div><div class="post-content"><p>项目总归要协作开发，在此总结我在团队中推广使用的分支模型。</p>
<p><img src="/img/git/git_branch.png" alt="A successful Git branching model"></p>
<h1 id="分支模型"><a href="#分支模型" class="headerlink" title="分支模型"></a>分支模型</h1><h2 id="主分支（Main-branches）"><a href="#主分支（Main-branches）" class="headerlink" title="主分支（Main branches）"></a>主分支（Main branches）</h2><p>企业的项目开发不像开源的项目开发，通常只会有一个远程仓库。这种情况下，通常会有两个常驻分支：</p>
<table>
<thead>
<tr>
<th>Branch Name</th>
<th>Is locked?</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>master</code></td>
<td>YES</td>
<td>主干分支，仅用于发布新版本，平时不能在上面干活，只做代码合并、以及打标记（<code>git tag</code>）。<br/> 理论上，每当对 <code>master</code> 分支有一个合并提交操作，我们就可以使用 Git 钩子脚本来自动构建并且发布软件到生产服务器。</td>
</tr>
<tr>
<td><code>dev</code></td>
<td>NO</td>
<td>开发分支，平时干活的地方。每当发版时，需要被合并到 <code>master</code>。</td>
</tr>
</tbody></table>
<p>对于简单的项目而言，这样的分支模型已经够用了。</p>
<h2 id="辅助性分支（Supporting-branches）"><a href="#辅助性分支（Supporting-branches）" class="headerlink" title="辅助性分支（Supporting branches）"></a>辅助性分支（Supporting branches）</h2><p>除了常驻分支，通常大的特性开发或生产缺陷修复还建议创建相应的临时分支。因为：</p>
<ol>
<li>在分支上开发可以让你随意尝试，进退自如，比如碰上无法正常工作的特性或补丁，可以先搁在那边，直到有时间仔细核查修复为止。</li>
<li>团队中如果有代码审查流程，独立的分支还可以留给审查者抽空审查的时间和改进代码的余地，并将是否合并、是否发布的权利留给审查者，为代码质量设一道门槛。</li>
</ol>
<p>每一类分支都有一个特定目的，如何命名每一类分支？建议用相关的主题关键字进行命名，并且建议将分支名称分置于不同<strong>命名空间（前缀）</strong>下，例如：</p>
<table>
<thead>
<tr>
<th>Branch Name</th>
<th>May branch off from</th>
<th>Must merge back into</th>
<th>Is locked?</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>feature-*</code></td>
<td><code>dev</code></td>
<td><code>dev</code></td>
<td>NO</td>
<td>特性分支，为了开发某种特定功能而建。开发完成并测试通过后，需发送 Merge Request 到 <code>release-*</code> 进行代码审查及合版。</td>
</tr>
<tr>
<td><code>release-*</code></td>
<td><code>dev</code></td>
<td><code>dev</code> <br/> <code>master</code></td>
<td>YES</td>
<td>预发布分支，为了新版本的发布做准备，一般命名为 <code>release-&lt;版本号&gt;</code>。这是一个稳定分支，只接受审核通过的 Merge Request。</td>
</tr>
<tr>
<td><code>hotfix-*</code></td>
<td><code>master</code></td>
<td><code>dev</code> <br/> <code>master</code></td>
<td>NO</td>
<td>补丁分支，为了修复生产缺陷而建，一般命名为 <code>hotfix-&lt;issue 编号&gt;</code></td>
</tr>
</tbody></table>
<p>与主分支不同，这些辅助性分支总是有一个有限的生命期，因为他们在被合并到主分支之后，就会被移除掉。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《<a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a>》</li>
<li>《<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">Git 分支管理策略 - 阮一峰</a>》</li>
<li>《<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a>》</li>
</ul>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/04/01/git-diff/" class="post-title-link">Git 实战系列（十）git diff 命令对比文件差异</a></h2><div class="post-info">2016-04-01<a href="/tags/Git/" title="Git" class="post-demo">Git</a></div><div class="post-content"><p>对比两个分支中，所有文件的详细差异，常用于合并操作之后确认有没有遗漏文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff branch1 branch2</span><br></pre></td></tr></table></figure>

<p>对比两个分支中，指定文件的详细差异：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff branch1 branch2 文件名(带路径)</span><br></pre></td></tr></table></figure>

<p>对比两个分支中，差异的文件列表：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff branch1 branch2 --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure>

</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/10/javascript-best-practice/" class="post-title-link">Javascript 编程最佳实践</a></h2><div class="post-info">2016-03-10<a href="/tags/前端/" title="前端" class="post-demo">前端</a></div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文总结出一些广受认可的编程最佳实践，用于解决特定领域的问题。</p>
<h1 id="编程最佳实践"><a href="#编程最佳实践" class="headerlink" title="编程最佳实践"></a>编程最佳实践</h1><h2 id="避免使用全局变量"><a href="#避免使用全局变量" class="headerlink" title="避免使用全局变量"></a>避免使用全局变量</h2><p>在 JavaScript 所有的糟糕特性之中，最为糟糕的一个就是它对全局变量的依赖。JS 大神 Douglas Crockford 甚至称之为“毒瘤”。想象一下，一个全局变量可以被程序的任何部分在任意时间修改，将使得程序的行为变得极度复杂。可怕的全局变量还带来了以下问题：</p>
<ol>
<li>命名冲突</li>
<li>代码的脆弱性</li>
<li>难以测试</li>
</ol>
<p>共有三种方式定义全局变量，这些方式都是我们要避免的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = value;       <span class="comment">// 1、在任何函数之外放置一个 var 语句</span></span><br><span class="line"><span class="built_in">window</span>.foo = value;    <span class="comment">// 2、直接给全局对象添加属性</span></span><br><span class="line">foo = value;           <span class="comment">// 3、直接使用未经声明的变量，即隐式的全局变量。一般都是开发者忘记声明，这将导致查找 bug 非常困难</span></span><br></pre></td></tr></table></figure>

<p>下面是一些解决办法：</p>
<h3 id="零全局变量"><a href="#零全局变量" class="headerlink" title="零全局变量"></a>零全局变量</h3><p>如果你编写的是一段不会被其它脚本访问到的完全独立的脚本，可以使用一个立即执行的匿名函数来<a href="/2016/03/09/javascript-style-guideline/#创建私有作用域">创建私有作用域</a>。</p>
<h3 id="单全局变量"><a href="#单全局变量" class="headerlink" title="单全局变量"></a>单全局变量</h3><p>最小化使用全局变量的方法之一是为你的应用创建唯一一个全局变量，并将你所有的功能代码都挂载到这个全局对象上。这种做法既降低了模块之间发生冲突的可能，又能保证模块之间的正常通信。可以参考 <a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="noopener">JavaScript 模块模式</a>。</p>
<p>目前这种单全局变量模式已经在各种流行的库中广泛使用了：</p>
<ul>
<li>jQuery 定义了两个全局对象，<code>$</code> 和 <code>jQuery</code>。只有在 <code>$</code> 被其它库使用了的情况下，为了避免冲突，才使用 <code>jQuery</code>。</li>
<li>YUI 定义了唯一一个 <code>YUI</code> 全局对象。</li>
<li>Dojo 定义了唯一一个 <code>dojo</code> 全局对象。</li>
<li>……</li>
</ul>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>最后一种、也是最为推崇的做法是使用“模块化”方式组织代码：</p>
<ul>
<li>ECMAScript 6 可以使用最新的原生模块标准语法；</li>
<li>使用主流的模块框架规范，如 AMD 和 CMD（<a href="https://www.zhihu.com/question/20351507/answer/14859415" target="_blank" rel="noopener">AMD 和 CMD 的区别有哪些？</a>）。</li>
</ul>
<h2 id="不是你的对象不要动"><a href="#不是你的对象不要动" class="headerlink" title="不是你的对象不要动"></a>不是你的对象不要动</h2><p>JavaScript 独一无二之处在于任何东西都不是神圣不可侵犯的。默认情况下，你可以修改任何你可以触及的对象。解析器根本就不在乎这些对象是开发者定义的还是默认执行环境的一部分——只要是能访问到的对象都可以修改。如果你的代码没有创建这些对象，禁止修改它们，包括：</p>
<ul>
<li>原生对象（<code>Object</code>、<code>Array</code> 等等）；</li>
<li>文档对象模型（DOM）（<code>document</code> 等等）；</li>
<li>浏览器对象模型（BOM）（<code>window</code> 等等）；</li>
<li>类库的对象（<code>$</code>、<code>jQuery</code> 等等）。</li>
</ul>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><h4 id="不覆盖方法"><a href="#不覆盖方法" class="headerlink" title="不覆盖方法"></a>不覆盖方法</h4><p>覆盖方法将会导致所有依赖该方法的代码失效：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法 - 覆盖了 DOM 方法</span></span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 任意代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="不新增方法"><a href="#不新增方法" class="headerlink" title="不新增方法"></a>不新增方法</h4><p>新增方法将会导致未来潜在的命名冲突，因为一个对象此刻没有某个方法不代表它未来没有。更糟糕的是如果将来原生的方法和你新增的方法行为不一致，将会陷入一场代码维护的噩梦：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法，在 DOM 对象上增加了方法</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName = <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 非原生实现。</span></span><br><span class="line">    <span class="comment">// 该新增方法在 HTML 5 中被官方实现了，这将会导致所有依赖该方法的代码报错。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不好的写法，在原生对象上增加了方法</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.reverseSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sort().reverse();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不好的写法，在库对象上增加了方法</span></span><br><span class="line">$.doSomeThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 任意代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="不删除方法"><a href="#不删除方法" class="headerlink" title="不删除方法"></a>不删除方法</h4><p>删除方法将会导致所有依赖该方法的代码运行时错误。对于已发布的库来说，无用的方法应该被标识位“废弃”而不是直接删掉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法 - 删除了 DOM 方法</span></span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>下面介绍一些解决方法：</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>如果一种类型的对象已经做到了你想要的大多数工作，那么继承它然后再新增一些功能是最好的做法。JavaScript 中有两种基本的继承形式：</p>
<ul>
<li>基于对象的继承</li>
<li>基于类型的继承</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyError = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.message = message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();    <span class="comment">// 基于类型的继承，继承自原生的 Error 类</span></span><br></pre></td></tr></table></figure>

<h4 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h4><p>JavaScript 的继承有一些很大的限制，就是无法继承自 DOM 或 BOM 对象。解决办法是利用门面模式为这些已存在的对象创建一个新的接口，达到二次封装的效果。jQuery 和 YUI 的 DOM 接口都使用了门面模式。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义一个 DOM 对象包装器</span></span><br><span class="line"><span class="keyword">var</span> DOMWrapper = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DOMWrapper.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: DOMWrapper,</span><br><span class="line">    addClass: function(className) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element.className += <span class="string">' '</span> + className;</span><br><span class="line">    &#125;,</span><br><span class="line">    remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element.parentNode.removeChild(<span class="keyword">this</span>.element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">var</span> wrapper = <span class="keyword">new</span> DOMWrapper(<span class="built_in">document</span>.getElementById(<span class="string">"my-div"</span>));</span><br><span class="line"><span class="comment">// 添加一个 className</span></span><br><span class="line">wrapper.addClass(<span class="string">"selected"</span>);</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">wrapper.remove();</span><br></pre></td></tr></table></figure>

<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="解耦事件处理"><a href="#解耦事件处理" class="headerlink" title="解耦事件处理"></a>解耦事件处理</h3><p>事件处理常见的问题是将事件处理程序和业务逻辑紧紧耦合在一起，降低了代码的可维护性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">var</span> handleClick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM Level 2</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line">    event.stopPropagation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 耦合业务逻辑</span></span><br><span class="line">    <span class="keyword">var</span> popup = <span class="built_in">document</span>.getElementById(<span class="string">"popup"</span>);</span><br><span class="line">    popup.style.left = event.clientX + <span class="string">"px"</span>;</span><br><span class="line">    popup.style.top = event.clientY + <span class="string">"px"</span>;</span><br><span class="line">    popup.className = <span class="string">"reveal"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'btn-action'</span>)</span><br><span class="line">            .addEventListener(<span class="string">"click"</span>, handleClick, <span class="literal">false</span>);    <span class="comment">// DOM Level 2</span></span><br></pre></td></tr></table></figure>

<p>正确的做法应该是解耦事件处理程序和业务逻辑，提高代码的可维护性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理程序，唯一能接触 event 对象的函数</span></span><br><span class="line"><span class="keyword">var</span> handleClick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// DOM Level 2</span></span><br><span class="line">        event.preventDefault();</span><br><span class="line">        event.stopPropagation();</span><br><span class="line"></span><br><span class="line">        showPopup(event.clientX, event.clientY);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 抽取业务逻辑，与事件隔离，便于重用与测试</span></span><br><span class="line">    showPopup = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> popup = <span class="built_in">document</span>.getElementById(<span class="string">"popup"</span>);</span><br><span class="line">        popup.style.left = x + <span class="string">"px"</span>;</span><br><span class="line">        popup.style.top = y + <span class="string">"px"</span>;</span><br><span class="line">        popup.className = <span class="string">"reveal"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'btn-action'</span>)</span><br><span class="line">            .addEventListener(<span class="string">"click"</span>, handleClick, <span class="literal">false</span>);    <span class="comment">// DOM Level 2</span></span><br></pre></td></tr></table></figure>

<p>可见，业务逻辑不应该依赖于 <code>event</code> 对象来完成功能，原因如下：</p>
<ul>
<li>好的 API 一定是对于期望和依赖都是透明的，因此方法接口应该表明哪些数据是必要的。将 <code>event</code> 对象作为参数并不能告诉你 <code>event</code> 的哪些属性是有用的，用来干什么？</li>
<li>如果想测试这个方法，你必须构建一个 <code>event</code> 对象并作为参数传入。这迫使你关注方法内部实现，以确切地知道这个方法使用了哪些信息，这样才能正确地写出测试代码。</li>
</ul>
<h3 id="使用事件委托"><a href="#使用事件委托" class="headerlink" title="使用事件委托"></a>使用事件委托</h3><p>关于“事件绑定（Event Binding）”和“事件委托（Event Delegation）”两种机制的区别在 <a href="/2016/05/22/javascript-event-delegation">本文</a> 有详细的描述。简而言之，从“内存消耗”、“处理速度”、“新增元素的处理”三方面考虑，都更建议使用“事件委托”。下例演示了如何使用 jQuery 语法进行“事件委托”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).on(<span class="string">'click'</span>, <span class="string">'li'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//function code here.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>当 <code>#list</code> 内任一 <code>li</code> 子元素被点击时，<code>click</code> 事件将冒泡到其父元素 <code>#list</code> 并触发 <code>#list</code> 的事件处理程序，即子元素的事件都委托给父元素进行处理。这种做法有利于提升性能，推荐使用。</p>
<h2 id="UI-层保持松耦合"><a href="#UI-层保持松耦合" class="headerlink" title="UI 层保持松耦合"></a>UI 层保持松耦合</h2><p>保持 Web UI 层的松耦合，以便在以下场景中调试代码，定位问题：</p>
<ul>
<li>当发生了文本或结构相关的问题，通过查找 HTML 即可定位；</li>
<li>当发生了样式相关的问题，通过查找 CSS 即可定位；</li>
<li>当发生了行为和交互相关的问题，通过查找 JavaScript 即可定位。</li>
</ul>
<p>这种快速定位问题的能力是 Web 界面可维护性的核心关键。</p>
<h3 id="将-JavaScript-从-CSS-中抽离"><a href="#将-JavaScript-从-CSS-中抽离" class="headerlink" title="将 JavaScript 从 CSS 中抽离"></a>将 JavaScript 从 CSS 中抽离</h3><p>禁止使用 CSS 表达式（CSS Expression）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line">.box &#123;</span><br><span class="line">    width: expression(<span class="built_in">document</span>.body.offsetWidth + <span class="string">"px"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CSS 表达式是 IE8 及更早版本中的一个特性，它允许你将 JavaScript 直接插入到 CSS 中，这样可以在 CSS 代码中直接执行运算或其它操作。但 CSS 表达式会带来两个问题：</p>
<ul>
<li>性能问题</li>
<li>代码可维护性问题</li>
</ul>
<h3 id="将-CSS-从-JavaScript-中抽离"><a href="#将-CSS-从-JavaScript-中抽离" class="headerlink" title="将 CSS 从 JavaScript 中抽离"></a>将 CSS 从 JavaScript 中抽离</h3><p>禁止在 JavaScript 脚本中直接操作 CSS 样式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line">element.style.color = <span class="string">'red'</span>;</span><br><span class="line">element.style.left = <span class="string">'10px'</span>;</span><br><span class="line">element.style.cssText = <span class="string">'color: red; left: 10px'</span>;</span><br></pre></td></tr></table></figure>

<p>当需要通过 JavaScript 来操作元素样式的时候，最佳方法是操作 CSS 的 <code>className</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.className = <span class="string">'className'</span>;    <span class="comment">// 原生方法</span></span><br><span class="line">$(element).addClass(<span class="string">'className'</span>);   <span class="comment">// jQuery</span></span><br></pre></td></tr></table></figure>

<p>CSS 的 <code>className</code> 应该成为 CSS 和 JavaScript 之间通信的桥梁。JavaScript 不应当直接操作 CSS 样式，以便保持和 CSS 的松耦合。</p>
<h3 id="将-JavaScript-从-HTML-中抽离"><a href="#将-JavaScript-从-HTML-中抽离" class="headerlink" title="将 JavaScript 从 HTML 中抽离"></a>将 JavaScript 从 HTML 中抽离</h3><p>禁止在 HTML 标签中嵌入 JavaScript 脚本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 不好的写法，不该直接为 HTML 标签的 on 属性挂载事件处理程序 --&gt;</span><br><span class="line">&lt;button onclick=<span class="string">"doSomeThing()"</span> id=<span class="string">"btn-action"</span>&gt;Click Me&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样会导致 HTML 页面和 JavaScript 脚本紧紧耦合。正确的做法应当是在外部脚本文件中添加事件处理程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomeThing() &#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'btn-action'</span>)</span><br><span class="line">            .addEventListener(<span class="string">"click"</span>, doSomeThing, <span class="literal">false</span>);    <span class="comment">// DOM Level 2</span></span><br><span class="line">$(<span class="string">'#btn-action'</span>).click(doSomeThing);    <span class="comment">// jQuery</span></span><br></pre></td></tr></table></figure>

<p>这种做法的优势在于，函数 <code>doSomeThing()</code> 的定义和事件处理程序的绑定都是在同一个文件中完成的。如果函数名称需要修改，则只需修改一个文件即可；如果点击发生时想额外做一些动作，也只需在一处做修改。</p>
<p>此外，不到迫不得已，不建议在 HTML 页面中嵌入 JavaScript 脚本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  不好的做法 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    doSomeThing();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="将-HTML-从-JavaScript-中抽离"><a href="#将-HTML-从-JavaScript-中抽离" class="headerlink" title="将 HTML 从 JavaScript 中抽离"></a>将 HTML 从 JavaScript 中抽离</h3><p>不建议在 JavaScript 脚本文件中嵌入 HTML 操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'my-div'</span>);</span><br><span class="line">div.innerHTML = <span class="string">"&lt;h3&gt;Error&lt;/h3&gt;&lt;p&gt;Invalid e-mail address.&lt;/p&gt;"</span>;</span><br></pre></td></tr></table></figure>

<p>这样会导致 JavaScript 脚本和 HTML 标签紧紧耦合，从而降低了代码的可维护性，增加了跟踪文本和结构性问题的复杂度。正常来说，调试上述这段标签的典型方法，应当是先去浏览器调试工具中的 DOM 树中查找，然后打开页面的 HTML 源码对比其不同。一旦 JavaScript 脚本文件中做了除简单 DOM 操作之外的事情，如渲染标签，追踪 Bug 就变得很麻烦。因为脚本和标签都耦合成一坨了，让人望而却步。</p>
<p>HTML 文本和标签应该只存放于一个地方：可以控制你 HTML 代码的地方。最为推崇的做法是利用 <strong>JavaScript 模板引擎</strong> 解决这个问题。</p>
<p>项目中我引入了模板引擎 <a href="https://github.com/aui/artTemplate" target="_blank" rel="noopener">artTemplate</a> 进行 HTML 渲染，并通过修改源码内置了两个常用的格式化工具：</p>
<ul>
<li>货币格式化：<a href="http://openexchangerates.github.io/accounting.js/" target="_blank" rel="noopener">accounting.js</a></li>
<li>日期格式化：datetime.js</li>
</ul>
<p>详见 DEMO：finance-marketres-mobi\js\utility\util-demo.html</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《编写可维护的 JavaScript》</li>
<li>《JavaScript 高级程序设计》</li>
<li>《JavaScript 权威指南》</li>
<li>《JavaScript 语言精粹》</li>
</ul>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/03/09/javascript-style-guideline/" class="post-title-link">Javascript 编程风格规范</a></h2><div class="post-info">2016-03-09<a href="/tags/前端/" title="前端" class="post-demo">前端</a></div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在团队开发中，所有的代码看起来风格一致是极其重要的，原因有以下几点：</p>
<ul>
<li>任何开发者都不会在乎某个文件的作者是谁，因为所有代码排版格式看起来应当是非常一致，不该花费额外精力去理解代码逻辑并重新排版。</li>
<li>风格一致能够让人很容易识别出问题代码并发现错误。如果所有代码看起来很像，当你看到一段与众不同的代码时，很可能错误就产生在这段代码中。</li>
</ul>
<p>当项目变得庞大时，统一的编程风格能够节省的大量时间成本。</p>
<h1 id="基本编程风格"><a href="#基本编程风格" class="headerlink" title="基本编程风格"></a>基本编程风格</h1><p>本节编程风格（Style Guideline）是用于规范单文件中的代码，使团队编程风格保持一致。</p>
<h2 id="缩进层级"><a href="#缩进层级" class="headerlink" title="缩进层级"></a>缩进层级</h2><p>每一行的层级由 <strong>四个空格</strong> 组成，避免使用制表符（Tab）进行缩进，以便在所有的系统和编辑器中，文件的展现格式不会有任何差异。建议在文本编辑器中配置敲击 <code>Tab</code> 键时插入四个空格。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="行的长度"><a href="#行的长度" class="headerlink" title="行的长度"></a>行的长度</h2><p>每行长度不应该超过 80 个字符。如果一行多于 80 个字符，应当在一个<strong>运算符（逗号、加号等）后换行</strong>。下一行应当<strong>增加两级缩进（8 个字符）</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">doSomething(arg1, arg2, arg3, arg4,</span><br><span class="line">        arg5);</span><br><span class="line"></span><br><span class="line">// 不好的写法：第二行只有 4 个空格的缩进</span><br><span class="line">doSomething(arg1, arg2, arg3, arg4,</span><br><span class="line">    arg5);</span><br><span class="line"></span><br><span class="line">// 不好的写法：在运算符之前换行</span><br><span class="line">doSomething(arg1, arg2, arg3, arg4</span><br><span class="line">        , arg5);</span><br></pre></td></tr></table></figure>

<h2 id="语句格式"><a href="#语句格式" class="headerlink" title="语句格式"></a>语句格式</h2><ul>
<li>始终使用分号 <code>;</code> 结束一个语句。禁止省略分号，因为：<ul>
<li>后续使用构建工具时，可以通过自动删除多余的空格和换行来压缩代码行（代码行结尾处没有分号会导致压缩错误）。</li>
<li>在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了。</li>
<li>避免解析器错误的插入分号，导致程序报错。</li>
</ul>
</li>
<li>始终使用花括号 <code>{}</code> 包住块语句，可以让编程意图更清晰，降低修改代码时出错的几率。</li>
</ul>
<p>这里展示了一些例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法，缺少花括号</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    doSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法，左花括号应当放在块语句中第一句代码的末尾</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法，缺少空格间隔</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法，缺少适当的换行</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123; doSomething(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法，缺少分号结尾</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    doSomething()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="操作符间隔"><a href="#操作符间隔" class="headerlink" title="操作符间隔"></a>操作符间隔</h2><p>二元操作符（如赋值、逻辑运算）前后必须使用一个空格来保持表达式的整洁。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> found = (value[i] === item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：丢失了空格</span></span><br><span class="line"><span class="keyword">var</span> found=(value[i]===item);</span><br></pre></td></tr></table></figure>

<h2 id="注释声明"><a href="#注释声明" class="headerlink" title="注释声明"></a>注释声明</h2><p>注释有时候可以用于给一段代码声明额外的信息。这些声明的格式如下：</p>
<table>
<thead>
<tr>
<th>注释声明</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>TODO</code></td>
<td>说明代码还未完成。此时应当描述下一步要做的事情。</td>
</tr>
<tr>
<td><code>HACK</code></td>
<td>说明代码实现走了一个捷径。此时应当描述为何使用 hack 的原因。这也可能表明该问题可能会有更好的解决方法。</td>
</tr>
<tr>
<td><code>FIXME</code></td>
<td>说明代码是有问题的需要尽快修复。此时应当描述问题出在哪里，或者提供解决方案。</td>
</tr>
<tr>
<td><code>REVIEW</code></td>
<td>说明代码任何可能的改动都需要评审。</td>
</tr>
</tbody></table>
<p>注释声明可以用于单行或多行注释，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 我希望找到一种效率更快的实现方式</span></span><br><span class="line">doSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * HACK: 不得不针对 IE 做的特殊处理。我计划后续有时间时</span></span><br><span class="line"><span class="comment"> * 重写这部分。这些代码可能需要在 v1.2 版本之后替换掉。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.all) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><ul>
<li>变量命名使用小驼峰式（Camel Case）命名法，即以小写字母开头，后续每个单词首字母都大写。</li>
<li>常量命名使用大写字母和下划线。</li>
<li>私有属性、方法使用下划线前缀：<code>_</code>。</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>所有字母大写，不同单词之间用单个下划线 <code>_</code> 分隔。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数使用大驼峰式（Pascal Case）命名法，即以大写字母开头，后续每个单词首字母都大写。</p>
<h3 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h3><p>函数变量使用前缀：<code>fn</code>。</p>
<h3 id="DOM-变量"><a href="#DOM-变量" class="headerlink" title="DOM 变量"></a>DOM 变量</h3><ul>
<li>class：使用全小写字母 + 中划线的形式命名。如果该类是用于在 JS 中引用的，还需要添加前缀 <code>js-</code>。注意用于 JS 的类严禁用于样式文件中引用。</li>
<li>id：使用小驼峰命名，并添加前缀如下：</li>
</ul>
<table>
<thead>
<tr>
<th>前缀</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ipt</code></td>
<td>input 输入框</td>
</tr>
<tr>
<td><code>btn</code></td>
<td>按钮</td>
</tr>
<tr>
<td><code>lbl</code></td>
<td>Label</td>
</tr>
<tr>
<td><code>chk</code></td>
<td>CheckBox</td>
</tr>
<tr>
<td><code>lnk</code></td>
<td>A链接</td>
</tr>
<tr>
<td><code>img</code></td>
<td>图片</td>
</tr>
</tbody></table>
<h2 id="禁止使用的"><a href="#禁止使用的" class="headerlink" title="禁止使用的"></a>禁止使用的</h2><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>JavaScript 中有三种<a href="/2016/02/11/javascript-primitive-types/#基本包装类型">基本包装类型</a>：<code>Boolean</code>、<code>Number</code>、<code>String</code>，每种类型都代表全局作用域中的一个构造函数，并分别表示各自对应的原始值的对象。基本包装类型的主要作用是让原始值具有对象般的行为。</p>
<p>禁止使用这些基本包装类型声明变量，应该直接使用对应的字面量：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>注意项</th>
</tr>
</thead>
<tbody><tr>
<td>布尔值</td>
<td>统一使用字面量 <code>true</code>、<code>false</code> 而不是构造函数 <code>new Boolean()</code></td>
<td></td>
</tr>
<tr>
<td>数字值</td>
<td>统一使用<a href="/2016/02/11/javascript-primitive-types/#字面量">字面量</a>，而不是构造函数 <code>new Number()</code></td>
<td>避免使用八进制字面量</td>
</tr>
<tr>
<td>字符串</td>
<td>统一使用单引号 <code>&#39;&#39;</code>，而不是构造函数 <code>new String()</code></td>
<td>避免在字符串中使用斜杠 <code>\</code> 另起一行</td>
</tr>
<tr>
<td><a href="/2016/02/17/javascript-object/">对象</a></td>
<td>统一使用字面量 <code>{}</code> 而不是构造函数 <code>new Object()</code></td>
<td></td>
</tr>
<tr>
<td><a href="/2016/02/18/javascript-array/">数组</a></td>
<td>统一使用字面量 <code>[]</code> 而不是构造函数 <code>new Array()</code></td>
<td></td>
</tr>
</tbody></table>
<h3 id="等号操作符"><a href="#等号操作符" class="headerlink" title="等号操作符"></a>等号操作符</h3><p>由于相等（<code>==</code>）和不相等（<code>!=</code>）操作符存在 <strong>自动类型转换</strong> 的问题，因此禁止使用。为了保持代码中数据类型的完整性，要求使用全等（<code>===</code>）和不全等（<code>!==</code>）操作符。</p>
<h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p><code>setTimeout()</code>、<code>setInterval()</code> 函数中的回调代码禁止使用字符串格式。</p>
<p><code>eval()</code> 函数禁止使用。</p>
<h2 id="空链接跳转"><a href="#空链接跳转" class="headerlink" title="空链接跳转"></a>空链接跳转</h2><p>常用的三种空链接跳转：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">javascript:<span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">javascript:;    <span class="comment">// 推荐这种</span></span><br></pre></td></tr></table></figure>

<h1 id="进阶编程风格"><a href="#进阶编程风格" class="headerlink" title="进阶编程风格"></a>进阶编程风格</h1><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>在具有块级作用域的语言中，在狭小的作用域内让变量声明和使用变量的代码尽可能彼此靠近，通常是个好的编程习惯。因此在编写 JavaScript 时常常会出现类似的惯性思维：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'for 语句内，i='</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'for 语句外，i='</span> + i);    <span class="comment">// 注意这里，JavaScript 没有块级作用域，因此 for 语句外仍然可以读取变量 i</span></span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 语句内，i=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> 语句内，i=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> 语句内，i=<span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> 语句外，i=<span class="number">3</span>    <span class="comment">// 注意这里</span></span><br></pre></td></tr></table></figure>

<p>但由于 JavaScript 中并没有块级作用域（block scope），只有函数作用域（function scope），因此函数内声明的所有变量在函数体内始终是可见的。这个特性被非正式地称为 <strong>声明提前（hoisting）</strong>，即 JavaScript 函数内声明的所有变量（但不涉及赋值）都被“提前”至函数顶部。这步操作是在代码开始运行之前、<a href="http://www.slideshare.net/lijing00333/javascript-engine" target="_blank" rel="noopener">JavaScript 引擎</a>的“预编译”阶段进行的。上述代码编译如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;    <span class="comment">// 变量声明提前</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'for 语句内，i='</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'for 语句外，i='</span> + i);</span><br></pre></td></tr></table></figure>

<p>变量声明提前意味着：在函数内部任意地方声明变量和在函数顶部声明变量是完全一样的。为了让源代码能够非常清晰地反映出真实的变量作用域，避免潜藏错误，规范要求始终在函数顶部使用单 <code>var</code> 语句统一声明所有变量，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个变量声明都独占一行，同时注意每行的缩进</span></span><br><span class="line"><span class="keyword">var</span> iptUsername = $(<span class="string">'input[name="username"]'</span>),</span><br><span class="line">    iptPwd = $(<span class="string">'input[name="pwd"]'</span>),</span><br><span class="line">    btnLogin = $(<span class="string">'#js-btn-login'</span>),</span><br><span class="line">    fnLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>和上述变量声明提前一样，函数声明也会被 JavaScript 引擎提前（function declaration hoisting）。因此，在代码中函数的调用可以出现在函数声明之前：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line">doSomeThing();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello world!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是可以正常运行的，因为 JavaScript 引擎将这段代码解析为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明提前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello world!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomeThing();</span><br></pre></td></tr></table></figure>

<p>由于 JavaScript 的这种行为会放宽函数必须 <strong>先声明后使用</strong> 的要求，因此会导致代码混乱。</p>
<p>规范要求函数始终 <strong>先声明后使用</strong>。</p>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>更好的办法是使用 <strong>函数表达式</strong> 代替函数声明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> doSomeThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello world!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">doSomeThing();</span><br></pre></td></tr></table></figure>

<p>这种形式看起来像是常规的变量赋值语句，即创建一个函数并将它赋值给变量 <code>doSomeThing</code>。这种情况下创建的函数叫做 <strong>匿名函数（anonymous function）</strong>（也称为 <strong>拉姆达函数</strong>），因为 <code>function</code> 关键字后面没有标识符，其 <code>name</code> 属性为空。</p>
<p>与使用函数声明的区别在于，如果执行顺序颠倒，函数调用 <code>doSomeThing()</code> 将会报错。因为函数表达式必须等到解析器执行到它所在的代码行，才会真正被解释执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> doSomeThing === <span class="string">'undefined'</span>;    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doSomeThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello world!'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>除此之外，函数声明与函数表达式的语法其实是等价的。尽管如此，规范仍然要求优先使用函数表达式，原因有二：</p>
<ul>
<li>强制开发者 <strong>先声明后使用</strong> 函数，避免函数声明提升带来的混乱；</li>
<li>函数表达式更能明确表示一个包含函数的变量。要学好这门语言，理解 <strong>函数就是对象</strong> 是很重要的。因为函数是对象，所以它们可以像任何其它的值一样被使用。例如：<ul>
<li>函数可以保存在变量、对象和数组中；</li>
<li>函数可以被当做 <strong>参数</strong> 传递给其它函数，也可以被作为函数的 <strong>返回值</strong>；</li>
<li>函数可以拥有方法。</li>
</ul>
</li>
</ul>
<h2 id="立即执行的函数"><a href="#立即执行的函数" class="headerlink" title="立即执行的函数"></a>立即执行的函数</h2><p>使用函数表达式可以声明匿名函数，并将匿名函数赋值给变量或者属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomeThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'doSomeThing'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> doSomeThing === <span class="string">'function'</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这种匿名函数可以通过在最后加上一对圆括号 <code>()</code> 来 <strong>立即执行并返回</strong> 一个值给变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">var</span> doSomeThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'doSomeThing'</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> doSomeThing === <span class="string">'string'</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这种写法的问题在于，会让人误以为将一个匿名函数赋值给了这个变量。除非读完整段代码并看到最后一行的那对圆括号 <code>()</code>，否则你不会知道是将函数赋值给变量还是将函数的执行结果赋值给变量。这种困惑会影响代码的可读性。</p>
<p>为了让立即执行的函数能够被一眼看出来，可以用一对圆括号 <code>()</code> 将函数包起来。这样做并不会影响代码的执行结果，却能让人一眼就看出这是个立即执行的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> doSomeThing = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'doSomeThing'</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> doSomeThing === <span class="string">'string'</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="创建私有作用域"><a href="#创建私有作用域" class="headerlink" title="创建私有作用域"></a>创建私有作用域</h3><p>此外，还可以使用<a href="http://www.zuojj.com/archives/631.html" target="_blank" rel="noopener">立即执行的匿名函数（immediately executed anonymous function）</a>来创建私有作用域，从而解决全局变量污染的问题。这种函数一般是没有返回值的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hidden_variable = <span class="string">'Hello world!'</span>;    <span class="comment">// hidden_variable 只是一个局部变量</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>要注意的是在这种场景下，函数表达式外的那对圆括号 <code>()</code> 绝不能省略，因为官方的语法假定以单词 <code>function</code> 开头的语句是一个函数声明语句，而函数声明语句是无法匿名的，否则会报错。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《编写可维护的 JavaScript》</li>
<li>《JavaScript 高级程序设计》</li>
<li>《JavaScript 权威指南》</li>
<li>《JavaScript 语言精粹》</li>
</ul>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/02/19/javascript-data-types-determine/" class="post-title-link">Javascript 类型判断</a></h2><div class="post-info">2016-02-19<a href="/tags/前端/" title="前端" class="post-demo">前端</a></div><div class="post-content"><p>鉴于 ECMAScript 是松散类型（loosely typed）的，因此需要有一种手段来检测给定变量的数据类型——<code>typeof</code> 和 <code>instanceof</code> 操作符提供了这方面的信息：</p>
<h1 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h1><p><code>typeof</code> 操作符可能返回下列某个字符串：</p>
<table>
<thead>
<tr>
<th>类型字符串</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>undefined</code></td>
<td>如果这个值未定义</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td>如果这个值是布尔值</td>
</tr>
<tr>
<td><code>string</code></td>
<td>如果这个值是字符串</td>
</tr>
<tr>
<td><code>number</code></td>
<td>如果这个值是数值</td>
</tr>
<tr>
<td><code>object</code></td>
<td>如果这个值是对象或 <code>null</code></td>
</tr>
<tr>
<td><code>function</code></td>
<td>如果这个值是函数</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span></span><br><span class="line"><span class="string">"undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span></span><br><span class="line"><span class="string">"object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span></span><br><span class="line"><span class="string">"boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span></span><br><span class="line"><span class="string">"boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">''</span></span><br><span class="line"><span class="string">"string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">""</span></span><br><span class="line"><span class="string">"string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">70</span></span><br><span class="line"><span class="string">"number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">070</span></span><br><span class="line"><span class="string">"number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">0xA</span></span><br><span class="line"><span class="string">"number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3.125e7</span></span><br><span class="line"><span class="string">"number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3e-7</span></span><br><span class="line"><span class="string">"number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span></span><br><span class="line"><span class="string">"number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">Infinity</span></span><br><span class="line"><span class="string">"number"</span></span><br></pre></td></tr></table></figure>

<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>由于在检测对象的值时，<code>typeof</code> 无法辨别出 <code>null</code> 与对象，因此建议使用下列这样的判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> my_value = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (my_value &amp;&amp; <span class="keyword">typeof</span> my_value === <span class="string">'object'</span>) &#123;    <span class="comment">// null 值为 false</span></span><br><span class="line">    <span class="comment">// my_value 是一个对象或数组！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h2><p><code>typeof</code> 无法辨别出 <code>NaN</code> 和数字：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> === <span class="string">'number'</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>isNaN()</code> 函数可以解决这类判断问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>);     <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h2><p><code>typeof</code> 无法辨别出 <code>Infinity</code> 和数字：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">Infinity</span> === <span class="string">'number'</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>可以自定义一个 <code>isNumber()</code> 函数用于判断数字：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'number'</span> </span><br><span class="line">        &amp;&amp; <span class="built_in">isFinite</span>(value);    <span class="comment">// isFinite 函数会筛选掉 NaN 和 Infinity</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isNumber(<span class="number">100</span>);    <span class="comment">// true</span></span><br><span class="line">isNumber(<span class="literal">NaN</span>);    <span class="comment">// false</span></span><br><span class="line">isNumber(<span class="literal">Infinity</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><p>比较特殊的类型是 <code>function</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="string">"function"</span></span><br></pre></td></tr></table></figure>

<p>从技术角度讲，函数在 ECMAScript 中是对象，而不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 <code>typeof</code> 操作符来区分函数和其他对象是有必要的。</p>
<h1 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h1><p><code>typeof</code> 操作符存在一个问题：在判断任何引用类型时都会返回 <code>&quot;object&quot;</code>，因此 ECMAScript 引入了 <code>instanceof</code> 操作符来解决这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《JavaScript 高级程序设计》</li>
</ul>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/02/18/javascript-array/" class="post-title-link">Javascript 引用类型之 Array</a></h2><div class="post-info">2016-02-18<a href="/tags/前端/" title="前端" class="post-demo">前端</a></div><div class="post-content"><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>除了 <code>Object</code> 之外，<code>Array</code> 类型恐怕是 ECMAScript 中最常用的类型了。ECMAScript 的数组特点如下：</p>
<ul>
<li>数组是有序列表；</li>
<li>数组的每一项可以保存不同类型的数据；</li>
<li>数组的大小可以动态调整，可以随着数据的添加自动增长以容纳新增数据。</li>
</ul>
<h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>创建 <code>Array</code> 实例的方式有两种。第一种是使用 <code>Array</code> 构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();    <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);    <span class="comment">// 创建 length 值为 20 的数组</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);    <span class="comment">// 创建一个包含 3 个字符串值的数组</span></span><br></pre></td></tr></table></figure>

<p>另一种方式是使用数组字面量表示法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [];    <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];    <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br></pre></td></tr></table></figure>

<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>针对数组有很多常用方法：</p>
<h3 id="栈、队列方法"><a href="#栈、队列方法" class="headerlink" title="栈、队列方法"></a>栈、队列方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>push()</code></td>
<td>入栈（向数组的末尾添加一个或更多元素，并返回新的长度）</td>
</tr>
<tr>
<td><code>pop()</code></td>
<td>出栈（删除并返回数组的最后一个元素）</td>
</tr>
<tr>
<td><code>unshift()</code></td>
<td>向数组的开头添加一个或更多元素，并返回新的长度。</td>
</tr>
<tr>
<td><code>shift()</code></td>
<td>出队（删除并返回数组的第一个元素）</td>
</tr>
</tbody></table>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>sort()</code></td>
<td>按升序排列数组项</td>
</tr>
<tr>
<td><code>reverse()</code></td>
<td>反转数组项的顺序</td>
</tr>
</tbody></table>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>concat()</code></td>
<td>拼接并返回新数组</td>
</tr>
<tr>
<td><code>slice()</code></td>
<td>裁剪并返回新数组</td>
</tr>
</tbody></table>
<h3 id="拼接方法"><a href="#拼接方法" class="headerlink" title="拼接方法"></a>拼接方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>join()</code></td>
<td>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</td>
</tr>
<tr>
<td><code>toString()</code></td>
<td>把数组转换为字符串，并返回结果。</td>
</tr>
<tr>
<td><code>toLocaleString()</code></td>
<td>把数组转换为本地字符串，并返回结果。</td>
</tr>
</tbody></table>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>ECMAScript 5 新增的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>indexOf()</code></td>
<td>查询特定项在数组的起始索引</td>
</tr>
<tr>
<td><code>lastIndexOf()</code></td>
<td>查询特定项在数组的结束索引</td>
</tr>
</tbody></table>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>ECMAScript 5 新增的方法：</p>
<p><code>every()</code> 和 <code>some()</code> 是一组相似的方法，用于查询数组中的项是否满足某个条件：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>every()</code></td>
<td>对数组中的每一项运行给定函数，如果该函数对每一项都返回 <code>true</code>，则返回 <code>true</code>。</td>
</tr>
<tr>
<td><code>some()</code></td>
<td>对数组中的每一项运行给定函数，如果该函数对任一项返回 <code>true</code>，则返回 <code>true</code>。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>filter()</code></td>
<td>对数组中的每一项运行给定函数，返回该函数会返回 <code>true</code> 的项组成的数组。</td>
</tr>
<tr>
<td><code>map()</code></td>
<td>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</td>
</tr>
<tr>
<td><code>forEach()</code></td>
<td>对数组中的每一项运行给定函数。这个方法没有返回值。</td>
</tr>
</tbody></table>
<p>这些数组方法通过执行不同的操作，可以大大方便处理数组的任务。</p>
<h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><p>ECMAScript 5 新增的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>reduce()</code></td>
<td>从数组的第一项开始，逐个遍历到最后，执行给定的归并函数。</td>
</tr>
<tr>
<td><code>reduceRight()</code></td>
<td>从数组的最后一项开始，向前遍历到第一项，执行给定的归并函数。</td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《JavaScript 高级程序设计》</li>
<li>《<a href="https://www.runoob.com/w3cnote/es6-array.html" target="_blank" rel="noopener">ES6 数组</a>》</li>
<li>《<a href="https://www.w3school.com.cn/jsref/jsref_obj_array.asp" target="_blank" rel="noopener">JavaScript Array 对象</a>》</li>
</ul>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2016/02/17/javascript-object/" class="post-title-link">Javascript 引用类型之 Object</a></h2><div class="post-info">2016-02-17<a href="/tags/前端/" title="前端" class="post-demo">前端</a></div><div class="post-content"><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>ECMAScript 中使用最多的类型就是 <code>Object</code>。虽然 <code>Object</code> 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们是非常理想的选择。</p>
<h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>创建 <code>Object</code> 实例的方式有两种。第一种是使用 <code>new</code> 操作符后跟 <code>Object</code> 构造函数，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>

<p>另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">"Nicholas"</span>,</span><br><span class="line">    age : <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用这种对象字面量语法要求的代码量更少，而且能够给人以封装数据的感觉。</p>
<p>实际上，对象字面量也是向函数传递大量可选参数的首选方式。一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">arg0, arg1, arg2, arg3, arg4</span>) </span>&#123;　　</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething(<span class="string">''</span>, <span class="string">'foo'</span>, <span class="number">5</span>, [], <span class="literal">false</span>);    <span class="comment">// 这里必须传够五个命名参数，无法跳过中间某个可选参数</span></span><br></pre></td></tr></table></figure>

<p>但最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不传任何参数也能正常运行</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 undefined 的参数设置默认值</span></span><br><span class="line">    <span class="keyword">var</span> oArgs = <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">        arg0  = oArgs.arg0 || <span class="string">""</span>,</span><br><span class="line">        arg1  = oArgs.arg1 || <span class="string">""</span>,</span><br><span class="line">        arg2  = oArgs.arg2 || <span class="number">0</span>,</span><br><span class="line">        arg3  = oArgs.arg3 || [],</span><br><span class="line">        arg4  = oArgs.arg4 || <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入可选参数而不报错</span></span><br><span class="line">doSomething(&#123;</span><br><span class="line">    arg1: <span class="string">"foo"</span>,</span><br><span class="line">    arg2: <span class="number">5</span>,</span><br><span class="line">    arg4: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h2><p>由于在 ECMAScript 中 <code>Object</code> 是所有对象的基础，因此所有对象都具有下列这些基本的属性和方法：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>constructor</code></td>
<td>保存着用于创建当前对象的函数。</td>
</tr>
<tr>
<td><code>isPrototypeOf(object)</code></td>
<td>用于检查传入的对象是否是传入对象的原型。</td>
</tr>
<tr>
<td><code>hasOwnProperty(propertyName)</code></td>
<td>用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。</td>
</tr>
<tr>
<td><code>propertyIsEnumerable(propertyName)</code></td>
<td>用于检查给定的属性是否能够使用 <code>for-in</code> 语句来枚举。</td>
</tr>
<tr>
<td><code>toLocaleString()</code></td>
<td>返回对象的字符串表示，该字符串与执行环境的地区对应。</td>
</tr>
<tr>
<td><code>toString()</code></td>
<td>返回对象的字符串表示。</td>
</tr>
<tr>
<td><code>valueOf()</code></td>
<td>返回对象的字符串、数值或布尔值表示。通常与 <code>toString()</code> 方法的返回值相同。</td>
</tr>
</tbody></table>
<p>例如，要检查某个对象的专有属性，可以使用 <code>hasOwnProperty(propertyName)</code> 方法进行判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>: <span class="string">'foo'</span>, <span class="attr">bar</span>: <span class="string">'bar'</span>&#125;;</span><br><span class="line">obj.hasOwnProperty(<span class="string">'foo'</span>)    <span class="comment">// true</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">'constructor'</span>)    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《JavaScript 高级程序设计》</li>
<li>《JavaScript 语言精粹》</li>
</ul>
</div></article></li></ul><div class="right-container"><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/DNS/" style="font-size: 12.5px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GNU-Linux/" style="font-size: 16.67px;">GNU/Linux</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 19.17px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 11.67px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10.83px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15.83px;">Spring</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 18.33px;">前端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">响应式编程</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 12.5px;">安全</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">并发编程</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 13.33px;">建站</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 12.5px;">管理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.17px;">读书笔记</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 12.5px;">金融</a></div></div><div class="widget"><div class="recent"><h4>最近文章</h4><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/02/26/cpp-io-library/">C/C++ 语言系列（十一）I/O 库总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/25/cpp-oop-inheritance-and-polymorphism/">C/C++ 语言系列（十）面向对象编程之继承与多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/20/cpp-oop-class/">C/C++ 语言系列（九）面向对象编程之类、类模板、类指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/18/cpp-type-aliases/">C/C++ 语言系列（八）复合数据类型之类型别名</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/16/cpp-struct/">C/C++ 语言系列（七）复合数据类型之结构体</a></li></ul></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/page/13/" class="prev">PREV</a><a href="/page/15/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2021 <a href="https://github.com/qidawu" target="_blank">Qida's Blog</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>