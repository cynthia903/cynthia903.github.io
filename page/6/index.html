<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> Qida's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="学习笔记 知识总结 思考感悟"><meta name="keywords"><meta name="author" content="Qida's Blog"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://qidawu.github.io/atom.xml" title="Qida's Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><a href="/" class="title-link">Qida's Blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/02/18/concurrency-control/" class="post-title-link">并发编程系列（一）两种并发控制机制的总结</a></h2><div class="post-info">2019-02-18<a href="/tags/MySQL/" title="MySQL" class="post-demo">MySQL</a><a href="/tags/并发编程/" title="并发编程" class="post-demo">并发编程</a></div><div class="post-content"><h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><p>计算机领域中，并发控制（Concurrency Control）是一种机制，它确保并发操作可以产生正确结果。</p>
<p>有两种常用的并发控制机制：</p>
<ul>
<li>乐观并发控制（Optimistic Concurrency Control, OCC），又称为乐观锁（Optimistic Lock），最早是由孔祥重（H.T.Kung）教授提出的。</li>
<li>悲观并发控制（Pessimistic Concurrency Control, PCC），又称为悲观锁（Pessimistic Lock）。</li>
</ul>
<p>这两种机制或者锁并不是 MySQL 或者数据库中独有的概念，而是并发编程的基本概念。</p>
<h2 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h2><ul>
<li><p>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，没有才能更新成功。</p>
</li>
<li><p>适用场景：</p>
<ul>
<li>它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理<strong>各自影响的那部分数据</strong>。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其它事务又修改了该数据。如果其它事务有更新的话，正在提交的事务会进行<strong>回滚</strong>。因此乐观并发控制多数用于数据争用不大、冲突较少的环境中。这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因此可以获得比其它并发控制方法更高的吞吐量。</li>
</ul>
</li>
<li><p>实现方式：</p>
<ul>
<li><p>MVCC 多版本并发控制。</p>
</li>
<li><p>CAS（Compare And Set）：实现思路是在 <code>set</code> 的时候，加上初始状态的 <code>compare</code> 条件判断，只有初始状态不变时，才 <code>set</code> 成功。为了避免 ABA 问题（例如 CAS 过程中只简单进行“值”的校验，在有些情况下，“值”相同不会引入错误的业务逻辑（例如余额），但有些情况下，“值”虽然相同，却已经不是原来的数据了），CAS 不能只比对“值”，还<strong>必须确保数据是原来的数据</strong>，才能修改成功。实现方式是采用“数据版本”机制，例如通过版本号（version）、时间戳（update_time），来做乐观锁的判断条件，一个数据一个版本，版本变化，即使值相同，也不应该修改成功。</p>
<ul>
<li><p>例如，使用 Java 原子类 <code>AtomicStampedReference</code> 进行值与版本号的双重校验，而不是 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code>、<code>AtomicReference</code> 等等只基于值的校验。</p>
</li>
<li><p>例如，MySQL：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE condition&#x3D;#condition#;</span><br><span class="line">UPDATE table_name SET name&#x3D;#name#, version&#x3D;version+1 WHERE version&#x3D;#version#；</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="悲观并发控制"><a href="#悲观并发控制" class="headerlink" title="悲观并发控制"></a>悲观并发控制</h2><ul>
<li><p>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，直到使用完毕才会解锁，这样别人想拿这个数据就会 block 住直到它拿到锁。</p>
</li>
<li><p>适用场景：</p>
<ul>
<li>悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。悲观锁大多数情况下依靠数据库的<strong>锁机制</strong>实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，由于会阻塞其它事务导致其一直等待，<strong>降低整体吞吐量</strong>，这样的开销往往无法承受。而乐观锁机制则避免了长事务中的数据库开销。</li>
</ul>
</li>
</ul>
<ul>
<li>使用场景：</li>
</ul>
<h3 id="原子性操作"><a href="#原子性操作" class="headerlink" title="原子性操作"></a>原子性操作</h3><p>集群部署环境下，面对并发请求，我们常常使用“一锁二判三更新”这套常规操作，其中第一步加锁是为了确保后两步操作的原子性，实现串行化访问临界资源，即同一时刻只能有一个线程独占性的访问临界资源（同步互斥访问），确保并发情况下临界资源的线程安全。</p>
<p>下面提供两种实现方案：</p>
<p>方案一 使用数据库行锁</p>
<ul>
<li>MySQL：在同一事务中先对资源加<strong>排它锁（写锁）</strong>，阻塞其它事务对同一资源的读写访问，然后在事务内进行代码判断以及资源更新提交，实现串行化访问资源：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 共享锁（读锁）</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- 排它锁（写锁）</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>方案二 使用其它分布式锁，节约数据库资源（<strong>推荐方案</strong>）</p>
<ul>
<li><p>Redis：<code>SETNX</code> 互斥锁（mutex key）实现分布式锁，使用时注意设置锁的过期时间避免锁死，然后后台线程设置锁续命，解锁时只能由集群内同机器操作。</p>
</li>
<li><p>Zookeeper：使用命令 <code>create -e -s</code> 创建临时+序号（<code>EPHEMERAL_SEQUENTIAL</code>）节点。</p>
</li>
</ul>
<h1 id="MySQL-的并发控制"><a href="#MySQL-的并发控制" class="headerlink" title="MySQL 的并发控制"></a>MySQL 的并发控制</h1><p><img src="/img/mysql/concurrency_control.png" alt="并发控制总结"></p>
<p>MySQL <code>InnoDB</code> 存储引擎中，悲观<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html" target="_blank" rel="noopener">锁的类型</a>还有很多种：</p>
<ul>
<li>Shared and Exclusive Locks（共享锁和排它锁）</li>
<li>Intention Locks（意向锁）</li>
<li>Record Locks（记录锁）</li>
<li>Gap Locks（区间锁）</li>
<li>Next-Key Locks</li>
<li>Insert Intention Locks（插入意向锁）</li>
<li>AUTO-INC Locks（自增锁）</li>
<li>Predicate Locks for Spatial Indexes（空间索引谓词锁）</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里举一个抽奖活动的例子，分别展示乐观锁和悲观锁的两种实现流程：</p>
<p><img src="/img/mysql/example_of_concurrency_control.jpg" alt="抽奖活动例子"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Concurrency_control" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Concurrency_control</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html</a></p>
<p><a href="https://segmentfault.com/a/1190000011200547" target="_blank" rel="noopener">《支付宝防并发方案之”一锁二判三更新”》</a></p>
<p>《高性能 MySQL》</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/01/03/mysql-charset/" class="post-title-link">MySQL 字符集与排序规则总结</a></h2><div class="post-info">2019-01-03<a href="/tags/MySQL/" title="MySQL" class="post-demo">MySQL</a></div><div class="post-content"><p>查看数据库支持的字符集：<code>SHOW CHARACTER SET</code></p>
<p>查看数据库支持的排序规则：<code>SHOW COLLATION</code></p>
<h1 id="字符集（Character-Sets）"><a href="#字符集（Character-Sets）" class="headerlink" title="字符集（Character Sets）"></a>字符集（Character Sets）</h1><p>下表是 MySQL 中八个可能影响到字符集的系统变量，其中有几个如果配置不当可能会乱码问题，需重点关注：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>character_set_client</code></td>
<td><code>utf8</code></td>
<td>The character set for statements that arrive from the client.</td>
</tr>
<tr>
<td><code>character_set_connection</code></td>
<td><code>utf8</code></td>
<td>The character set used for literals specified without a character set introducer and for number-to-string conversion.</td>
</tr>
<tr>
<td><code>character_set_database</code></td>
<td><code>latin1</code></td>
<td>The character set used by the default database.</td>
</tr>
<tr>
<td><code>character_set_filesystem</code></td>
<td><code>binary</code></td>
<td>The file system character set.</td>
</tr>
<tr>
<td><code>character_set_results</code></td>
<td><code>utf8</code></td>
<td>The character set used for returning query results to the client. This includes result data such as column values, result metadata such as column names, and error messages.</td>
</tr>
<tr>
<td><code>character_set_server</code></td>
<td><code>latin1</code></td>
<td>The server’s default character set.</td>
</tr>
<tr>
<td><code>character_set_system</code></td>
<td><code>utf8</code></td>
<td>The character set used by the server for storing identifiers.</td>
</tr>
<tr>
<td><code>character_sets_dir</code></td>
<td></td>
<td>The directory where character sets are installed.</td>
</tr>
</tbody></table>
<p>可以通过下图来了解 MySQL 内部字符集转换过程：</p>
<p><img src="/img/mysql/mysql_character_set.jpg" alt="MySQL Character Set"></p>
<ol>
<li>MySQL 收到请求时将请求数据从 <code>character_set_client</code> 转换为 <code>character_set_connection</code></li>
<li>进行内部操作前将请求数据从 <code>character_set_connection</code> 转换为内部操作字符集，步骤如下：<ol>
<li>使用每个数据字段的 <code>CHARACTER SET</code> 设定值；</li>
<li>若上述值不存在，则使用对应数据表的字符集设定值；</li>
<li>若上述值不存在，则使用对应数据库的字符集设定值；</li>
<li>若上述值不存在，则使用 <code>character_set_server</code> 设定值。</li>
</ol>
</li>
<li>最后将操作结果从内部操作字符集转换为 <code>character_set_results</code></li>
</ol>
<p>而系统变量 <code>character_set_database</code> 主要用来设置默认创建数据库的编码格式，如果在创建数据库时没有设置编码格式，就按照这个格式设置，如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`testdb`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET latin1 */</span></span><br></pre></td></tr></table></figure>

<p>从而影响到建表时默认的字符集：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=latin1;</span><br></pre></td></tr></table></figure>

<p>从而影响到中文字符的插入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">values</span> (<span class="string">'你好'</span>);</span><br><span class="line"></span><br><span class="line">[Err] 1366 - Incorrect string value: '\xE4\xBD\xA0\xE5\xA5\xBD' for column 'name' at row 1</span><br></pre></td></tr></table></figure>

<h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 影响系统变量 character_set_database 和 character_set_server</span><br><span class="line">character-set-server &#x3D; utf8</span><br><span class="line">collation-server &#x3D; utf8_unicode_ci</span><br><span class="line">init-connect &#x3D; &#39;SET NAMES utf8&#39;</span><br><span class="line"></span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine&#x3D;INNODB</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set &#x3D; utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set &#x3D; utf8</span><br></pre></td></tr></table></figure>

<p>配置后，需要重启服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql</span><br><span class="line">net start mysql</span><br></pre></td></tr></table></figure>

<p>之后，通过命令 <code>SHOW VARIABLES LIKE &#39;%character%&#39;</code> 查看结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------+----------+</span><br><span class="line">| Variable_name            | Value    |</span><br><span class="line">+--------------------------+----------+</span><br><span class="line">| character_set_client     | utf8     |</span><br><span class="line">| character_set_connection | utf8     |</span><br><span class="line">| character_set_database   | utf8     |</span><br><span class="line">| character_set_filesystem | binary   |</span><br><span class="line">| character_set_results    | utf8     |</span><br><span class="line">| character_set_server     | utf8     |</span><br><span class="line">| character_set_system     | utf8     |</span><br><span class="line">| character_sets_dir       | ...      |</span><br><span class="line">+--------------------------+----------+</span><br></pre></td></tr></table></figure>

<p>如果在创建数据库之前，没有在配置文件中配置好默认字符集，可以通过 <code>SET</code> 命令进行修改。</p>
<p>配置好后，建库结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`testdb`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci */</span></span><br></pre></td></tr></table></figure>

<h1 id="排序规则（Collations）"><a href="#排序规则（Collations）" class="headerlink" title="排序规则（Collations）"></a>排序规则（Collations）</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/charset.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/charset.html</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html</a></p>
<p><img src="/img/mysql/charset.png" alt="charset"></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/12/01/java-jdk-proxy/" class="post-title-link">Java 反射篇（四）动态代理之 JDK Proxy 总结</a></h2><div class="post-info">2018-12-01<a href="/tags/Java/" title="Java" class="post-demo">Java</a></div><div class="post-content"><p>什么是代理？</p>
<blockquote>
<p>代理对象 = 增强代码 + 目标对象</p>
</blockquote>
<p><img src="/img/java/proxy/Proxy.png" alt="proxy"></p>
<p>有哪些代理方式？</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<p>什么是动态代理？</p>
<blockquote>
<p>动态代理是一种在<strong>运行时</strong>动态生成代理的机制。这个概念是与静态代理相对的，静态代理需要为每一个目标类都手工编写或用工具生成一个对应的代理类，非常繁琐。</p>
</blockquote>
<p>动态代理的实现方式？</p>
<blockquote>
<p>动态代理的实现方式有很多种，比如：</p>
<ul>
<li><p>利用 JDK 自身提供的动态代理 API（<code>java.lang.reflect</code>）</p>
</li>
<li><p>或者利用性能更高的第三方字节码生成框架（例如 ASM、cglib（基于 ASM）、Javassist 等）</p>
</li>
</ul>
<p>最终目标都是生成一个代理类的字节码。</p>
</blockquote>
<p>哪些场景用到动态代理？</p>
<blockquote>
<p>比如：</p>
<p>包装 RPC 调用、…</p>
<p>面向切面的编程（AOP）</p>
<p><img src="/img/spring/aop/aop_lib.png" alt=""></p>
</blockquote>
<p>动态代理从代理对象创建到方法执行的整体流程如下：</p>
<p><img src="/img/java/proxy/jdk_proxy_process.png" alt="jdk_proxy_process"></p>
<p>下面来看下 JDK 自身提供的动态代理，底层是如何实现的。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>来个例子，实现如图效果：</p>
<p><img src="/img/java/proxy/jdk_proxy_example.png" alt="jdk_proxy_process2"></p>
<p>首先创建接口 <code>Flyable</code> 和目标类 <code>Bird</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标类和代理类共同实现的接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String param)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Target bird fly, param = &#123;&#125;"</span>, param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是关键的一步，实现 <code>InvocationHandler</code> 接口，创建代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Flyable target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// proxy 参数表示动态生成的 Proxy 类 通过反射创建出来的对象</span></span><br><span class="line">    <span class="comment">// method 参数表示 proxy 对象本次执行的方法，可以判断该参数动态决定执行对应的业务逻辑</span></span><br><span class="line">    <span class="comment">// args 参数表示 proxy 对方本次执行的方法参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 在目标对象执行前执行代码</span></span><br><span class="line">        log.info(<span class="string">"Before target bird method: &#123;&#125;"</span>, method.getName());</span><br><span class="line">        <span class="comment">// 在目标对象上执行指定方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 在目标对象执行后执行代码</span></span><br><span class="line">        log.info(<span class="string">"After target bird method: &#123;&#125;"</span>, method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Flyable <span class="title">newProxy</span><span class="params">(Flyable target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方式一：显式使用反射创建代理对象（先获取 com.sun.proxy.$Proxy0 的 Class 对象）</span></span><br><span class="line">        <span class="comment">// Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Flyable.class.getClassLoader(), target.getClass().getInterfaces());</span></span><br><span class="line">        <span class="comment">// Constructor&lt;?&gt; constructor = proxyClass.getConstructor(InvocationHandler.class);</span></span><br><span class="line">        <span class="comment">// return (Flyable) constructor.newInstance(new BirdProxy(target));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式二：隐式使用反射创建代理对象，API 更简单</span></span><br><span class="line">        <span class="keyword">return</span> (Flyable) Proxy.newProxyInstance(Flyable<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), <span class="title">target</span>.<span class="title">getClass</span>().<span class="title">getInterfaces</span>(), <span class="title">new</span> <span class="title">BirdProxy</span>(<span class="title">target</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建目标对象</span></span><br><span class="line">        Bird target = <span class="keyword">new</span> Bird();</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        Flyable proxy = BirdProxy.newProxy(target);</span><br><span class="line">        <span class="comment">// 调用任意方法，将执行代理逻辑</span></span><br><span class="line">        proxy.fly(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before target bird method: fly</span><br><span class="line">Target bird fly, param = hello world</span><br><span class="line">After target bird method: fly</span><br></pre></td></tr></table></figure>

<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>例子中涉及到两个 API，由 Java 1.3 引入：</p>
<p><code>java.lang.reflect.InvocationHandler</code>，代理对象内部的成员变量。作为代理对象和目标对象的<strong>桥梁</strong>，代理对象的每个方法调用，都会调用其 <code>invoke()</code> 方法，委托其去调用目标对象，可在此时机补充<strong>增强代码</strong>。</p>
<p><img src="/img/java/proxy/InvocationHandler_class.png" alt="InvocationHandler"></p>
<p><code>java.lang.reflect.Proxy</code>，用于创建代理类或代理对象，同时还是它们的父类。</p>
<p><img src="/img/java/proxy/Proxy_class.png" alt="Proxy"></p>
<p><code>Proxy</code> 的核心方法 <code>newProxyInstance</code> 用于运行时动态生成代理类并通过反射创建实例，其源码及关键注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 代理类构造方法的参数类型 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler<span class="class">.<span class="keyword">class</span> &#125;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 查找或生成指定的代理类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 反射调用代理类的构造方法（入参为指定的 invocation handler）创建实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反射获取构造方法</span></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用构造方法，创建代理对象</span></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Generate a proxy class.  Must call the checkProxyAccess method</span></span><br><span class="line"><span class="comment">     * to perform permission checks before calling this.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">        <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">        <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="获取动态代理生成的-Class-文件"><a href="#获取动态代理生成的-Class-文件" class="headerlink" title="获取动态代理生成的 Class 文件"></a>获取动态代理生成的 Class 文件</h1><p><code>java.lang.reflect.Proxy</code> 底层使用了 <code>sun.misc.ProxyGenerator</code> 工具类生成代理类。通过指定 <code>java</code> 命令参数 <code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</code> 可以让工具类将动态生成的字节码写到本地磁盘文件（$ProxyN.class）。本例生成的字节码文件反编译后源码如下，重点关注 <code>fly</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.proxy.Flyable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 proxy 对象的 fly 方法，则委托 InvocationHandler 对象执行 invoke 方法</span></span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.github.proxy.Flyable"</span>).getMethod(<span class="string">"fly"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，动态生成的 <code>$Proxy0</code> 类同样实现了 <code>Flyable</code> 接口，与目标类 <code>Bird</code> 类形成一个三角结构：</p>
<p><img src="/img/java/proxy/jdk_proxy.png" alt="jdk_proxy"></p>
<p><code>fly</code> 方法的实现，仅仅只是调用了 <code>InvocationHandler</code> 对象的 <code>invoke</code> 方法，传入上下文参数。具体的业务逻辑还是在自己的 <code>InvocationHandler</code> 中根据参数判断并自行实现。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://en.wikipedia.org/wiki/Proxy_pattern" target="_blank" rel="noopener">Proxy pattern 设计模式</a>》</p>
<p>《<a href="https://refactoringguru.cn/design-patterns/proxy" target="_blank" rel="noopener">代理设计模式</a>》</p>
<p>《<a href="https://www.jianshu.com/p/fc285d669bc5" target="_blank" rel="noopener">10分钟看懂动态代理设计模式</a>》</p>
<p>《<a href="https://time.geekbang.org/column/article/7489" target="_blank" rel="noopener">动态代理是基于什么原理？</a>》</p>
<p>《<a href="https://www.zhihu.com/question/20794107/answer/658139129" target="_blank" rel="noopener">Java 动态代理作用是什么？ - 知乎用户的回答</a>》</p>
<p>《<a href="http://stackoverflow.com/questions/22930195/understanding-proxy-arguments-of-the-invoke-method-of-java-lang-reflect-invoca" target="_blank" rel="noopener">Understanding “proxy” arguments of the invoke method of java.lang.reflect.InvocationHandler</a>》</p>
<p>《<a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">字节码增强技术探索</a>》</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/11/21/java-reflection-generic-type/" class="post-title-link">Java 反射篇（三）泛型 API 总结</a></h2><div class="post-info">2018-11-21<a href="/tags/Java/" title="Java" class="post-demo">Java</a></div><div class="post-content"><h1 id="泛型-API"><a href="#泛型-API" class="headerlink" title="泛型 API"></a>泛型 API</h1><p>JDK 1.5 引入了泛型特性，一同引入的还有 Java <code>Type</code> 类型体系。其中 <code>Type</code> 接口作为核心，是 Java 编程语言中所有类型的通用超级接口（common superinterface），这些类型包括：</p>
<ul>
<li>原始类型（raw types）</li>
<li>参数化类型（parameterized types）</li>
<li>数组类型（array types）</li>
<li>类型变量（type variables）</li>
<li>八大原始类型（primitive types）</li>
</ul>
<p>调整后新引入的五个接口如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Type</span><br><span class="line">  java.lang.reflect.ParameterizedType &#x2F;&#x2F; 最最常用</span><br><span class="line">  java.lang.reflect.TypeVariable</span><br><span class="line">  java.lang.reflect.WildcardType</span><br><span class="line">  java.lang.reflect.GenericArrayType</span><br></pre></td></tr></table></figure>

<p><img src="/img/java/reflection/Type.png" alt="Type"></p>
<p>它们的核心方法如下：</p>
<p><img src="/img/java/reflection/Type_methods.png" alt="Type_methods"></p>
<p>同时新增的接口还有 <code>GenericDeclaration</code>。从源码中看，只有三个类实现了该接口（见下图）。因此我们只能在<strong>类型</strong>（例如 <code>class</code>，<code>interface</code>）、<strong>方法</strong>（<code>Method</code>）和<strong>构造方法</strong>（<code>Constructor</code>）这三个地方声明泛型参数（type variables），而其它地方只能使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Method</span><br><span class="line">java.lang.reflect.Constructor</span><br><span class="line">java.lang.Class</span><br></pre></td></tr></table></figure>

<p><img src="/img/java/reflection/GenericDeclaration.png" alt="GenericDeclaration"></p>
<p><code>GenericDeclaration</code> 接口只定义了一个方法，用于获取 <code>TypeVariable</code>：</p>
<p><img src="/img/java/reflection/GenericDeclaration_method.png" alt="GenericDeclaration_method"></p>
<p>类、字段、方法、构造方法也相应增加了一组方法用于获取 <code>Type</code>、<code>TypeVariable</code>：</p>
<ul>
<li><p><code>Class</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取普通 Class</span></span><br><span class="line">Class&lt;? <span class="keyword">super</span> T&gt; getSuperclass()</span><br><span class="line">Class&lt;?&gt;[] getInterfaces()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Type</span></span><br><span class="line"><span class="function">Type <span class="title">getGenericSuperclass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getGenericInterfaces</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取 TypeVariable</span></span></span><br><span class="line"><span class="function">TypeVariable&lt;?&gt;[] <span class="title">getTypeParameters</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Field</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取普通 Class</span></span><br><span class="line">Class&lt;?&gt; getType()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Type</span></span><br><span class="line"><span class="function">Type <span class="title">getGenericType</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Method</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取普通 Class</span></span><br><span class="line">Class&lt;?&gt; getReturnType()</span><br><span class="line">Class&lt;?&gt;[] getParameterTypes()</span><br><span class="line">Class&lt;?&gt;[] getExceptionTypes()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Type</span></span><br><span class="line"><span class="function">Type <span class="title">getGenericReturnType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getGenericParameterTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getGenericExceptionTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取 TypeVariable</span></span></span><br><span class="line"><span class="function">TypeVariable&lt;?&gt;[] <span class="title">getTypeParameters</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Constructor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取普通 Class</span></span><br><span class="line">Class&lt;?&gt;[] getParameterTypes()</span><br><span class="line">Class&lt;?&gt;[] getExceptionTypes()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Type</span></span><br><span class="line">Type[] getGenericParameterTypes()</span><br><span class="line">Type[] getGenericExceptionTypes()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 TypeVariable</span></span><br><span class="line">TypeVariable&lt;?&gt;[] getTypeParameters()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="泛型术语"><a href="#泛型术语" class="headerlink" title="泛型术语"></a>泛型术语</h1><p>泛型涉及的术语比较多，其与反射接口的对应关系如下：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>中文含义</th>
<th>举例</th>
<th>反射接口</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>Generic type</td>
<td>泛型</td>
<td><code>List&lt;E&gt;</code></td>
<td><code>ParameterizedType</code></td>
<td></td>
</tr>
<tr>
<td>Parameterized type</td>
<td>参数化类型</td>
<td><code>List&lt;String&gt;</code></td>
<td><code>ParameterizedType</code></td>
<td></td>
</tr>
<tr>
<td>Raw type</td>
<td>原始类型</td>
<td><code>List</code></td>
<td><code>ParameterizedType#getRawType</code></td>
<td>该方法虽然返回  <code>Type</code> 类型，但实际类型是 <code>Class</code>，可以强转使用：<code>(Class&lt;?&gt;) type</code>。</td>
</tr>
<tr>
<td>Unbounded wildcard type</td>
<td>无限制通配符类型</td>
<td><code>List&lt;?&gt;</code></td>
<td><code>ParameterizedType</code></td>
<td></td>
</tr>
<tr>
<td>Bounded wildcard type</td>
<td>有限制通配符类型（上限）</td>
<td><code>List&lt;? extends Number&gt;</code></td>
<td><code>ParameterizedType</code></td>
<td></td>
</tr>
<tr>
<td>Bounded wildcard type</td>
<td>有限制通配符类型（下限）</td>
<td><code>List&lt;? super Number&gt;</code></td>
<td><code>ParameterizedType</code></td>
<td></td>
</tr>
<tr>
<td>wildcard type</td>
<td>通配符类型</td>
<td><code>?</code></td>
<td><code>WildcardType</code></td>
<td></td>
</tr>
<tr>
<td>Formal type parameter</td>
<td>形式类型参数</td>
<td><code>E</code></td>
<td><code>TypeVarialbe</code></td>
<td></td>
</tr>
<tr>
<td>Actual type parameter</td>
<td>实际类型参数</td>
<td><code>String</code></td>
<td><code>ParameterizedType#getActualTypeArguments</code></td>
<td>该方法虽然返回  <code>Type[]</code> 类型，但各元素实际类型是 <code>Class</code>，可以强转使用：<code>(Class&lt;?&gt;) type</code>。</td>
</tr>
<tr>
<td>Bounded type parameter</td>
<td>有限制类型参数</td>
<td><code>&lt;E extends Number&gt;</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Recursive type bound</td>
<td>递归类型限制</td>
<td><code>&lt;T extends Comparable&lt;T&gt;&gt;</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Generic method</td>
<td>泛型方法</td>
<td><code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Type token</td>
<td>类型令牌</td>
<td><code>String.class</code></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>下面是几个获取 <code>Type</code> 的例子，先创建三个类：<code>BaseMapper</code>、<code>PersonMapper</code>、<code>Person</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span> &amp; <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;, <span class="title">K</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getById</span><span class="params">(K id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonMapper</span> <span class="keyword">implements</span> <span class="title">BaseMapper</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Number&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;T&gt; list1, List&lt;? extends Comparable&lt;T&gt;&gt; list2, T[] array, T item)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.personName.compareTo(o.getPersonName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Method method = PersonMapper.class.getMethod("test", List.class, List.class, Number[].class, Number.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [0] ParameterizedType</span></span><br><span class="line">    <span class="comment">// [1] ParameterizedType</span></span><br><span class="line">    <span class="comment">// [2] GenericArrayType</span></span><br><span class="line">    <span class="comment">// [3] TypeVariable</span></span><br><span class="line">    Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Class</span></span><br><span class="line">    Type genericReturnType = method.getGenericReturnType();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Class[0]</span></span><br><span class="line">    Type[] genericExceptionTypes = method.getGenericExceptionTypes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个 <code>Type</code> 变量的内容如下：</p>
<p><img src="/img/java/reflection/generic_type_example.png" alt="generic_type_examples"></p>
<h2 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h2><p>接下来看下 <code>ParameterizedType</code> 的使用，可以用于获取泛型的原始类型（Raw type）、实际类型参数（Actual type parameter）列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// com.github.reflection.BaseMapper&lt;com.github.reflection.Person, java.lang.Long&gt;</span></span><br><span class="line">    Type genericInterface = PersonMapper.class.getGenericInterfaces()[0];</span><br><span class="line">    assertTrue(genericInterface <span class="keyword">instanceof</span> ParameterizedType);</span><br><span class="line">    ParameterizedType parameterizedType = (ParameterizedType) genericInterface;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取原始类型：BaseMapper.class</span></span><br><span class="line">    assertEquals(BaseMapper<span class="class">.<span class="keyword">class</span>, <span class="title">parameterizedType</span>.<span class="title">getRawType</span>())</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实际类型参数列表：Person.class、Long.class</span></span><br><span class="line">    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">    assertEquals(<span class="string">"There are two actual type arguments"</span>, <span class="number">2</span>, actualTypeArguments.length);</span><br><span class="line">    <span class="comment">// class com.github.reflection.Person</span></span><br><span class="line">    assertClass(<span class="string">"One is Person"</span>, actualTypeArguments[<span class="number">0</span>], Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// class java.lang.Long</span></span><br><span class="line">    assertClass(<span class="string">"Another is Long"</span>, actualTypeArguments[<span class="number">1</span>], Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">assertClass</span><span class="params">(Type type, Class expectedClass)</span> </span>&#123;</span><br><span class="line">    assertTrue(type <span class="keyword">instanceof</span> Class);</span><br><span class="line">    Class clazz = (Class) type;</span><br><span class="line">    assertEquals(expectedClass, clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>genericInterface</code> 变量的内容如下，接口返回类型虽然为 <code>Type</code>，实际类型为 <code>ParameterizedType</code>，因此可以强转。该泛型变量的原始类型、实际类型参数列表如下，实际都为 <code>Class</code> 类型，因此可以强转 <code>(Class&lt;?&gt;) type</code>：</p>
<p><img src="/img/java/reflection/ParameterizedType_example.png" alt="ParameterizedType_example"></p>
<h2 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h2><p><code>WildcardType</code> 的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// java.util.List&lt;?&gt;</span></span><br><span class="line">    Method method = PersonMapper.class.getMethod("log", List.class);</span><br><span class="line">    Type genericParameterType = method.getGenericParameterTypes()[<span class="number">0</span>];</span><br><span class="line">    assertTrue(<span class="string">"The first parameter type of log method is instance of ParameterizedType"</span>, </span><br><span class="line">               genericParameterType <span class="keyword">instanceof</span> ParameterizedType);</span><br><span class="line">    ParameterizedType parameterType = (ParameterizedType) genericParameterType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WildcardType</span></span><br><span class="line">    Type type = parameterType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    assertTrue(<span class="string">"The actual type argument of ParameterizedType is instance of WildcardType"</span>, </span><br><span class="line">               type <span class="keyword">instanceof</span> WildcardType);</span><br><span class="line">    WildcardType wildcardType = (WildcardType) type;</span><br><span class="line">    assertEquals(<span class="string">"No lower bounds exist"</span>, <span class="number">0</span>, wildcardType.getLowerBounds().length);</span><br><span class="line">    assertEquals(<span class="string">"Only one upper bound exist"</span>, <span class="number">1</span>, wildcardType.getUpperBounds().length);</span><br><span class="line">    <span class="comment">// 通配符默认上限类型为 Object</span></span><br><span class="line">    assertEquals("The upper bound is Object", Object.class, wildcardType.getUpperBounds()[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Type</code> 类型变量 <code>genericParameterType</code> 的内容如下，实际类型是 <code>ParameterizedType</code>，其 <code>?</code> 通配符是 <code>WildcardType</code>：</p>
<p><img src="/img/java/reflection/WildcardType_example.png" alt="WildcardType_example"></p>
<h2 id="例子四"><a href="#例子四" class="headerlink" title="例子四"></a>例子四</h2><p><code>TypeVariable</code> 的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Method method = BaseMapper.class.getMethod("getById", Serializable.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TypeVariable</span></span><br><span class="line">    Type genericReturnType = method.getGenericReturnType();</span><br><span class="line">    assertTrue(<span class="string">"Return type of method is instance of TypeVariable"</span>, genericReturnType <span class="keyword">instanceof</span> TypeVariable);</span><br><span class="line">    TypeVariable typeVariable = (TypeVariable) genericReturnType;</span><br><span class="line">    assertEquals("First upper bound is Serializable", Serializable.class, typeVariable.getBounds()[0]);</span><br><span class="line">    ParameterizedType parameterizedType = (ParameterizedType) typeVariable.getBounds()[<span class="number">1</span>];</span><br><span class="line">    assertEquals(<span class="string">"Second upper bound is Comparable"</span>, Comparable<span class="class">.<span class="keyword">class</span>, <span class="title">parameterizedType</span>.<span class="title">getRawType</span>())</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Type</code> 类型变量 <code>genericReturnType</code> 的内容如下，实际类型是 <code>TypeVariable</code>，</p>
<p><img src="/img/java/reflection/TypeVariable_example.png" alt="TypeVariable_example"></p>
<h2 id="例子五"><a href="#例子五" class="headerlink" title="例子五"></a>例子五</h2><p>定义一个泛型工具类，用于获取 <code>T.class</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射获得定义 Class 时声明的父类的泛型参数的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回第一个类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">getSuperClassGenricType</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSuperClassGenricType(clazz, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射获得定义 Class 时声明的父类的泛型参数的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 返回某个下标的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">getSuperClassGenricType</span><span class="params">(Class clazz, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;</span><br><span class="line">        Type genType = clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (!(genType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Object<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Type[] params = ((ParameterizedType) genType).getActualTypeArguments();</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= params.length || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Object<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(params[index] <span class="keyword">instanceof</span> Class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Object<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Class) params[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/faed45dbfa0c" target="_blank" rel="noopener">https://www.jianshu.com/p/faed45dbfa0c</a></p>
<p><a href="https://blog.csdn.net/ShuSheng0007/article/details/89520530" target="_blank" rel="noopener">https://blog.csdn.net/ShuSheng0007/article/details/89520530</a></p>
<p>API：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Type.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Type.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/ParameterizedType.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/ParameterizedType.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/TypeVariable.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/TypeVariable.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/WildcardType.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/WildcardType.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/GenericArrayType.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/GenericArrayType.html</a></li>
</ul>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/11/14/java-reflection-annotation/" class="post-title-link">Java 反射篇（二）注解 API 总结</a></h2><div class="post-info">2018-11-14<a href="/tags/Java/" title="Java" class="post-demo">Java</a></div><div class="post-content"><p>JDK 1.5 引入了注解，其主要用途如下：</p>
<ul>
<li>生成文档，通过代码里标识的元数据生成 javadoc 文档。</li>
<li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li>
<li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li>
<li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li>
</ul>
<h1 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h1><p>首先，注解也是一种 <code>class</code>，所有注解都默认继承自通用接口：<code>java.lang.annotation.Annotation</code>：</p>
<p><img src="/img/java/reflection/annotation.png" alt="annotation"></p>
<p>从上图可见，JDK 提供的元注解（meta annotation）如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Native</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable</span></span><br><span class="line"><span class="meta">@Target</span></span><br><span class="line"><span class="meta">@Retention</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>@Native</code>、<code>@Documented</code>、<code>@Inherited</code> 是一个“标记注解”，没有成员。</p>
<p>常用元注解的作用如下：</p>
<h2 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h2><p><code>@Inherited</code> 用于定义<strong>子类是否可继承父类定义的注解</strong>。仅针对 <code>@Target(ElementType.TYPE)</code> 类型的注解有效，并且仅针对 <code>class</code> 的继承，对 <code>interface</code> 的继承无效。注意：</p>
<ul>
<li>因此 <code>interface</code> 上标注的注解，无法被 JDK Proxy 动态代理生成的类所继承。</li>
<li>也因此 Spring AOP 的切点表达式 <code>@annotation(...)</code> 无法切到基于 JDK Proxy 的动态代理类。</li>
</ul>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html</a></p>
<blockquote>
<p>Indicates that an annotation type is automatically inherited. If an Inherited meta-annotation is present on an annotation type declaration, and the user queries the annotation type on a class declaration, and the class declaration has no annotation for this type, <strong>then the class’s superclass will automatically be queried for the annotation type.</strong> This process will be repeated until an annotation for this type is found, or the top of the class hierarchy (Object) is reached. If no superclass has an annotation for this type, then the query will indicate that the class in question has no such annotation.</p>
<p><strong>Note that this meta-annotation type has no effect if the annotated type is used to annotate anything other than a class. Note also that this meta-annotation only causes annotations to be inherited from superclasses; annotations on implemented interfaces have no effect.</strong></p>
</blockquote>
<h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p><code>@Target</code> 用于定义注解能够被标注于源码的哪些位置。可用字段参考 <code>ElementType</code> 枚举。</p>
<p>JDK 8 扩展了注解的上下文，现在注解几乎可以加到任何地方：局部变量、泛型类、⽗类与接⼝的实现，就连⽅法的异常也能添加注解。</p>
<p>JDK 8 引入的这两个枚举如下：</p>
<ul>
<li><code>ElementType.TYPE_PARAMETER</code> 用于标注泛型的类型参数。</li>
<li><code>ElementType.TYPE_USE</code> 用于标注各种类型。</li>
</ul>
<p><img src="/img/java/reflection/extended_annotations_support.png" alt="extended_annotations_support"></p>
<h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h2><p><code>@Retention</code> 用于定义注解的生命周期。可用字段参考下面的 <code>RetentionPolicy</code> 枚举源码，常用的是 <code>RUNTIME</code> 类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Annotation retention policy.  The constants of this enumerated type</span></span><br><span class="line"><span class="comment">* describe the various policies for retaining annotations.  They are used</span></span><br><span class="line"><span class="comment">* in conjunction with the &#123;<span class="doctag">@link</span> Retention&#125; meta-annotation type to specify</span></span><br><span class="line"><span class="comment">* how long annotations are to be retained.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  Joshua Bloch</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h2><p>JDK 8 引入了 <code>@Repeatable</code>，表示该注解是否可重复标注。配套引入的还有为 <code>AnnotatedElement</code> 接口新增了两个方法 <code>getAnnotationsByType</code>、<code>getDeclaredAnnotationsByType</code>。</p>
<h1 id="AnnotatedElement"><a href="#AnnotatedElement" class="headerlink" title="AnnotatedElement"></a>AnnotatedElement</h1><p>读取运行时（<code>@Retention(RetentionPolicy.RUNTIME)</code>）的注解，需要用到反射 API。<code>java.lang.reflect.AnnotatedElement</code> 接口提供了一组方法，用于获取注解信息：</p>
<p><img src="/img/java/reflection/AnnotatedElement_methods.png" alt="AnnotatedElement_methods"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断某个注解是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取注解（包括父类）</span></span></span><br><span class="line"><span class="function">&lt;T extends Annotation&gt; T <span class="title">getAnnotation</span><span class="params">(Class&lt;T&gt;)</span></span></span><br><span class="line"><span class="function">&lt;T extends Annotation&gt; T[] <span class="title">getAnnotationsByType</span><span class="params">(Class&lt;T&gt;)</span></span></span><br><span class="line"><span class="function">Annotation[] <span class="title">getAnnotations</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取注解（不包括父类）</span></span></span><br><span class="line"><span class="function">&lt;T extends Annotation&gt; T <span class="title">getDeclaredAnnotation</span><span class="params">(Class&lt;T&gt;)</span></span></span><br><span class="line"><span class="function">&lt;T extends Annotation&gt; T[] <span class="title">getDeclaredAnnotationsByType</span><span class="params">(Class&lt;T&gt;)</span></span></span><br><span class="line"><span class="function">Annotation[] <span class="title">getDeclaredAnnotations</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>由于下列类都实现了该接口，因此都拥有这些方法获取注解信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Class</span><br><span class="line">java.lang.Package</span><br><span class="line">java.lang.reflect.Field</span><br><span class="line">java.lang.reflect.Method</span><br><span class="line">java.lang.reflect.Constructor</span><br><span class="line">java.lang.reflect.Parameter</span><br></pre></td></tr></table></figure>

<p><img src="/img/java/reflection/main_api.png" alt="main_api"></p>
<p>举个例子，看下哪些情况通过反射可以拿到注解（或拿不到）：</p>
<p>注解如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>例子一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Check</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String msg)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String childName = <span class="string">"Hello"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ToString annotation = Child<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">ToString</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        assertNull(<span class="string">"结果为 null 因为 @ToString 标注为 @Retention(RetentionPolicy.SOURCE)"</span>, annotation);</span><br><span class="line"></span><br><span class="line">        Check annotation1 = Child<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Check</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        assertNotNull(<span class="string">"结果不为 null 因为 @Check 标注为 @Retention(RetentionPolicy.RUNTIME)、@Inherited 并且 @Check 被标注在父类上，可以被子类继承"</span>, annotation1);</span><br><span class="line"></span><br><span class="line">        Check annotation2 = Child<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredAnnotation</span>(<span class="title">Check</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        assertNull(<span class="string">"结果为 null 因为 getDeclaredAnnotation 方法无法拿到父类注解"</span>, annotation2);</span><br><span class="line"></span><br><span class="line">        Method sayString = Child.class.getMethod("say", String.class);</span><br><span class="line">        Check annotation3 = sayString.getAnnotation(Check<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        assertNotNull(<span class="string">"结果不为 null 因为 say 方法未被子类重写，被完整继承下来"</span>, annotation3);</span><br><span class="line"></span><br><span class="line">        Method say = Child.class.getMethod("say");</span><br><span class="line">        Check annotation4 = say.getAnnotation(Check<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        assertNull(<span class="string">"结果为 null 因为 say 方法被子类重写了"</span>, annotation4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Check</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sayable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Sayable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Check annotation5 = Student<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Check</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        assertNull(<span class="string">"结果为 null 因为接口上的注解无法被子类继承"</span>, annotation5);</span><br><span class="line"></span><br><span class="line">        Check annotation6 = Student.class.getMethod("say").getAnnotation(Check.class);</span><br><span class="line">        assertNull(<span class="string">"结果为 null"</span>, annotation6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AnnotatedType"><a href="#AnnotatedType" class="headerlink" title="AnnotatedType"></a>AnnotatedType</h1><p>JDK 8 引入了 <code>java.lang.reflect.AnnotatedType</code>：</p>
<p><img src="/img/java/reflection/AnnotatedType.png" alt="AnnotatedType"></p>
<p>类、字段、方法、构造方法相应增加了一组方法用于获取 <code>AnnotatedType</code>：</p>
<ul>
<li><p><code>Class</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AnnotatedType <span class="title">getAnnotatedSuperclass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">AnnotatedType[] <span class="title">getAnnotatedInterfaces</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Field</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AnnotatedType <span class="title">getAnnotatedType</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Method</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AnnotatedType <span class="title">getAnnotatedReturnType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">AnnotatedType[] <span class="title">getAnnotatedParameterTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">AnnotatedType[] <span class="title">getAnnotatedExceptionTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">AnnotatedType <span class="title">getAnnotatedReceiverType</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Constructor</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AnnotatedType <span class="title">getAnnotatedReturnType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">AnnotatedType[] <span class="title">getAnnotatedParameterTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">AnnotatedType[] <span class="title">getAnnotatedExceptionTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">AnnotatedType <span class="title">getAnnotatedReceiverType</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://mp.weixin.qq.com/s?__biz=MzAxMjY1NTIxNA==&mid=2454441897&idx=1&sn=729688d470c94560c1e73e79f0c13adc&chksm=8c11e0a8bb6669be1cc4daee95b221ba437d536d598520d635fac4f18612dded58d6fddb0dce&scene=21#wechat_redirect" target="_blank" rel="noopener">深入理解java注解的实现原理</a>》</p>
<p>API：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Annotation.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Annotation.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedType.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedType.html</a></li>
</ul>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/11/07/java-reflection-api/" class="post-title-link">Java 反射篇（一）基础 API 总结</a></h2><div class="post-info">2018-11-07<a href="/tags/Java/" title="Java" class="post-demo">Java</a></div><div class="post-content"><p>什么是反射？</p>
<blockquote>
<p>反射机制是 Java 语言提供的一种基础功能，赋予程序在<strong>运行时自省</strong>（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p>
</blockquote>
<p>主要类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Class</span><br><span class="line">java.lang.Package</span><br><span class="line">java.lang.reflect.Field</span><br><span class="line">java.lang.reflect.Method</span><br><span class="line">java.lang.reflect.Constructor</span><br><span class="line"><span class="comment">// JDK 1.8 新引入，通过该类的 getName 方法能在运行时得到参数的名称（前提是通过 -parameters 指定编译器在编译的时候将参数名编译进去）</span></span><br><span class="line">java.lang.reflect.Parameter</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Array</span><br></pre></td></tr></table></figure>

<p>工具类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Modifier</span><br></pre></td></tr></table></figure>

<p>继承关系：</p>
<p><img src="/img/java/reflection/main_api.png" alt="main_api"></p>
<h1 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h1><p>如何获取一个 <code>class</code> 的 <code>Class</code> 实例？有几种方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：直接通过一个 class 的静态变量 class 获取</span></span><br><span class="line">Class&lt;String&gt; aClass = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：通过实例变量提供的 getClass() 方法获取</span></span><br><span class="line">Class&lt;? extends String&gt; aClass2 = <span class="string">"Hello"</span>.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：通过 class 的完整类名获取，底层调用的是应用类加载器 Application ClassLoader (sun.misc.Launcher$AppClassLoader)</span></span><br><span class="line">Class&lt;?&gt; aClass3 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法四：通过自定义 ClassLoader 获取</span></span><br><span class="line">URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:/c:/"</span>)&#125;);</span><br><span class="line">Class&lt;?&gt; aClass4 = classLoader.loadClass(<span class="string">"java.lang.String"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父类</span></span><br><span class="line">Class&lt;? <span class="keyword">super</span> String&gt; superclass = String<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>()</span>;  <span class="comment">// class java.lang.Object</span></span><br><span class="line"><span class="comment">// 获取外部类</span></span><br><span class="line">Class&lt;?&gt; enclosingClass = Map.Entry<span class="class">.<span class="keyword">class</span>.<span class="title">getEnclosingClass</span>()</span>;  <span class="comment">// interface java.util.Map</span></span><br><span class="line"><span class="comment">// 获取内部类</span></span><br><span class="line">Class&lt;?&gt;[] classes = HashMap<span class="class">.<span class="keyword">class</span>.<span class="title">getClasses</span>()</span>;  <span class="comment">// 2 个内部类</span></span><br><span class="line">Class&lt;?&gt;[] declaredClasses = HashMap<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredClasses</span>()</span>;  <span class="comment">// 13 个内部类</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>Class</code> 实例在 JVM 中是唯一的，因此，上述方法获取的 <code>Class</code> 实例都是同一个实例。可以用 <code>==</code> 比较两个 <code>Class</code> 实例求证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true</span></span><br><span class="line">assertTrue(aClass == aClass2);</span><br><span class="line">assertTrue(aClass == aClass3);</span><br><span class="line">assertTrue(aClass2 == aClass3);</span><br></pre></td></tr></table></figure>

<p>拿到 <code>Class</code> 实例后，可以通过下列方法获取字段、方法、构造方法、注解，以进行后续操作。方法名以 <code>getDeclared</code> 开头的表示仅获取当前类的信息（不包括父类）：</p>
<table>
<thead>
<tr>
<th>Member</th>
<th>Class API</th>
<th>Param  type</th>
<th>Return type</th>
<th>Inherited members</th>
<th>Private members</th>
</tr>
</thead>
<tbody><tr>
<td><code>Class</code></td>
<td><code>getDeclaredClasses()</code></td>
<td></td>
<td>Array</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td></td>
<td><code>getClasses()</code></td>
<td></td>
<td>Array</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td><code>Field</code></td>
<td><code>getDeclaredField()</code></td>
<td><code>String</code></td>
<td>Single</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td></td>
<td><code>getField()</code></td>
<td><code>String</code></td>
<td>Single</td>
<td>Y</td>
<td><code>java.lang.NoSuchFieldException</code></td>
</tr>
<tr>
<td></td>
<td><code>getDeclaredFields()</code></td>
<td></td>
<td>Array</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td></td>
<td><code>getFields()</code></td>
<td></td>
<td>Array</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td><code>Method</code></td>
<td><code>getDeclaredMethod()</code></td>
<td><code>String</code>, <code>Class&lt;?&gt;...</code></td>
<td>Single</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td></td>
<td><code>getMethod()</code></td>
<td><code>String</code>, <code>Class&lt;?&gt;...</code></td>
<td>Single</td>
<td>Y</td>
<td><code>java.lang.NoSuchMethodException</code></td>
</tr>
<tr>
<td></td>
<td><code>getDeclaredMethods()</code></td>
<td></td>
<td>Array</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td></td>
<td><code>getMethods()</code></td>
<td></td>
<td>Array</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td><code>Constructor</code></td>
<td><code>getDeclaredConstructor()</code></td>
<td><code>Class&lt;?&gt;...</code></td>
<td>Single</td>
<td>N/A</td>
<td>Y</td>
</tr>
<tr>
<td></td>
<td><code>getConstructor()</code></td>
<td><code>Class&lt;?&gt;...</code></td>
<td>Single</td>
<td>N/A</td>
<td><code>java.lang.NoSuchMethodException</code></td>
</tr>
<tr>
<td></td>
<td><code>getDeclaredConstructors()</code></td>
<td></td>
<td>Array</td>
<td>N/A</td>
<td>Y</td>
</tr>
<tr>
<td></td>
<td><code>getConstructors()</code></td>
<td></td>
<td>Array</td>
<td>N/A</td>
<td>N</td>
</tr>
<tr>
<td><code>Annotation</code></td>
<td><code>getDeclaredAnnotation()</code></td>
<td><code>Class&lt;T&gt;</code></td>
<td>Single</td>
<td>N</td>
<td>N/A</td>
</tr>
<tr>
<td></td>
<td><code>getAnnotation()</code></td>
<td><code>Class&lt;T&gt;</code></td>
<td>Single</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr>
<td></td>
<td><code>getDeclaredAnnotationsByType()</code></td>
<td><code>Class&lt;T&gt;</code></td>
<td>Array</td>
<td>N</td>
<td>N/A</td>
</tr>
<tr>
<td></td>
<td><code>getAnnotationsByType()</code></td>
<td><code>Class&lt;T&gt;</code></td>
<td>Array</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr>
<td></td>
<td><code>getDeclaredAnnotations()</code></td>
<td></td>
<td>Array</td>
<td>N</td>
<td>N/A</td>
</tr>
<tr>
<td></td>
<td><code>getAnnotations()</code></td>
<td></td>
<td>Array</td>
<td>Y</td>
<td>N/A</td>
</tr>
</tbody></table>
<h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><p>一个 <code>Field</code> 对象包含了一个字段的所有信息，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字段名称</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 字段类型</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt; <span class="title">getType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 字段的修饰符，返回值是一个int，不同的 bit 表示不同的含义。使用 Modifier 工具类进行解析</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>以 <code>String</code> 类的 <code>value</code> 字段为例，它的定义是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用反射获取该字段的信息，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Field f = String.class.getDeclaredField("value");</span><br><span class="line">f.getName(); <span class="comment">// "value"</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>获取或设置字段值，使用如下方法。注意如果试图获取非 <code>public</code> 字段，将抛出异常 <code>java.lang.IllegalAccessException</code>，解决办法是先设置 <code>setAccessible(true)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取字段值</span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getChar</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">getShort</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLong</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置字段值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBoolean</span><span class="params">(Object obj, <span class="keyword">boolean</span> z)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setByte</span><span class="params">(Object obj, <span class="keyword">byte</span> b)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setChar</span><span class="params">(Object obj, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setShort</span><span class="params">(Object obj, <span class="keyword">short</span> s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(Object obj, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLong</span><span class="params">(Object obj, <span class="keyword">long</span> l)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(Object obj, <span class="keyword">float</span> f)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDouble</span><span class="params">(Object obj, <span class="keyword">double</span> d)</span></span></span><br></pre></td></tr></table></figure>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>一个 <code>Method</code> 对象包含一个方法的所有信息，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法名称</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 方法参数个数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParameterCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 方法参数类型</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt;[] <span class="title">getParameterTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 方法参数注解</span></span></span><br><span class="line"><span class="function">Annotation[][] <span class="title">getParameterAnnotations</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 方法返回值类型</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt; <span class="title">getReturnType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 方法异常类型</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt;[] <span class="title">getExceptionTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 方法的修饰符，返回值是一个int，不同的 bit 表示不同的含义。使用 Modifier 工具类进行解析</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>方法调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数为指定的实例对象。</span></span><br><span class="line"><span class="comment">// 如果是静态方法，可传 null。</span></span><br><span class="line"><span class="comment">// 如果是非 public 方法，需先设置 setAccessible(true)</span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br></pre></td></tr></table></figure>

<h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>创建新实例的几种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：通过 new 操作符</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：通过反射，调用 Class 提供的 newInstance() 方法。局限是只能调用其 public 无参构造方法</span></span><br><span class="line">Person p = Person<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：通过反射，调用 Constructor 提供的 newInstance() 方法。如果是非 public 方法，需先设置 setAccessible(true)</span></span><br><span class="line"><span class="comment">// 这里通过 private Person(String name) 构造新实例</span></span><br><span class="line">Constructor&lt;Person&gt; constructor = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Person peter = constructor.newInstance(<span class="string">"Peter"</span>);</span><br></pre></td></tr></table></figure>

<h1 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h1><p>通过以下方法获取父类或已实现接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取父类（Object 的父类是 null，其他任何非 interface 的 Class 都必定存在一个父类类型）</span></span><br><span class="line">Class&lt;? <span class="keyword">super</span> T&gt; getSuperclass()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取已实现接口（只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型）</span></span><br><span class="line">Class&lt;?&gt;[] getInterfaces()</span><br></pre></td></tr></table></figure>

<h2 id="isInstance"><a href="#isInstance" class="headerlink" title="isInstance"></a>isInstance</h2><p>使用 <code>instanceof</code> 操作符或者 <code>Class#isInstance</code> 方法，可以判断一个实例的继承关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object n = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">boolean</span> isDouble = n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> isInteger = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isNumber = n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isSerializable = n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isDouble = Double<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">n</span>)</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h2><p>如果 <code>instanceof</code> 为 <code>true</code>，可以使用以下方法对实例进行强制类型转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number num1 = (Number) n;</span><br><span class="line">Number num2 = Number<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">n</span>)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="isAssignableFrom"><a href="#isAssignableFrom" class="headerlink" title="isAssignableFrom"></a>isAssignableFrom</h2><p>如果是两个 <code>Class</code> 实例，要判断向上转型是否成立，可以调用 <code>Class#isAssignableFrom</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line">Number<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line">Object<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line">Integer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Number</span>.<span class="title">class</span>)</span>; <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/index.html</a></p>
<p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/index.html</a></p>
<p><a href="https://www.cnblogs.com/Kidezyq/p/11763988.html" target="_blank" rel="noopener">JDK1.8 反射包新增了<code>Parameter</code>类</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512</a></p>
<p>API：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Package.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/Package.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Parameter.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Parameter.html</a></li>
</ul>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/11/05/java-spi/" class="post-title-link">Java 类加载篇（二）Java SPI 机制总结</a></h2><div class="post-info">2018-11-05<a href="/tags/Java/" title="Java" class="post-demo">Java</a></div><div class="post-content"><h1 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h1><p>SPI 全称 Service Provider Interface，Java 1.6 引入，是 Java 在语言层面为我们提供了一种方便地创建可扩展应用的途径。SPI 提供了一种 JVM 级别的服务发现机制，我们只需要按照 SPI 的要求，在 jar 包中进行适当的配置，JVM 就会在运行时通过懒加载，帮我们找到所需的服务并加载。如果我们一直不使用某个服务，那么它不会被加载，一定程度上避免了资源的浪费。</p>
<p>整体机制图如下：</p>
<p><img src="/img/java/spi/java-spi.webp" alt="Java SPI"></p>
<h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><p>以 JDBC 为例，<strong>标准服务接口</strong>为 <code>com.mysql.jdbc.Driver</code>。</p>
<p>MySQL 作为<strong>服务提供方</strong>，以 mysql-connector-java 5.1.44 为例，按规范要求其 <code>META-INF/services/java.sql.Driver</code> 配置文件中声明了两个<strong>实现类</strong>，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.mysql.jdbc.Driver</span><br><span class="line">com.mysql.fabric.jdbc.FabricMySQLDriver</span><br></pre></td></tr></table></figure>

<p>当类加载器载入 <code>java.sql.DriverManager</code> 类时，会执行其静态代码块，从而执行其中的 SPI 代码加载 JDBC Driver 实现，源码如下，详见：<a href="/2019/01/23/java-jdbc-driver/">《Java 数据持久化系列（一）JDBC Driver 驱动程序总结》</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"><span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">    Driver driver = driversIterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流程如下：</p>
<p><img src="/img/java/spi/spi_flow_diagram.png" alt="spi_flow_diagram"></p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p><code>ServiceLoader</code> 的结构如下：</p>
<p><img src="/img/java/spi/ServiceLoader.png" alt="ServiceLoader"></p>
<p>其成员变量如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类加载器加载配置文件时 所用的固定目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代表被加载的类或者接口</span></span><br><span class="line">    <span class="comment">// The class or interface representing the service being loaded</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于定位，加载和实例化 providers 的类加载器</span></span><br><span class="line">    <span class="comment">// The class loader used to locate, load, and instantiate providers</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ServiceLoader 时采用的访问控制上下文</span></span><br><span class="line">    <span class="comment">// The access control context taken when the ServiceLoader is created</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存 providers，按实例化的顺序排列</span></span><br><span class="line">    <span class="comment">// Cached providers, in instantiation order</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒查找迭代器</span></span><br><span class="line">    <span class="comment">// The current lazy-lookup iterator</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SPI 的核心在于内部类 <code>LazyIterator</code>，承担了以下职责：</p>
<ol>
<li>加载配置文件，解析、验证其内容</li>
<li>加载类</li>
<li>反射构造实例</li>
</ol>
<p>核心源码及注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Private inner class implementing fully-lazy provider lookup</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;S&gt; service;</span><br><span class="line">        ClassLoader loader;</span><br><span class="line">        Enumeration&lt;URL&gt; configs = <span class="keyword">null</span>;</span><br><span class="line">        Iterator&lt;String&gt; pending = <span class="keyword">null</span>;</span><br><span class="line">        String nextName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否首次使用</span></span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 本例中值为 META-INF/services/java.sql.Driver</span></span><br><span class="line">                    String fullName = PREFIX + service.getName();</span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 使用类加载器从类路径中加载文件：META-INF/services/java.sql.Driver，如果多个 jar 包都存在该文件则结果为多个 URL 实例</span></span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                    fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 依次解析 URL，获取 URL 内容的迭代器</span></span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 依次获取 URL 内容，例如第一条为 com.mysql.jdbc.Driver</span></span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            String cn = nextName;</span><br><span class="line">            nextName = <span class="keyword">null</span>;</span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用指定的类加载器查找并加载类：com.mysql.jdbc.Driver</span></span><br><span class="line">                c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过反射，调用 com.mysql.jdbc.Driver 的 public 无参构造方法创建 Object 实例对象，并强制转换为 interface java.sql.Driver 类型</span></span><br><span class="line">                S p = service.cast(c.newInstance());</span><br><span class="line">                <span class="comment">// 塞入缓存，key 为 com.mysql.jdbc.Driver 字符串，value 是对应的实例对象</span></span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">                     x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>Java SPI 实际上是“<strong>基于接口的编程＋策略模式＋配置文件</strong>”组合实现的动态加载机制。这种动态加载机制的使用场景如下：</p>
<ul>
<li>JDBC Driver 驱动程序管理类 <a href="https://docs.oracle.com/javase/8/docs/api/java/sql/DriverManager.html" target="_blank" rel="noopener"><code>java.sql.DriverManager</code></a>。详见：<a href="/2018/02/03/java-jdbc-driver/">JDBC Driver 驱动程序总结</a></li>
<li>JSR-303 Bean Validation 的 <a href="https://docs.oracle.com/javaee/7/api/javax/validation/Validation.html" target="_blank" rel="noopener"><code>javax.validation.Validation</code></a></li>
<li>日志门面接口实现类加载，SLF4J 加载不同提供商的日志实现类。</li>
<li>Spring<ul>
<li>对 servlet3.0 规范对 <code>ServletContainerInitializer</code> 的实现</li>
<li>自动类型转换 Type Conversion SPI (Converter SPI、Formatter SPI) 等</li>
<li>Spring Factories 机制（<code>SpringFactoriesLoader</code>）</li>
</ul>
</li>
<li>Dubbo 通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。详见：<a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html</a></li>
</ul>
<h1 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h1><p>下面总结下这几个加载类：</p>
<ul>
<li>Java <code>java.util.ServiceLoader</code></li>
<li>Spring <code>org.springframework.core.io.support.SpringFactoriesLoader</code></li>
<li>Dubbo <code>com.alibaba.dubbo.common.extension.ExtensionLoader</code></li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Java SPI</th>
<th>Spring Factories</th>
<th>Dubbo SPI</th>
</tr>
</thead>
<tbody><tr>
<td>加载类</td>
<td><code>ServiceLoader</code></td>
<td><code>SpringFactoriesLoader</code></td>
<td><code>ExtensionLoader</code></td>
</tr>
<tr>
<td>加载文件</td>
<td><code>META-INF/services/接口全限定名</code></td>
<td><code>META-INF/spring.factories</code></td>
<td><code>META-INF/dubbo</code></td>
</tr>
<tr>
<td>文件内容</td>
<td>接口实现类，多值以<strong>换行</strong>分隔</td>
<td>通过键值对方式（key=value）配置，多值以<strong>逗号</strong>分隔</td>
<td>通过键值对方式（key=value）配置，支持按需加载接口实现类</td>
</tr>
<tr>
<td>接口注解</td>
<td>/</td>
<td>/</td>
<td><code>@SPI</code></td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/46b42f7f593c" target="_blank" rel="noopener">https://www.jianshu.com/p/46b42f7f593c</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/11/04/java-classloader/" class="post-title-link">Java 类加载篇（一）类加载机制总结</a></h2><div class="post-info">2018-11-04<a href="/tags/Java/" title="Java" class="post-demo">Java</a></div><div class="post-content"><h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><p>单个 .java 源文件的从加载到创建对象的过程如下：</p>
<p><img src="/img/java/classloader/classloaoder_process.jpg" alt="classloaoder_process"></p>
<p>多个 .java 源文件经过 <code>javac</code> 编译后生成 .class 类文件（内含字节码），然后通过 <code>jar</code> 命令或其它构建工具（如 Maven、Gradle）打包生成可运行的 jar 包。最终通过 <code>java -jar</code> 命令运行 jar 包，执行其中清单文件（<code>META-INF/MANIFEST.MF</code>）中通过 <code>Main-Class</code> 指定的入口类的 <code>main</code> 方法以启动程序，并按照其 <code>Class-Path</code> 设置类路径。</p>
<p>从这里开始，就需要使用到类加载器将入口类（<code>Main-Class</code>）加载到 JVM。入口类在使用过程中如果使用到其它类，会根据类路径查找类文件并逐一加载。因此， jar 包中的类、及类路径中指定的类并不是一次性全部加载到 JVM 内存，而是使用到时才<strong>动态加载</strong>。可以指定启动参数 <code>-verbose:class</code> 输出类加载日志进行验证：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String param)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(String param)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">        Bird bird = <span class="keyword">new</span> Bird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类加载日志输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Opened D:\tool\jdk1.8.0_131\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.Object from D:\tool\jdk1.8.0_131\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.io.Serializable from D:\tool\jdk1.8.0_131\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.Comparable from D:\tool\jdk1.8.0_131\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.CharSequence from D:\tool\jdk1.8.0_131\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.String from D:\tool\jdk1.8.0_131\jre\lib\rt.jar]</span><br><span class="line">...</span><br><span class="line">[Loaded Test from file:&#x2F;D:&#x2F;workspaces&#x2F;project-test&#x2F;target&#x2F;classes&#x2F;]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">[Loaded com.github.proxy.Flyable from file:&#x2F;D:&#x2F;workspaces&#x2F;project-test&#x2F;target&#x2F;classes&#x2F;]</span><br><span class="line">[Loaded com.github.proxy.Bird from file:&#x2F;D:&#x2F;workspaces&#x2F;project-test&#x2F;target&#x2F;classes&#x2F;]</span><br></pre></td></tr></table></figure>

<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>类从加载到 JVM 内存到被从内存中释放，经历的生命周期如下：</p>
<p><img src="/img/java/classloader/lifecycle_of_class.png" alt="lifecycle_of_class"></p>
<ul>
<li>加载阶段：包括根据类或接口的二进制名称（<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#name" target="_blank" rel="noopener">binary name</a>）查找其字节码文件（可能是之前由 <code>javac</code> 编译器源代码编译出的字节码文件；或者是通过动态编译，例如 JDK 动态代理使用的 <code>sun.misc.ProxyGenerator</code> 工具类编译出的字节码文件 <code>$Proxy0.class</code>），并构造成一个表示该类或接口的 <code>Class</code> 类对象。<strong>加载阶段由类加载器 <code>ClassLoader</code> 及其子类负责实现：<code>findClass</code> 方法负责查找字节码文件，<code>defineClass</code> 方法负责构造成 <code>Class</code> 对象。</strong></li>
<li>验证阶段：确保类或接口的二进制代码在结构上是正确的。类文件校验器（Class File Verifier）会进行以下四类校验：<ul>
<li>文件完整性校验（File Integrity Check）：第一步也是最简单的一步是检查类文件的结构。 它确保类文件具有适当的签名（前四个字节为魔数 <code>0xCAFEBABE</code>），并且类文件中的每个结构都具有适当的长度。它检查类文件本身不能内容过长或过短，并且常量池仅包含有效条目。当然，类文件的长度可能有所不同，但是每个结构（例如常量池）的长度作为文件规范的一部分都包含其中。</li>
<li>类完整性校验（Class Integrity Check）：<ul>
<li>该类具有父类（除非该类是 <code>Object</code>）。</li>
<li>该父类不是一个 <code>final</code> 类，并且该子类不会尝试覆盖其父类中的 <code>final</code> 方法。</li>
<li>常量池的条目格式正确，并且所有方法和字段引用均具有合法的名称和签名。</li>
</ul>
</li>
<li>字节码完整性校验（Bytecode Integrity Check）：执行字节码校验器（Bytecode Verifier），检查每个字节码以确定代码在运行时的实际行为，包括对方法参数和字节码操作数的数据流分析，堆栈检查和静态类型检查。是整个验证阶段中最复杂的一步。</li>
<li>运行时完整性校验（Runtime Integrity Check）</li>
</ul>
</li>
<li>准备阶段：包括为类或接口创建 <code>static</code> 静态字段（包括类变量和常量），并赋默认值。</li>
<li>解析阶段：包括检查符号引用是否正确、将符号引用替换为直接引用。</li>
<li>初始化阶段：<ul>
<li>类的初始化阶段包括执行 <code>static</code> 静态代码块、为 <code>static</code> 静态字段（变量）赋值。</li>
<li>接口的初始化阶段包括为字段（接口字段默认为 <code>public static final</code> 常量）赋值。</li>
</ul>
</li>
</ul>
<p>各个步骤可以详见官方文档 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html" target="_blank" rel="noopener">“Execution” chapter of The Java™ Language Specification</a>：</p>
<p><img src="/img/java/classloader/execution.png" alt="execution"></p>
<h1 id="类加载器源码解析"><a href="#类加载器源码解析" class="headerlink" title="类加载器源码解析"></a>类加载器源码解析</h1><p>Java 虚拟机中的类加载器（<code>ClassLoader</code>）负责加载来自文件系统、网络或其它来源的类文件。<code>ClassLoader</code> 是一个抽象类，其继承结构如下：</p>
<p><img src="/img/java/classloader/ClassLoader.png" alt="ClassLoader"></p>
<p>类加载后，每个 <code>Class</code> 对象都包含一个定义它的类加载器的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getClassLoader--" target="_blank" rel="noopener">引用</a>。可以通过以下方式查看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结果为 null，因为启动类加载器为 C++ 编写</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = java.lang.String<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        <span class="comment">// sun.misc.Launcher$ExtClassLoader</span></span><br><span class="line">        ClassLoader extClassLoader = com.sun.crypto.provider.DESKeyFactory<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        <span class="comment">// sun.misc.Launcher$AppClassLoader</span></span><br><span class="line">        ClassLoader appClassLoader = Test<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClassLoader</code> 的核心方法如下：</p>
<h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h3><p><code>loadClass</code> 方法使用二进制名称（<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#name" target="_blank" rel="noopener">binary name</a>）加载指定类。此方法的默认实现按以下顺序查找类：</p>
<ol>
<li>调用自身的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#findLoadedClass-java.lang.String-" target="_blank" rel="noopener"><code>findLoadedClass(String)</code></a> 方法以检查是否已加载该类。</li>
<li>递归调用父加载器的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#loadClass-java.lang.String-" target="_blank" rel="noopener"><code>loadClass</code></a> 方法。 如果父加载器为 <code>null</code>，则使用虚拟机内置的启动类加载器（Bootstrap ClassLoader）。</li>
<li>调用自身的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#findClass-java.lang.String-" target="_blank" rel="noopener"><code>findClass(String)</code></a> 方法查找类。</li>
</ol>
<p>如果上述步骤找到了类，并且 <code>resolve</code> 标记为 <code>true</code>，则此方法将在目标 <code>Class</code> 对象上调用 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#resolveClass-java.lang.Class-" target="_blank" rel="noopener"><code>resolveClass(Class)</code></a> 方法。</p>
<p><code>ClassLoader</code> 整个过程的源码及注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先，检查类是否已经被加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 未被加载的情况</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果父加载器不为 null，则委托父加载器去加载类</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 调用父加载器的 loadClass 方法，委托其去加载类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果父加载器为 null，则委托 Bootstrap ClassLoader 去加载类</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果父加载器都加载不到，则调用自身的 findClass 方法查找类</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果上述步骤找到了类，并且 resolve 标记为 true，则在目标 Class 对象上调用 resolveClass(Class) 方法，进入“连接（Linking）”阶段（详见官方文档）</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这整个加载过程被称为“双亲委派模型 (Delegation Model)”（流程见下图）。这种设计的好处体现在：</p>
<ul>
<li>沙箱安全机制：例如自己写的 <code>java.lang.String</code> 类不会被加载，否则在 <code>defineClass</code> 方法这一步会报错，<strong>防止恶意代码污染，核心 API 库被随意篡改。</strong>核心 API 库只能由 <code>Bootstrap ClassLoader</code> 从<code>$JAVA_HOME/jre/lib</code> 目录进行加载。</li>
<li>避免类的重复加载：当父加载器已经加载了该类时，就没有必要再加载一次，<strong>保证被加载类的唯一性。</strong></li>
</ul>
<p><img src="/img/java/classloader/classloader_hierarchy.png" alt="classloader_hierarchy"></p>
<p>这三个自带的 <code>ClassLoader</code> 细节详见类路径一节。</p>
<p>加载到的 <code>Class</code> 可以通过反射的方式实例化对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"com.github.parent.HelloWorld"</span>);</span><br><span class="line">Object instance = clazz.newInstance();</span><br></pre></td></tr></table></figure>

<h3 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h3><p>实现“加载阶段（Loading）”的查找功能。该方法应当被子类覆盖重写，用于使用指定的二进制名称（<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#name" target="_blank" rel="noopener">binary name</a>）查找类或接口的字节码文件。<code>ClassLoader</code> 的默认实现是抛出一个 <code>ClassNotFoundException</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过覆盖这个方法实现一个自定义的类加载器（参考 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html" target="_blank" rel="noopener">ClassLoader</a> 介绍的例子，自定义 <code>NetworkClassLoader</code>）。</p>
<p>类可以按需动态加载到内存，这是 Java 的一大特点，也称为运行时绑定，或动态绑定。类文件的获取途径如下：</p>
<ul>
<li>从 ZIP 包中读取，最常见，JAR，WAR，EAR 格式的基础。</li>
<li>从网络中获取，典型场景是 Applet。</li>
<li>运行时计算生成，典型情景是 JDK 动态代理技术。</li>
<li>从其它文件中生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Servlet Class 类。</li>
</ul>
<p>如果用户想从其它位置加载类文件，可以自定义类加载器，或者使用自带的 <code>URLClassLoader</code> 从本地路径（<code>file:/</code>）或网络路径（<code>http://</code>）加载类文件，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 E 盘中加载类文件</span></span><br><span class="line">URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:/e:/"</span>)&#125;);</span><br><span class="line"><span class="comment">// 从 localhost 中加载类文件</span></span><br><span class="line"><span class="comment">// URLClassLoader classLoader = new URLClassLoader(new URL[] &#123;new URL("http://localhost/testfile/")&#125;);</span></span><br><span class="line">Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"com.github.parent.HelloWorld"</span>);</span><br><span class="line">Object instance = clazz.newInstance();</span><br><span class="line"><span class="comment">// java.net.URLClassLoader</span></span><br><span class="line">String name = instance.getClass().getClassLoader().getClass().getName();</span><br></pre></td></tr></table></figure>

<p>下面是子类 <code>URLClassLoader</code> 的默认实现，源码及注释如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                    <span class="comment">// 将二进制名称替换为文件路径（类似全限定名），例如：com.github.HelloWorld &gt; com/github/HelloWorld.class</span></span><br><span class="line">                    String path = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>);</span><br><span class="line">                    <span class="comment">// 从 URLClassPath 对象中查找文件</span></span><br><span class="line">                    Resource res = ucp.getResource(path, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 如果找到文件，则构造为 Class 类实例</span></span><br><span class="line">                            <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, acc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，如果找不到类（<code>result == null</code>），最底层的 <code>ClassLoader</code> 将抛出 <code>ClassNotFoundException</code>。</p>
<h3 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h3><p>实现“加载阶段（Loading）”的构造功能。</p>
<p><code>ClassLoader</code> 提供了四个 <code>defineClass</code> 方法可供自定义类加载器时使用，如下图。其中，第二个方法最常使用：<code>defineClass(String name, byte[] b, int off, int len)</code>。</p>
<p><img src="/img/java/classloader/defineClass.png" alt="defineClass"></p>
<p>其调用的底层源码如下，会调用 <code>preDefineClass</code> 和 <code>postDefineClass</code> 进行预处理和后置处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">                                     ProtectionDomain protectionDomain)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    String source = defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果自定义类加载器打破了双亲委派模型，然后还去加载核心 API 库，例如自己伪造一个 <code>java.lang.String</code>，会报错如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException: Prohibited package name: java.lang</span><br><span class="line">    at java.lang.ClassLoader.preDefineClass(ClassLoader.java:659)</span><br><span class="line">    at java.lang.ClassLoader.defineClass(ClassLoader.java:758)</span><br><span class="line">    at java.lang.ClassLoader.defineClass(ClassLoader.java:642)</span><br><span class="line">    at com.github.MyClassLoader.findClass(...)</span><br><span class="line">    at com.github.MyClassLoader.loadClass(...)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这是由于 <code>preDefineClass</code> 预处理方法进行了二进制名称的前缀校验，源码如下，关键判断 <code>name.startsWith(&quot;java.&quot;)</code> 抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine protection domain, and check that:</span></span><br><span class="line"><span class="comment">    - not define java.* class,</span></span><br><span class="line"><span class="comment">    - signer of this class matches signers for the rest of the classes in</span></span><br><span class="line"><span class="comment">      package.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ProtectionDomain <span class="title">preDefineClass</span><span class="params">(String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        ProtectionDomain pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(<span class="string">"IllegalName: "</span> + name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias</span></span><br><span class="line">    <span class="comment">// relies on the fact that spoofing is impossible if a class has a name</span></span><br><span class="line">    <span class="comment">// of the form "java.*"</span></span><br><span class="line">    <span class="comment">// 关键判断</span></span><br><span class="line">    <span class="keyword">if</span> ((name != <span class="keyword">null</span>) &amp;&amp; name.startsWith(<span class="string">"java."</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException</span><br><span class="line">            (<span class="string">"Prohibited package name: "</span> +</span><br><span class="line">             name.substring(<span class="number">0</span>, name.lastIndexOf(<span class="string">'.'</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        pd = defaultDomain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span>) checkCerts(name, pd.getCodeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resolveClass"><a href="#resolveClass" class="headerlink" title="resolveClass"></a>resolveClass</h3><p>进入类加载的“连接（Linking）”阶段（详见官方文档 “Execution” chapter of The Java™ Language Specification）。</p>
<h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><p>使用场景：例如 Spring Factories 机制中 <code>SpringFactoriesLoader</code> 加载类路径下的文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classLoader.getResources(<span class="string">"META-INF/spring.factories"</span>)</span><br></pre></td></tr></table></figure>

<p>文件加载后，通过 key-value 的方式读取指定 key，并以反射的方式实例化指定的类型。</p>
<h3 id="getResource"><a href="#getResource" class="headerlink" title="getResource"></a>getResource</h3><p>查找指定名称的资源（图像、音频、文本等）。资源的名称是用“/”分隔的路径名，用于标识资源。<br>该方法首先递归调用父加载器查找资源；如果父加载器为 <code>null</code>，则使用虚拟机内置的启动类加载器（Bootstrap ClassLoader）。如果父加载器查找失败，则调用自身的 <code>findResource(String)</code> 查找资源。整个资源加载过程仍然为“双亲委派模型 (Delegation Model)”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URL <span class="title">getResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    URL url;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        url = parent.getResource(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        url = getBootstrapResource(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        url = findResource(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="findResource"><a href="#findResource" class="headerlink" title="findResource"></a>findResource</h3><p>查找指定名称的资源。类加载器实现应当重写此方法以指定在何处查找资源。默认返回 <code>null</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是子类 <code>URLClassLoader</code> 的默认实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URL <span class="title">findResource</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The same restriction to finding classes applies to resources</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    URL url = AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> PrivilegedAction&lt;URL&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> URL <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ucp.findResource(name, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, acc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> url != <span class="keyword">null</span> ? ucp.checkURL(url) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h1><p>Java Launcher（即使用 <code>java</code> 命令）启动 Java 虚拟机时，类加载器按以下顺序搜索指定路径并加载类：</p>
<p><img src="/img/java/classloader/default_classloader.png" alt="Class Loader"></p>
<p>三个类加载器使用的类路径，从以下系统属性中获取，可以通过 <code>System.getProperty(...)</code> 获取查看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bootstrap ClassLoader</span></span><br><span class="line">String property1 = System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line"><span class="comment">// Extension ClassLoader</span></span><br><span class="line">String property2 = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line"><span class="comment">// Application ClassLoader</span></span><br><span class="line">String property3 = System.getProperty(<span class="string">"java.class.path"</span>);</span><br></pre></td></tr></table></figure>

<p>下面详细介绍各个类加载器：</p>
<h2 id="Bootstrap-ClassLoader"><a href="#Bootstrap-ClassLoader" class="headerlink" title="Bootstrap ClassLoader"></a>Bootstrap ClassLoader</h2><p>负责加载构成 Java 平台的基础类（Bootstrap classes），位于 <code>$JAVA_HOME/jre/lib</code> 目录，包括 <code>rt.jar</code> 和其它几个重要 jar 文件中的类。这些基础类包括 Java 类库（<a href="https://en.wikipedia.org/wiki/Java_Class_Library" target="_blank" rel="noopener">Java Class Library (JCL)</a>）的公共类，以及此库可用的私有类。</p>
<p>几乎所有的 Java 类库（JCL） 都存储在一个名为“<code>rt.jar</code>”的 <a href="https://en.wikipedia.org/wiki/JAR_(file_format)" target="_blank" rel="noopener">Java archive (jar)</a> 归档文件中，该文件随 <a href="https://en.wikipedia.org/wiki/Java_Runtime_Environment" target="_blank" rel="noopener">JRE</a> 和 <a href="https://en.wikipedia.org/wiki/Java_Development_Kit" target="_blank" rel="noopener">JDK</a> 发行版一起提供。Java 类库（<code>rt.jar</code>）位于默认的 bootstrap classpath（<code>$JAVA_HOME/jre/lib</code>）下，不必出现在为应用程序声明的 <a href="https://en.wikipedia.org/wiki/Classpath_(Java)" target="_blank" rel="noopener">classpath</a> 中。JRE 会使用引导类加载器（bootstrap class loader）找到 JCL。</p>
<p>Java 9 的<a href="https://en.wikipedia.org/wiki/Java_Module_System" target="_blank" rel="noopener">模块系统</a>目前已将这个单块的 <code>rt.jar</code> jar 包拆分并模块化。</p>
<h2 id="Extension-ClassLoader"><a href="#Extension-ClassLoader" class="headerlink" title="Extension ClassLoader"></a>Extension ClassLoader</h2><p>负责加载扩展 Java 平台的扩展类（Extension classes）。位于 <code>$JAVA_HOME/jre/lib/ext</code> 扩展目录的每个 <code>.jar</code> 文件都被假定为扩展文件，并使用 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/extensions/index.html" target="_blank" rel="noopener">Java Extension Framework</a> 扩展机制加载。</p>
<p><code>sun.misc.Launcher$ExtClassLoader</code> 执行过程中，<code>URLClassPath</code> 的值如下：</p>
<p><img src="/img/java/classloader/ext_classpath.png" alt="ext_classpath"></p>
<p>例如，可以将 MySQL 厂商驱动程序 <code>mysql-connector-java</code> 放到该扩展目录中。</p>
<h2 id="Application-ClassLoader"><a href="#Application-ClassLoader" class="headerlink" title="Application ClassLoader"></a>Application ClassLoader</h2><p>负责加载由开发人员和第三方定义的未利用 Java 扩展机制的类（User classes）。可以使用命令行上的 <code>-classpath</code> 选项（首选方法）或使用 <code>CLASSPATH</code> 环境变量来标识这些类的位置 。(See <strong>Setting the Classpath</strong> for <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/classpath.html" target="_blank" rel="noopener">Windows</a> or <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/classpath.html" target="_blank" rel="noopener">Unix</a>.)</p>
<h1 id="应用类加载器如何查找-User-classes？"><a href="#应用类加载器如何查找-User-classes？" class="headerlink" title="应用类加载器如何查找 User classes？"></a>应用类加载器如何查找 User classes？</h1><p>为了查找 User classes，Java Launcher 启动程序将引用 <em>User Classpath</em> - 一个包含了用户定义的类文件的目录、jar 包和 zip 包列表。作为 Java 虚拟机或 Java 编译器中的一个参数，可以在命令行上或通过环境变量进行设置。</p>
<p><em>User Classpath</em> 使用字符串格式指定，路径不要含有空格，否则转义为 <code>%20</code> 之后会报错，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Cannot resolve classpath entry: java.lang.RuntimeException: Cannot resolve classpath entry: D:\myprogram\mybatis%20tool\mybatis-generator-gui-0.8.4\target\classes\lib\mysql-connector-java-5.1.38.jar</span><br></pre></td></tr></table></figure>

<p>每个路径使用以下方式进行分隔：</p>
<ul>
<li>在类 Unix 系统中，以冒号（<code>:</code>）分隔</li>
<li>在 Windows 系统中，以分号（<code>;</code>）分隔</li>
</ul>
<p>Java Launcher 启动程序将这个 <em>User Classpath</em> 字符串放到 <code>java.class.path</code> 系统属性中。该值的来源及优先级如下：</p>
<ul>
<li>默认值“ <code>.</code>”，表示当前工作目录下的所有类文件（如果在 jar 包中，则位于其下）。</li>
<li><code>CLASSPATH</code> 环境变量，覆盖默认值。查看方式：<code>echo $CLASSPATH</code>，设置方式：<code>set CLASSPATH=</code></li>
<li><code>-cp</code> 或 <code>-classpath</code> 命令行选项，覆盖默认值以及 <code>CLASSPATH</code> 环境变量。</li>
<li>由 <code>-jar</code> 选项指定的 jar 包，它覆盖上述所有值。如果使用此选项，则所有用户类必须来自指定的 jar 包。</li>
</ul>
<p>类文件具有反映“类的完全限定名称（class’s fully-qualified name）”的子路径名。例如，如果类 <code>com.mypackage.MyClass</code> 存储在 <code>/myclasses</code> 目录，则 <code>/myclasses</code> 必须在 <em>User Classpath</em> 中，并且类文件的完整路径必须为 <code>/myclasses/com/mypackage/MyClass.class</code>。</p>
<p>如果类存储在名为 <code>myclasses.jar</code> 的 jar 包中，则 <code>myclasses.jar</code> 必须在  <em>User Classpath</em>  中，并且类文件必须存储 <code>myclasses.jar/com/mypackage/MyClass.class</code>。</p>
<p>下面来看几个例子，总结如下：</p>
<p><img src="/img/java/classloader/User_Classpath.png" alt="CLASSPATH 例子"></p>
<h2 id="Unpacked-Classes"><a href="#Unpacked-Classes" class="headerlink" title="Unpacked Classes"></a>Unpacked Classes</h2><p>假设我们有一个名为主类：HelloWorld，存储在 <em>D:\myprogram</em> 目录下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D:\myprogram\</span><br><span class="line">      |</span><br><span class="line">      ---&gt; org\  </span><br><span class="line">            |</span><br><span class="line">            ---&gt; mypackage\</span><br><span class="line">                     |</span><br><span class="line">                     ---&gt; HelloWorld.class       </span><br><span class="line">                     ---&gt; SupportClass.class   </span><br><span class="line">                     ---&gt; UtilClass.class</span><br></pre></td></tr></table></figure>

<p>查看 Windows 下 <code>CLASSPATH</code> 环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$CLASSPATH</span></span><br><span class="line">.;E:\Developer\Java\jdk1.8.0_191\lib;</span><br></pre></td></tr></table></figure>

<p>由于 <code>CLASSPATH</code> 环境变量默认包含当前目录（<code>.</code>），这意味着当我们的工作目录为 <code>D:\myprogram\</code> 时，我们不需要显式指定 <code>CLASSPATH</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /D/myprogram</span><br><span class="line">$ java org.mypackage.HelloWorld</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>否则，需要使用 <code>-classpath</code> 参数显式指定如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -classpath D:\myprogram org.mypackage.HelloWorld</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>总结，设置 <em>Classpath</em> 的两种方式：</p>
<ul>
<li>永久设置：使用 <code>CLASSPATH</code> 环境变量</li>
<li>临时设置：使用 <code>-cp</code> 或 <code>-classpath</code> 命令行选项</li>
</ul>
<h2 id="JAR-files"><a href="#JAR-files" class="headerlink" title="JAR files"></a>JAR files</h2><ul>
<li>单个 jar 包：使用绝对路径指定具体某个 jar 包</li>
<li>多个 jar 包：使用绝对路径加上通配符 <code>*</code></li>
</ul>
<h2 id="META-INF-MANIFEST-MF"><a href="#META-INF-MANIFEST-MF" class="headerlink" title="META-INF/MANIFEST.MF"></a>META-INF/MANIFEST.MF</h2><p>如果程序已经打成 jar 包，需要使用<a href="https://en.wikipedia.org/wiki/Manifest_file" target="_blank" rel="noopener">清单文件</a>指定入口类及 <code>CLASSPATH</code>，并使用 <code>java -jar</code> 命令启动。例如 Tomcat 的 <code>bootstrap.jar</code> 引导包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">Main-Class: org.apache.catalina.startup.Bootstrap</span><br><span class="line">Class-Path: commons-daemon.jar</span><br></pre></td></tr></table></figure>

<h1 id="IDEA-如何查找类？"><a href="#IDEA-如何查找类？" class="headerlink" title="IDEA 如何查找类？"></a>IDEA 如何查找类？</h1><p>首先，为 IDEA 平台配置上你所拥有的 JDK：</p>
<p><img src="/img/java/idea/platform_sdks.png" alt="Platform Settings SDKs"></p>
<p>然后，为你的项目指定一个默认 SDK：</p>
<p><img src="/img/java/idea/project_sdk.png" alt="Project SDK"></p>
<p>搞掂之后，IDEA 会为项目载入指定版本的 SDK，将基础目录  <code>jre/lib/</code> 的 Bootstrap classes 和扩展目录  <code>jre/lib/ext/</code> 的 Extension classes 加入 classpath：</p>
<p><img src="/img/java/idea/external_libraries.png" alt="External Libraries"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>JavaDoc</p>
<ul>
<li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html</a></p>
</li>
<li><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html</a></p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.html</a></p>
</li>
<li><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p>
</li>
<li><p><a href="http://cr.openjdk.java.net/~mr/jigsaw/ea/module-summary.html" target="_blank" rel="noopener">http://cr.openjdk.java.net/~mr/jigsaw/ea/module-summary.html</a></p>
</li>
<li><p><a href="http://medialab.di.unipi.it/web/doc/JNetSec/jns_ch5.htm" target="_blank" rel="noopener">The Class Loader and Class File Verifier</a></p>
</li>
</ul>
<p>Wikipedia</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Classpath_(Java)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Classpath_(Java)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Java_class_file" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Java_class_file</a></li>
<li><a href="https://en.wikipedia.org/wiki/Java_Class_Library" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Java_Class_Library</a></li>
</ul>
<p>其它：</p>
<ul>
<li><p><a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/54973413</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/doit8791/p/5820037.html" target="_blank" rel="noopener">https://www.cnblogs.com/doit8791/p/5820037.html</a></p>
</li>
<li><p>《<a href="https://www.cnblogs.com/Kidezyq/p/11769839.html" target="_blank" rel="noopener">理解java对象初始化顺序</a>》先父后子，先静后动</p>
</li>
<li><p>《<a href="https://mp.weixin.qq.com/s/iGKprJEqCZpIO77sAMYRCQ" target="_blank" rel="noopener">原来热加载如此简单，手动写一个 Java 热加载吧</a>》</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/54693308" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54693308</a></p>
</li>
</ul>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/09/23/high-output-management/" class="post-title-link">《格鲁夫给经理人的第一课》读书笔记</a></h2><div class="post-info">2018-09-23<a href="/tags/读书笔记/" title="读书笔记" class="post-demo">读书笔记</a><a href="/tags/管理/" title="管理" class="post-demo">管理</a></div><div class="post-content"><p>最近阅读了《格鲁夫给经理人的第一课》，获益良多，书中系统性的总结了许多管理经验，对于新晋经理人的观念转变及管理技能提升有较大帮助。</p>
<p>附上读书笔记：</p>
<p><img src="/img/management/high-output-management/%E3%80%8A%E7%BB%99%E7%BB%8F%E7%90%86%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E8%AF%BE%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.png" alt="《给经理人的第一课》学习笔记"></p>
<p>书摘：<a href="/img/management/high-output-management/《给经理人的第一课》书摘.pdf">《给经理人的第一课》书摘</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/08/31/financial-funds/" class="post-title-link">《证券投资基金》读书笔记——基金知识总结</a></h2><div class="post-info">2018-08-31<a href="/tags/金融/" title="金融" class="post-demo">金融</a><a href="/tags/读书笔记/" title="读书笔记" class="post-demo">读书笔记</a></div><div class="post-content"><p>证券投资基金是资产管理的主要方式之一，它是一种组合投资、专业管理、利益共享、风险共担的集合投资方式。它主要通过向投资者发行受益凭证（基金份额），将众多不特定投资者的资金汇集起来，形成独立财产，委托<strong>基金管理人</strong>进行投资管理，<strong>基金托管人</strong>进行财产托管，由<strong>基金投资人</strong>共享投资收益、共担投资风险的集合投资方式。</p>
<p>投资基金是一种<strong>间接投资</strong>工具，基金投资者、基金管理人、托管人是基金运作中的主要当事人。</p>
<p>基金管理机构和托管机构分别作为基金管理人和基金托管人，一般按照基金的资产规模获得一定比例的<strong>管理费收入和托管费收入（即为净值型产品）</strong>。</p>
<h1 id="基金概况"><a href="#基金概况" class="headerlink" title="基金概况"></a>基金概况</h1><p><img src="/img/finance/financial_funds.png" alt="证券投资基金概况"></p>
<h1 id="基金分类"><a href="#基金分类" class="headerlink" title="基金分类"></a>基金分类</h1><p><img src="/img/finance/financial_funds_classification.png" alt="证券投资基金分类"></p>
<h2 id="按法律形式"><a href="#按法律形式" class="headerlink" title="按法律形式"></a>按法律形式</h2><table>
<thead>
<tr>
<th></th>
<th>契约型基金</th>
<th>公司型基金</th>
</tr>
</thead>
<tbody><tr>
<td>法律主体资格不同</td>
<td>不具有法人资格</td>
<td>具有法人资格</td>
</tr>
<tr>
<td>投资者的地位不同</td>
<td>依据基金合同成立，基金投资者可通过持有人大会表达意见，但权利相对较小</td>
<td>通过股东大会，持有人权利较大</td>
</tr>
<tr>
<td>基金组织方式和营运依据不同</td>
<td>借用了信托法律制度，依据基金合同营运基金，基金投资人和基金管理人、托管人之间是信托委托人、受托人和受益人。基金投资人通过基金持有人大会行使权力。</td>
<td>借用了《公司法》规定的股份有限公司的组织方式，其依据投资公司章程营运基金，设有股东会、董事会等决策监督机构，基金投资人通过股东会行使权力，设立董事会进行相关事务的决策与监督，基金管理人的身份是公司董事会聘请的投资顾问。</td>
</tr>
<tr>
<td>优点</td>
<td>在设立上更为简单易行</td>
<td>法律关系明确清晰，监督约束机制较为完善</td>
</tr>
<tr>
<td>范围</td>
<td>中国的基金均是契约型基金</td>
<td>美国的投资公司为代表</td>
</tr>
</tbody></table>
<h2 id="按运作方式"><a href="#按运作方式" class="headerlink" title="按运作方式"></a>按运作方式</h2><table>
<thead>
<tr>
<th></th>
<th>开放式基金</th>
<th>封闭式基金</th>
</tr>
</thead>
<tbody><tr>
<td>份额</td>
<td>不固定</td>
<td>固定</td>
</tr>
<tr>
<td>存续期限</td>
<td>不确定，理论上可以无限期存续</td>
<td>确定</td>
</tr>
<tr>
<td>交易方式</td>
<td>一般不上市，通过向基金管理公司和代销机构进行申购、赎回</td>
<td>上市流通</td>
</tr>
<tr>
<td>交易价格</td>
<td>按照每日基金单位资产净值（NAVPS）</td>
<td>根据市场行情变化，相对于单位资产净值可能折价或溢价，多为折价</td>
</tr>
<tr>
<td>估值频率</td>
<td>每个交易日估值，次日公告</td>
<td>每个交易日估值，每周披露</td>
</tr>
<tr>
<td>信息披露</td>
<td>每日公布基金单位资产净值（NAVPS），每季度公布资产组合，每六个月公布变更的招募说明书</td>
<td>每周公布基金单位资产净值（NAVPS），每季度公布资产组合</td>
</tr>
<tr>
<td>投资策略</td>
<td>强调流动性管理，基金资产中要保持一定现金及流动性资产</td>
<td>全部资金在封闭期内可进行长期投资</td>
</tr>
<tr>
<td>收益分配频率</td>
<td>开放式基金的基金合同应当约定每年基金收益分配的最多次数和基金收益分配的最低比例。实践中，许多基金合同规定每年至少一次。如果是货币基金，一般为每日结转收益或按月结转收益。</td>
<td>每年不得少于一次</td>
</tr>
<tr>
<td>收益分配方式</td>
<td>1、现金分红；2、分红再投资转换为基金份额</td>
<td>现金分红</td>
</tr>
<tr>
<td>总结</td>
<td>基金份额不固定，基金份额可以在基金合同约定的时间和场所进行申购、赎回的一种基金运作方式</td>
<td>基金份额在基金合同期限内固定不变，基金份额可以在证交所交易，但基金份额持有人不得申请赎回</td>
</tr>
</tbody></table>
<h2 id="按资金募集方式"><a href="#按资金募集方式" class="headerlink" title="按资金募集方式"></a>按资金募集方式</h2><table>
<thead>
<tr>
<th></th>
<th>公募基金</th>
<th>私募基金</th>
</tr>
</thead>
<tbody><tr>
<td>制度</td>
<td>基金募集注册制。即证监会不进行实质性审核，而只是进行合规性审查。</td>
<td>基金管理人登记制，即私募基金的基金管理人只需向基金业协会登记即可，无须中国证监会审批。</td>
</tr>
<tr>
<td>申请期限</td>
<td>依据《证券投资基金法》的规定，公募基金应当经中国证监会注册。证监会在受理申请之日起 6 个月内依照法律法规进行审查，作出注册或者不予注册的决定。</td>
<td>基金业协会应当在私募基金管理人登记材料齐备后的 20 个工作日内，通过网站公告私募基金管理人名单及其基本情况的方式，为私募基金管理人办理登记手续。</td>
</tr>
<tr>
<td>监管主体</td>
<td>由证监会监管</td>
<td>由基金业协会制定相关指引和准则，实行自律管理。</td>
</tr>
<tr>
<td>提交文件</td>
<td>1、申请报告；2、基金合同草案；3、基金托管协议草案；4、招募说明书草案；5、律所出具的法律意见书；6、中国证监会规定提交的其它文件。</td>
<td>1、工商登记和营业执照正副本复印件；2、公司章程或者合伙协议；3、主要股东或者合伙人名单；4、高级管理人员的基本信息；5、基金业协会规定的其它信息。</td>
</tr>
<tr>
<td>募集群体</td>
<td>不特定对象、或特定对象累计超过 200 人。</td>
<td>合格投资者，且累计不得超过 200 人。</td>
</tr>
</tbody></table>
<h2 id="按投资对象"><a href="#按投资对象" class="headerlink" title="按投资对象"></a>按投资对象</h2><h3 id="股票基金"><a href="#股票基金" class="headerlink" title="股票基金"></a>股票基金</h3><h3 id="债券基金"><a href="#债券基金" class="headerlink" title="债券基金"></a>债券基金</h3><table>
<thead>
<tr>
<th></th>
<th>债券</th>
<th>债券基金</th>
</tr>
</thead>
<tbody><tr>
<td>利息</td>
<td>有固定的利息收入</td>
<td>不同债券的组合，利息不固定</td>
</tr>
<tr>
<td>到期日</td>
<td>有确定的到期日</td>
<td>没有确定的到期日</td>
</tr>
<tr>
<td>收益率</td>
<td>单一债券的收益率可以根据购买价格、现金流以及到期收回的本金计算其投资收益率</td>
<td>较难计算和预测收益率</td>
</tr>
<tr>
<td>投资风险</td>
<td>单一债券的信用风险比较集中，随着到期日的临近，所承担的利率风险会下降</td>
<td>债券基金通过分散投资可以有效避免单一债券可能面临的较高的信用风险。由于没有固定到期日，所承担的利率风险将取决于所持有的债券的平均到期日</td>
</tr>
</tbody></table>
<p>债券基金的风险如下：</p>
<ol>
<li>利率风险</li>
<li>再投资风险</li>
<li>信用风险</li>
<li>流动性风险</li>
<li>提前赎回风险</li>
<li>可转债的特定风险</li>
<li>债券回购风险</li>
</ol>
<h3 id="货币基金"><a href="#货币基金" class="headerlink" title="货币基金"></a>货币基金</h3><h4 id="货币市场基金在投资组合中的作用"><a href="#货币市场基金在投资组合中的作用" class="headerlink" title="货币市场基金在投资组合中的作用"></a>货币市场基金在投资组合中的作用</h4><blockquote>
<p>与其它类型基金相比，货币市场基金具有风险低、流动性好的特点，是厌恶风险、对资产<strong>流动性</strong>和<strong>安全性</strong>要求较高的投资者进行短期投资和<strong>现金管理</strong>的理想工具，或是暂时存放现金的理想场所。</p>
</blockquote>
<h4 id="货币市场基金的投资对象与货币市场工具"><a href="#货币市场基金的投资对象与货币市场工具" class="headerlink" title="货币市场基金的投资对象与货币市场工具"></a>货币市场基金的投资对象与货币市场工具</h4><blockquote>
<p> 货币市场基金的投资对象是货币市场工具，通常指到期日不足 1 年的短期金融工具，也成为<strong>现金投资工具</strong>。货币市场工具通常由政府、金融机构以及信誉卓著的大型工商企业发行，流动性好、安全性高，但其收益率与其它证券相比则非常低。货币市场与股票市场的一个主要区别是：货币市场进入门槛通常很高，在很大程度上限制了一般投资者的进入。此外，货币市场属于场外交易市场，交易主要由买卖双方通过电话或电子交易系统以协商价格完成。货币市场基金的投资门槛极低，因此，货币市场基金为普通投资者进入货币市场提供了重要通道。</p>
<p>按照中国证监会和中国人民银行 2015 年颁布的《货币市场基金监督管理办法》的规定，货币市场基金应当投资于以下金融工具：</p>
<ol>
<li>现金；</li>
<li>期限在 1 年以内（含 1 年）的银行存款、债券回购、中央银行票据、同业存单；</li>
<li>剩余期限在 397 天以内（含 397 天）的债券、非金融企业债务融资工具、资产支持证券；</li>
<li>中国证监会、中国人民银行认可的其它具有良好流动性的货币市场工具。</li>
</ol>
<p>货币市场基金不得投资于以下金融工具：</p>
<ol>
<li>股票；</li>
<li>可转换债券、可交换债券；</li>
<li>以定期存款利率为基准利率的浮动利率债券，已进入最后一个利率调整期的除外；</li>
<li>信用等级在 AA+ 以下的债券与非金融企业债务融资工具；</li>
<li>中国证监会、中国人民银行禁止投资的其它金融工具。</li>
</ol>
</blockquote>
<h4 id="货币市场基金的支付功能"><a href="#货币市场基金的支付功能" class="headerlink" title="货币市场基金的支付功能"></a>货币市场基金的支付功能</h4><blockquote>
<p>由于货币市场基金风险低、流动性好，通过以下机制设计，基金管理公司将货币市场基金的功能从投资拓展为类似货币的支付功能：</p>
<ol>
<li>每个交易日办理基金份额申购、赎回；</li>
<li>在基金合同中将<strong>收益分配</strong>的方式约定为<strong>红利再投资</strong>，并<strong>每日</strong>进行收益分配（每日结转收益）；</li>
<li>每日按照面值（一般为 1 元）进行报价。</li>
</ol>
</blockquote>
<h1 id="基金术语"><a href="#基金术语" class="headerlink" title="基金术语"></a>基金术语</h1><h2 id="基金分红"><a href="#基金分红" class="headerlink" title="基金分红"></a>基金分红</h2><p>基金<strong>收益分配</strong>（即分红）是指将本基金的<strong>净收益</strong>根据持有基金单位的数量（即持有份额）按比例向基金持有人进行分配。若基金上一年度亏损，当年收益应先用于弥补上年亏损，在基金亏损完全弥补后尚有剩余的，方能进行当年收益分配。基金当年发生亏损无净收益的，不进行收益分配。</p>
<p>基金进行收益分配会导致<strong>基金份额净值</strong>的下降，但对投资者的利益没有实际影响。一只基金在收益分配前份额净值为1.2元，每份基金分配0.05元收益，在分配后基金份额净值将会下降到1.15元。但对投资者来说，分红前后的价值是不变的。</p>
<p>收益分配后基金份额净值<strong>不得低于面值</strong>。</p>
<p>现有制度下，基金分红主要有两种形式：</p>
<ol>
<li>现金分红。是指直接获得现金红利，落袋为安；</li>
<li>红利再投资转换为基金份额。红利再投资是指将所分得的现金红利再投资该基金或者购买的个股，从而达到增加原先持有基金或股票的份额，俗称“利滚利”，这样做既可免掉再投资的申购费，而且再投资所获得的基金份额还可以享受或增加下次分红的数额，可使基金份额随着分红的次数而增加。</li>
</ol>
<p>假如选择红利再投资方式对开放式基金进行长期投资，则可享受基金投资增值的<strong>复利增长</strong>效果。例如，假如开放式基金<strong>每年</strong>分红5%，选择红利再投资，则10年后资金将增值为62.89%；而假如同样的收益情况，选择现金分红方式，则10年后资金只增值为50%，收益少了12.89%。假如投资时间更长，则差别更大。</p>
<p>中国法律规定默认的基金分红方式是现金分红，投资者可以通过销售机构将分红方式变更为红利再投资，以获得更大的回报。</p>
<p>现金分红涉；及三个日期：</p>
<ol>
<li><p>权益登记日：是基金公司进行红利分配时，需要定出某一天，界定哪些基金持有人可以参加分红，定出的这一天就是权益登记日。也就说，在权益登记日当天仍持有或申购基金并得到确认的投资者均可享受此次分红。</p>
</li>
<li><p>除息日：分红方案中确定的将红利从基金资产中扣除的日期。除息日当天，基金净值将会降低，如果不考虑当日市场波动，下降的幅度就是单位基金的现金分红额。</p>
</li>
<li><p>派息日：也就是基金分红拨付给基金持有人的日子。</p>
</li>
</ol>
<h2 id="基金分拆"><a href="#基金分拆" class="headerlink" title="基金分拆"></a>基金分拆</h2><p>基金分拆是指保证投资者的投资总额不发生改变的前提下，将一份基金按照一定的比例分拆为若干份，每一基金份额的单位净值也按相同比例降低：</p>
<ul>
<li>分拆比例大于 1 的分拆为基金分拆；</li>
<li>分拆比例小于 1 的分拆为基金合并。</li>
</ul>
<h2 id="基金份额净值"><a href="#基金份额净值" class="headerlink" title="基金份额净值"></a>基金份额净值</h2><ul>
<li>基金资产估值：通过对基金所拥有的全部资产及全部负债按一定的原则和方法进行估算，进而确定基金资产公允价值的过程。</li>
<li>基金资产总值（AV, Asset Value）：基金全部资产的价值总和。</li>
<li>基金资产净值（NAV, Net Asset Value）：基金资产 - 基金负债（NAV = Assets - Liabilities）</li>
<li>基金份额净值（<a href="https://www.investopedia.com/terms/n/navpershare.asp" target="_blank" rel="noopener">NAVPS, Net Asset Value Per Share</a>）：基金资产净值 / 基金总份额（NAVPS = Net Asset Value (NAV) / Number of Shares Outstanding）。也叫“<strong>单位净值</strong>”，与“累计净值”的区别<a href="/img/finance/NAVPS.jpg">查看这里</a>。</li>
<li>基金份额：是指基金发起人向投资者公开发行的，表示持有人按其所持份额对基金财产享有收益分配权、清算后剩余财产取得权和其他相关权利，并承担相应义务的凭证。</li>
</ul>
<p>一图看清“基金份额净值”：<a href="/img/finance/net_value_of_the_fund_assets_per_shares.jpg">基金份额净值</a></p>
<h2 id="基金份额类型（费率模式）"><a href="#基金份额类型（费率模式）" class="headerlink" title="基金份额类型（费率模式）"></a>基金份额类型（费率模式）</h2><p>常见的基金收费有申购费、赎回费、管理费、托管费、销售服务费。还有一个认购费，但那是只有在基金募集期才会用到的。这么多费率，怎么区分？</p>
<h3 id="货币基金-1"><a href="#货币基金-1" class="headerlink" title="货币基金"></a>货币基金</h3><p>一般来说，我们常见的货币基金主要分A类、B类，其实货基的A、B类相差并不大，在收益方面的差别也不是很大，但门槛方面相差还是比较多的（具体以基金合同为准）：</p>
<table>
<thead>
<tr>
<th>基金份额类型（费率模式）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>A类份额</td>
<td>货币基金中的低门槛份额，适用于认购、申购金额低于500万的投资者，散户投资者买货基都是此类；</td>
</tr>
<tr>
<td>B类份额</td>
<td>货币基金中的高门槛份额，适用于认购、申购金额高于500万的投资者，专为高净值客户或机构客户设置。</td>
</tr>
</tbody></table>
<h3 id="股票型-混合型-债券型基金"><a href="#股票型-混合型-债券型基金" class="headerlink" title="股票型/混合型/债券型基金"></a>股票型/混合型/债券型基金</h3><table>
<thead>
<tr>
<th>基金份额类型（费率模式）</th>
<th>费用差别</th>
<th>适合人群</th>
</tr>
</thead>
<tbody><tr>
<td>A类份额</td>
<td>前端收费，即申购时收取申购费（不同的销售渠道会有打折）</td>
<td>投资时间没有明确判断</td>
</tr>
<tr>
<td>B类份额</td>
<td>后端收费，即赎回时收取申购费（持有的时间越长，申购费越少，持有超过一定年限后，不再收取）</td>
<td>长期持有（一般3~5年）</td>
</tr>
<tr>
<td>C类份额</td>
<td>无申购费，但按日收取销售服务费</td>
<td>短期持有（一般1~2年）</td>
</tr>
</tbody></table>
<p>值得注意的是：A类份额和B类份额，都要收取一定的基金管理费和托管费，但是不收取销售服务费。</p>
<p>A类基金：前端申购费+赎回费+管理费+托管费<br>B类基金：后端申购费+赎回费+管理费+托管费<br>C类基金：销售服务费+赎回费+管理费+托管费</p>
<h2 id="持有区间收益率"><a href="#持有区间收益率" class="headerlink" title="持有区间收益率"></a>持有区间收益率</h2><ul>
<li>资产回报：是指股票、债券、房地产等资产价格的增加或减少。</li>
<li>资产回报率 = (期末资产价格 - 期初资产价格) ÷ 期初资产价格 × 100%</li>
<li>收入回报：包括分红、利息等。</li>
<li>收入回报率 = 期间收入 ÷ 期初资产价格 × 100%</li>
<li>持有区间收益 = 资产回报 + 收入回报</li>
<li>持有区间收益率 = 资产回报率 + 收入回报率</li>
</ul>
<ul>
<li>除权：因<strong>送股或配股</strong>而形成的剔除行为。</li>
<li>除息：因<strong>派息</strong>而引起的剔除行为。</li>
<li>除权（息）参考价 = (前收盘价 - 现金红利 + 配股价格 × 股份变动比例) ÷ (1+ 股份变动比例)</li>
</ul>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><h3 id="申购计算公式"><a href="#申购计算公式" class="headerlink" title="申购计算公式"></a>申购计算公式</h3><p>净申购金额=申购金额/(1+申购费率)</p>
<p>申购费用=申购金额-净申购金额</p>
<p>申购份额=净申购金额/T日基金份额净值</p>
</div></article></li></ul><div class="right-container"><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/DNS/" style="font-size: 12.5px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GNU-Linux/" style="font-size: 16.67px;">GNU/Linux</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 19.17px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 11.67px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10.83px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15.83px;">Spring</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 18.33px;">前端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">响应式编程</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 12.5px;">安全</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">并发编程</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 13.33px;">建站</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 12.5px;">管理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.17px;">读书笔记</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 12.5px;">金融</a></div></div><div class="widget"><div class="recent"><h4>最近文章</h4><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/02/26/cpp-io-library/">C/C++ 语言系列（十一）I/O 库总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/25/cpp-oop-inheritance-and-polymorphism/">C/C++ 语言系列（十）面向对象编程之继承与多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/20/cpp-oop-class/">C/C++ 语言系列（九）面向对象编程之类、类模板、类指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/18/cpp-type-aliases/">C/C++ 语言系列（八）复合数据类型之类型别名</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/16/cpp-struct/">C/C++ 语言系列（七）复合数据类型之结构体</a></li></ul></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/page/5/" class="prev">PREV</a><a href="/page/7/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2021 <a href="https://github.com/qidawu" target="_blank">Qida's Blog</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>