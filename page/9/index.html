<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> Qida's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="学习笔记 知识总结 思考感悟"><meta name="keywords"><meta name="author" content="Qida's Blog"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://qidawu.github.io/atom.xml" title="Qida's Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><a href="/" class="title-link">Qida's Blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/27/spring-transaction/" class="post-title-link">Java 数据持久化系列（五）Spring 事务管理总结</a></h2><div class="post-info">2018-02-27<a href="/tags/Java/" title="Java" class="post-demo">Java</a><a href="/tags/Spring/" title="Spring" class="post-demo">Spring</a></div><div class="post-content"><p>本文梳理 Spring 事务管理的方方面面，总览如下：</p>
<p><img src="/img/spring/transaction/transaction_management.png" alt=""></p>
<h1 id="Spring-框架的事务支持模型的优点"><a href="#Spring-框架的事务支持模型的优点" class="headerlink" title="Spring 框架的事务支持模型的优点"></a>Spring 框架的事务支持模型的优点</h1><p>全面的事务支持是使用 Spring 框架的最有说服力的理由之一。Spring 框架为事务管理提供了一致的抽象层，并具有以下优势：</p>
<ul>
<li>跨不同事务 API 的一致编程模型，如 JTA (Java Transaction API)、JPA (Java Persistence API)、JDBC、Hibernate、MyBatis。</li>
<li>支持<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#transaction-declarative" target="_blank" rel="noopener">声明式事务管理</a>，可通过 XML 或注解进行配置。</li>
<li>比复杂的事务 API（如 JTA）更简单的<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#transaction-programmatic" target="_blank" rel="noopener">编程式事务管理 API</a>。</li>
<li>与 Spring 框架的数据访问抽象层集成。</li>
</ul>
<h1 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h1><h2 id="理解声明式事务实现"><a href="#理解声明式事务实现" class="headerlink" title="理解声明式事务实现"></a>理解声明式事务实现</h2><p>关于 Spring 框架的声明式事务支持，最重要的概念是掌握其通过 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-understanding-aop-proxies" target="_blank" rel="noopener">AOP 代理</a>来启用此支持，并且事务 advice 由元数据（基于 XML 或注释 <code>@Transactional</code>）驱动。AOP 与事务元数据的组合产生 AOP 代理，该代理使用 <code>TransactionInterceptor</code> 搭配合适的 <code>PlatformTransactionManager</code> 实现来驱动围绕方法调用的事务代理。</p>
<p><code>TransactionInterceptor</code> 的结构如下：</p>
<p><img src="/img/spring/transaction/TransactionInterceptor.png" alt="TransactionInterceptor"></p>
<p>下图展示了调用事务代理方法的过程：</p>
<p><img src="/img/spring/transaction/tx.png" alt="事务代理调用"></p>
<h2 id="基于-XML-方式配置事务管理"><a href="#基于-XML-方式配置事务管理" class="headerlink" title="基于 XML 方式配置事务管理"></a>基于 XML 方式配置事务管理</h2><p>使用 <code>&lt;tx:advice/&gt;</code> 创建事务 advice，并创建切面通过 <code>&lt;aop:advisor/&gt;</code> 指定该事务 advice 须应用到哪些切点之上：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- the transactional advice (what 'happens'; see the &lt;aop:advisor/&gt; bean below) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- the transactional semantics... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- all methods starting with 'get' are read-only --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- other methods use the default transaction settings (see below) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ensure that the above transactional advice runs for any execution</span></span><br><span class="line"><span class="comment">        of an operation defined by the FooService interface --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"fooServiceOperation"</span> <span class="attr">expression</span>=<span class="string">"execution(* x.y.service.FooService.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"fooServiceOperation"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>事务配置可通过修改 <code>&lt;tx:method/&gt;</code> 的属性，详见脑图。</p>
<h2 id="基于注解方式配置事务管理"><a href="#基于注解方式配置事务管理" class="headerlink" title="基于注解方式配置事务管理"></a>基于注解方式配置事务管理</h2><p>除了使用基于 XML 的方式（<code>&lt;tx:advice/&gt;</code>）声明事务配置之外，您还可以使用基于注解的方式（<code>@Transactional</code> ）。直接在 Java 源代码中声明事务语义会使声明更靠近受影响的代码，易于配置和修改。这样之所以不存在过度耦合的原因是因为，无论如何，用于事务处理的代码几乎总是以事务的方式进行部署。</p>
<p>您可以将 <code>@Transactional</code> 注解应用于：</p>
<ul>
<li>接口定义（interface）</li>
<li>接口上的方法</li>
<li>类定义（class）</li>
<li>类上的公有方法（public method on class）</li>
</ul>
<p><code>@Transactional</code> 提供的配置属性如下：</p>
<p><img src="/img/spring/transaction/spring_annotation_transactional.png" alt="@Transactional"></p>
<h3 id="开启事务支持"><a href="#开启事务支持" class="headerlink" title="开启事务支持"></a>开启事务支持</h3><p>但是，仅仅使用 <code>@Transactional</code> 注解并不足以激活事务行为，还需要开启事务支持，可以使用以下方式：</p>
<ul>
<li><code>&lt;tx:annotation-driven/&gt;</code></li>
<li><code>@EnableTransactionManagement</code></li>
</ul>
<p>配置参数如下：</p>
<table>
<thead>
<tr>
<th>XML 属性</th>
<th>注解属性</th>
<th>默认</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>transaction-manager</code></td>
<td>N/A (see <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/TransactionManagementConfigurer.html" target="_blank" rel="noopener"><code>TransactionManagementConfigurer</code></a> javadoc)</td>
<td><code>transactionManager</code></td>
<td>要使用的事务管理器的名称。仅在事务管理器的名称不是  <code>transactionManager</code> 时才需要设置。</td>
</tr>
<tr>
<td><code>mode</code></td>
<td><code>mode</code></td>
<td><code>proxy</code></td>
<td>默认为代理模式（<code>proxy</code>），使用 Spring AOP 框架处理被 <code>@Transactional</code> 注解的 bean，仅适用于通过代理进入的方法调用。<br/>相反，替代模式（<code>aspectj</code>）使用Spring AspectJ 事务切面织入到受影响的类，修改目标类的字节码以应用于任何类型的方法调用（支持任意访问修饰符、支持自调用）。AspectJ 织入需要在类路径中包含 <code>spring-aspects.jar</code> 以及开启类加载期织入（load-time weaving）或编译期织入（compile-time weaving）。（参阅 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-aj-ltw-spring" target="_blank" rel="noopener">Spring 配置</a>）</td>
</tr>
<tr>
<td><code>proxy-target-class</code></td>
<td><code>proxyTargetClass</code></td>
<td><code>false</code></td>
<td>仅适用于 <code>proxy</code> 模式。控制为使用 <code>@Transactional</code> 注解的类所创建的事务代理类型。如果 <code>proxy-target-class</code> 属性设置为 <code>true</code>，则创建基于类的代理（CGLib Proxy）。如果为 <code>false</code> 或者省略该属性，则创建基于标准 JDK 接口的代理（JDK Proxy）。（参阅<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-proxying" target="_blank" rel="noopener">代理机制</a>）</td>
</tr>
<tr>
<td><code>order</code></td>
<td><code>order</code></td>
<td><code>Ordered.LOWEST_PRECEDENCE</code></td>
<td>参阅 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-ataspectj-advice-ordering" target="_blank" rel="noopener">Advice 排序</a>。</td>
</tr>
</tbody></table>
<p>更多注意点，详见官方文档：</p>
<blockquote>
<p>The default advice mode for processing <code>@Transactional</code> annotations is <code>proxy</code>, which allows for interception of calls through the proxy only. Local calls within the same class cannot get intercepted that way. For a more advanced mode of interception, consider switching to <code>aspectj</code> mode in combination with compile-time or load-time weaving.</p>
</blockquote>
<blockquote>
<p>In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation (in effect, a method within the target object calling another method of the target object) does not lead to an actual transaction at runtime even if the invoked method is marked with <code>@Transactional</code>.</p>
</blockquote>
<blockquote>
<p>The <code>proxy-target-class</code> attribute controls what type of transactional proxies are created for classes annotated with the <code>@Transactional</code> annotation. If <code>proxy-target-class</code> is set to <code>true</code>, class-based proxies are created. If<code>proxy-target-class</code> is <code>false</code> or if the attribute is omitted, standard JDK interface-based proxies are created. (See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#aop-proxying" target="_blank" rel="noopener">[aop-proxying]</a> for a discussion of the different proxy types.)</p>
</blockquote>
<blockquote>
<p>The Spring team recommends that you annotate only concrete classes (and methods of concrete classes) with the <code>@Transactional</code> annotation, as opposed to annotating interfaces. You certainly can place the <code>@Transactional</code> annotation on an interface (or an interface method), but this works only as you would expect it to if you use interface-based proxies. The fact that Java annotations are not inherited from interfaces means that, if you use class-based proxies (<code>proxy-target-class=&quot;true&quot;</code>) or the weaving-based aspect (<code>mode=&quot;aspectj&quot;</code>), the transaction settings are not recognized by the proxying and weaving infrastructure, and the object is not wrapped in a transactional proxy.</p>
</blockquote>
<blockquote>
<p>When you use proxies, you should apply the <code>@Transactional</code> annotation only to methods with public visibility. If you do annotate protected, private or package-visible methods with the <code>@Transactional</code> annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings. If you need to annotate non-public methods, consider using AspectJ.</p>
</blockquote>
<p><code>@EnableTransactionManagement</code> 注解主要用于导入 <code>TransactionManagementConfigurationSelector</code>，其判断 <code>mode</code> 属性：</p>
<ul>
<li><code>mode</code> 为 <code>AdviceMode.PROXY</code>，返回配置  <code>org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration</code>，该 Java Config 用于配置以下 bean：<ul>
<li><code>TransactionInterceptor</code> 最关键的类</li>
<li><code>TransactionAttributeSource</code></li>
<li><code>BeanFactoryTransactionAttributeSourceAdvisor</code></li>
</ul>
</li>
<li><code>mode</code> 为 <code>AdviceMode.ASPECTJ</code>，默认返回配置 <code>org.springframework.transaction.aspectj.AspectJTransactionManagementConfiguration</code></li>
</ul>
<h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><p>其中事务的传播行为需要留意下，是 Spring 特有的概念，与数据库无关。它是为了解决业务层方法之间互相调用的事务问题而引入的。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。有以下几种方式：</p>
<table>
<thead>
<tr>
<th>传播行为</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>REQUIRED</code></td>
<td>支持当前事务，如果不存在，就新建一个。默认配置。</td>
</tr>
<tr>
<td><code>SUPPORTS</code></td>
<td><del>支持当前事务，如果不存在，就以非事务方式执行。</del></td>
</tr>
<tr>
<td><code>MANDATORY</code></td>
<td><del>支持当前事务，如果不存在，就抛出异常。</del></td>
</tr>
<tr>
<td><code>REQUIRES_NEW</code></td>
<td>如果当前存在事务，挂起当前事务，创建一个新事务。</td>
</tr>
<tr>
<td><code>NOT_SUPPORTED</code></td>
<td><del>以非事务方式执行，如果当前存在事务，则挂起当前事务。</del></td>
</tr>
<tr>
<td><code>NEVER</code></td>
<td><del>以非事务方式执行，如果当前存在事务，则抛出异常。</del></td>
</tr>
<tr>
<td><code>NESTED</code></td>
<td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 <code>REQUIRED</code> 类似的操作。</td>
</tr>
</tbody></table>
<p>强烈不建议使用非事务方式执行，因此上述标注删除线的传播行为不建议使用。</p>
<p>在 Spring 管理的事务中，请注意物理事务和逻辑事务之间的区别，以及传播行为应用于两者之上时的区别。</p>
<h3 id="REQUIRED"><a href="#REQUIRED" class="headerlink" title="REQUIRED"></a>REQUIRED</h3><p><img src="/img/spring/transaction/tx_prop_required.png" alt="REQUIRED"></p>
<h3 id="REQUIRED-NEW"><a href="#REQUIRED-NEW" class="headerlink" title="REQUIRED_NEW"></a>REQUIRED_NEW</h3><p><img src="/img/spring/transaction/tx_prop_requires_new.png" alt="REQUIRED_NEW"></p>
<h1 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h1><p>Spring 框架提供了两种编程式事务管理方法：</p>
<ul>
<li>直接使用 Spring 框架最底层的 <code>PlatformTransactionManager</code>  的实现类；</li>
<li>更建议使用 Spring 框架封装过的 <code>TransactionTemplate</code> 事务模板类。</li>
</ul>
<h2 id="使用-PlatformTransactionManager"><a href="#使用-PlatformTransactionManager" class="headerlink" title="使用 PlatformTransactionManager"></a>使用 <code>PlatformTransactionManager</code></h2><p>Spring 事务抽象的关键在于事务策略的概念。事务策略由<code>org.springframework.transaction.PlatformTransactionManager</code>接口定义 ，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>PlatformTransactionManager</code> 是一个接口，因此很容易按需 mock 或 stub。它与查找策略无关，例如JNDI。<code>PlatformTransactionManager</code> 的实现就像其它对象或 bean 一样在 Spring 框架的 IoC 容器中定义。仅此优势就让 Spring 框架事务成为一种有价值的抽象，即便是使用 JTA。与直接使用 JTA 相比，您可以更轻松地测试事务代码。</p>
<p>同时，为了与 Spring 的理念保持一致，<code>PlatformTransactionManager</code> 接口的所有方法抛出的  <code>TransactionException</code> 异常都是非受检的（即继承自 <code>java.lang.RuntimeException</code> 类）。事务基础设施故障几乎都是致命性的。只有极少数情况下，应用程序能够从事务故障中恢复过来。开发人员仍然可以选择 try catch <code>TransactionException</code>，但重点是开发人员不会<strong>被迫</strong>这样做。</p>
<p><code>getTransaction(..)</code> 方法根据 <code>TransactionDefinition</code> 参数返回一个 <code>TransactionStatus</code> 对象 。<code>TransactionStatus</code> 表示一个新事务，但如果当前调用堆栈中存在匹配事务，则表示该已有事务，即 <code>TransactionStatus</code> 是与执行的线程相关联的。</p>
<p><code>TransactionDefinition</code> 接口可以控制事务的传播行为、隔离级别、超时时间、只读状态，其结构如下：</p>
<p><img src="/img/spring/transaction/TransactionDefinition.png" alt="TransactionDefinition"></p>
<p><code>TransactionStatus</code> 接口为事务代码提供了一种简单的方法来控制事务执行和查询事务状态，其结构如下：</p>
<p><img src="/img/spring/transaction/TransactionStatus.png" alt="TransactionDefinition"></p>
<p>在 Spring 中无论选择使用声明式还是编程式事务管理，定义正确的 <code>PlatformTransactionManager</code> 实现都是绝对必要的。Spring 提供了下面几种实现：</p>
<table>
<thead>
<tr>
<th>实现类</th>
<th>包</th>
<th>工作环境</th>
</tr>
</thead>
<tbody><tr>
<td><code>DataSourceTransactionManager</code></td>
<td>spring-jdbc</td>
<td>JDBC、Mybatis</td>
</tr>
<tr>
<td><code>HibernateTransactionManager</code></td>
<td>spring-orm</td>
<td>Hibernate</td>
</tr>
<tr>
<td><code>JpaTransactionManager</code></td>
<td>spring-orm</td>
<td>JPA</td>
</tr>
<tr>
<td><code>JtaTransactionManager</code></td>
<td>spring-tx</td>
<td>JTA</td>
</tr>
</tbody></table>
<p>其继承关系如下：</p>
<p><img src="/img/spring/transaction/PlatformTransactionManager.png" alt="PlatformTransactionManager 实现"></p>
<p>以最常用的 <code>DataSourceTransactionManager</code> 为例，重点看下都提供了哪些方法：</p>
<p><img src="/img/spring/transaction/DataSourceTransactionManager.png" alt="DataSourceTransactionManager"></p>
<h2 id="使用-TransactionTemplate"><a href="#使用-TransactionTemplate" class="headerlink" title="使用 TransactionTemplate"></a>使用 <code>TransactionTemplate</code></h2><p>和 Spring 框架的其它模板类一样，<code>TransactionTemplate</code> 也采用了回调方法来减少样板代码。相比起直接使用 <code>PlatformTransactionManager</code> 接口，<code>TransactionTemplate</code> 可以让开发人员无须重复编写获取与释放事务资源的代码，从而更聚焦于业务代码。</p>
<p><img src="/img/spring/transaction/TransactionTemplate.png" alt="TransactionTemplate"></p>
<p>你需要编写一个 <code>TransactionCallback</code> 实现（通常为匿名内部类），其中包含需要在事务上下文中执行的代码。然后传递给 <code>TransactionTemplate</code> 的 <code>execute(..)</code> 方法去执行：</p>
<p><img src="/img/spring/transaction/TransactionCallback.png" alt="TransactionCallback"></p>
<p>由于 <code>TransactionTemplate</code> 继承自 <code>DefaultTransactionDefinition</code>，因此可以直接修改其属性进行事务配置（如传播行为、隔离级别、超时时间等）。<code>TransactionTemplate</code> 类的实例是线程安全的，实例并不维护任何会话状态，但是却会维护配置状态。因此，当多个类共享使用同一个 <code>TransactionTemplate</code> 类的实例时，如果其中一个需要使用不同的配置（例如不同的隔离级别），你需要创建两个不同的 <code>TransactionTemplate</code> 类的实例。</p>
<h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDbService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestDAO testDAO;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要使用底层 `PlatformTransactionManager` 接口直接管理事务，请先注入所需的实现类。</span></span><br><span class="line"><span class="comment">     * 然后，通过 `TransactionDefinition` 和 `TransactionStatus` 对象启动、回滚和提交事务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultTransactionDefinition def = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">        <span class="comment">// explicitly setting the transaction name is something that can be done only programmatically</span></span><br><span class="line">        def.setName(<span class="string">"SomeTxName"</span>);</span><br><span class="line">        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line">        </span><br><span class="line">        TransactionStatus status = transactionManager.getTransaction(def);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer result = insert();</span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TransactionTemplate 采用了回调方法来减少样板代码。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">save1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> insert();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(e.getMessage(), e);</span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用注解方式配置事务，是最简单最推荐的方式。事务的参数配置详见脑图。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Integer</span> <span class="title">save3</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/20/spring-jdbc/" class="post-title-link">Java 数据持久化系列（四）Spring JDBC 使用总结</a></h2><div class="post-info">2018-02-20<a href="/tags/Java/" title="Java" class="post-demo">Java</a><a href="/tags/Spring/" title="Spring" class="post-demo">Spring</a></div><div class="post-content"><h1 id="Spring-JDBC-简介"><a href="#Spring-JDBC-简介" class="headerlink" title="Spring JDBC 简介"></a>Spring JDBC 简介</h1><p>Spring 的 JDBC 框架承担了资源管理和异常处理的工作，从而简化了底层 JDBC API 代码，让我们只需编写从数据库读写数据所需的代码。具体特性如下：</p>
<ul>
<li><p>Spring 为读取和写入数据库的几乎所有错误提供了丰富的异常，且不与特定的持久化框架相关联（如下图）。异常都继承自的父类 <code>DataAccessException</code>，是一个非受检异常，无需捕获，因为 Spring 认为触发异常的很多问题是不能在 <code>catch</code> 代码块中修复，因此不强制开发人员编写 <code>catch</code> 代码块。这把是否要捕获异常的权利留给了开发人员。</p>
<p><img src="/img/spring/jdbc/data-access-exceptions.png" alt="data-access-exceptions"></p>
</li>
<li><p>Spring 将数据访问过程中固定的和可变的部分明确划分为两个不同的类：<em>模板（template）</em> 和 <em>回调（callback）</em>。模板管理过程中固定的部分（如事务控制、资源管理、异常处理），而回调处理自定义的数据访问代码（如 SQL 语句、绑定参数、整理结果集）。针对不同的持久化平台，Spring 提供了多个可选的模板：</p>
<p><img src="/img/spring/jdbc/data-access-templates.png" alt="data-access-templates"></p>
</li>
</ul>
<h1 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h1><p>要在 Spring 中使用 JDBC，需要依赖 <code>spring-jdbc</code>。如果使用 Spring Boot 的话，可以直接导入起步依赖 <code>spring-boot-starter-jdbc</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring JDBC 起步依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- MySQL JDBC 驱动程序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>mvn dependency:tree</code> 分析传递依赖如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[INFO] +- mysql:mysql-connector-java:jar:8.0.13:compile</span><br><span class="line">[INFO] \- org.springframework.boot:spring-boot-starter-jdbc:jar:2.1.2.RELEASE:compile</span><br><span class="line">[INFO]    +- org.springframework.boot:spring-boot-starter:jar:2.1.2.RELEASE:compile</span><br><span class="line">[INFO]    |  +- org.springframework.boot:spring-boot:jar:2.1.2.RELEASE:compile</span><br><span class="line">[INFO]    |  |  \- org.springframework:spring-context:jar:5.1.4.RELEASE:compile</span><br><span class="line">[INFO]    |  |     +- org.springframework:spring-aop:jar:5.1.4.RELEASE:compile</span><br><span class="line">[INFO]    |  |     \- org.springframework:spring-expression:jar:5.1.4.RELEASE:compile</span><br><span class="line">[INFO]    |  +- org.springframework.boot:spring-boot-autoconfigure:jar:2.1.2.RELEASE:compile</span><br><span class="line">[INFO]    |  +- org.springframework.boot:spring-boot-starter-logging:jar:2.1.2.RELEASE:compile</span><br><span class="line">[INFO]    |  |  +- ch.qos.logback:logback-classic:jar:1.2.3:compile</span><br><span class="line">[INFO]    |  |  |  \- ch.qos.logback:logback-core:jar:1.2.3:compile</span><br><span class="line">[INFO]    |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.11.1:compile</span><br><span class="line">[INFO]    |  |  |  \- org.apache.logging.log4j:log4j-api:jar:2.11.1:compile</span><br><span class="line">[INFO]    |  |  \- org.slf4j:jul-to-slf4j:jar:1.7.25:compile</span><br><span class="line">[INFO]    |  +- javax.annotation:javax.annotation-api:jar:1.3.2:compile</span><br><span class="line">[INFO]    |  +- org.springframework:spring-core:jar:5.1.4.RELEASE:compile</span><br><span class="line">[INFO]    |  |  \- org.springframework:spring-jcl:jar:5.1.4.RELEASE:compile</span><br><span class="line">[INFO]    |  \- org.yaml:snakeyaml:jar:1.23:runtime</span><br><span class="line">[INFO]    +- com.zaxxer:HikariCP:jar:3.2.0:compile</span><br><span class="line">[INFO]    |  \- org.slf4j:slf4j-api:jar:1.7.25:compile</span><br><span class="line">[INFO]    \- org.springframework:spring-jdbc:jar:5.1.4.RELEASE:compile</span><br><span class="line">[INFO]       +- org.springframework:spring-beans:jar:5.1.4.RELEASE:compile</span><br><span class="line">[INFO]       \- org.springframework:spring-tx:jar:5.1.4.RELEASE:compile</span><br></pre></td></tr></table></figure>

<p>可见，<code>spring-boot-starter-jdbc</code> 引入了如下传递依赖：</p>
<ul>
<li><code>spring-boot-starter</code><ul>
<li><code>spring-boot-autoconfigure</code> Spring Boot 自动配置类</li>
</ul>
</li>
<li><code>spring-jdbc</code> Spring JDBC 核心库</li>
<li><code>HikariCP</code>，Spring Boot 2 的默认数据库连接池</li>
<li>……</li>
</ul>
<h1 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h1><p><code>spring-boot-autoconfigure</code> 依赖内含几个关键的配置类，提供了如下外部配置：</p>
<ul>
<li><p><code>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</code>，用于自动配置嵌入式数据源 或 连接池数据源</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span></span><br><span class="line">    <span class="attr">url:</span></span><br><span class="line">    <span class="attr">username:</span></span><br><span class="line">    <span class="attr">password:</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration</code>，用于自动配置 JNDI 数据源</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">jndi-name:</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration</code>，用于自动配置分布式事务的数据源</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">xa:</span></span><br><span class="line">      <span class="attr">data-source-class-name:</span></span><br><span class="line">      <span class="attr">properties:</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration</code>，用于导入配置类：<code>JdbcTemplateConfiguration</code>、<code>NamedParameterJdbcTemplateConfiguration</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jdbc:</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">fetch-size:</span> </span><br><span class="line">      <span class="attr">max-rows:</span> </span><br><span class="line">      <span class="attr">query-timeout:</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration</code> 用于自动配置 <code>DataSourceTransactionManager</code></p>
</li>
<li><p><code>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">transaction:</span></span><br><span class="line">    <span class="attr">defaultTimeout:</span></span><br><span class="line">    <span class="attr">rollbackOnCommitFailure:</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="使用-JDBC-Template"><a href="#使用-JDBC-Template" class="headerlink" title="使用 JDBC Template"></a>使用 JDBC Template</h1><h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>为了让 <code>JdbcTemplate</code> 正常工作，只需要为其设置 <code>DataSource</code> 数据源即可。Spring Boot 下直接使用外部配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span>  <span class="comment">#使用 HikariCP，Spring Boot 2 的默认数据库连接池</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true;characterEncoding=utf-8</span></span><br><span class="line">    <span class="attr">username:</span> </span><br><span class="line">    <span class="attr">password:</span></span><br></pre></td></tr></table></figure>

<p>如果未使用 Spring Boot，Java Config 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HikariDataSource ds = <span class="keyword">new</span> HikariDataSource();</span><br><span class="line">    ds.setDriverClassName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">    ds.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/test?useUnicode=true;characterEncoding=utf-8"</span>);</span><br><span class="line">    ds.setUsername(<span class="string">""</span>);</span><br><span class="line">    ds.setPassword(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="API-介绍"><a href="#API-介绍" class="headerlink" title="API 介绍"></a>API 介绍</h2><p><img src="/img/spring/jdbc/JdbcOperations.png" alt="JdbcOperations"></p>
<ul>
<li><p><code>org.springframework.jdbc.core.JdbcOperations</code> 是 Spring 封装 JDBC 操作的核心接口，提供的方法如下，基于<strong>索引参数</strong>进行 SQL 参数绑定。实现类为 <code>org.springframework.jdbc.core.JdbcTemplate</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; List&lt;T&gt; <span class="title">query</span><span class="params">(String, RowMapper&lt;T&gt;, Object...)</span>  <span class="comment">// 多列查询</span></span></span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">queryForMap</span><span class="params">(String, Object...)</span>  <span class="comment">// 单行多列查询</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">queryForObject</span><span class="params">(String, Class&lt;T&gt;, Object...)</span>  <span class="comment">// 单行单列查询</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">queryForObject</span><span class="params">(String, RowMapper&lt;T&gt;, Object...)</span>  <span class="comment">// 单行多列查询</span></span></span><br><span class="line"><span class="function">&lt;T&gt; List&lt;T&gt; <span class="title">queryForList</span><span class="params">(String, Class&lt;T&gt;, Object...)</span>  <span class="comment">// 多行单列查询</span></span></span><br><span class="line"><span class="function">List&lt;Map&lt;String, Object&gt;&gt; <span class="title">queryForList</span><span class="params">(String, Object...)</span>  <span class="comment">// 多行多列查询</span></span></span><br><span class="line"><span class="function">SqlRowSet <span class="title">queryForRowSet</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(...)</span>  <span class="comment">// 执行单个增删改</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>[] <span class="title">batchUpdate</span><span class="params">(...)</span>  <span class="comment">// 执行批量增删改</span></span></span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">call</span><span class="params">(...)</span>  <span class="comment">// 执行存储过程和函数</span></span></span><br><span class="line"><span class="function">......</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations</code> 接口支持将值以<strong>命名参数</strong>的形式绑定到 SQL，实现类为 <code>org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate</code>，其底层使用的仍然是 <code>JdbcOperations</code>，是一个二次封装的 API，推荐使用。</p>
</li>
</ul>
<p>如果使用 Spring Boot 的话，可以直接导入起步依赖 <code>spring-boot-starter-jdbc</code>，会引入自动配置类 <code>org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration</code>，用于导入配置类：<code>JdbcTemplateConfiguration</code>、<code>NamedParameterJdbcTemplateConfiguration</code>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; DataSource<span class="class">.<span class="keyword">class</span>, <span class="title">JdbcTemplate</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnSingleCandidate</span>(<span class="title">DataSource</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(<span class="title">DataSourceAutoConfiguration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">JdbcProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123; JdbcTemplateConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">NamedParameterJdbcTemplateConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JdbcTemplateAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要满足几个条件，该自动配置类就会生效：</p>
<ul>
<li>classpath 包含 <code>DataSource</code>、<code>JdbcTemplate</code> 类</li>
<li><code>DataSource</code> bean 有且只有一个</li>
</ul>
<h3 id="使用-JdbcOperations"><a href="#使用-JdbcOperations" class="headerlink" title="使用 JdbcOperations"></a>使用 JdbcOperations</h3><p>依赖注入 <code>JdbcTemplate</code> 实现之后，使用如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TestPO&gt; testPOList = jdbcOperations.query(</span><br><span class="line">        <span class="string">"SELECT id, name, city FROM test WHERE name = ? AND city = ?"</span>, </span><br><span class="line">        (rs, rowNum) -&gt; <span class="keyword">new</span> TestPO(</span><br><span class="line">            rs.getLong(<span class="string">"id"</span>),</span><br><span class="line">            rs.getString(<span class="string">"name"</span>),</span><br><span class="line">            rs.getString(<span class="string">"city"</span>)</span><br><span class="line">        ), </span><br><span class="line">        <span class="string">"李四"</span>, <span class="string">"beijing"</span></span><br><span class="line">    );</span><br><span class="line">log.info(<span class="string">"Result is &#123;&#125;"</span>, testPOList);  <span class="comment">// Result is [TestPO(id=2, name=李四, city=beijing)]</span></span><br><span class="line"></span><br><span class="line">TestPO testPO = jdbcOperations.queryForObject(</span><br><span class="line">        <span class="string">"SELECT id, name, city FROM test WHERE id = ?"</span>, </span><br><span class="line">        (rs, rowNum) -&gt; <span class="keyword">new</span> TestPO(</span><br><span class="line">            rs.getLong(<span class="string">"id"</span>),</span><br><span class="line">            rs.getString(<span class="string">"name"</span>),</span><br><span class="line">            rs.getString(<span class="string">"city"</span>)</span><br><span class="line">        ), </span><br><span class="line">        <span class="number">2</span></span><br><span class="line">    );</span><br><span class="line">log.info(<span class="string">"Result is &#123;&#125;"</span>, testPO);  <span class="comment">// Result is TestPO(id=2, name=李四, city=beijing)</span></span><br><span class="line"></span><br><span class="line">String name = jdbcOperations.queryForObject(<span class="string">"SELECT name FROM test WHERE id = ?"</span>, String<span class="class">.<span class="keyword">class</span>, 2)</span>;</span><br><span class="line">log.info(<span class="string">"Result is &#123;&#125;"</span>, name);  <span class="comment">// Result is 李四</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; names = jdbcOperations.queryForList("SELECT name FROM test WHERE city = ?", String.class, "beijing");</span><br><span class="line">log.info(<span class="string">"Result is &#123;&#125;"</span>, names);  <span class="comment">// Result is [李四, 王五]</span></span><br><span class="line"></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; testMapList = jdbcOperations.queryForList(<span class="string">"SELECT id, name, city FROM test WHERE city = ?"</span>, <span class="string">"beijing"</span>);</span><br><span class="line">log.info(<span class="string">"Result is &#123;&#125;"</span>, testMapList);  <span class="comment">// Result is [&#123;id=2, name=李四, city=beijing&#125;, &#123;id=3, name=王五, city=beijing&#125;]</span></span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; testMap = jdbcOperations.queryForMap(<span class="string">"SELECT id, name, city FROM test WHERE id = ?"</span>, <span class="number">2</span>);</span><br><span class="line">log.info(<span class="string">"Result is &#123;&#125;"</span>, testMap);  <span class="comment">// Result is &#123;id=2, name=李四, city=beijing&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-NamedParameterJdbcTemplate"><a href="#使用-NamedParameterJdbcTemplate" class="headerlink" title="使用 NamedParameterJdbcTemplate"></a>使用 NamedParameterJdbcTemplate</h3><p>使用 <code>JdbcOperations</code> 需要特别注意索引参数的正确顺序，如果在修改 SQL 时忘记修改参数顺序，将导致查询出错。因此更建议使用命名参数，按照名字来绑定值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; cityParamMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">paramMap.put(<span class="string">"city"</span>, <span class="string">"beijing"</span>);</span><br><span class="line">paramMap.put(<span class="string">"name"</span>, <span class="string">"李四"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;TestPO&gt; testPOList = namedParameterJdbcOperations.query(</span><br><span class="line">        <span class="string">"SELECT id, name, city FROM test WHERE name = :name AND city = :city"</span>, </span><br><span class="line">        paramMap, </span><br><span class="line">        (rs, rowNum) -&gt; <span class="keyword">new</span> TestPO(</span><br><span class="line">            rs.getLong(<span class="string">"id"</span>),</span><br><span class="line">            rs.getString(<span class="string">"name"</span>),</span><br><span class="line">            rs.getString(<span class="string">"city"</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"Result is &#123;&#125;"</span>, testPOList);  <span class="comment">// Result is [TestPO(id=2, name=李四, city=beijing)]</span></span><br></pre></td></tr></table></figure>

</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/08/java-jdbc-mapping-sql-and-java-types/" class="post-title-link">Java 数据持久化系列（三）JDBC SQL 和 Java 数据类型映射总结</a></h2><div class="post-info">2018-02-08<a href="/tags/Java/" title="Java" class="post-demo">Java</a></div><div class="post-content"><h1 id="映射概述"><a href="#映射概述" class="headerlink" title="映射概述"></a>映射概述</h1><p>由于 SQL 中的数据类型和 Java 编程语言中的数据类型并不相同，因此需要使用某种机制在使用 Java 类型的应用程序和使用 SQL 类型的数据库之间传输数据。</p>
<h1 id="SQL-类型映射成-JDBC-类型"><a href="#SQL-类型映射成-JDBC-类型" class="headerlink" title="SQL 类型映射成 JDBC 类型"></a>SQL 类型映射成 JDBC 类型</h1><p>不同数据库产品支持的 SQL 类型之间存在显着差异。即使不同的数据库支持具有相同语义的 SQL 类型，它们也可能为这些类型提供了不同的名称。例如，大多数主要数据库都支持 large binary 这种 SQL 类型，但是：</p>
<ul>
<li>MySQL 的命名为 <code>BINARY</code>、<code>VARBINARY</code>（详见：<a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html" target="_blank" rel="noopener">The BINARY and VARBINARY Types</a>）</li>
<li>Oracle 的命名为 <code>LONG RAW</code></li>
<li>Sybase 的命名为 <code>IMAGE</code></li>
<li>Informix 的命名为 <code>BYTE</code></li>
<li>DB2 的命名为 <code>LONG VARCHAR FOR BIT DATA</code></li>
</ul>
<p>幸运的是，JDBC 开发通常不需要关心目标数据库使用的实际 SQL 类型名称。大多数情况下，JDBC 开发将针对现有数据库表进行编程，并不需要关心用于创建这些表的确切 SQL 类型名称。</p>
<p>JDBC API 在 <code>java.sql.Types</code> 类中定义了一组通用 SQL 类型标识符，旨在表达最常用的 SQL 类型。在使用 JDBC API 进行编程时，程序员通常可以使用这些 JDBC 类型来引用通用 SQL 类型，而无需关心目标数据库使用的确切 SQL 类型名称。</p>
<p>下表提供了 MySQL 类型与  JDBC 类型、Java 类型的映射关系：</p>
<p><img src="/img/java/jdbc/mysql-types.png" alt="JDBC Types Mapped to Database-specific SQL Types"></p>
<h2 id="基本-JDBC-类型"><a href="#基本-JDBC-类型" class="headerlink" title="基本 JDBC 类型"></a>基本 JDBC 类型</h2><table>
<thead>
<tr>
<th>Java 类型</th>
<th>SQL 数据类型</th>
</tr>
</thead>
<tbody><tr>
<td><code>byte[]</code></td>
<td><code>BINARY</code>、<code>VARBINARY</code>、<code>LONGVARBINARY</code></td>
</tr>
<tr>
<td><code>String</code></td>
<td><code>CHAR</code>，<code>VARCHAR</code>、<code>LONGVARCHAR</code></td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>BIT</code></td>
</tr>
<tr>
<td><code>byte</code></td>
<td><code>TINYINT</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>SMALLINT</code></td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>INTEGER</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>BIGINT</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>REAL</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>FLOAT</code>、<code>DOUBLE</code></td>
</tr>
<tr>
<td><code>java.math.BigDecimal</code></td>
<td><code>NUMERIC</code>、<code>DECIMAL</code></td>
</tr>
<tr>
<td><code>java.sql.Date</code></td>
<td><code>DATE</code></td>
</tr>
<tr>
<td><code>java.sql.Time</code></td>
<td><code>TIME</code></td>
</tr>
<tr>
<td><code>java.sql.Timestamp</code></td>
<td><code>TIMESTAMP</code></td>
</tr>
</tbody></table>
<h2 id="高级-JDBC-类型"><a href="#高级-JDBC-类型" class="headerlink" title="高级 JDBC 类型"></a>高级 JDBC 类型</h2><p>SQL 标准后续引入的数据类型，包括 <code>BLOB</code>， <code>CLOB</code>，<code>ARRAY</code>，<code>REF</code> 等等：</p>
<table>
<thead>
<tr>
<th>Java 类型</th>
<th>SQL 数据类型</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>java.sql.Array</code></td>
<td><code>ARRAY</code></td>
<td>JDBC API 1.2 引入</td>
</tr>
<tr>
<td><code>java.sql.Blob</code></td>
<td><code>BLOB</code></td>
<td>JDBC API 1.2 引入</td>
</tr>
<tr>
<td><code>java.sql.Clob</code></td>
<td><code>CLOB</code></td>
<td>JDBC API 1.2 引入</td>
</tr>
<tr>
<td><code>java.sql.NClob</code></td>
<td><code>NCLOB</code></td>
<td>JDBC API 1.6 引入</td>
</tr>
<tr>
<td><code>java.sql.Ref</code></td>
<td><code>REF</code></td>
<td>JDBC API 1.2 引入</td>
</tr>
<tr>
<td><code>java.sql.RowId</code></td>
<td><code>ROWID</code></td>
<td>JDBC API 1.6 引入</td>
</tr>
<tr>
<td><code>java.sql.Struct</code></td>
<td><code>STRUCT</code></td>
<td>JDBC API 1.2 引入</td>
</tr>
<tr>
<td><code>java.sql.SQLXML</code></td>
<td><code>XML</code></td>
<td>JDBC API 1.6 引入</td>
</tr>
</tbody></table>
<h1 id="数据访问-API"><a href="#数据访问-API" class="headerlink" title="数据访问 API"></a>数据访问 API</h1><p>为了在数据库和 Java 应用程序之间传输数据，JDBC API 提供了三组方法：</p>
<ul>
<li><code>ResultSet</code> 类提供的用于将 <code>SELECT</code> 检索结果转换为 Java 类型的方法；</li>
<li><code>PreparedStatement</code> 类提供的用于将 Java 类型作为 SQL 语句参数发送的方法；</li>
<li><code>CallableStatement</code>类提供的用于将 <code>OUT</code> 参数转换为 Java 类型的方法。</li>
</ul>
<h2 id="静态数据访问"><a href="#静态数据访问" class="headerlink" title="静态数据访问"></a>静态数据访问</h2><h3 id="标准映射"><a href="#标准映射" class="headerlink" title="标准映射"></a>标准映射</h3><p>Java 程序从数据库中检索数据时，都必然会有某种形式的数据映射和数据转换。大多数情况下，JDBC 开发是知道目标数据库的 schema 的，例如表结构及其每列的数据类型。因此，JDBC 开发可以使用 <code>ResultSet</code>、<code>PreparedStatement</code>、<code>CallableStatement</code> 接口的强类型访问方法进行类型转换，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PreparedStatement 接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBoolean</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">boolean</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setByte</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">byte</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setShort</span><span class="params">(<span class="keyword">int</span> <span class="keyword">short</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLong</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">long</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDouble</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBigDecimal</span><span class="params">(<span class="keyword">int</span>, BigDecimal)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setString</span><span class="params">(<span class="keyword">int</span>, String)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">byte</span>[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDate</span><span class="params">(<span class="keyword">int</span>, Date)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span>, Time)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTimestamp</span><span class="params">(<span class="keyword">int</span>, Timestamp)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBinaryStream</span><span class="params">(<span class="keyword">int</span>, InputStream)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharacterStream</span><span class="params">(<span class="keyword">int</span>, Reader)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setRef</span><span class="params">(<span class="keyword">int</span>, Ref)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBlob</span><span class="params">(<span class="keyword">int</span>, Blob)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setClob</span><span class="params">(<span class="keyword">int</span>, Clob)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">int</span>, Array)</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ResultSet 接口</span></span></span><br><span class="line"><span class="function">Object <span class="title">getObject</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">getShort</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLong</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">getBigDecimal</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">String <span class="title">getString</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">byte</span>[] <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Date <span class="title">getDate</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Time <span class="title">getTime</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Timestamp <span class="title">getTimestamp</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">InputStream <span class="title">getBinaryStream</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Reader <span class="title">getCharacterStream</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Ref <span class="title">getRef</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Blob <span class="title">getBlob</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Clob <span class="title">getClob</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Array <span class="title">getArray</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义映射"><a href="#自定义映射" class="headerlink" title="自定义映射"></a>自定义映射</h3><p>自定义映射（SQL user-defined type (UDT) 到 Java 类）使用如下接口：</p>
<ul>
<li><code>java.sql.SQLData</code> 接口</li>
<li><code>java.sql.SQLInput</code> 接口</li>
<li><code>java.sql.SQLOutput</code> 接口</li>
</ul>
<h2 id="动态数据访问"><a href="#动态数据访问" class="headerlink" title="动态数据访问"></a>动态数据访问</h2><p>在大多数情况下，用户都希望访问在编译期数据类型已知的结果或参数。但是某些情况下，应用程序在编译期无法获知它们访问的目标数据库的 schema。因此，除了静态的数据类型访问之外，JDBC 还提供了对动态的数据类型访问的支持。</p>
<p>有三种方法可以方便地访问在编译期数据类型未知的值，使用所有 Java 对象的共同父类 <code>Object</code> 类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ResultSet.getObject</span><br><span class="line">PreparedStatement.setObject</span><br><span class="line">CallableStatement.getObject</span><br></pre></td></tr></table></figure>

<p><code>boolean</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code> 八种基本数据类型将返回其对应的包装类型，其它的则返回对应的类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(url)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement stmt = conn.prepareStatement(<span class="string">"SELECT * FROM test WHERE name = ?;"</span>)) &#123;</span><br><span class="line">        stmt.setObject(<span class="number">1</span>, <span class="string">"李四"</span>, JDBCType.VARCHAR);</span><br><span class="line">        <span class="keyword">try</span> (ResultSet rs = stmt.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                Object id = rs.getObject(<span class="string">"id"</span>);</span><br><span class="line">                String name = rs.getObject(<span class="string">"name"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                log.info(<span class="string">"Result is &#123;&#125;, &#123;&#125;"</span>, id <span class="keyword">instanceof</span> Long, name);  <span class="comment">// Result is true, 李四</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.oracle.com/javase/6/docs/technotes/guides/jdbc/getstart/mapping.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/6/docs/technotes/guides/jdbc/getstart/mapping.html</a></p>
<p><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-type-conversions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-type-conversions.html</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/06/java-jdbc-api/" class="post-title-link">Java 数据持久化系列（二）JDBC API 规范总结</a></h2><div class="post-info">2018-02-06<a href="/tags/Java/" title="Java" class="post-demo">Java</a></div><div class="post-content"><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>首先，来总览下 JDBC API：</p>
<p><img src="/img/java/jdbc/jdbc-api.png" alt="JDBC"></p>
<h1 id="JDBC-API-规范"><a href="#JDBC-API-规范" class="headerlink" title="JDBC API 规范"></a>JDBC API 规范</h1><p>JDBC API 作为 Java SE™（Java 标准版）的一部分，由以下部分组成：</p>
<ul>
<li><p>JDBC 核心 API —— <code>java.sql</code> package。</p>
</li>
<li><p>JDBC 可选 API —— <code>javax.sql</code> package，是 Java EE™（Java 企业版）的重要组成部分。</p>
</li>
</ul>
<p>其中，<code>java.sql</code> package 包含下列 API：</p>
<ul>
<li><p>通过 <code>java.sql.DriverManager</code> 与数据库建立连接</p>
<ul>
<li><code>java.sql.DriverManager</code> 类 - 用于与驱动程序建立连接</li>
<li><code>java.sql.SQLPermission</code> 类</li>
<li><code>java.sql.Driver</code> 接口 - 提供用于注册和连接驱动程序的 API。</li>
<li><code>java.sql.DriverPropertyInfo</code> 类 - 提供 JDBC 驱动程序的属性。</li>
</ul>
</li>
<li><p>发送 SQL 语句到数据库</p>
<ul>
<li><code>java.sql.Connection</code> 接口 - 提供创建语句、管理连接及其属性的方法</li>
<li><code>java.sql.Statement</code> 接口 - 用于发送基本的 SQL 语句</li>
<li><code>java.sql.PreparedStatement</code> 接口 - 用于发送预编译语句或基本 SQL 语句（继承自<code>Statement</code>）</li>
<li><code>java.sql.CallableStatement</code> 接口 - 用于调用数据库存储过程（继承自<code>PreparedStatement</code>）</li>
<li><code>java.sql.Savepoint</code> 接口 - 在事务中提供保存点</li>
</ul>
</li>
<li><p>检索和更新查询结果</p>
<ul>
<li><code>java.sql.ResultSet</code> 接口</li>
</ul>
</li>
<li><p>标准映射（SQL 数据类型到 Java 类或接口）</p>
</li>
<li><p>自定义映射（SQL user-defined type (UDT) 到 Java 类）</p>
</li>
<li><p>元数据</p>
<ul>
<li><code>java.sql.DatabaseMetaData</code> 接口 - 提供有关数据库的信息</li>
<li><code>java.sql.ResultSetMetaData</code> 接口 - 提供有关 <code>ResultSet</code> 对象的列信息</li>
<li><code>java.sql.ParameterMetaData</code> 接口 - 提供有关 <code>PreparedStatement</code> 命令的参数信息</li>
</ul>
</li>
<li><p>异常</p>
<ul>
<li><code>java.sql.SQLException</code> 类 - 被大多数方法抛出，当数据访问出现问题或出于其它原因</li>
<li><code>java.sql.SQLWarning</code> 类 - 抛出表示警告</li>
<li><code>java.sql.DataTruncation</code> 类 - 抛出表示数据可能已被截断</li>
<li><code>java.sql.BatchUpdateException</code> 类 - 抛出表示批量更新中的部分命令未执行成功</li>
</ul>
</li>
</ul>
<p>下面重点看下常用的接口和类。</p>
<h2 id="DriverManager-类"><a href="#DriverManager-类" class="headerlink" title="DriverManager 类"></a>DriverManager 类</h2><p><code>java.sql.DriverManager</code> 类充当用户和驱动程序之间的接口。它跟踪可用的驱动程序并处理数据库与相应驱动程序之间的连接。<code>DriverManager</code> 类维护了一个通过调用 <code>DriverManager.registerDriver()</code> 方法来注册自己的 <code>java.sql.Driver</code> 类列表。</p>
<p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(Driver driver)</span> <span class="comment">// 用于通过 `DriverManager` 注册给定的驱动程序。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deregisterDriver</span><span class="params">(Driver driver)</span>  <span class="comment">// 用于从 `DriverManager` 取消注册给定的驱动程序（从列表中删除驱动程序）。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url)</span>  <span class="comment">// 用于与指定的 URL 建立连接。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url, String userName, String password)</span>  <span class="comment">// 用于与指定的 URL 建立连接，通过用户名和密码。</span></span></span><br></pre></td></tr></table></figure>

<p>关于 Driver 驱动程序注册，详见《<a href="/2019/01/23/java-jdbc-driver/">注册驱动程序</a>》。</p>
<h2 id="Connection-接口"><a href="#Connection-接口" class="headerlink" title="Connection 接口"></a>Connection 接口</h2><p><code>java.sql.Connection</code> 接口表示 Java 应用程序和数据库之间的会话（Session），它提供了许多事务管理方法如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">boolean</span> status)</span>  <span class="comment">// 修改当前 `Connection` 对象的事务自动提交模式。默认为 `true`。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setReadOnly</span><span class="params">(<span class="keyword">boolean</span> readOnly)</span>  <span class="comment">// 修改当前 `Connection` 对象的只读状态以提示驱动程序开启数据库优化。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTransactionIsolation</span><span class="params">(<span class="keyword">int</span> level)</span>  <span class="comment">// 修改当前 `Connection` 对象的事务隔离级别。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span>  <span class="comment">// 保存自上次提交/回滚以来所做的所有更改。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span>  <span class="comment">// 丢弃自上次提交/回滚以来所做的所有更改。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 在当前事务中设置或移除保存点。</span></span></span><br><span class="line"><span class="function">Savepoint <span class="title">setSavepoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Savepoint <span class="title">setSavepoint</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseSavepoint</span><span class="params">(Savepoint savepoint)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>  <span class="comment">// 关闭连接并立即释放 JDBC 资源。</span></span></span><br></pre></td></tr></table></figure>

<p><code>Connection</code> 接口同时也是一个工厂类，用于获取 <code>Statement</code>、<code>PreparedStatement</code> 和 <code>DatabaseMetaData</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Statement <span class="title">createStatement</span><span class="params">(...)</span>  <span class="comment">// 创建一个可用于执行 SQL 查询或更新的语句对象。</span></span></span><br><span class="line"><span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(...)</span>  <span class="comment">// 创建一个可用于执行 SQL 参数化查询或更新的语句对象。</span></span></span><br><span class="line"><span class="function">CallableStatement <span class="title">prepareCall</span><span class="params">(...)</span>  <span class="comment">// 用于调用存储过程和函数。</span></span></span><br><span class="line"><span class="function">DatabaseMetaData <span class="title">getMetaData</span><span class="params">()</span>  <span class="comment">// 用于获取数据库的元数据，例如数据库产品名称，数据库产品版本，驱动程序名称，表总数名称，总视图名称等。</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Statement-接口"><a href="#Statement-接口" class="headerlink" title="Statement 接口"></a>Statement 接口</h2><p><code>java.sql.Statement</code> 接口提供用于执行数据库查询与更新的方法。<code>Statement</code>  接口是 <code>ResultSet</code> 的工厂，即它提供工厂方法来获取 <code>ResultSet</code> 的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span>  <span class="comment">// 用于执行 `SELECT` 查询并返回 `ResultSet` 的对象。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span>  <span class="comment">// 用于执行指定的更新，如 `create`，`drop`，`insert`，`update`，`delete` 等。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String sql)</span>  <span class="comment">// 用于执行可能返回多种结果的查询。</span></span></span><br></pre></td></tr></table></figure>

<p>除了通过上述方法来执行单个查询或更新，还可以通过下列方法执行批量命令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addBatch</span><span class="params">(String sql)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBatch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>[] <span class="title">executeBatch</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>使用批量命令前，记得先使用 <code>setAutoCommit()</code> 将事务的自动提交模式设置为 <code>false</code> 。</p>
<p>批处理允许您将相关的 SQL 语句分组到批处理中，并通过一次调用数据库来提交它们。当您一次性向数据库发送多个 SQL 语句时，可以减少通信开销，从而提高性能。参考：<a href="https://www.tutorialspoint.com/jdbc/jdbc-batch-processing.htm" target="_blank" rel="noopener">JDBC - Batch Processing</a>。</p>
<h2 id="PreparedStatement-接口"><a href="#PreparedStatement-接口" class="headerlink" title="PreparedStatement 接口"></a>PreparedStatement 接口</h2><p><code>java.sql.PreparedStatement</code> 接口是 <code>java.sql.Statement</code> 的子接口。它用于执行参数化查询（parameterized query），例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement stmt = connection.prepareStatement("<span class="keyword">insert</span> <span class="keyword">into</span> emp <span class="keyword">values</span>(?, ?, ?)<span class="string">");</span></span><br></pre></td></tr></table></figure>

<p>为什么要使用 <code>PreparedStatement</code>？</p>
<ul>
<li><strong>提升性能</strong>：应用程序的性能会更快，因为 SQL 语句只会编译一次。</li>
<li><strong>提升安全</strong></li>
</ul>
<p>创建预编译的参数化查询语句后，需要通过 <code>setXxx</code> 方法设置对应参数。参数设置完毕后，就可以通过下列方法执行 SQL 语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ResultSet <span class="title">executeQuery</span><span class="params">()</span>  <span class="comment">// 用于执行 `SELECT` 查询并返回 `ResultSet` 的对象。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span>  <span class="comment">// 用于执行指定的更新，如 `create`，`drop`，`insert`，`update`，`delete` 等。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span>  <span class="comment">// 用于执行可能返回多种结果的查询。</span></span></span><br></pre></td></tr></table></figure>

<p><code>PreparedStatement</code> 还提供了批处理方式，减少网络请求，提升性能，API 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a set of parameters to this &lt;code&gt;PreparedStatement&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * object's batch of commands.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> SQLException if a database access error occurs or</span></span><br><span class="line"><span class="comment"> * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Statement#addBatch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addBatch</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement ps = conn.prepareStatement(<span class="string">"INSERT into employees values (?, ?, ?)"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">100</span>; n++) &#123;</span><br><span class="line">    ps.setString(name[n]);</span><br><span class="line">    ps.setLong(id[n]);</span><br><span class="line">    ps.setInt(salary[n]);</span><br><span class="line">    <span class="comment">// 多次执行PreparedStatement，多次数据库请求（网络请求）</span></span><br><span class="line">    ps.executeUpdate();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用批处理方法，一次性执行多条 SQL：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement ps = conn.prepareStatement(<span class="string">"INSERT into employees values (?, ?, ?)"</span>);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">100</span>; n++) &#123;</span><br><span class="line">    ps.setString(name[n]);</span><br><span class="line">    ps.setLong(id[n]);</span><br><span class="line">    ps.setInt(salary[n]);</span><br><span class="line">    <span class="comment">// 添加批次</span></span><br><span class="line">    ps.addBatch();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用父接口 Statement#executeBatch() 执行批次</span></span><br><span class="line">ps.executeBatch();</span><br></pre></td></tr></table></figure>

<h2 id="ResultSet-接口"><a href="#ResultSet-接口" class="headerlink" title="ResultSet 接口"></a>ResultSet 接口</h2><p><code>java.sql.ResultSet</code> 对象维护了一个指向 table 行的游标。游标初始值指向第 0 行。默认情况下，<code>ResultSet</code> 对象只能向前移动，并且不可更新。可以通过在 <code>createStatement(int, int)</code> 方法中传递指定参数修改该默认行为。</p>
<p>可以通过以下方法操作游标：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span>  <span class="comment">// 将游标移动到当前位置的下一行。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">previous</span><span class="params">()</span>  <span class="comment">// 将游标移动到当前位置之前的一行。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">first</span><span class="params">()</span>  <span class="comment">// 将游标移动到结果集的第一行。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">last</span><span class="params">()</span>  <span class="comment">// 将游标移动到结果集的最后一行。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">absolute</span><span class="params">(<span class="keyword">int</span> row)</span>  <span class="comment">// 将游标移动到结果集的指定行号。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">relative</span><span class="params">(<span class="keyword">int</span> row)</span>  <span class="comment">// 将游标移动到结果集的相对行号，它可以是正数或负数。</span></span></span><br></pre></td></tr></table></figure>

<p>将游标移动到指定行之后，可以通过 <code>getXxx</code> 方法获取当前行的指定列的数据。</p>
<p>此外，还可以直接获取 table 的元数据，例如列的总数，列名，列类型等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ResultSetMetaData <span class="title">getMetaData</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<h2 id="ResultSetMetaData-接口"><a href="#ResultSetMetaData-接口" class="headerlink" title="ResultSetMetaData 接口"></a>ResultSetMetaData 接口</h2><p><code>java.sql.ResultSetMetaData</code> 用于获取 table 的元数据，例如列的总数，列名，列类型等。</p>
<h2 id="DatabaseMetaData-接口"><a href="#DatabaseMetaData-接口" class="headerlink" title="DatabaseMetaData 接口"></a>DatabaseMetaData 接口</h2><p><code>java.sql.DatabaseMetaData</code> 用于获取数据库的元数据，例如数据库产品名称，数据库产品版本，驱动程序名称，表总数名称，总视图名称等。</p>
<h2 id="RowSet-接口"><a href="#RowSet-接口" class="headerlink" title="RowSet 接口"></a>RowSet 接口</h2><p><code>javax.sql.RowSet</code> 继承自 <code>java.sql.ResultSet</code>，是其包装器类。它包含类似 <code>ResultSet</code> 的表格数据，但使用起来非常简单灵活。其实现类如下：</p>
<p><img src="/img/java/jdbc/rowset.jpg" alt="RowSet"></p>
<p>下面是一个不含事件处理代码的 <code>JdbcRowSet</code> 的简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (JdbcRowSet rowSet = RowSetProvider.newFactory().createJdbcRowSet()) &#123;</span><br><span class="line">    rowSet.setUrl(url);</span><br><span class="line">    rowSet.setCommand(<span class="string">"SELECT * FROM test"</span>);</span><br><span class="line">    rowSet.execute();</span><br><span class="line">    <span class="keyword">while</span> (rowSet.next()) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = rowSet.getInt(<span class="string">"id"</span>);</span><br><span class="line">        String name = rowSet.getString(<span class="string">"name"</span>);</span><br><span class="line">        log.info(<span class="string">"Result is &#123;&#125; &#123;&#125;"</span>, id, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比下面传统的 JDBC API，代码更加直观，需要直接管理的资源也更少：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(url)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (Statement stmt = conn.createStatement()) &#123;</span><br><span class="line">        <span class="keyword">try</span> (ResultSet rs = stmt.executeQuery(<span class="string">"SELECT * FROM test"</span>)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">                log.info(<span class="string">"Result is &#123;&#125;, &#123;&#125;"</span>, id, name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要使用 <code>JdbcRowSet</code> 执行事件处理，需要在 <code>JdbcRowSet</code> 的 <code>addRowSetListener</code> 方法中添加 <code>RowSetListener</code> 的实例。<code>RowSetListener</code> 接口提供了必须实现的三个方法，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cursorMoved</span><span class="params">(RowSetEvent event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rowChanged</span><span class="params">(RowSetEvent event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rowSetChanged</span><span class="params">(RowSetEvent event)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="DataSource-接口"><a href="#DataSource-接口" class="headerlink" title="DataSource 接口"></a>DataSource 接口</h2><h1 id="JDBC-API-示例"><a href="#JDBC-API-示例" class="headerlink" title="JDBC API 示例"></a>JDBC API 示例</h1><p>JDBC API 的使用步骤如下：</p>
<p><img src="/img/java/jdbc/steps-to-connect-to-the-database-in-java.jpg" alt="JDBC 使用步骤"></p>
<p>其中：</p>
<ol>
<li>步骤一：JDBC API 从 4.0 开始利用 Java SPI 机制自动加载驱动程序，可以省略该步骤。</li>
<li>步骤二、三：如果使用如 Spring <code>JdbcTempate</code>、MyBatis 等框架，可以省略该步骤。</li>
<li>步骤五：使用 <code>try-with-resources</code> 语句，可以省略该步骤。</li>
</ol>
<p>下面来两个示例：</p>
<h2 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h2><p>下例通过 <code>PreparedStatement</code> 接口的 <code>setBinaryStream()</code> 方法将图片（二进制信息）存储到数据库中。为了将图片存储到数据库中，需要在表中使用 <code>BLOB</code>（Binary Large Object）数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(url)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement stmt = conn.prepareStatement(<span class="string">"INSERT INTO test(title, photo) VALUES(?, ?)"</span>)) &#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"F:\\test.jpg"</span>);</span><br><span class="line">        stmt.setString(<span class="number">1</span>, <span class="string">"pic1"</span>);</span><br><span class="line">        stmt.setBinaryStream(<span class="number">2</span>, fileInputStream);</span><br><span class="line">        assertTrue(<span class="number">1</span> == stmt.executeUpdate());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这只是一个例子，生产环境中是不会将这类二进制信息存储到数据库中的，而是存储到专门的文件系统，以提升性能，并节省宝贵的数据库资源 :)</p>
<h2 id="检索图片"><a href="#检索图片" class="headerlink" title="检索图片"></a>检索图片</h2><p>Using <code>try-with-resources</code> Statements to Automatically Close JDBC Resources: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(url)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement stmt = conn.prepareStatement(<span class="string">"SELECT title, photo FROM test"</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> (ResultSet rs = stmt.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                String title = rs.getString(<span class="number">1</span>);</span><br><span class="line">                log.info(<span class="string">"title is &#123;&#125;"</span>, title);</span><br><span class="line"></span><br><span class="line">                Blob photo = rs.getBlob(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = photo.getBytes(<span class="number">1</span>, (<span class="keyword">int</span>) photo.length());</span><br><span class="line">                String fileName = String.format(<span class="string">"F:\\%s.png"</span>, title);</span><br><span class="line">                <span class="keyword">try</span> (FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(fileName)) &#123;</span><br><span class="line">                    fileOutputStream.write(bytes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDBC 4.1 (Java SE 7) introduces the ability to use a <code>try-with-resources</code> statement to automatically close <code>java.sql.Connection</code>, <code>java.sql.Statement</code>, and <code>java.sql.ResultSet</code> objects, regardless of whether a <code>SQLException</code> or any other exception has been thrown. See <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/try-with-resources.html" target="_blank" rel="noopener">The try-with-resources Statement</a> for more information.</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://docs.oracle.com/javase/6/docs/technotes/guides/jdbc/getstart/GettingStartedTOC.fm.html" target="_blank" rel="noopener">Getting Started with the JDBC API</a>》</p>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/jdbc_41.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/jdbc_41.html</a></p>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/jdbc_42.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/jdbc_42.html</a></p>
<p><a href="https://docs.oracle.com/javase/9/docs/api/java/sql/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/9/docs/api/java/sql/package-summary.html</a></p>
<p><a href="https://www.javatpoint.com/java-jdbc" target="_blank" rel="noopener">https://www.javatpoint.com/java-jdbc</a></p>
<p><a href="https://www.tutorialspoint.com/jdbc/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/jdbc/index.htm</a></p>
<p><a href="https://www.tutorialspoint.com/dbutils/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/dbutils/index.htm</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/03/java-jdbc-driver/" class="post-title-link">Java 数据持久化系列（一）JDBC Driver 驱动程序总结</a></h2><div class="post-info">2018-02-03<a href="/tags/Java/" title="Java" class="post-demo">Java</a></div><div class="post-content"><h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img src="/img/java/jdbc/jdbc-driver.png" alt="JDBC Driver"></p>
<h1 id="什么是-JDBC？"><a href="#什么是-JDBC？" class="headerlink" title="什么是 JDBC？"></a>什么是 JDBC？</h1><p>JDBC 表示 Java Database Connectivity，是 JavaSE（Java 标准版）的一部分，。JDBC API 用于在 Java 应用程序中执行以下活动：</p>
<ol>
<li>连接到数据库</li>
<li>执行查询并将语句更新到数据库</li>
<li>检索从数据库收到的结果</li>
</ol>
<p><img src="/img/java/jdbc/usage-of-jdbc.png" alt="JDBC API"></p>
<h1 id="为什么要使用-JDBC？"><a href="#为什么要使用-JDBC？" class="headerlink" title="为什么要使用 JDBC？"></a>为什么要使用 JDBC？</h1><p>在 JDBC 之前，ODBC API 是用于连接和执行命令的数据库 API 标准。但是，ODBC API 是使用 C 语言编写的驱动程序，依赖于平台。这就是为什么 Java 定义了自己的 JDBC API，它使用的 JDBC 驱动程序，是用 Java 语言编写的，具有与平台无关的特性，支持跨平台部署，性能也较好。</p>
<h1 id="什么是-JDBC-驱动程序？"><a href="#什么是-JDBC-驱动程序？" class="headerlink" title="什么是 JDBC 驱动程序？"></a>什么是 JDBC 驱动程序？</h1><p>由于 JDBC API 只是一套接口规范，因此要使用 JDBC API 操作数据库，首先需要选择合适的驱动程序：</p>
<h2 id="驱动程序四种类型"><a href="#驱动程序四种类型" class="headerlink" title="驱动程序四种类型"></a>驱动程序四种类型</h2><p>有四种类型的 JDBC 驱动程序：</p>
<ol>
<li>JDBC-ODBC bridge driver (<del>In Java 8, the JDBC-ODBC Bridge has been removed.</del>)</li>
<li>Native-API driver (partially java driver)</li>
<li>Network-Protocol driver (Middleware driver, fully java driver)</li>
<li><strong>Database-Protocol driver (Thin driver, fully java driver)</strong>，目前最常用的驱动类型，日常开发中使用的驱动 jar 包基本都属于这种类型，通常由数据库厂商直接提供，例如 <code>mysql-connector-java</code>。驱动程序把 JDBC 调用直接转换为数据库特定的网络协议，因此性能更好。驱动程序纯 Java 实现，支持跨平台部署。</li>
</ol>
<blockquote>
<p>我们知道，ODBC几乎能在所有平台上连接几乎所有的数据库。为什么 Java 不使用 ODBC？</p>
<p>答案是：Java 可以使用 ODBC，但最好是以JDBC-ODBC桥的形式使用（Java连接总体分为Java直连和JDBC-ODBC桥两种形式）。</p>
<p>那为什么还需要 JDBC？</p>
<p>因为ODBC 不适合直接在 Java 中使用，因为它使用 C 语言接口。从Java 调用本地 C代码在安全性、实现、坚固性和程序的自动移植性方面都有许多缺点。从 ODBC C API 到 Java API 的字面翻译是不可取的。例如，Java 没有指针，而 ODBC 却对指针用得很广泛（包括很容易出错的指针”void *”）。</p>
<p>另外，ODBC 比较复杂，而JDBC 尽量保证简单功能的简便性，同时在必要时允许使用高级功能。如果使用ODBC，就必须手动地将 ODBC 驱动程序管理器和驱动程序安装在每台客户机上。如果完全用 Java 编写 JDBC 驱动程序则 JDBC代码在所有 Java 平台上（从网络计算机到大型机）都可以自 动安装、移植并保证安全性。</p>
<p>总之，JDBC 在很大程度上是借鉴了ODBC的，从他的基础上发展而来。JDBC 保留了 ODBC 的基本设计特征，因此，熟悉 ODBC 的程序员将发现 JDBC 很容易使用。它们之间最大的区别在于：JDBC 以 Java 风格与优点为基础并进行优化，因此更加易于使用。</p>
</blockquote>
<p>各类型的优缺点详见：</p>
<p><a href="https://en.wikipedia.org/wiki/JDBC_driver" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/JDBC_driver</a></p>
<p><a href="https://www.javatpoint.com/jdbc-driver" target="_blank" rel="noopener">https://www.javatpoint.com/jdbc-driver</a></p>
<p><a href="https://blog.csdn.net/autfish/article/details/52170053" target="_blank" rel="noopener">https://blog.csdn.net/autfish/article/details/52170053</a></p>
<h2 id="驱动程序厂商实现"><a href="#驱动程序厂商实现" class="headerlink" title="驱动程序厂商实现"></a>驱动程序厂商实现</h2><p>如果选定使用推荐的第四种驱动程序类型，接下来需要下载对应厂商的驱动程序，目前提供这些<a href="https://www.oracle.com/technetwork/java/index-136695.html" target="_blank" rel="noopener">支持列表</a>。</p>
<p>例如最常用的 MySQL 数据库，提供了 <a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">MySQL Connector/J</a>（即 <code>mysql-connector-java</code>）。Maven 依赖配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MySQL 驱动程序的更多信息，例如：</p>
<ul>
<li>驱动程序/数据源类名</li>
<li>连接 URL 语法</li>
<li>配置属性</li>
<li>JDBC API 实现说明</li>
<li>Java，JDBC 和 MySQL 类型</li>
<li>使用字符集和 Unicode</li>
<li>各种连接方式（如 SSL 安全连接）</li>
<li>MySQL 错误码与 JDBC SQLState 代码的映射关系</li>
<li>……</li>
</ul>
<p>详见：<a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-overview.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-overview.html</a></p>
<h1 id="注册驱动程序源码分析"><a href="#注册驱动程序源码分析" class="headerlink" title="注册驱动程序源码分析"></a>注册驱动程序源码分析</h1><p>有几种方式可以注册驱动程序，如下：</p>
<h2 id="手工注册"><a href="#手工注册" class="headerlink" title="手工注册"></a>手工注册</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);  <span class="comment">// 方式一，底层实现其实就是方式二</span></span><br><span class="line">DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());  <span class="comment">// 方式二</span></span><br><span class="line">System.setProperty(<span class="string">"jdbc.drivers"</span>, <span class="string">"com.mysql.jdbc.Driver"</span>);  <span class="comment">// 方式三</span></span><br></pre></td></tr></table></figure>

<h2 id="自动注册"><a href="#自动注册" class="headerlink" title="自动注册"></a>自动注册</h2><p>从 JDBC API 4.0 开始，<code>java.sql.DriverManager</code> 类得到了增强，利用 <strong>Java SPI 机制</strong>从厂商驱动程序的 <code>META-INF/services/java.sql.Driver</code> 文件中自动加载 <code>java.sql.Driver</code> 实现类。 因此应用程序无需再显式调用 <code>Class.forName</code> 或 <code>DriverManager.registerDriver</code> 方法来注册或加载驱动程序。<code>java.sql.DriverManager</code> 源码分析如下，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Load the initial JDBC drivers by checking the System property</span></span><br><span class="line"><span class="comment">     * jdbc.properties and then use the &#123;<span class="doctag">@code</span> ServiceLoader&#125; mechanism</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        loadInitialDrivers();</span><br><span class="line">        println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String drivers;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            drivers = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> System.getProperty(<span class="string">"jdbc.drivers"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            drivers = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If the driver is packaged as a Service Provider, load it.</span></span><br><span class="line">        <span class="comment">// Get all the drivers through the classloader</span></span><br><span class="line">        <span class="comment">// exposed as a java.sql.Driver.class service.</span></span><br><span class="line">        <span class="comment">// ServiceLoader.load() replaces the sun.misc.Providers()</span></span><br><span class="line"></span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Load these drivers, so that they can be instantiated.</span></span><br><span class="line"><span class="comment">                 * It may be the case that the driver class may not be there</span></span><br><span class="line"><span class="comment">                 * i.e. there may be a packaged driver with the service class</span></span><br><span class="line"><span class="comment">                 * as implementation of java.sql.Driver but the actual class</span></span><br><span class="line"><span class="comment">                 * may be missing. In that case a java.util.ServiceConfigurationError</span></span><br><span class="line"><span class="comment">                 * will be thrown at runtime by the VM trying to locate</span></span><br><span class="line"><span class="comment">                 * and load the service.</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * Adding a try catch block to catch those runtime errors</span></span><br><span class="line"><span class="comment">                 * if driver not available in classpath but it's</span></span><br><span class="line"><span class="comment">                 * packaged as service and that service is there in classpath.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                        driversIterator.next();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">                <span class="comment">// Do nothing</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"DriverManager.initialize: jdbc.drivers = "</span> + drivers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drivers == <span class="keyword">null</span> || drivers.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] driversList = drivers.split(<span class="string">":"</span>);</span><br><span class="line">        println(<span class="string">"number of Drivers:"</span> + driversList.length);</span><br><span class="line">        <span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">"DriverManager.Initialize: loading "</span> + aDriver);</span><br><span class="line">                Class.forName(aDriver, <span class="keyword">true</span>,</span><br><span class="line">                        ClassLoader.getSystemClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                println(<span class="string">"DriverManager.Initialize: load failed: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面源码中可见，当类加载器载入 <code>java.sql.DriverManager</code> 类时，会执行其静态代码块，从而执行 <code>loadInitialDrivers()</code> 方法。该方法实现中通过 Java SPI <code>ServiceLoader</code> 查找 classpath 下所有 jar 包内的 <code>META-INF/services</code> 目录，找到 <code>java.sql.Driver</code> 文件，加载其中定义的实现类并通过反射创建实例。以 <code>mysql-connector-java</code> 8.x 为例，该类定义就是 <code>com.mysql.cj.jdbc.Driver</code>，此时由于该 <code>Driver</code> 类内含静态代码块，会用 <code>new</code> 关键字创建自身实例并反向注册到 <code>DriverManager</code>，从而达到自动注册驱动程序的效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="JDBC-URL"><a href="#JDBC-URL" class="headerlink" title="JDBC URL"></a>JDBC URL</h1><p>驱动程序注册完毕之后，接下来是通过 JDBC URL 与数据源建立连接。</p>
<p>JDBC URL 提供了一种标识数据源的方法，以便相应的驱动程序识别它并与之建立连接。</p>
<p>JDBC URL 的标准语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:&lt;subprotocol&gt;:&lt;subname&gt;</span><br></pre></td></tr></table></figure>

<p>它有三个部分，用冒号分隔，分解如下：</p>
<ul>
<li><code>jdbc</code> - 协议。JDBC URL 中的协议始终是 <code>jdbc</code>。</li>
<li><code>&lt;subprotocol&gt;</code> - 驱动程序的名称（如 <code>mysql</code>）或数据库连接机制的名称（如 <code>odbc</code>），可由一个或多个驱动程序支持。</li>
<li><code>&lt;subname&gt;</code> - 数据源的名称。</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true;characterEncoding&#x3D;utf-8</span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>如果有多个不同的驱动程序都被注册，调用 <code>DriverManager.getConnection</code> 方法通过 JDBC URL 获取数据源连接时，会使用第一个可用的驱动程序来创建连接。源码分析如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/test?useUnicode=true;characterEncoding=utf-8"</span>)</span><br></pre></td></tr></table></figure>

<p><code>DriverManager</code> 会遍历已注册的驱动程序，尝试获取连接，关键代码：<code>Connection con = aDriver.driver.connect(url, info);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DriverManager 源码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">        <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">        <span class="comment">// skip it.</span></span><br><span class="line">        <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">"    trying "</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Success!</span></span><br><span class="line">                    println(<span class="string">"getConnection returning "</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="keyword">return</span> (con);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    reason = ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">"    skipping: "</span> + aDriver.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MySQL 驱动程序实现类会判断该 JDBC URL 是否支持：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.mysql.cj.jdbc.NonRegisteringDriver 源码，实现 java.sql.Driver 接口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> java.sql.<span class="function">Connection <span class="title">connect</span><span class="params">(String url, Properties info)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ConnectionUrl.acceptsUrl(url)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * According to JDBC spec:</span></span><br><span class="line"><span class="comment">             * The driver should return "null" if it realizes it is the wrong kind of driver to connect to the given URL. This will be common, as when the</span></span><br><span class="line"><span class="comment">             * JDBC driver manager is asked to connect to a given URL it passes the URL to each loaded driver in turn.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, info);</span><br><span class="line">        <span class="keyword">switch</span> (conStr.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> SINGLE_CONNECTION:</span><br><span class="line">                <span class="keyword">return</span> com.mysql.cj.jdbc.ConnectionImpl.getInstance(conStr.getMainHost());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> LOADBALANCE_CONNECTION:</span><br><span class="line">                <span class="keyword">return</span> LoadBalancedConnectionProxy.createProxyInstance((LoadbalanceConnectionUrl) conStr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> FAILOVER_CONNECTION:</span><br><span class="line">                <span class="keyword">return</span> FailoverConnectionProxy.createProxyInstance(conStr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> REPLICATION_CONNECTION:</span><br><span class="line">                <span class="keyword">return</span> ReplicationConnectionProxy.createProxyInstance((ReplicationConnectionUrl) conStr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedConnectionStringException e) &#123;</span><br><span class="line">        <span class="comment">// when Connector/J can't handle this connection string the Driver must return null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (CJException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.createException(UnableToConnectException<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">                  Messages.getString("NonRegisteringDriver.17", new Object[] &#123; ex.toString() &#125;), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>scheme 支持列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.mysql.cj.conf.Type 枚举源码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The database URL type which is determined by the scheme section of the connection string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;</span><br><span class="line">    SINGLE_CONNECTION(<span class="string">"jdbc:mysql:"</span>, HostsCardinality.SINGLE), <span class="comment">//</span></span><br><span class="line">    FAILOVER_CONNECTION(<span class="string">"jdbc:mysql:"</span>, HostsCardinality.MULTIPLE), <span class="comment">//</span></span><br><span class="line">    LOADBALANCE_CONNECTION(<span class="string">"jdbc:mysql:loadbalance:"</span>, HostsCardinality.ONE_OR_MORE), <span class="comment">//</span></span><br><span class="line">    REPLICATION_CONNECTION(<span class="string">"jdbc:mysql:replication:"</span>, HostsCardinality.ONE_OR_MORE), <span class="comment">//</span></span><br><span class="line">    XDEVAPI_SESSION(<span class="string">"mysqlx:"</span>, HostsCardinality.ONE_OR_MORE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String scheme;</span><br><span class="line">    <span class="keyword">private</span> HostsCardinality cardinality;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果该 JDBC URL 没有对应可用的驱动程序，程序将抛出异常：<code>java.sql.SQLException: No suitable driver found for jdbc:...</code>。</p>
<h2 id="常用列表"><a href="#常用列表" class="headerlink" title="常用列表"></a>常用列表</h2><p>常见的 JDBC URL 前缀及对应 Driver Class 如下：</p>
<p><img src="/img/java/jdbc/jdbc-url.png" alt=""></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/JDBC_driver" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/JDBC_driver</a></p>
<p><a href="https://www.javatpoint.com/jdbc-driver" target="_blank" rel="noopener">https://www.javatpoint.com/jdbc-driver</a></p>
<p><a href="https://blog.csdn.net/autfish/article/details/52170053" target="_blank" rel="noopener">https://blog.csdn.net/autfish/article/details/52170053</a></p>
<p><a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/connector/j/</a></p>
<p><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-overview.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-overview.html</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/02/02/mysql-select-syntax/" class="post-title-link">MySQL SELECT 语法总结</a></h2><div class="post-info">2018-02-02<a href="/tags/MySQL/" title="MySQL" class="post-demo">MySQL</a></div><div class="post-content"><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><p><code>SELECT</code> 基础语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    [ALL | DISTINCT]</span><br><span class="line">    select_expr [, select_expr ...]</span><br><span class="line">    [</span><br><span class="line">      FROM table_references</span><br><span class="line">      [WHERE where_condition]</span><br><span class="line">      [GROUP BY &#123;col_name | expr | position&#125;</span><br><span class="line">        [ASC | DESC], ... [WITH ROLLUP]]</span><br><span class="line">      [HAVING where_condition]</span><br><span class="line">      [ORDER BY &#123;col_name | expr | position&#125;</span><br><span class="line">        [ASC | DESC], ...]</span><br><span class="line">      [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;]</span><br><span class="line">      [</span><br><span class="line">        INTO OUTFILE &#39;file_name&#39;</span><br><span class="line">          [CHARACTER SET charset_name]</span><br><span class="line">          export_options</span><br><span class="line">        | INTO DUMPFILE &#39;file_name&#39;</span><br><span class="line">        | INTO var_name [, var_name]</span><br><span class="line">      ]</span><br><span class="line">      [FOR UPDATE | LOCK IN SHARE MODE]</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p><code>SELECT</code> 语句可用于检索单个、多个、所有列（星号 <code>*</code> 通配符）。每个 <em>select_expr</em> 表示您想要检索的列。必须至少有一个 <em>select_expr</em>。</p>
<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>修饰符 <code>ALL</code> 和 <code>DISTINCT</code> 用于指定<strong>重复行是否应该返回（是否去重）</strong>，作用于所有的列，而不仅仅是跟在其后的那一列。例如 <code>SELECT DISTINCT vend_id, prod_price</code> ，除非指定的两列完全相同，否则所有的行都会被检索出来。</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ALL</code></td>
<td>默认值，指定应返回所有匹配的行，包括重复项。</td>
</tr>
<tr>
<td><code>DISTINCT</code></td>
<td>指定从结果集中删除重复的行。</td>
</tr>
</tbody></table>
<h2 id="检索表"><a href="#检索表" class="headerlink" title="检索表"></a>检索表</h2><p><em>table_references</em> 指示检索表，其语法可参考 <a href="https://dev.mysql.com/doc/refman/5.7/en/join.html" target="_blank" rel="noopener">JOIN语法</a>。<code>SELECT</code> 也可以不使用 <code>FROM</code> 子句而用来检索计算出的行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1 + 1;</span><br><span class="line"> -&gt; 2</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>FROM DUAL</code> 指定虚拟表，MySQL 会忽略这个子句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1 + 1 FROM DUAL;</span><br><span class="line"> -&gt; 2</span><br></pre></td></tr></table></figure>

<h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><p><code>WHERE</code> 子句用于过滤数据，<em>where_condition</em> 可以使用以下表达式语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">expr:</span><br><span class="line">    expr OR expr</span><br><span class="line">  | expr || expr</span><br><span class="line">  | expr XOR expr</span><br><span class="line">  | expr AND expr</span><br><span class="line">  | expr &amp;&amp; expr</span><br><span class="line">  | NOT expr</span><br><span class="line">  | ! expr</span><br><span class="line">  | boolean_primary IS [NOT] &#123;TRUE | FALSE | UNKNOWN&#125;</span><br><span class="line">  | boolean_primary</span><br><span class="line"></span><br><span class="line">boolean_primary:</span><br><span class="line">    boolean_primary IS [NOT] NULL</span><br><span class="line">  | boolean_primary &lt;&#x3D;&gt; predicate</span><br><span class="line">  | boolean_primary comparison_operator predicate</span><br><span class="line">  | boolean_primary comparison_operator &#123;ALL | ANY&#125; (subquery)</span><br><span class="line">  | predicate</span><br><span class="line"></span><br><span class="line">comparison_operator: &#x3D; | &gt;&#x3D; | &gt; | &lt;&#x3D; | &lt; | &lt;&gt; | !&#x3D;</span><br><span class="line"></span><br><span class="line">predicate:</span><br><span class="line">    bit_expr [NOT] IN (subquery)</span><br><span class="line">  | bit_expr [NOT] IN (expr [, expr] ...)</span><br><span class="line">  | bit_expr [NOT] BETWEEN bit_expr AND predicate</span><br><span class="line">  | bit_expr SOUNDS LIKE bit_expr</span><br><span class="line">  | bit_expr [NOT] LIKE simple_expr [ESCAPE simple_expr]</span><br><span class="line">  | bit_expr [NOT] REGEXP bit_expr</span><br><span class="line">  | bit_expr</span><br><span class="line"></span><br><span class="line">bit_expr:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">simple_expr:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p><code>LIKE</code> 可使用以下通配符：</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>%</code></td>
<td>匹配多个字符</td>
</tr>
<tr>
<td><code>_</code></td>
<td>匹配单个字符</td>
</tr>
<tr>
<td><code>[]</code></td>
<td>匹配一个字符集</td>
</tr>
</tbody></table>
<h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h2><p><code>ORDER BY</code> 子句用于排序，使用以下关键字进行升序或降序排序，要注意关键字只应用于直接位于其前面的列名。如果想在多个列上进行降序排序，必须对每一列指定 <code>DESC</code> 关键字。</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>ASC</code></td>
<td>升序排序（默认）</td>
</tr>
<tr>
<td><code>DESC</code></td>
<td>降序排序</td>
</tr>
</tbody></table>
<h2 id="限制结果集"><a href="#限制结果集" class="headerlink" title="限制结果集"></a>限制结果集</h2><p><code>LIMIT</code> 子句可用于限制 <code>SELECT</code> 语句返回的结果集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl LIMIT 5;     # Retrieve first 5 rows, equivalent to LIMIT 0, 5</span><br><span class="line">SELECT * FROM tbl LIMIT 5,10;  # Retrieve rows 6-15</span><br><span class="line">SELECT * FROM tbl LIMIT 5 OFFSET 10;  # Retrieve rows 11-15</span><br></pre></td></tr></table></figure>

<h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><p>我们经常需要汇总数据而不用把它们实际检索出来，为此 SQL 提供了五个聚集函数（aggregate function）。使用这些函数，SQL 查询可用于检索数据，以便分析和报表生成。这种类型的检索例子有：</p>
<ul>
<li>确定表中行数（或者满足某个条件或包含某个特定值的行数）；</li>
<li>获得表中某些行的和；</li>
<li>找出表列（或所有行或某些特定的行）的最大值、最小值、平均值。</li>
</ul>
<table>
<thead>
<tr>
<th>聚集函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>COUNT()</code></td>
<td>返回某列的行数，忽略 <code>NULL</code> 值。<code>COUNT(*)</code> 则包含 <code>NULL</code> 值。</td>
</tr>
<tr>
<td><code>AVG()</code></td>
<td>返回某列的平均值，忽略 <code>NULL</code> 值。</td>
</tr>
<tr>
<td><code>MAX()</code></td>
<td>返回某列的最大值，忽略 <code>NULL</code> 值。</td>
</tr>
<tr>
<td><code>MIN()</code></td>
<td>返回某列的最小值，忽略 <code>NULL</code> 值。</td>
</tr>
<tr>
<td><code>SUM()</code></td>
<td>返回某列值之和，忽略 <code>NULL</code> 值。</td>
</tr>
</tbody></table>
<p>修饰符 <code>ALL</code> 和 <code>DISTINCT</code> 可用于指定重复行是否应该返回。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 返回特定供应商所提供产品的平均价格</span><br><span class="line">SELECT AVG(prod_price) AS avg_price</span><br><span class="line">FROM Products</span><br><span class="line">WHERE vend_id &#x3D; &#39;DLL01&#39;;</span><br><span class="line"> -&gt; 3.8650</span><br><span class="line"></span><br><span class="line"># 同上，但平均值只考虑各个不同的价格</span><br><span class="line">SELECT AVG(DISTINCT prod_price) AS avg_price</span><br><span class="line">FROM Products</span><br><span class="line">WHERE vend_id &#x3D; &#39;DLL01&#39;;</span><br><span class="line"> -&gt; 4.2400</span><br></pre></td></tr></table></figure>

<p>可以看到，使用了 <code>DISTINCT</code> 后的 <em>avg_price</em> 会比较高，因为此例子中有多个物品具有相同的较低价格，排除它们提升了平均价格。</p>
<p><code>SELECT</code> 语句也可根据需要同时使用多个聚集函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) AS num_items,</span><br><span class="line">       MIN(prod_price) AS price_min,</span><br><span class="line">       MAX(prod_price) AS price_max,</span><br><span class="line">       AVG(prod_price) AS price_avg</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure>

<h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><p><code>GROUP BY</code> 子句用于分组数据，注意：</p>
<ul>
<li><code>GROUP BY</code> 子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。</li>
<li>如果在 <code>GROUP BY</code> 子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li>
<li><code>GROUP BY</code> 子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在 <code>SELECT</code> 中使用表达式，则必须在 <code>GROUP BY</code> 子句中指定相同的表达式。不能使用别名。</li>
<li>除聚集计算语句外，<code>SELECT</code> 语句中的每一列都必须在 <code>GROUP BY</code> 子句中给出。否则，如果 <code>SELECT</code> 语句中出现了 <code>GROUP BY</code> 中没有的列，假如该分组内的条目数大于 1，这样的列显示的内容为第一个条目的值。</li>
<li>如果分组列中包含具有 <code>NULL</code> 值的行，则 <code>NULL</code> 将作为一个分组返回。如果列中有多行 <code>NULL</code> 值，它们将分为一组。</li>
</ul>
<p><code>GROUP BY</code> 可以搭配使用 <code>HAVING</code> 过滤分组。<code>HAVING</code> 和 <code>WHERE</code> 的差别在于，<code>WHERE</code> 对分组前的数据进行过滤， <code>HAVING</code> 对分组后的数据进行过滤。</p>
<h1 id="加锁读"><a href="#加锁读" class="headerlink" title="加锁读"></a>加锁读</h1><p><code>InnoDB</code> 支持两种类型的 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking_read" target="_blank" rel="noopener">加锁读（Locking Reads）</a>，为事务操作提供额外的<strong>安全性</strong>：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE</code> 设置<strong>共享（<em>S</em>）锁</strong></li>
<li><code>SELECT ... FOR UPDATE</code> 设置<strong>排它（<em>X</em>）锁</strong></li>
</ul>
<p>详情请参考《<a href="/2018/10/20/mysql-locking/">MySQL 锁机制总结</a>》。</p>
<h1 id="UNION-子句"><a href="#UNION-子句" class="headerlink" title="UNION 子句"></a>UNION 子句</h1><p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span> | <span class="keyword">DISTINCT</span>] <span class="keyword">SELECT</span> ...</span><br><span class="line">[<span class="keyword">UNION</span> [<span class="keyword">ALL</span> | <span class="keyword">DISTINCT</span>] <span class="keyword">SELECT</span> ...]</span><br></pre></td></tr></table></figure>

<p><code>UNION</code> 将来自多个 <code>SELECT</code> 语句的结果合并为一个结果集，结果集列名取自第一条 <code>SELECT</code> 语句的列名。</p>
<p><code>UNION</code> 或 <code>UNION DISTINCT</code> 去重，而 <code>UNION ALL</code> 则不去重。</p>
<p>要为单独的一条 <code>SELECT</code> 语句应用 <code>ORDER BY</code> 或 <code>LIMIT</code> 子句，需要将子句放在包含 <code>SELECT</code> 的括号内，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> a <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> a=<span class="number">10</span> <span class="keyword">AND</span> B=<span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">10</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> a <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> a=<span class="number">11</span> <span class="keyword">AND</span> B=<span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>反之，如要应用到整个 <code>UNION</code> 结果集，则在单个 <code>SELECT</code> 语句后面加上括号，并在最后一个语句后面加上子句，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> a <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> a=<span class="number">10</span> <span class="keyword">AND</span> B=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> a <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> a=<span class="number">11</span> <span class="keyword">AND</span> B=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>



<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL 必知必会》</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/select.html</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/26/mysql-datetime/" class="post-title-link">MySQL 常用日期函数</a></h2><div class="post-info">2018-01-26<a href="/tags/MySQL/" title="MySQL" class="post-demo">MySQL</a></div><div class="post-content"><h1 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h1><h2 id="获得当前日期-时间"><a href="#获得当前日期-时间" class="headerlink" title="获得当前日期/时间"></a>获得当前日期/时间</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Synonym</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_current-date" target="_blank" rel="noopener"><code>CURRENT_DATE</code>, <code>CURRENT_DATE()</code></a></td>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_curdate" target="_blank" rel="noopener"><code>CURDATE()</code></a></td>
<td>Return the current date as <br/><em><code>&#39;YYYY-MM-DD&#39;</code></em> / <em><code>YYYYMMDD</code></em></td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_current-time" target="_blank" rel="noopener"><code>CURRENT_TIME</code>, <code>CURRENT_TIME([fsp])</code></a></td>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_curtime" target="_blank" rel="noopener"><code>CURTIME([fsp])</code></a></td>
<td>Return the current time as <br/><em><code>&#39;hh:mm:ss&#39;</code></em> / <em><code>hhmmss</code></em><br/>The value is expressed in the session time zone.</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_current-timestamp" target="_blank" rel="noopener"><code>CURRENT_TIMESTAMP</code>, <code>CURRENT_TIMESTAMP([fsp])</code></a><br/><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_localtime" target="_blank" rel="noopener"><code>LOCALTIME</code>, <code>LOCALTIME([fsp])</code></a><br/><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_localtimestamp" target="_blank" rel="noopener"><code>LOCALTIMESTAMP</code>, <code>LOCALTIMESTAMP([fsp])</code></a></td>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_now" target="_blank" rel="noopener"><code>NOW([fsp])</code></a></td>
<td>Return the current date and time as <br/><em><code>&#39;YYYY-MM-DD hh:mm:ss&#39;</code></em> / <em><code>YYYYMMDDhhmmss</code></em><br/>The value is expressed in the session time zone.</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_utc-date" target="_blank" rel="noopener"><code>UTC_DATE</code>, <code>UTC_DATE()</code></a></td>
<td></td>
<td>Return the current UTC date as <br/><em><code>&#39;YYYY-MM-DD&#39;</code></em> / <em><code>YYYYMMDD</code></em></td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_utc-time" target="_blank" rel="noopener"><code>UTC_TIME</code>, <code>UTC_TIME([fsp])</code></a></td>
<td></td>
<td>Return the current UTC time as <br/><em><code>&#39;hh:mm:ss&#39;</code></em> / <em><code>hhmmss</code></em></td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_utc-timestamp" target="_blank" rel="noopener"><code>UTC_TIMESTAMP</code>, <code>UTC_TIMESTAMP([fsp])</code></a></td>
<td></td>
<td>Return the current UTC date and time as <br/><em><code>&#39;YYYY-MM-DD hh:mm:ss&#39;</code></em> / <em><code>YYYYMMDDhhmmss</code></em></td>
</tr>
</tbody></table>
<p>注意，MySQL 时间支持的最高存储精度为微秒：</p>
<blockquote>
<p>1 秒(s) =<br>1,000 毫秒(ms) =<br>1,000,000 微秒(μs) =<br>1,000,000,000 纳秒(ns) =<br>1,000,000,000,000 皮秒(ps) =<br>1,000,000,000,000,000 飞秒(fs) =<br>1,000,000,000,000,000,000 仄秒(zs) =<br>1,000,000,000,000,000,000,000 幺秒(ys) =<br>1,000,000,000,000,000,000,000,000 渺秒(as)</p>
</blockquote>
<blockquote>
<p>1 微秒(μs) = 10^-6 秒（0.000,001，百万分之一秒）<br>1 毫秒(ms) = 10^-3 秒（0.001，千分之一秒）</p>
</blockquote>
<p>因此 <code>fsp</code> 参数范围只能为 0 ~ 6：</p>
<blockquote>
<p>If the <em><code>fsp</code></em> argument is given to specify a fractional seconds precision from 0 to 6, the return value includes a fractional seconds part of that many digits.</p>
</blockquote>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT CURDATE();                       -- 2018-08-08，获取当前年月日</span><br><span class="line">SELECT CURTIME();                       -- 22:41:30，获取当前时分秒</span><br><span class="line">SELECT NOW();                           -- 2018-08-08 22:20:46，获取当前年月日时分秒</span><br><span class="line">SELECT NOW(3);                          -- 2018-08-08 22:20:46.166，获取当前年月日时分秒毫秒</span><br><span class="line">SELECT NOW(6);                          -- 2018-08-08 22:20:46.166123，获取当前年月日时分秒毫秒微秒</span><br><span class="line">SELECT CURRENT_TIMESTAMP;               -- 2018-08-08 22:20:46，获取当前年月日时分秒</span><br></pre></td></tr></table></figure>

<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><h3 id="查看当前时区"><a href="#查看当前时区" class="headerlink" title="查看当前时区"></a>查看当前时区</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 结果主要看 system_time_zone</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%time_zone%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询系统时区、会话时区、下一事务时区</span></span><br><span class="line"><span class="keyword">SELECT</span> @@GLOBAL.time_zone, </span><br><span class="line">       @@SESSION.time_zone, </span><br><span class="line">       @@<span class="keyword">time_zone</span>;;</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.cnblogs.com/Uest/p/8259821.html" target="_blank" rel="noopener">MySQL 中几个关于时间/时区的变量</a></p>
<h3 id="修改时区"><a href="#修改时区" class="headerlink" title="修改时区"></a>修改时区</h3><p>通过 SQL <code>SET</code> 语法临时修改：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置 Global 全局时区，重启后失效</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> <span class="keyword">time_zone</span> = <span class="string">'+8:00'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置 Session 会话时区，会话关闭后失效</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">time_zone</span> = <span class="string">'+8:00'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置 下一事务 时区，事务结束后失效</span></span><br><span class="line"><span class="keyword">set</span> @@<span class="keyword">time_zone</span> = <span class="string">'+8:00'</span>;</span><br></pre></td></tr></table></figure>

<p>通过修改配置文件，重启后永久生效：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/mysql/my.cnf</span><br><span class="line">default-time_zone = '+8:00'</span><br><span class="line"></span><br><span class="line">$ service mysql restart</span><br></pre></td></tr></table></figure>

<h3 id="时区转换"><a href="#时区转换" class="headerlink" title="时区转换"></a>时区转换</h3><p>参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/datetime.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/datetime.html</a></p>
<blockquote>
<p>MySQL converts <code>TIMESTAMP</code> values from the current time zone to UTC for storage, and back from UTC to the current time zone for retrieval. (This does not occur for other types such as <code>DATETIME</code>.) By default, the current time zone for each connection is the server’s time. The time zone can be set on a per-connection basis. As long as the time zone setting remains constant, you get back the same value you store. If you store a <code>TIMESTAMP</code> value, and then change the time zone and retrieve the value, the retrieved value is different from the value you stored. This occurs because the same time zone was not used for conversion in both directions. The current time zone is available as the value of the <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_time_zone" target="_blank" rel="noopener"><code>time_zone</code></a> system variable. For more information, see <a href="https://dev.mysql.com/doc/refman/5.7/en/time-zone-support.html" target="_blank" rel="noopener">Section 5.1.13, “MySQL Server Time Zone Support”</a>.</p>
</blockquote>
<p><code>CONVERT_TZ(dt, from_tz, to_tz)</code> 函数用于将 <code>DATETIME</code> 类型转为指定时区，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TIMESTAMP 类型（UTC±00:00） &gt; DATETIME 类型（UTC±00:00） &gt; DATETIME 类型（UTC+08:00）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONVERT_TZ</span>( FROM_UNIXTIME( <span class="keyword">UNIX_TIMESTAMP</span>() ), <span class="string">'+00:00'</span>, <span class="string">'+08:00'</span> ) <span class="keyword">AS</span> <span class="keyword">NOW</span>;</span><br></pre></td></tr></table></figure>

<h2 id="日期-时间转换"><a href="#日期-时间转换" class="headerlink" title="日期/时间转换"></a>日期/时间转换</h2><h3 id="日期-时间-gt-时间戳"><a href="#日期-时间-gt-时间戳" class="headerlink" title="日期/时间 &gt; 时间戳"></a>日期/时间 &gt; 时间戳</h3><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_unix-timestamp" target="_blank" rel="noopener"><code>UNIX_TIMESTAMP([date])</code></a></td>
<td>Return a Unix timestamp.<br/>If no <em><code>date</code></em> argument, it returns a Unix timestamp representing seconds since <code>&#39;1970-01-01 00:00:00&#39;</code> UTC.<br/>If with a <em><code>date</code></em> argument, it returns the value of the argument as seconds since <code>&#39;1970-01-01 00:00:00&#39;</code> UTC.</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UNIX_TIMESTAMP</span>();                <span class="comment">-- 1218124800，获取当前时间戳</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UNIX_TIMESTAMP</span>(<span class="keyword">now</span>());           <span class="comment">-- 1218124800，将当前时间转换为时间戳，等价于上例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2008-08-08'</span>);    <span class="comment">-- 1219125100，将指定参数转换为时间戳</span></span><br></pre></td></tr></table></figure>

<h3 id="时间戳-gt-日期-时间"><a href="#时间戳-gt-日期-时间" class="headerlink" title="时间戳 &gt; 日期/时间"></a>时间戳 &gt; 日期/时间</h3><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_from-unixtime" target="_blank" rel="noopener"><code>FROM_UNIXTIME(unix_timestamp[,format])</code></a></td>
<td>Format Unix timestamp as a date</td>
</tr>
</tbody></table>
<p>注意，该函数只支持单位为秒的时间戳，不支持毫秒、微秒，需要先换算：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1447430881</span>);                                    <span class="comment">-- 2015-11-13 10:08:01</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1447430881123</span> / <span class="number">1000</span>);                          <span class="comment">-- 2015-11-13 16:08:01.1230</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1447430881123456</span> / <span class="number">1000000</span>, <span class="string">'%Y %D %M %r %f'</span>);  <span class="comment">-- 2015 13th November 04:08:01 PM 123456</span></span><br></pre></td></tr></table></figure>

<p>支持指定 <code>fomart</code> 格式：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">0</span>);                       <span class="comment">-- 1970-01-01 00:00:00</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">0</span>, <span class="string">'%Y %D %M %h:%i:%s'</span>);  <span class="comment">-- 1970 1st January 12:00:00</span></span><br></pre></td></tr></table></figure>

<h3 id="日期-时间-gt-字符串"><a href="#日期-时间-gt-字符串" class="headerlink" title="日期/时间 &gt; 字符串"></a>日期/时间 &gt; 字符串</h3><p>Date/Time to Str（日期/时间转换为字符串）函数：</p>
<ul>
<li><code>date_format(date, format)</code></li>
<li><code>time_format(time, format)</code></li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select date_format(now(), &#39;%Y-%m-%d&#39;);                          -- 2018-08-08</span><br><span class="line">select date_format(&#39;2018-08-08 22:23:00&#39;, &#39;%W %M %Y&#39;);          -- Friday August 2018</span><br><span class="line">select date_format(&#39;2018-08-08 22:23:01&#39;, &#39;%Y%m%d%H%i%s&#39;);      -- 20180808222301</span><br><span class="line">select time_format(&#39;22:23:01&#39;, &#39;%H.%i.%s&#39;);                     -- 22.23.01</span><br></pre></td></tr></table></figure>

<h3 id="字符串-gt-日期-时间"><a href="#字符串-gt-日期-时间" class="headerlink" title="字符串 &gt; 日期/时间"></a>字符串 &gt; 日期/时间</h3><p>Str to Date （字符串转换为日期）函数：</p>
<ul>
<li><code>str_to_date(str, format)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select str_to_date(&#39;08&#x2F;09&#x2F;2008&#39;, &#39;%m&#x2F;%d&#x2F;%Y&#39;);                   -- 2008-08-09</span><br><span class="line">select str_to_date(&#39;08&#x2F;09&#x2F;08&#39;  , &#39;%m&#x2F;%d&#x2F;%y&#39;);                   -- 2008-08-09</span><br><span class="line">select str_to_date(&#39;08.09.2008&#39;, &#39;%m.%d.%Y&#39;);                   -- 2008-08-09</span><br><span class="line">select str_to_date(&#39;08:09:30&#39;, &#39;%h:%i:%s&#39;);                     -- 08:09:30</span><br><span class="line">select str_to_date(&#39;08.09.2008 08:09:30&#39;, &#39;%m.%d.%Y %h:%i:%s&#39;); -- 2008-08-09 08:09:30</span><br></pre></td></tr></table></figure>

<h3 id="format-参数"><a href="#format-参数" class="headerlink" title="format 参数"></a>format 参数</h3><p><code>format</code> 如下，这里只列出常用的：</p>
<table>
<thead>
<tr>
<th><code>format</code></th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>%Y</code></td>
<td>Year, numeric, four digits</td>
</tr>
<tr>
<td><code>%y</code></td>
<td>Year, numeric (two digits)</td>
</tr>
<tr>
<td><code>%M</code></td>
<td>Month name (<code>January</code>..<code>December</code>)</td>
</tr>
<tr>
<td><code>%m</code></td>
<td>Month, numeric (<code>00</code>..<code>12</code>)</td>
</tr>
<tr>
<td><code>%D</code></td>
<td>Day of the month with English suffix (<code>0th</code>, <code>1st</code>, <code>2nd</code>, <code>3rd</code>, …)</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>Day of the month, numeric (<code>00</code>..<code>31</code>)</td>
</tr>
<tr>
<td><code>%H</code></td>
<td>Hour (<code>00</code>..<code>23</code>)</td>
</tr>
<tr>
<td><code>%h</code></td>
<td>Hour (<code>01</code>..<code>12</code>)</td>
</tr>
<tr>
<td><code>%i</code></td>
<td>Minutes, numeric (<code>00</code>..<code>59</code>)</td>
</tr>
<tr>
<td><code>%s</code></td>
<td>Seconds (<code>00</code>..<code>59</code>)</td>
</tr>
<tr>
<td><code>%f</code></td>
<td>Microseconds (<code>000000</code>..<code>999999</code>)</td>
</tr>
<tr>
<td><code>%T</code></td>
<td>Time, 24-hour (<em><code>hh:mm:ss</code></em>)</td>
</tr>
<tr>
<td><code>%r</code></td>
<td>Time, 12-hour (<em><code>hh:mm:ss</code></em> followed by <code>AM</code> or <code>PM</code>)</td>
</tr>
</tbody></table>
<h2 id="日期-时间计算"><a href="#日期-时间计算" class="headerlink" title="日期/时间计算"></a>日期/时间计算</h2><p>为日期增加一个时间间隔：</p>
<ul>
<li><code>date_add()</code></li>
</ul>
<p>为日期减去一个时间间隔：</p>
<ul>
<li><code>date_sub()</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set @dt &#x3D; now();</span><br><span class="line"></span><br><span class="line">select date_add(@dt, interval 1 day);        -- add 1 day</span><br><span class="line">select date_add(@dt, interval 1 hour);       -- add 1 hour</span><br><span class="line">select date_add(@dt, interval 1 minute);     -- ...</span><br><span class="line">select date_add(@dt, interval 1 second);</span><br><span class="line">select date_add(@dt, interval 1 microsecond);</span><br><span class="line">select date_add(@dt, interval 1 week);</span><br><span class="line">select date_add(@dt, interval 1 month);</span><br><span class="line">select date_add(@dt, interval 1 quarter);</span><br><span class="line">select date_add(@dt, interval 1 year);</span><br><span class="line"></span><br><span class="line">select date_add(@dt, interval -1 day);       -- sub 1 day</span><br><span class="line"></span><br><span class="line">SELECT DATE_SUB(@dt, INTERVAL 7 DAY);        -- 七天前</span><br></pre></td></tr></table></figure>

<h2 id="日期-时间截取"><a href="#日期-时间截取" class="headerlink" title="日期/时间截取"></a>日期/时间截取</h2><p>选取日期时间的各个部分：日期、时间、年、季度、月、日、小时、分钟、秒、微秒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set @dt &#x3D; now();</span><br><span class="line"></span><br><span class="line">select date(@dt);        -- 2008-09-10</span><br><span class="line">select time(@dt);        -- 07:15:30.123456</span><br><span class="line">select year(@dt);        -- 2008</span><br><span class="line">select quarter(@dt);     -- 3</span><br><span class="line">select month(@dt);       -- 9</span><br><span class="line">select week(@dt);        -- 36</span><br><span class="line">select day(@dt);         -- 10</span><br><span class="line">select hour(@dt);        -- 7</span><br><span class="line">select minute(@dt);      -- 15</span><br><span class="line">select second(@dt);      -- 30</span><br><span class="line">select microsecond(@dt); -- 123456</span><br></pre></td></tr></table></figure>

<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="按天统计订单量"><a href="#按天统计订单量" class="headerlink" title="按天统计订单量"></a>按天统计订单量</h2><p>按天统计订单量（同理，按小时统计：<code>DATE_FORMAT(create_time,&#39;%Y-%m-%d %H:00:00&#39;)</code>）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*), <span class="keyword">DATE_FORMAT</span>(create_time,<span class="string">'%Y-%m-%d'</span>) <span class="keyword">days</span> </span><br><span class="line"><span class="keyword">from</span> t_order </span><br><span class="line"><span class="keyword">where</span> create_time <span class="keyword">BETWEEN</span> <span class="string">'2008-9-29'</span> <span class="keyword">AND</span> <span class="string">'2008-9-30'</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">days</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----------+------------+</span></span><br><span class="line">| count(*) | hours      |</span><br><span class="line">+<span class="comment">----------+------------+</span></span><br><span class="line">|   150628 | 2008-09-01 |</span><br><span class="line">|   172419 | 2008-09-02 |</span><br><span class="line">|   177021 | 2008-09-03 |</span><br><span class="line">|   178917 | 2008-09-04 |</span><br><span class="line">|   180960 | 2008-09-05 |</span><br><span class="line">|   177626 | 2008-09-06 |</span><br><span class="line">|   177504 | 2008-09-07 |</span><br><span class="line">|   166118 | 2008-09-08 |</span><br><span class="line">|   193006 | 2008-09-09 |</span><br><span class="line">|   204156 | 2008-09-10 |</span><br><span class="line">|   196598 | 2008-09-11 |</span><br><span class="line">|   200184 | 2008-09-12 |</span><br><span class="line">|   159169 | 2008-09-13 |</span><br><span class="line">|   179798 | 2008-09-14 |</span><br><span class="line">|   203586 | 2008-09-15 |</span><br><span class="line">|   217863 | 2008-09-16 |</span><br><span class="line">|   231207 | 2008-09-17 |</span><br><span class="line">|   245960 | 2008-09-18 |</span><br><span class="line">|   226578 | 2008-09-19 |</span><br><span class="line">|   211986 | 2008-09-20 |</span><br><span class="line">|   201396 | 2008-09-21 |</span><br><span class="line">|   183012 | 2008-09-22 |</span><br><span class="line">|   221780 | 2008-09-23 |</span><br><span class="line">|   228094 | 2008-09-24 |</span><br><span class="line">|   220251 | 2008-09-25 |</span><br><span class="line">|   240866 | 2008-09-26 |</span><br><span class="line">|   235670 | 2008-09-27 |</span><br><span class="line">|   244964 | 2008-09-28 |</span><br><span class="line">|    98805 | 2008-09-29 |</span><br><span class="line">+<span class="comment">----------+------------+</span></span><br><span class="line">29 rows in <span class="keyword">set</span> (<span class="number">5.83</span> sec)</span><br></pre></td></tr></table></figure>

<h2 id="按-N-分钟统计订单量"><a href="#按-N-分钟统计订单量" class="headerlink" title="按 N 分钟统计订单量"></a>按 N 分钟统计订单量</h2><p>做法在于将每行的分钟数 <code>(MINUTE(create_time)</code> 除以 10 得到的小数向下取整，再乘以 10 就是所属的区间。例如：</p>
<ul>
<li>1 分钟 &gt; 0</li>
<li>25 分钟 &gt; 20</li>
<li>59 分钟 &gt; 50</li>
</ul>
<p>下例按 10 分钟统计订单量：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*), <span class="keyword">DATE_FORMAT</span>(</span><br><span class="line">  <span class="keyword">CONCAT</span>(</span><br><span class="line">    <span class="built_in">DATE</span>(create_time), </span><br><span class="line">    <span class="string">' '</span>, </span><br><span class="line">    <span class="keyword">HOUR</span>(create_time), </span><br><span class="line">    <span class="string">':'</span>, </span><br><span class="line">    <span class="keyword">FLOOR</span>(<span class="keyword">MINUTE</span>(create_time) / <span class="number">10</span>) * <span class="number">10</span></span><br><span class="line">  ), <span class="string">'%Y-%m-%d %H:%i'</span></span><br><span class="line">) <span class="keyword">AS</span> <span class="keyword">hours</span></span><br><span class="line"><span class="keyword">FROM</span> t_order</span><br><span class="line"><span class="keyword">WHERE</span> create_time <span class="keyword">BETWEEN</span> <span class="string">'2008-9-29'</span> <span class="keyword">AND</span> <span class="string">'2008-9-30'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">hours</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----------+------------------+</span></span><br><span class="line">| COUNT(*) | hours            |</span><br><span class="line">+<span class="comment">----------+------------------+</span></span><br><span class="line">|       51 | 2008-09-29 00:00 |</span><br><span class="line">|       53 | 2008-09-29 00:10 |</span><br><span class="line">|       43 | 2008-09-29 00:20 |</span><br><span class="line">|       59 | 2008-09-29 00:30 |</span><br><span class="line">|       40 | 2008-09-29 00:40 |</span><br><span class="line">|       27 | 2008-09-29 00:50 |</span><br><span class="line">|       22 | 2008-09-29 01:00 |</span><br><span class="line">|       24 | 2008-09-29 01:10 |</span><br><span class="line">|       15 | 2008-09-29 01:20 |</span><br><span class="line">|       15 | 2008-09-29 01:30 |</span><br><span class="line">|       26 | 2008-09-29 01:40 |</span><br><span class="line">|       18 | 2008-09-29 01:50 |</span><br><span class="line">|     1949 | 2008-09-29 02:00 |</span><br></pre></td></tr></table></figure>

<h1 id="建表自动初始化与更新时间"><a href="#建表自动初始化与更新时间" class="headerlink" title="建表自动初始化与更新时间"></a>建表自动初始化与更新时间</h1><p>假设表有 3 个字段：id、name、update_time，希望在新增记录时能自动设置 update_time 字段为当前时间，设置 <code>DEFAULT CURRENT_TIMESTAMP</code> 子句即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;test&#96; (</span><br><span class="line">&#96;id&#96; int NOT NULL,</span><br><span class="line">&#96;name&#96; varchar(255),</span><br><span class="line">&#96;update_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果希望在更新记录时还能自动更新 update_time 字段为当前时间，设置 <code>ON UPDATE CURRENT_TIMESTAMP</code> 子句即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#96;update_time&#96; timestamp NOT NULL ON UPDATE CURRENT_TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>设置之后，即使直接通过 Navicat 工具修改了 name 字段，那么 update_time 也会自动更新，除非手动设置了 update_time 字段。</p>
<p>参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/timestamp-initialization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/timestamp-initialization.html</a></p>
<h1 id="DATETIME-类型快速对比"><a href="#DATETIME-类型快速对比" class="headerlink" title="DATETIME 类型快速对比"></a>DATETIME 类型快速对比</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(1) </span><br><span class="line">from t_table </span><br><span class="line">where createTime between 20180215 and 20180216;</span><br></pre></td></tr></table></figure>

<p>datetime 会自动转为整数，查询范围从 2018-02-15 00:00:00 到 2018-02-16 00:00:00。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/functions.html</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/timestamp-initialization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/timestamp-initialization.html</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/time-zone-support.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/time-zone-support.html</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/05/mysql-data-types/" class="post-title-link">MySQL 常用数据类型</a></h2><div class="post-info">2018-01-05<a href="/tags/MySQL/" title="MySQL" class="post-demo">MySQL</a></div><div class="post-content"><h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><p>MySQL 支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于作出更好的选择。</p>
<h2 id="更小的通常更好"><a href="#更小的通常更好" class="headerlink" title="更小的通常更好"></a>更小的通常更好</h2><p>更小的数据类型通常更快，因为占用更少的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期也更少。</p>
<h2 id="简单就好"><a href="#简单就好" class="headerlink" title="简单就好"></a>简单就好</h2><p>简单数据类型的操作通常需要更少的 CPU 周期、索引性能更好。例如，整型比字符操作代价更低，因为字符集和校对规则（排序规则）使得字符比整型更复杂。</p>
<p>有几个例子：</p>
<ul>
<li><p>使用日期与时间类型，而不是字符串来存储日期和时间，以便排序和格式转换。</p>
</li>
<li><p>使用整型，而不是字符串来存储 IP 地址。MySQL 提供了两个函数来处理 IP 地址：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 INT unsigned 类型存储（存储范围：0 ~ 2^32-1）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">inet_aton</span>(<span class="string">'0.0.0.0'</span>);  <span class="comment">--结果：0</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">inet_aton</span>(<span class="string">'192.168.1.1'</span>);  <span class="comment">--结果：3232235777</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">inet_aton</span>(<span class="string">'255.255.255.255'</span>);  <span class="comment">--结果：4294967295</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">inet_ntoa</span>(<span class="string">'3232235777'</span>);  <span class="comment">--结果：192.168.1.1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用定长二进制类型（如 <code>binary</code>），而不是字符串来存储散列值：</p>
<ul>
<li><code>MD5</code> 128 bit / 4 = 32 length</li>
<li><code>SHA-1</code> 160 bit / 4 = 40 length</li>
<li><code>SHA-224</code> 224 bit / 4 = 56 length</li>
<li><code>SHA-256</code> 256 bit / 4 = 64 length</li>
<li><code>SHA-384</code> 384 bit / 4 = 96 length</li>
<li><code>SHA-512</code> 512 bit / 4 = 128 length</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_hash`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键 ID'</span>,</span><br><span class="line">  <span class="string">`hash`</span> varbinary(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'散列值'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_hash`</span> (<span class="string">`hash`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_hash(<span class="keyword">hash</span>) <span class="keyword">values</span>(<span class="keyword">md5</span>(<span class="string">'0.0.0.0'</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_hash(<span class="keyword">hash</span>) <span class="keyword">values</span>(<span class="keyword">sha1</span>(<span class="string">'0.0.0.0'</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_hash(<span class="keyword">hash</span>) <span class="keyword">values</span>(<span class="string">'你好吗'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试结果</span></span><br><span class="line"><span class="comment">-- length() 函数返回值的单位为字节。</span></span><br><span class="line"><span class="comment">-- 由于二进制类型无字符集，因此中文乱码</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">hash</span>, <span class="keyword">length</span>(<span class="keyword">hash</span>), <span class="keyword">char_length</span>(<span class="keyword">hash</span>) <span class="keyword">from</span> t_hash <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>;</span><br><span class="line">+<span class="comment">------------------------------------------+--------------+-------------------+</span></span><br><span class="line">| hash                                     | length(hash) | char_length(hash) |</span><br><span class="line">+<span class="comment">------------------------------------------+--------------+-------------------+</span></span><br><span class="line">| f1f17934834ae2613699701054ef9684         |           32 |                32 |</span><br><span class="line">| e562f69ec36e625116376f376d991e41613e9bf3 |           40 |                40 |</span><br><span class="line">| 浣犲ソ鍚?                                 |            9 |                 9 |</span><br><span class="line">+<span class="comment">------------------------------------------+--------------+-------------------+</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="避免使用-NULL"><a href="#避免使用-NULL" class="headerlink" title="避免使用 NULL"></a>避免使用 NULL</h2><p><code>NULL</code> 列使得 MySQL 索引、索引统计和值比较都更复杂。可为 <code>NULL</code> 的列会使用更多的存储空间（例如当可为 <code>NULL</code> 的列被索引时，每个索引记录需要一个额外的字节），在 MySQL 里也需要特殊处理。如果计划在列上建索引，应该尽量避免。</p>
<h1 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h1><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><h3 id="比特类型"><a href="#比特类型" class="headerlink" title="比特类型"></a>比特类型</h3><p><code>BIT[(M)]</code> 比特类型，<em>M</em> 为 1~64 位比特。</p>
<p><code>b&#39;value&#39;</code> 符号可用于指定比特值。<code>value</code> 是一组使用 0 和 1 编写的二进制值。例如 <code>b&#39;111&#39;</code> 和 <code>b&#39;10000000&#39;</code> 分别代表 <code>7</code> 和 <code>128</code> 。详见《<a href="https://dev.mysql.com/doc/refman/5.7/en/bit-value-literals.html" target="_blank" rel="noopener">Bit-Value Literals</a>》。</p>
<p>如果赋值给小于 <em>M</em> 位长的 <code>BIT(M)</code> 类型列，则该值左侧用零填充。例如，为 <code>BIT(6)</code> 列赋值 <code>b&#39;101&#39;</code> 实际上等于赋值 <code>b&#39;000101&#39;</code>。</p>
<p><code>BIT(1)</code> 常用来表示布尔类型，<code>b&#39;0&#39;</code> 表示 <code>false</code>，<code>b&#39;1&#39;</code> 表示 <code>true</code>。</p>
<p>1 byte = 8 bit。</p>
<h3 id="整数类型（精确值）"><a href="#整数类型（精确值）" class="headerlink" title="整数类型（精确值）"></a>整数类型（精确值）</h3><p>MySQL 可以使用以下几种整数类型，存储的值的范围从“-2^(N-1)”到“2^(N-1)-1”，其中 N 是存储空间的位数（1 byte = 8 bit）：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节长度</th>
<th>取值范围（有符号）</th>
<th>取值范围（无符号）</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>TINYINT</code></td>
<td>1 byte</td>
<td>-2^7 ~2^7-1</td>
<td>0~2^8-1</td>
<td>同义词 <code>BOOL</code>、<code>BOOLEAN</code> ，0 为 false，!0 为 true</td>
</tr>
<tr>
<td><code>SMALLINT</code></td>
<td>2 bytes</td>
<td>-2^15 ~2^15-1</td>
<td>0~2^16-1</td>
<td></td>
</tr>
<tr>
<td><code>MEDIUMINT</code></td>
<td>3 bytes</td>
<td>-2^23 ~2^23-1</td>
<td>0~2^24-1</td>
<td></td>
</tr>
<tr>
<td><code>INT</code></td>
<td>4 bytes</td>
<td>-2^31 ~2^31-1</td>
<td>0~2^32-1</td>
<td>同义词 <code>INTEGER</code></td>
</tr>
<tr>
<td><code>BIGINT</code></td>
<td>8 bytes</td>
<td>-2^63 ~2^63-1</td>
<td>0~2^64-1</td>
<td><code>SERIAL</code> 等于 <code>BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE</code> 的别名 ，适用于创建主键</td>
</tr>
</tbody></table>
<p><code>INT[(M)] [UNSIGNED] [ZEROFILL] [AUTO_INCREMENT]</code> 整数类型</p>
<ul>
<li><p><em><code>M</code></em> 最大显示宽度，例如 <code>INT(11)</code> ：</p>
<p>这个属性对于大多数应用都是没有意义的：它不会限制值的合法范围，只是规定了 MySQL 的一些交互工具用来<strong>显示字符</strong>的个数，最大值为 255，一般配合 <code>ZEROFILL</code> 使用。对于存储和计算来说，<code>INT(1)</code> 和 <code>INT(20)</code> 是相同的，并不会影响该类型的占用字节数。</p>
</li>
<li><p><code>ZEROFILL</code> 填充零：</p>
<p>顾名思义就是用 “0” 填充的意思，也就是在数字位数不够（&lt; <em><code>M</code></em>）的空间用字符 “0” 填满。只在一些交互工具中有效，例如 MyCli。</p>
</li>
</ul>
<ul>
<li><p><code>UNSIGNED</code> 无符号：</p>
<p>整数类型有可选的 <code>UNSIGNED</code> 属性，表示不允许负值，这大致可以使正数的上限提高一倍。例如 <code>tinyint UNSIGNED</code> 可以存储的范围是 0<del>255，而 <code>tinyint</code> 的存储范围是 -128</del>127。</p>
</li>
</ul>
<ul>
<li><p><code>AUTO_INCREMENT</code> 自动递增：</p>
<p>在需要产生唯一标识符或顺序值时，可利用此属性，这个属性只用于整数类型。<code>AUTO_INCREMENT</code> 值一般从 1 开始，每行增加 1。 一个表中最多只能有一个 <code>AUTO_INCREMENT</code> 列 。对于任何想要使用 <code>AUTO_INCREMENT</code> 的列，应该定义为 <code>NOT NULL</code>，并定义为 <code>PRIMARY KEY</code> 或定义为 <code>UNIQUE</code> 键。</p>
</li>
</ul>
<h3 id="定点类型（精确值）"><a href="#定点类型（精确值）" class="headerlink" title="定点类型（精确值）"></a>定点类型（精确值）</h3><p><code>DECIMAL[(M[,D])] [UNSIGNED] [ZEROFILL]</code> 定点类型（fixed-point number），用于存储高精度数值，如货币数据。</p>
<p><em>M</em> 是总位数（精度，precision），<em>D</em> 是小数点后的位数（标度，scale）。小数点和（对于负数） <code>-</code> 符号不计入 <em>M</em>。如果 <em>D</em> 为 0，则值不包含小数点或小数部分。如果指定 <code>UNSIGNED</code>，则不允许负值。<code>DECIMAL</code> 的所有基本运算 (+, -, *, /) 都以 65 位数的最大精度完成。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th><em>M</em> 精度范围（总位数）</th>
<th><em>D</em> 标度范围（小数位数）</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>DECIMAL</code></td>
<td>0~65，默认 10</td>
<td>0~30，默认 0</td>
<td>同义词 <code>DEC</code>、<code>NUMERIC</code>、<code>FIXED</code></td>
</tr>
</tbody></table>
<p>例如 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salary DECIMAL(5,2)</span><br></pre></td></tr></table></figure>

<p>可以存储在 <em>salary</em> 列中的值范围从 -999.99 ~ 999.99。</p>
<p><code>DECIMAL</code> 以二进制格式存储值，每 4 个字节存 9 个数字。例如，<code>DECIMAL(18,9)</code> 小数点两边各存储 9 个数字，一共使用 9 个字节：小数点前的数字使用 4 个字节，小数点后的数字使用 4 个字节，小数点本身占 1 个字节。详见《<a href="https://dev.mysql.com/doc/refman/5.7/en/precision-math.html" target="_blank" rel="noopener">Precision Math</a>》。</p>
<p>因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用 <code>DECIMAL</code> —— 例如存储财务数据。但在数据量比较大的时候，可以考虑使用 <code>BIGINT</code> 代替 <code>DECIMAL</code> ，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。假设要存储的财务数据精确到万分之一分，则可以把所有金额乘以一百万，然后将结果存储在 <code>BIGINT</code> 里，这样可以同时避免浮点存储计算不精确和 <code>DECIMAL</code> 精确计算代价高的问题。</p>
<h3 id="浮点类型（近似值）"><a href="#浮点类型（近似值）" class="headerlink" title="浮点类型（近似值）"></a>浮点类型（近似值）</h3><p><code>FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]</code> 单精度浮点类型（floating-point number），<em>M</em> 是总位数，<em>D</em> 是小数点后面的位数。如果 <em>M</em> 和 <em>D</em> 省略，值将存储到硬件允许的限制。单精度浮点数精确到约 7 位小数。</p>
<p><code>DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]</code> 双精度浮点类型（floating-point number），<em>M</em> 是总位数，<em>D</em> 是小数点后面的位数。如果 <em>M</em> 和 <em>D</em> 省略，值将存储到硬件允许的限制。双精度浮点数精确到小数点后 15 位。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节长度</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>FLOAT</code></td>
<td>4 bytes</td>
<td><code>-3.402823466E+38</code> to <code>-1.175494351E-38</code>, <code>0</code>, and <code>1.175494351E-38</code> to <code>3.402823466E+38</code></td>
</tr>
<tr>
<td><code>DOUBLE</code></td>
<td>8 bytes</td>
<td><code>-1.7976931348623157E+308</code> to <code>-2.2250738585072014E-308</code>, <code>0</code>, and<code>2.2250738585072014E-308</code> to <code>1.7976931348623157E+308</code></td>
</tr>
</tbody></table>
<p>因为浮点值是近似值而不是作为精确值存储的，比值时可能会导致问题。详见《<a href="https://dev.mysql.com/doc/refman/5.7/en/problems-with-float.html" target="_blank" rel="noopener">Problems with Floating-Point Values</a>》。</p>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><h3 id="CHAR-和-VARCHAR-类型"><a href="#CHAR-和-VARCHAR-类型" class="headerlink" title="CHAR 和 VARCHAR 类型"></a>CHAR 和 VARCHAR 类型</h3><p>下列表格中，<em>M</em> 表示字符长度，<em>L</em> 表示实际字节存储长度。这两种类型很相似，但它们被存储和检索的方式不同。它们的最大字节长度 <em>L</em> 和尾部空格是否保留也不同。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>最大字节长度</th>
<th>尾部空格是否保留</th>
<th>描述</th>
<th>适用情况</th>
</tr>
</thead>
<tbody><tr>
<td><code>VARCHAR(M)</code></td>
<td>65,535 bytes (2^16-1)</td>
<td>否</td>
<td>用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，因为它仅使用必要的空间。其有效最大长度取决于<strong>行大小限制</strong>（默认 65,535 字节，在所有列中共享） 和使用的字符集（例如， UTF-8 字符集每个字符最多可能需要三个字节，因此最多可以声明为 21,844 个字符）。参加《<a href="https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html" target="_blank" rel="noopener">表列数量和行数限制</a>》。</td>
<td>字符的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像 UTF-8 这样复杂的字符集，每个字符都使用不同的字节数进行存储。</td>
</tr>
<tr>
<td><code>CHAR(M)</code></td>
<td>255 bytes (2^8-1)</td>
<td>是</td>
<td>用于存储定长字符串。长度不足时会填充尾部空格到指定的长度。</td>
<td>存储很短的字符串，或者所有值都接近同一个长度。例如，存储密码的 MD5 值；经常变更的数据，定长的 <code>CHAR</code> 类型不容易产生碎片。</td>
</tr>
</tbody></table>
<p>不同于 <code>CHAR</code> 类型，<code>VARCHAR</code> 类型需要使用 1 或 2 个额外字节记录字符串的长度：如果列的最大长度小于或等于 255 字节，则只使用 1 个字节表示，否则使用 2 个字节：</p>
<blockquote>
<p><em>L</em> + 1 bytes if column values require 0 − 255 bytes, <em>L</em> + 2 bytes if values may require more than 255 bytes</p>
</blockquote>
<p>下表通过存储各种字符串值到 <code>CHAR(4)</code> 和 <code>VARCHAR(4)</code> 列说明了 <code>CHAR</code> 和 <code>VARCHAR</code> 之间的差别（假设该列使用单字节字符集，例如 latin1）：</p>
<table>
<thead>
<tr>
<th>值</th>
<th><code>CHAR(4)</code></th>
<th>需要存储</th>
<th><code>VARCHAR(4)</code></th>
<th>需要存储</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;&#39;</code></td>
<td><code>&#39;    &#39;</code></td>
<td>4 bytes</td>
<td><code>&#39;&#39;</code></td>
<td>1 byte</td>
</tr>
<tr>
<td><code>&#39;ab&#39;</code></td>
<td><code>&#39;ab  &#39;</code></td>
<td>4 bytes</td>
<td><code>&#39;ab&#39;</code></td>
<td>3 bytes</td>
</tr>
<tr>
<td><code>&#39;abcd&#39;</code></td>
<td><code>&#39;abcd&#39;</code></td>
<td>4 bytes</td>
<td><code>&#39;abcd&#39;</code></td>
<td>5 bytes</td>
</tr>
<tr>
<td><code>&#39;abcdefgh&#39;</code></td>
<td><code>&#39;abcd&#39;</code></td>
<td>4 bytes</td>
<td><code>&#39;abcd&#39;</code></td>
<td>5 bytes</td>
</tr>
</tbody></table>
<h3 id="BLOB-和-TEXT-类型"><a href="#BLOB-和-TEXT-类型" class="headerlink" title="BLOB 和 TEXT 类型"></a>BLOB 和 TEXT 类型</h3><p><code>TEXT</code> 表示二进制字符串（字节字符串），没有排序规则或字符集。<code>BLOB</code> 表示非二进制字符串（字符串），有排序规则、字符集。与其它类型不同，MySQL 把每个 <code>BLOB</code> 和 <code>TEXT</code> 值当做一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当 <code>BLOB</code> 和 <code>TEXT</code> 值太大时，InnoDB 会使用专门的“外部”存储区域来进行存储，<strong>此时每个值在行内需要 1~4 个字节存储一个指针，然后在外部存储区域存储实际的值</strong>。它们的最大字节长度如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>指针长度</th>
<th>实际值的最大字节长度</th>
</tr>
</thead>
<tbody><tr>
<td><code>TINYTEXT</code>、<code>TINYBLOB</code></td>
<td>1 byte</td>
<td>256 bytes (2^8)</td>
</tr>
<tr>
<td><code>TEXT</code>、<code>BLOB</code></td>
<td>2 bytes</td>
<td>65,536 bytes (2^16)，64 KB</td>
</tr>
<tr>
<td><code>MEDIUMTEXT</code>、<code>MEDIUMBLOB</code></td>
<td>3 bytes</td>
<td>16,777,216 bytes (2^24)，16 MB</td>
</tr>
<tr>
<td><code>LONGTEXT</code>、<code>LONGBLOB</code></td>
<td>4 bytes</td>
<td>4,294,967,296 bytes  (2^32)，4 GB</td>
</tr>
</tbody></table>
<p>MySQL 不能将 <code>BLOB</code> 和 <code>TEXT</code> 列全部长度的字符串进行索引，也不能使用这些索引消除排序，因此可以使用“前缀索引”解决这个问题。</p>
<h2 id="日期与时间类型"><a href="#日期与时间类型" class="headerlink" title="日期与时间类型"></a>日期与时间类型</h2><ul>
<li>MySQL 有多种表示日期的数据类型，比如，当只记录年信息的时候，可以使用 <code>YEAR</code> 类型，而没有必要使用 <code>DATE</code> 类型。</li>
<li>每一个类型都有合法的取值范围，当指定确实不合法的值时系统将 “零” 值插入到数据库中。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节长度</th>
<th>默认值（0 值）</th>
<th>取值范围</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><code>YEAR</code></td>
<td>1 byte</td>
<td>0000</td>
<td>1901 ~ 2155</td>
<td></td>
</tr>
<tr>
<td><code>DATE</code></td>
<td>3 bytes</td>
<td>0000-00-00</td>
<td>1000-01-01 ~ 9999-12-31</td>
<td></td>
</tr>
<tr>
<td><code>TIME</code></td>
<td>3 bytes</td>
<td>00:00:00</td>
<td>-838:59:59 ~ 838:59:59</td>
<td></td>
</tr>
<tr>
<td><code>DATETIME</code></td>
<td>5 bytes</td>
<td>0000-00-00 00:00:00</td>
<td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td>
<td><code>DATETIME</code> 把日期和时间封装到格式为 <code>YYYYMMDDHHMMSS</code> 的整数中，与时区无关。默认情况下，MySQL 以一种可排序的、无歧义的格式显示 <code>DATETIME</code> 值，例如“2018-01-16 22:37:08”。这是 ANSI 标准定义的日期和时间显示方法。</td>
</tr>
<tr>
<td><code>TIMESTAMP</code></td>
<td>4 bytes</td>
<td>1970-01-01 00:00:00 UTC</td>
<td>1970-01-01 00:00:00 UTC ~ 2038-01-19 03:14:07 UTC</td>
<td><code>TIMESTAMP</code> 显示的值依赖于时区。</td>
</tr>
</tbody></table>
<h3 id="存储精度"><a href="#存储精度" class="headerlink" title="存储精度"></a>存储精度</h3><p>需要注意的是，MySQL 升级到 5.6 之后对日期与时间类型做过调整，可以精确到微秒并指定其精度（最多 6 位），参考 <a href="https://dev.mysql.com/doc/refman/5.6/en/upgrading-from-previous-series.html" target="_blank" rel="noopener">Changes in MySQL 5.6</a>：</p>
<p><img src="/img/mysql/datatype/incompatible_change_of_date_and_time_type.png" alt="incompatible_change_of_date_and_time_type"></p>
<p>参考 <a href="https://dev.mysql.com/doc/refman/5.6/en/storage-requirements.html#data-types-storage-reqs-date-time" target="_blank" rel="noopener">Date and Time Type Storage Requirements</a> 下表列明了日期与时间类型在 MySQL 5.6.4 前后的变化：</p>
<p><img src="/img/mysql/datatype/date_and_time_type_storage_requirements.png" alt="date_and_time_type_storage_requirements"></p>
<p>通过分析精确到小数部分的秒（Fractional Seconds Precision）所支持的最大十进制数值，并将其转换为二进制表示，可知为什么精度越高所需的存储空间越多：</p>
<table>
<thead>
<tr>
<th>Fractional Seconds Precision</th>
<th>Maximum Decimal Representation</th>
<th>Maximum Binary Representation</th>
<th>Storage Required</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0 (0 bit)</td>
<td>0 byte</td>
</tr>
<tr>
<td>1, 2</td>
<td>99</td>
<td>0110 0011 (8 bits)</td>
<td>1 byte</td>
</tr>
<tr>
<td>3, 4</td>
<td>9,999</td>
<td>0010 0111 0000 1111 (16 bits)</td>
<td>2 bytes</td>
</tr>
<tr>
<td>5, 6</td>
<td>999,999</td>
<td>0000 1111 0100 0010 0011 1111 (24 bits)</td>
<td>3 bytes</td>
</tr>
</tbody></table>
<p>有关于时间值的内部表示的详细信息，参考 <a href="https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html" target="_blank" rel="noopener">MySQL Internals: Important Algorithms and Structures - Date and Time Data Type Representation</a></p>
<p><code>DATETIME</code> 类型非小数部分的编码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 1 bit  sign           (1&#x3D; non-negative, 0&#x3D; negative)</span><br><span class="line">17 bits year*13+month  (year 0-9999, month 0-12)</span><br><span class="line"> 5 bits day            (0-31)</span><br><span class="line"> 5 bits hour           (0-23)</span><br><span class="line"> 6 bits minute         (0-59)</span><br><span class="line"> 6 bits second         (0-59)</span><br><span class="line">---------------------------</span><br><span class="line">40 bits &#x3D; 5 bytes</span><br></pre></td></tr></table></figure>

<p><code>TIMESTAMP</code> 类型的如下：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>时间戳</th>
<th>二进制字面量</th>
</tr>
</thead>
<tbody><tr>
<td>1970-01-01T00:00:00Z</td>
<td>0</td>
<td>00000000 00000000 00000000 00000000</td>
</tr>
<tr>
<td>2038-01-19T03:14:07Z</td>
<td>2^31-1, 2147483647</td>
<td>01111111 11111111 11111111 11111111</td>
</tr>
</tbody></table>
<h1 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h1><ul>
<li>默认值必须是常量，而不能是一个函数或表达式。举个栗子，这意味着你不能将日期列的默认值设置为诸如 <code>NOW()</code> 或 <code>CURRENT_DATE</code> 之类的函数的值。唯一例外是你可以指定 <code>CURRENT_TIMESTAMP</code> 为 <code>TIMESTAMP</code> 和 <code>DATETIME</code> 列的默认值。</li>
<li>隐式默认值定义如下：<ul>
<li>数字类型<ul>
<li>对于使用 <code>AUTO_INCREMENT</code> 属性声明的整数类型或浮点类型，默认值为下一个序列值。</li>
<li>否则默认值为 <code>0</code> 。</li>
</ul>
</li>
<li>字符串类型<ul>
<li><code>ENUM</code> 的默认值为第一个枚举值。</li>
<li><code>BLOB</code> 、<code>TEXT</code> 列无法指定默认值。</li>
<li>其它类型的默认值为空字符串。</li>
</ul>
</li>
<li>日期与时间类型<ul>
<li><code>TIMESTAMP</code><ul>
<li>如果系统变量 <code>explicit_defaults_for_timestamp</code> 开启，其默认值为 0 值。</li>
<li>否则表中第一列 <code>TIMESTAMP</code> 的默认值为当前时间。</li>
</ul>
</li>
<li>其它类型的默认值为相应的 0 值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/data-types.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/data-types.html</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html</a></p>
<p>《<a href="https://www.cnblogs.com/blankqdb/archive/2012/11/03/blank_qdb.html" target="_blank" rel="noopener">MySQL数据类型：UNSIGNED注意事项</a>》</p>
<p>《<a href="http://tech.it168.com/a2013/1013/1544/000001544067.shtml" target="_blank" rel="noopener">MySQL 5.6时间数据类型功能获得改进</a>》</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/03/mysql-cli/" class="post-title-link">MySQL 常用命令</a></h2><div class="post-info">2018-01-03<a href="/tags/MySQL/" title="MySQL" class="post-demo">MySQL</a></div><div class="post-content"><p>高安全的生产环境下只能使用命令行操作数据库，下面介绍一些常用命令。</p>
<h1 id="连接-DB"><a href="#连接-DB" class="headerlink" title="连接 DB"></a>连接 DB</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -h192.168.0.221 -P3306 -u账号 -p密码 [db_name]</span><br><span class="line"></span><br><span class="line">or better:</span><br><span class="line"></span><br><span class="line">$ mycli -h192.168.0.221 -P3306 -u账号 -p密码 [db_name]</span><br></pre></td></tr></table></figure>

<h1 id="查看库"><a href="#查看库" class="headerlink" title="查看库"></a>查看库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看所有库</span><br><span class="line">$ show databases;</span><br><span class="line"></span><br><span class="line">+------------------+</span><br><span class="line">| Database         |</span><br><span class="line">|------------------|</span><br><span class="line">| db_name_1        |</span><br><span class="line">| db_name_2        |</span><br><span class="line">+------------------+</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 进入某个库</span><br><span class="line">$ use db_name_1;</span><br></pre></td></tr></table></figure>

<h1 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h1><h2 id="所有表"><a href="#所有表" class="headerlink" title="所有表"></a>所有表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ show tables [from db_name];</span><br><span class="line"></span><br><span class="line">+---------------------+</span><br><span class="line">| Tables_in_db_name   |</span><br><span class="line">|---------------------|</span><br><span class="line">| table_name_1        |</span><br><span class="line">| table_name_2        |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure>

<h2 id="所有表状态"><a href="#所有表状态" class="headerlink" title="所有表状态"></a>所有表状态</h2><p>显示当前使用或者指定的 DB 中的每个表的信息。</p>
<p>由于字段较多，可用 <code>\G</code> 参数按列显示（行转列），起到显示美化的作用，方便查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ show table status [from db_name] \G;</span><br><span class="line"></span><br><span class="line">Name            | table_name</span><br><span class="line">Engine          | InnoDB</span><br><span class="line">Version         | 10</span><br><span class="line">Row_format      | Compact</span><br><span class="line">Rows            | 59079</span><br><span class="line">Avg_row_length  | 133</span><br><span class="line">Data_length     | 7880704</span><br><span class="line">Max_data_length | 0</span><br><span class="line">Index_length    | 21069824</span><br><span class="line">Data_free       | 5242880</span><br><span class="line">Auto_increment  | 75437</span><br><span class="line">Create_time     | 2017-04-13 20:51:55</span><br><span class="line">Update_time     | None</span><br><span class="line">Check_time      | None</span><br><span class="line">Collation       | utf8_general_ci</span><br><span class="line">Checksum        | None</span><br><span class="line">Create_options  |</span><br><span class="line">Comment         | 测试表</span><br></pre></td></tr></table></figure>

<p>比较重要的字段：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Rows</code></td>
<td>行的数目。部分存储引擎，如 <code>MyISAM</code>，存储精确的数目。<br/>对于其它存储引擎，比如 <code>InnoDB</code>，是一个大约的值，与实际值相差可达40到50％。在这些情况下，使用 <code>SELECT COUNT(*)</code> 来获得准确的数目。</td>
</tr>
<tr>
<td><code>Avg_row_length</code></td>
<td>平均的行长度。</td>
</tr>
<tr>
<td><code>Data_length</code></td>
<td>对于 <code>MyISAM</code>，<code>Data_length</code> 是数据文件的长度（以字节为单位）。<br/>对于 <code>InnoDB</code>，<code>Data_length</code> 是聚簇索引 <code>clustered index</code> 大约分配的内存量（以字节为单位）。</td>
</tr>
<tr>
<td><code>Index_length</code></td>
<td>对于 <code>MyISAM</code>，<code>Index_length</code> 是索引文件的长度（以字节为单位）。<br/>对于 <code>InnoDB</code>，<code>Index_length</code> 是非聚簇索引 <code>non-clustered index</code> 大约分配的内存量（以字节为单位）。</td>
</tr>
<tr>
<td><code>Auto_increment</code></td>
<td>下一个 <code>AUTO_INCREMENT</code> 值。</td>
</tr>
</tbody></table>
<h2 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h2><p>查看列名（三者等价）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ show columns from table_name [from db_name];</span><br><span class="line">$ show columns from [db_name.]table_name;</span><br><span class="line">$ desc table_name;  &#x2F;&#x2F; 简写形式</span><br></pre></td></tr></table></figure>

<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show index from table_name;</span><br></pre></td></tr></table></figure>

<h2 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show create table table_name;</span><br></pre></td></tr></table></figure>

<h1 id="查看用户权限"><a href="#查看用户权限" class="headerlink" title="查看用户权限"></a>查看用户权限</h1><p>显示一个用户的权限，显示结果类似于 <code>GRANT</code> 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ show grants [for user_name@&#39;192.168.0.%&#39;];</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------------------------------------+</span><br><span class="line">| Grants for user_name@192.168.0.%                                                            |</span><br><span class="line">+---------------------------------------------------------------------------------------------+</span><br><span class="line">| GRANT SELECT, INSERT, UPDATE, DELETE ON &#96;db_name&#96;.&#96;table_name&#96; TO &#39;user_name&#39;@&#39;192.168.0.%&#39; |</span><br><span class="line">+---------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<h1 id="查看系统相关"><a href="#查看系统相关" class="headerlink" title="查看系统相关"></a>查看系统相关</h1><h2 id="系统状态"><a href="#系统状态" class="headerlink" title="系统状态"></a>系统状态</h2><p>显示一些系统特定资源的信息，例如，正在运行的线程数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show status;</span><br></pre></td></tr></table></figure>

<h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>显示系统变量的名称和值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show variables;</span><br></pre></td></tr></table></figure>

<h2 id="DB-进程"><a href="#DB-进程" class="headerlink" title="DB 进程"></a>DB 进程</h2><p>显示系统中正在运行的所有进程，也就是当前正在执行的查询。大多数用户可以查看他们自己的进程，但是如果他们拥有process权限，就可以查看所有人的进程，包括密码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看当前 DB 进程</span><br><span class="line">$ show processlist;</span><br><span class="line">$ show full processlist;</span><br><span class="line">+----------+-----------+--------------------+---------+---------+------+-------+------------------+</span><br><span class="line">| Id       | User      | Host               | db      | Command | Time | State | Info             |</span><br><span class="line">+----------+-----------+--------------------+---------+---------+------+-------+------------------+</span><br><span class="line">| 33702451 | user_name | 192.168.0.200:49764 | db_name | Query   |    0 | init  | show processlist |</span><br><span class="line">+----------+-----------+--------------------+---------+---------+------+-------+------------------+</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Id</code></td>
<td>标识，用途：<code>kill 33702451</code> 杀死指定进程。</td>
</tr>
<tr>
<td><code>User</code></td>
<td>显示执行 SQL 的用户。</td>
</tr>
<tr>
<td><code>Host</code></td>
<td>显示这个账号是从哪个 IP 连过来的。</td>
</tr>
<tr>
<td><code>db</code></td>
<td>显示这个进程目前连接的是哪个数据库 。</td>
</tr>
<tr>
<td><code>command</code></td>
<td>显示当前连接的执行命令，一般就是休眠（ sleep ），查询（ query ），连接（ connect ）。</td>
</tr>
<tr>
<td><code>Time</code></td>
<td>这个状态持续的时间，单位是秒。</td>
</tr>
<tr>
<td><code>State</code></td>
<td>显示使用当前连接的 SQL 语句的状态。</td>
</tr>
<tr>
<td><code>Info</code></td>
<td>显示执行的 SQL 语句。</td>
</tr>
</tbody></table>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>显示服务器所支持的不同权限。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show privileges;</span><br></pre></td></tr></table></figure>

<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ show engies; &#x2F;&#x2F; 显示安装以后可用的存储引擎和默认引擎。 </span><br><span class="line"></span><br><span class="line">$ show innodb status; &#x2F;&#x2F; 显示innoDB存储引擎的状态 </span><br><span class="line"></span><br><span class="line">$ show logs; &#x2F;&#x2F; 显示BDB存储引擎的日志</span><br></pre></td></tr></table></figure>

<h2 id="警告与错误"><a href="#警告与错误" class="headerlink" title="警告与错误"></a>警告与错误</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ show warnings; &#x2F;&#x2F; 显示最后一个执行的语句所产生的错误、警告和通知 </span><br><span class="line"></span><br><span class="line">$ show errors; &#x2F;&#x2F; 只显示最后一个执行语句所产生的错误</span><br></pre></td></tr></table></figure>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2018/01/01/frontend-roadmap/" class="post-title-link">前端技术栈演进之路</a></h2><div class="post-info">2018-01-01<a href="/tags/前端/" title="前端" class="post-demo">前端</a></div><div class="post-content"><p>在随手科技这几年，兼任了金融前端团队的负责人，将团队从只有 1 名前端开始，扩展到了 10 多人的前端团队，推动了整个金融前端技术栈的建设及发展，是一段挑战自己未知领域的有趣之旅。</p>
<p>我总结了一下，这几年团队共经历了这样几个阶段：</p>
<ul>
<li>单块项目（服务端渲染） &gt; 项目分层（前后端分离） &gt; 项目拆分（按业务拆分）</li>
<li>前端模块化 &gt; 组件化 &gt; 工程化</li>
<li>事件驱动 &gt; 数据驱动</li>
<li>后台选型：JSP 服务端渲染 + EasyUI &gt; 前后端分离 + <a href="http://element.eleme.io/" target="_blank" rel="noopener">Element</a></li>
<li>浏览器 &gt; 服务端</li>
</ul>
<p>下面分几个阶段总结下。</p>
<h1 id="阶段1-服务端渲染"><a href="#阶段1-服务端渲染" class="headerlink" title="阶段1 服务端渲染"></a>阶段1 服务端渲染</h1><p>2016 年之前，由于团队和项目规模所限，人员构成以后端开发为主、前端开发为辅（就一个前端开发），只能通过最基础的技术栈，以后端人员最熟悉的技术着手进行业务开发并快速上线，因此技术选型都是偏向服务端的：前端只需按照设计师要求切图并输出静态页面（HTML + CSS），加上一些基础的 ES5 实现所需的动画效果和基础交互效果，后端套成 JSP （或 freemarker velocity thymeleaf）进行服务端渲染。后端开发一般会这样解决问题：</p>
<ul>
<li>通过 SiteMesh 等框架在 JSP 中将网页内容和页面结构分离，以达到页面结构共享的目的；</li>
<li>通过 tld 文件自定义标签，给 JSP 页面提供一些便捷工具（如货币、时间、字符串格式化）；</li>
<li>对于一些复杂的页面交互逻辑，在 JSP 页面上通过 <code>&lt;script&gt;</code> 标签直接引用所需的 JavaScript 文件。</li>
</ul>
<p>作为后端开发人员会觉得：这么写代码也没什么问题啊，毕竟身边的同事都是这么写的，项目也跑得好好的。但问题在于，后端开发写 JS 都是很业余的，而且随着功能越做越多，业务越做越深，前端脚本开始变得难以扩展与维护：</p>
<ul>
<li>脚本间依赖关系脆弱，加载顺序需要手工维护，一不小心顺序乱了就 JS 报错；</li>
<li>脚本中潜藏着各种全局变量（函数），导致命名冲突、作用域污染，没有合理的进行前端模块化；</li>
<li>各页面没有主入口脚本，代码不知从何看起…… </li>
</ul>
<h1 id="阶段2-前端模块化"><a href="#阶段2-前端模块化" class="headerlink" title="阶段2 前端模块化"></a>阶段2 前端模块化</h1><p>2016 年初，我着手重构前端的第一件事就是将前端模块化。</p>
<p>JavaScript 这门语言（或者说老版本 ES5），最为糟糕的地方就是基于全局变量的编程模型（<a href="/2016/03/10/javascript-best-practice/#避免使用全局变量">如何避免使用全局变量？</a>），并且由于不支持“类”与“模块”，使得稍具规模的应用都难以扩展。</p>
<p>一番对比和调研 AMD 和 CMD 规范的相关框架之后，第二阶段决定引入 Require.js（<a href="http://www.requirejs.org/" target="_blank" rel="noopener">英文</a>、<a href="http://www.requirejs.cn/" target="_blank" rel="noopener">中文</a>）这个前端框架。Require.js 以模块化的方式组织前端脚本，通过 AMD 规范定义的两个关键函数 <code>define()</code> 和 <code>require()</code> ，我们可以很轻松的在老版本 ES5 上实现模块化功能，解决模块依赖、全局变量与命名冲突的问题，并提供了统一的脚本主入口。</p>
<p>Require.js 入门教程参考<a href="/2016/07/05/javascript-requirejs/">此前博文</a>。</p>
<h1 id="阶段3-项目分层（前后端分离）"><a href="#阶段3-项目分层（前后端分离）" class="headerlink" title="阶段3  项目分层（前后端分离）"></a>阶段3  项目分层（前后端分离）</h1><p>前端模块化虽然提升了项目的可维护性，但由于此阶段前后端项目仍然强耦合，项目和团队仍存在以下问题：</p>
<ul>
<li>前端完成的 HTML 页面需交付给后端转换为 JSP 页面，多一道无谓的工序。更重要的是，后续前端任何页面修改，都需要通知后端进行同步修改，操作繁琐且易出错；</li>
<li>由于 JSP 页面由后端编写，后端开发如果觉悟不够或者贪图方便，在 JSP 页面中各种 JavaScript 代码信手拈来、Java 变量和 JS 变量混用，导致前后端难以解耦、代码后续难以维护；</li>
<li>后端开发无法专注于业务开发，大量精力浪费于编写前端样式及脚本，分工不明确、不专业。</li>
</ul>
<p>更为重要的是，当下前端领域日新月异，ES 新版本、层出不穷的新框架，SPA 单页技术、CSS 预处理语言、前端性能优化、自动化构建…… 受限于项目结构、迫于后端人员能力，新技术无法推广落地，前端人员能力也无法完全施展。</p>
<p>2016 年中，我开始渐进式的推动前后端分离，为了不让步子太大扯着蛋，前端主体技术栈仍采用 HTML + Require.js + Zepto，后台采用 EasyUI，并重点解决下面两类问题：</p>
<h2 id="引入自动化构建工具"><a href="#引入自动化构建工具" class="headerlink" title="引入自动化构建工具"></a>引入自动化构建工具</h2><p>传统的前端是无需构建的：前端开发编写的 HTML、JS、CSS 可以直接运行在浏览器中，代码所见即所得。但这种传统方式也带来了以下问题：</p>
<ul>
<li>无法根据不同环境构建代码，解决各环境间的差异。例如不同环境下资源引用路径是不同的，生产往往会使用 CDN 域名；</li>
<li>HTML 页面之间各种代码重复，例如一些全局 rem 设置、全局变量、事件，公共样式、脚本、页面布局，提升了维护成本；</li>
<li>JS 脚本没被检查（如静态语法分析），团队协作时代码规范程度无法保证；没有单元测试，潜藏缺陷容易直接流到生产环境；</li>
<li>CSS 样式无法扩展、浏览器兼容性问题处理复杂（如需手工添加厂商前缀）；</li>
<li>静态资源没被合并、压缩，体积大、数量多，导致用户请求慢；</li>
<li>静态资源没被 hash，带来版本管理和缓存问题，更新困难；</li>
<li>静态资源需手工打包上传，操作繁琐；</li>
</ul>
<p>为了解决这些问题，这个阶段我引入了自动化构建工具 <a href="https://www.gulpjs.com.cn/" target="_blank" rel="noopener">Gulp.js</a>，一些使用实践请参考<a href="/2016/12/05/javascript-gulpjs/">此前博文</a>。对于一个前端新手来说，这是一个很大的思维转变，自动化构建极大提升前端项目的工程能力，“构建”阶段能够实现很多之前无法实现的效果。</p>
<h2 id="引入-CSS-预处理语言"><a href="#引入-CSS-预处理语言" class="headerlink" title="引入 CSS 预处理语言"></a>引入 CSS 预处理语言</h2><p>前后端分离后，由于引入构建工具，前端开发能够自由发挥的空间更多了，这个阶段我们还引入了 less，一门 CSS 预处理语言，提升了编写前端样式的效率。</p>
<h2 id="API-接口设计"><a href="#API-接口设计" class="headerlink" title="API 接口设计"></a>API 接口设计</h2><p>前后端分离的另一个重点，在于数据与页面交互方式的改变——服务端渲染 &gt; 前端渲染。因此定义一套统一的 API 接口规范尤其重要。这个阶段我解决掉的问题：</p>
<ul>
<li>跨域方案选型：代理、JSONP、CORS，平衡了浏览器兼容性和开发便利性最终采用 CORS 方案；</li>
<li>接口规范：编写后端 API 网关层框架，大一统全公司项目的接口入参、出参规范及处理流程；</li>
<li>文档管理：前期手工编写 Markdown 文档 &gt; 后期使用 SwaggerUI 自动生成文档；</li>
<li>搭建 API Mock Server，前期 <a href="https://github.com/sanyueyu/gulp-mock-server" target="_blank" rel="noopener">gulp-mock-server</a> &gt; 后期 <a href="http://rapapi.org/org/index.do" target="_blank" rel="noopener">RAP Mock Server</a> ，大大提升前后端并行开发效率。</li>
</ul>
<h1 id="阶段4-项目拆分"><a href="#阶段4-项目拆分" class="headerlink" title="阶段4 项目拆分"></a>阶段4 项目拆分</h1><p>2017 年开始，随着业务做大（新业务越做越多，每周还搞各种运营活动）、人员增多，原来的一两个前端项目已经不能满足快速增长的需求了。这个阶段浮现出来的新问题：</p>
<ul>
<li>人员多、特性多，由于只有几个前端项目，并行开发时 git 分支难以管理，代码合版时容易发生冲突；</li>
<li>测试环境当时只有两套，测试时容易发生代码被覆盖的问题，特性间不好并行测试；</li>
<li>生产发版风险较大，出问题时只能整体回滚，粒度太大，影响前端项目内的其它正常特性。</li>
</ul>
<p>为了解决上述问题，2017 年我们按业务、活动两个维度进行了项目分拆：</p>
<ul>
<li>业务<ul>
<li>帐户项目</li>
<li>非标项目</li>
<li>基金项目</li>
<li>XX 项目 …</li>
</ul>
</li>
<li>活动<ul>
<li>首投活动</li>
<li>邀请活动</li>
<li>XX 活动 …</li>
</ul>
</li>
</ul>
<p>各业务、各项目分而治之，由专门的前端组长统筹、排期、开发、发版，满足各业务的个性化需求及节奏差异。</p>
<p>为了进一步提升开发效率，解决模块及组件的复用问题，这个阶段还：</p>
<ul>
<li>引入了新版 ES6 + Babel 编译器提升 JavaScript 开发效率；</li>
<li>引入了 MV* 库 Vue.js + 自动化构建工具 Webpack，解决之前的 DOM 节点操作 + 事件驱动机制的开发效率低的问题。</li>
<li>引入了 NPM 包管理器，搭建团队专属的仓库（控件库 + 组件库），提升代码复用性。</li>
</ul>
<h1 id="阶段5-重回服务端渲染"><a href="#阶段5-重回服务端渲染" class="headerlink" title="阶段5 重回服务端渲染"></a>阶段5 重回服务端渲染</h1><p>前端技术近年来日新月异，目前 Node.js 的应用已经铺天盖地，Node.js 中间层的出现改变了前后端的合作模式，各大公司前端都把 Node.js 作为前后端分离的新手段，并且在测试、监控等方面沉淀了大量内容。</p>
<p>2018 年起，前端团队也开始在预研 Node.js 技术、搭建各类基础库并尝试在生产中投入使用。以史为鉴，展望未来，只要我们有不断突破自我的勇气，一定能克服困难，让新技术在公司中落地开花，进一步提升团队的开发效率，为公司创造更大的价值。</p>
<p>待续。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://segmentfault.com/a/1190000002413526" target="_blank" rel="noopener">Web前后端分离开发思路</a></p>
<p><a href="http://www.cnblogs.com/whitewolf/p/4686154.html" target="_blank" rel="noopener">前后端分离后的契约</a></p>
<p><a href="https://segmentfault.com/q/1010000008376827/a-1020000008379228" target="_blank" rel="noopener">什么是基于数据驱动的前端框架？</a></p>
</div></article></li></ul><div class="right-container"><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/DNS/" style="font-size: 12.5px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GNU-Linux/" style="font-size: 16.67px;">GNU/Linux</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 19.17px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 11.67px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10.83px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15.83px;">Spring</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 18.33px;">前端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">响应式编程</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 12.5px;">安全</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">并发编程</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 13.33px;">建站</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 12.5px;">管理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.17px;">读书笔记</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 12.5px;">金融</a></div></div><div class="widget"><div class="recent"><h4>最近文章</h4><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/02/26/cpp-io-library/">C/C++ 语言系列（十一）I/O 库总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/25/cpp-oop-inheritance-and-polymorphism/">C/C++ 语言系列（十）面向对象编程之继承与多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/20/cpp-oop-class/">C/C++ 语言系列（九）面向对象编程之类、类模板、类指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/18/cpp-type-aliases/">C/C++ 语言系列（八）复合数据类型之类型别名</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/16/cpp-struct/">C/C++ 语言系列（七）复合数据类型之结构体</a></li></ul></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/page/8/" class="prev">PREV</a><a href="/page/10/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2021 <a href="https://github.com/qidawu" target="_blank">Qida's Blog</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>