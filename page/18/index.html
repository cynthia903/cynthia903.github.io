<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> Qida's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="学习笔记 知识总结 思考感悟"><meta name="keywords"><meta name="author" content="Qida's Blog"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://qidawu.github.io/atom.xml" title="Qida's Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><a href="/" class="title-link">Qida's Blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/15/gnu-bash-shell-builtin-commands/" class="post-title-link">GUN/Bash 系列（五）Shell 内建命令总结</a></h2><div class="post-info">2015-03-15<a href="/tags/GNU-Linux/" title="GNU/Linux" class="post-demo">GNU/Linux</a></div><div class="post-content"><p>GUN/Bash 提供了一些内建命令 (BUILTIN COMMANDS)，用于在命令行上方便使用：</p>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><p><code>echo</code> 显示一行文本或变量</p>
<p><code>unset</code> 取消变量</p>
<p><code>set</code> 查看所有变量（环境变量&amp;用户变量）</p>
<p><code>env</code> 查看所有环境变量（格式好看些）</p>
<p><code>export</code></p>
<ul>
<li>查看所有环境变量</li>
<li>将局部变量转成环境变量：<ul>
<li>可以利用 <code>export</code> 命令将局部变量转为环境变量，但是用户注销时值将丢失；</li>
<li>环境配置文件中，经常会用到 <code>export</code> 命令，相当于每次登录时系统都帮用户 <code>export</code> 一下所需环境变量；</li>
<li>环境变量在当前进程 fork 出来的子进程中也能被访问到；</li>
<li>目前发现安装软件时有用。</li>
</ul>
</li>
</ul>
<p><code>source</code> 或 <code>.</code></p>
<ul>
<li>加载环境配置文件（无须 <code>exit</code> 注销）</li>
<li>执行脚本（在父进程bash中执行，设置的变量都会保留）</li>
</ul>
<p><code>declare</code> 或 <code>typeset</code></p>
<ul>
<li><code>-a</code> 定义数组类型</li>
<li><code>-i</code> 定义整数类型</li>
<li><code>-x</code> 将用户变量转成环境变量（与 <code>export</code> 一样）</li>
<li><code>+x</code> 将环境变量降为用户变量</li>
<li><code>-r</code> 定义 readonly 类型</li>
</ul>
<p><code>read</code> 读取来自键盘输入的变量</p>
<ul>
<li><code>-p</code> 后接提示符</li>
<li><code>-t</code> 后接等待“秒数”</li>
</ul>
<p><code>test</code></p>
<ul>
<li><code>-e</code> 该文件名是否存在（exist）</li>
<li><code>-s</code> 该文件大小是否非 0</li>
<li><code>-z</code> 是否为空字符串（zero）</li>
<li><code>-f</code> 是否为文件（file）</li>
<li><code>-d</code> 是否为目录（directory）</li>
<li><code>-b</code> 是否为块特殊文件（block）</li>
<li><code>-L</code> 是否为连接文件（link）</li>
<li><code>-r</code> <code>-w</code> <code>-x</code> 是否可读、可写、可执行</li>
<li><code>-a</code> <code>-o</code> <code>!</code> 且、或、非</li>
<li><code>-eq</code> <code>-ne</code> <code>-gt</code> <code>-lt</code> <code>-ge</code> <code>-le</code> （判断2个整数）相等、不等、大于、小于、大于等于、小于等于</li>
</ul>
<p><code>[]</code></p>
<ul>
<li>中括号 <code>[]</code> 的使用方法与 <code>test</code> 命令几乎一模一样，只是中括号常用于条件判断式 <code>if…then…fi</code></li>
<li>中括号内的每个元素，都要有<strong>空格符</strong>分隔</li>
<li>中括号内的变量，最好都以<strong>双引号</strong>括起来</li>
<li>中括号内的常量（字符串），最好都以单引号 <code>&#39;&#39;</code> 或双引号 <code>&quot;&quot;</code> 括起来</li>
</ul>
<p><code>sh</code> 以 <code>sh</code> 方式执行，至少需要 <code>r</code> 权限；若以绝对路径方式执行，则需要 <code>r</code> 与 <code>x</code> 权限</p>
<ul>
<li><code>-n</code> 不执行 script，仅验证语法。若语法无误，则不显示任何信息。（貌似仅能验证关键字错误？）</li>
<li><code>-v</code> 在执行 script 前，先将 script 的内容输出到屏幕上</li>
<li><code>-x</code> 将 script 执行过程逐步输出到屏幕上</li>
</ul>
<h1 id="作业控制类"><a href="#作业控制类" class="headerlink" title="作业控制类"></a>作业控制类</h1><p>Bash 是一个多任务的 CLI ，有以下作业控制（Job Control）相关的命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>jobs</code></td>
<td>显示（当前会话中的）后台作业表</td>
</tr>
<tr>
<td><code>fg</code></td>
<td>将后台作业调到前台执行（前台运行作业）</td>
</tr>
<tr>
<td><code>bg</code></td>
<td>继续执行指定的后台作业（后台运行作业）</td>
</tr>
<tr>
<td><code>Ctrl+Z</code></td>
<td>暂停/挂起目前的命令，转入后台运行。通过在命令后追加一个&amp;，可以将该命令转入后台运行</td>
</tr>
<tr>
<td><code>Ctrl+C</code></td>
<td>终止目前的命令</td>
</tr>
</tbody></table>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.gnu.org/software/bash/manual/bashref.html#Shell-Builtin-Commands" target="_blank" rel="noopener">http://www.gnu.org/software/bash/manual/bashref.html#Shell-Builtin-Commands</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/12/gnu-bash-shell-commands/" class="post-title-link">GUN/Bash 系列（四）Shell 管道、重定向、序列、复合命令总结</a></h2><div class="post-info">2015-03-12<a href="/tags/GNU-Linux/" title="GNU/Linux" class="post-demo">GNU/Linux</a></div><div class="post-content"><h1 id="Shell-命令"><a href="#Shell-命令" class="headerlink" title="Shell 命令"></a>Shell 命令</h1><h2 id="简单命令（Simple-Commands）"><a href="#简单命令（Simple-Commands）" class="headerlink" title="简单命令（Simple Commands）"></a>简单命令（Simple Commands）</h2><p>即单个命令。</p>
<h2 id="管道（Pipelines）"><a href="#管道（Pipelines）" class="headerlink" title="管道（Pipelines）"></a>管道（Pipelines）</h2><p>pipeline（管道）是一个或多个命令的序列，用字符 | 分隔。管道的命令格式如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> [ | command2 ... ]</span><br></pre></td></tr></table></figure>

<p>管道的特点如下：</p>
<ul>
<li>管道是一个由“标准输入输出”链接起来的进程集合；</li>
<li>管道中的每个命令都作为单独的进程来执行（即在一个子 shell 中启动）；</li>
<li>每一个进程的输出（stdout）被直接作为下一个进程的输入（stdin）；</li>
<li>管道命令不处理 standard error output（stderr）；</li>
<li>管道的符号为：<code>|</code></li>
</ul>
<p>管道的处理流程如下图：</p>
<p><img src="/img/gnu-text-utilities/pipe.png" alt="pipe"></p>
<h2 id="重定向（Redirection）"><a href="#重定向（Redirection）" class="headerlink" title="重定向（Redirection）"></a>重定向（Redirection）</h2><p>在命令执行前，它的输入和输出可能被 redirected (重定向)，该功能可以用于如下场景：</p>
<ul>
<li>屏幕输出的信息很重要，而且需要将它存下来时；</li>
<li>一些运行命令的可能已知错误信息，想以 <code>2&gt; /dev/null</code> 将它丢掉；</li>
<li>一些系统的例行命令（例如写在 <code>/etc/crontab</code>）的运行结果，需要存下来时；</li>
<li>错误信息与正确信息需要分别输出时。</li>
</ul>
<p>例子：</p>
<p>快速创建带内容的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"hello world"</span> &gt; /tmp/file</span><br><span class="line">$ cat /tmp/file</span><br></pre></td></tr></table></figure>

<p>将已知错误信息丢弃</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find /tmp/ -name 2&gt; /dev/null</span><br></pre></td></tr></table></figure>

<h3 id="描述符（Descriptor-Number）"><a href="#描述符（Descriptor-Number）" class="headerlink" title="描述符（Descriptor Number）"></a>描述符（Descriptor Number）</h3><table>
<thead>
<tr>
<th>描述符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td>标准输入（stdin）</td>
</tr>
<tr>
<td><code>1</code></td>
<td>标准输出（stdout）</td>
</tr>
<tr>
<td><code>2</code></td>
<td>标准错误输出（stderr）</td>
</tr>
</tbody></table>
<h3 id="操作符（Operator）"><a href="#操作符（Operator）" class="headerlink" title="操作符（Operator）"></a>操作符（Operator）</h3><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;</code></td>
<td>重定向输入（Redirecting Input）</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>重定向输出（Redirecting Output），与 <code>1&gt;</code> 等价</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>追加到重定向输出（Appending Redirected Output）</td>
</tr>
<tr>
<td><code>2&gt;</code></td>
<td>重定向错误输出（Redirecting Error）</td>
</tr>
<tr>
<td><code>2&gt;&gt;</code></td>
<td>追加到重定向错误输出（Appending Redirected Error）</td>
</tr>
<tr>
<td><code>&amp;&gt;</code></td>
<td>重定向标准输出和标准错误输出（Redirecting Standard Output and Standard Error）。 <strong>推荐使用</strong>，它与 <code>&gt;word 2&gt;&amp;1</code> 在语义上等价</td>
</tr>
<tr>
<td><code>&gt;&amp;</code></td>
<td>同上，但不推荐使用</td>
</tr>
<tr>
<td><code>2&gt;&amp;1</code></td>
<td>将标准错误输出重定向到标准输出</td>
</tr>
</tbody></table>
<h2 id="序列（Lists-of-Commands）"><a href="#序列（Lists-of-Commands）" class="headerlink" title="序列（Lists of Commands）"></a>序列（Lists of Commands）</h2><p>list（序列）是一个或多个管道，用操作符 <code>;</code>、<code>&amp;</code>、<code>&amp;&amp;</code>、<code>||</code> 分隔的序列, 并且可以选择用 <code>;</code>、<code>&amp;</code>、<code>&lt;newline&gt;</code> 新行符结束。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>例子</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td>command1 &amp;&amp; command2</td>
<td>一个 AND 序列。command2 只有在 command1 返回 0 时才被执行</td>
</tr>
<tr>
<td><code>&#124;&#124;</code></td>
<td>command1 &#124;&#124; command2</td>
<td>一个 OR 序列。command2 只有在 command1 返回非 0 状态时才被执行</td>
</tr>
<tr>
<td><code>;</code></td>
<td>command1; command2</td>
<td>结束一个序列。不考虑命令的退出状态，连续执行命令</td>
</tr>
<tr>
<td><code>&lt;newline&gt;</code></td>
<td>command&lt;newline&gt;</td>
<td>结束一个序列</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>command1 &amp;</td>
<td>如果一个命令是由 &amp; 结束的, shell 将在后台的子 shell 中执行这个命令</td>
</tr>
</tbody></table>
<ul>
<li>AND 和 OR 序列的返回状态是序列中最后执行的命令的返回状态。</li>
<li>这些序列操作符中， <code>&amp;&amp;</code> 和 <code>||</code> 优先级相同， <code>;</code> 和 <code>&amp;</code> 优先级相同。</li>
</ul>
<h3 id="退出状态（Exit-Status）"><a href="#退出状态（Exit-Status）" class="headerlink" title="退出状态（Exit Status）"></a>退出状态（Exit Status）</h3><ul>
<li>从 shell 的角度看，一个命令退出状态是 0 意味着成功退出。 非零状态值表明失败。</li>
<li>如果没有找到命令，为执行它而创建的子进程返回 127。</li>
<li>如果找到了命令但是文件不可执行，返回状态是 126。</li>
<li>如果命令由于扩展或重定向错误而失败，退出状态大于零。</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在某些情况下，很多命令我想要一次输入去运行，有两种方法：</p>
<ol>
<li>Shell Script</li>
<li>使用序列</li>
</ol>
<p>例如，一串无人值守源代码形式安装的命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h2 id="复合命令（Compound-Commands）"><a href="#复合命令（Compound-Commands）" class="headerlink" title="复合命令（Compound Commands）"></a>复合命令（Compound Commands）</h2><p>compound command（复合命令）是如下情况之一：</p>
<ul>
<li><p><code>(list)</code></p>
</li>
<li><p><code>{ list; }</code></p>
</li>
<li><p><code>((expression))</code></p>
</li>
<li><p><code>[[ expression ]]</code></p>
</li>
<li><p><code>if list; then list; [ elif list; then list; ] ... [ else list; ] fi</code></p>
</li>
<li><p><code>case word in [ [(] pattern [ | pattern ]</code></p>
</li>
<li><p><code>while list; do list; done</code></p>
</li>
<li><p><code>until list; do list; done</code></p>
</li>
<li><p><code>for name [ in word ] ; do list ; done</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一个数组变量</span></span><br><span class="line">order_array=(</span><br><span class="line">  10000</span><br><span class="line">  10001</span><br><span class="line">  10002</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环打印与保存到文件</span></span><br><span class="line"><span class="keyword">for</span> id <span class="keyword">in</span> <span class="variable">$&#123;order_array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"order is <span class="variable">$id</span>"</span> | tee -a result.txt</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>for (( expr1 ; expr2 ; expr3 )) ; do list ; done</code></p>
</li>
<li><p><code>select name [ in word ] ; do list ; done</code></p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Arrays" target="_blank" rel="noopener">https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Arrays</a></p>
<p><a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Commands" target="_blank" rel="noopener">https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Commands</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/10/gnu-bash-shell-quoting-and-params/" class="post-title-link">GUN/Bash 系列（三）Shell 引用与参数总结</a></h2><div class="post-info">2015-03-10<a href="/tags/GNU-Linux/" title="GNU/Linux" class="post-demo">GNU/Linux</a></div><div class="post-content"><h1 id="Shell-语法"><a href="#Shell-语法" class="headerlink" title="Shell 语法"></a>Shell 语法</h1><h2 id="引用（Quoting）"><a href="#引用（Quoting）" class="headerlink" title="引用（Quoting）"></a>引用（Quoting）</h2><p>引用用于：</p>
<ul>
<li>阻止对特殊字符的处理。</li>
<li>阻止保留字被识别。</li>
<li>阻止参数的扩展。</li>
</ul>
<p>三种引用机制：</p>
<table>
<thead>
<tr>
<th>引用符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>转义字符 <code>\</code></td>
<td>保留其后下一个字符的字面意义</td>
</tr>
<tr>
<td>单引号 <code>&#39;&#39;</code></td>
<td>保留引用中所有字符的字面意义</td>
</tr>
<tr>
<td>双引号 <code>&quot;&quot;</code></td>
<td>保留引用中所有字符的字面意义，例外的情况是 $, `, 和 \</td>
</tr>
</tbody></table>
<p>单引号与双引号的使用区别：</p>
<p><img src="/img/gnu-linux/bash_quoting.png" alt="quoting"></p>
<p>注意，反引号 <code>`</code> 与单引号 <code>&#39;&#39;</code> 和双引号 <code>&quot;&quot;</code> 作用不同，是用于命令替换（Command Substitution），详见《Shell 常用扩展总结》。</p>
<h2 id="注释（Comments）"><a href="#注释（Comments）" class="headerlink" title="注释（Comments）"></a>注释（Comments）</h2><p>以 <code>#</code> 起始的词使得这个词和所有同一行上所有剩余的字符都被忽略。</p>
<h1 id="Shell-参数（Shell-Parameters）"><a href="#Shell-参数（Shell-Parameters）" class="headerlink" title="Shell 参数（Shell Parameters）"></a>Shell 参数（Shell Parameters）</h1><p><em>参数（Parameter）</em>是存储值的实体。它可以是以下三类：</p>
<ul>
<li>变量</li>
<li>位置参数</li>
<li>特殊参数</li>
</ul>
<h2 id="变量（Varialbe）"><a href="#变量（Varialbe）" class="headerlink" title="变量（Varialbe）"></a>变量（Varialbe）</h2><p>变量，即用<em>名称（name）</em>表示的参数，其具有<em>值（value）</em>以及零或多个<em>属性（attributes）</em>。</p>
<ul>
<li><p>通过 <code>$name</code> 引用，在双引号 <code>&quot;&quot;</code> 中可以被引用。</p>
</li>
<li><p>通过以下语句为变量赋值：<code>name=[value]</code>。如果变量未赋值，默认值为 <code>null</code> 字符串。</p>
</li>
<li><p>通过内建命令 <code>unset</code> 为取消变量。</p>
</li>
<li><p>通过内建命令 <code>declare</code> 为变量分配<em>属性（attributes）</em>。</p>
</li>
</ul>
<p>所有值都接受以下扩展：</p>
<ul>
<li>tilde expansion</li>
<li>parameter and variable expansion</li>
<li>command substitution</li>
<li>arithmetic expansion</li>
<li>quote removal</li>
</ul>
<h2 id="位置参数（Positional-Parameters）"><a href="#位置参数（Positional-Parameters）" class="headerlink" title="位置参数（Positional Parameters）"></a>位置参数（Positional Parameters）</h2><p><code>$n</code>：<code>$1</code> 表示第一个参数，<code>$2</code> 表示第二个参数，以此类推。</p>
<h2 id="特殊参数（Special-Parameters）"><a href="#特殊参数（Special-Parameters）" class="headerlink" title="特殊参数（Special Parameters）"></a>特殊参数（Special Parameters）</h2><p><code>$0</code>：表示脚本文件名</p>
<p><code>$#</code>：表示命令行参数的个数</p>
<p><code>$?</code>：前一个命令或函数的返回码，<code>0</code> 为成功，非 <code>0</code> 为错误/失败</p>
<p><code>$*</code>：以”参数1 参数2 … “ 的形式保存所有参数</p>
<p><code>$@</code>：以”参数1” “参数2” … 的形式保存所有参数</p>
<p><code>$$</code>：本程序的 PID（进程 ID 号）</p>
<p><code>$!</code>：最近执行的后台（即异步）命令的 PID</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html" target="_blank" rel="noopener">https://www.gnu.org/software/bash/manual/html_node/Quoting.html</a></p>
<p><a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Parameters" target="_blank" rel="noopener">https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Parameters</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/05/gnu-bash-shell-invocation/" class="post-title-link">GNU/Bash 系列（二）Shell 启动流程</a></h2><div class="post-info">2015-03-05<a href="/tags/GNU-Linux/" title="GNU/Linux" class="post-demo">GNU/Linux</a></div><div class="post-content"><p>了解完什么是 Shell，有哪些 Shell 类型之后，本文开始主要关注 Bash Shell。</p>
<h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><ol>
<li>/bin/login 程序首先会检查 <code>/etc/passwd</code> 文件，在这个文件里包含了用户名、密码和该用户的登录 shell，如 /bin/bash 。 /bin/login 在子进程里用 <code>execve</code> 调用了 /bin/bash 。</li>
<li>/bin/bash 读取 <strong>启动文件</strong> 并启动</li>
<li>/bin/bash 处理用户键入的命令</li>
</ol>
<ul>
<li>在执行磁盘上某个程序时，我们通常不会指定这个程序文件的绝对路径，比如要执行 <code>echo</code> 命令时，我们一般不会输入 <code>/bin/echo</code> ，而仅仅是输入 <code>echo</code> 。那为什么这样 bash 也能够找到 /bin/echo 呢？原因是 Linux 操作系统支持这样一种策略：shell 的一个环境变量 PATH 里头存放了程序的一些路径，当 shell 执行程序时会去这些目录下查找。</li>
<li><code>which</code> 作为 shell（这里特指 bash ）的一个内置命令，如果用户输入的命令是磁盘上的某个程序，它会返回这个文件的全路径。</li>
</ul>
<h1 id="启动文件"><a href="#启动文件" class="headerlink" title="启动文件"></a>启动文件</h1><h2 id="交互式-shell"><a href="#交互式-shell" class="headerlink" title="交互式 shell"></a>交互式 shell</h2><p>Bash 如何执行它的启动文件？交互式 shell（interactive shell）下需要区分两种情况：</p>
<h3 id="login-shell"><a href="#login-shell" class="headerlink" title="login shell"></a>login shell</h3><p>在下列情况下，我们可以获得一个 login shell：</p>
<ul>
<li>登录系统时获得的顶层 shell，无论是通过本地终端登录，还是通过网络 <code>ssh</code> 登录。这种情况下获得的 login shell 是一个交互式 shell。</li>
<li>在终端下使用 <code>--login</code> 选项调用 bash，可以获得一个交互式 login shell。</li>
<li>在脚本中使用 <code>--login</code> 选项调用 bash（比如在 shell 脚本第一行做如下指定：<code>#!/bin/bash --login</code>），此时得到一个非交互式的 login shell。</li>
<li>使用 <code>su -</code> 切换到指定用户时，获得此用户的 login shell。如果不使用 <code>-</code>，则获得 non-login shell。</li>
</ul>
<p>login shell 与 non-login shell 的主要区别在于它们启动时会读取不同的配置文件，从而导致环境不一样。login shell 启动时：</p>
<ul>
<li><p>首先读取全局配置：<code>/etc/profile</code></p>
</li>
<li><p>然后依次查找以下三个文件，读取第一个找到且可读的文件：</p>
<ul>
<li><code>~/.bash_profile</code></li>
<li><code>~/.bash_login</code></li>
<li><code>~/.profile</code></li>
</ul>
</li>
<li><p>退出时，读取：<code>~/.bash_logout</code></p>
</li>
</ul>
<h3 id="no-login-shell"><a href="#no-login-shell" class="headerlink" title="no login shell"></a>no login shell</h3><p>交互式的 non-login shell 启动时，会读取：</p>
<ul>
<li><code>~/.bashrc</code></li>
</ul>
<p>通常我们要定制一些配置时（例如 alias 别名），会将配置写在 <code>~/.bashrc</code> 中，然后在 <code>~/.bash_profile</code> 中读取 <code>~/.bashrc</code>，这样可以保证 login shell 和 non-login shell 得到相同的配置:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> -f ~/.bashrc &amp;&amp; . ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>至于 <code>/etc/profile</code> 就不要轻易去改啦，毕竟会影响系统全局的配置。</p>
<h2 id="非交互式-shell"><a href="#非交互式-shell" class="headerlink" title="非交互式 shell"></a>非交互式 shell</h2><ul>
<li><p>当 Bash 以非交互的方式（non-interactive shell）启动时，<strong>例如在运行一个 shell 脚本时</strong>，它会查找环境变量 <code>BASH_ENV</code>，如果存在则将它的值展开，使用展开的值作为一个文件的名称，读取并执行。 Bash 运作的过程就如同执行了下列命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$BASH_ENV</span>"</span> ]; <span class="keyword">then</span> </span><br><span class="line">    . <span class="string">"<span class="variable">$BASH_ENV</span>"</span>; </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其它情况：</p>
<blockquote>
<p>Aliases are not expanded when the shell is not interactive.</p>
<p>Functions are executed in the context of the current shell; no new process is created to interpret them (contrast this with the execution of a shell script).</p>
</blockquote>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="http://www.gnu.org/software/bash/manual/bashref.html#Bash-Startup-Files" target="_blank" rel="noopener">Bash Startup Files</a>》</p>
<p>《<a href="http://www.gnu.org/software/bash/manual/bashref.html#Interactive-Shells" target="_blank" rel="noopener">Interactive Shells</a>》</p>
<p>《<a href="http://linux.chinaunix.net/techdoc/develop/2008/09/16/1032346.shtml" target="_blank" rel="noopener">使用$BASH_ENV来提权</a>》</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/03/01/what-is-shell/" class="post-title-link">GNU/Bash 系列（一）什么是 Shell？</a></h2><div class="post-info">2015-03-01<a href="/tags/GNU-Linux/" title="GNU/Linux" class="post-demo">GNU/Linux</a></div><div class="post-content"><h1 id="什么是-Shell-？"><a href="#什么是-Shell-？" class="headerlink" title="什么是 Shell ？"></a>什么是 Shell ？</h1><ul>
<li>一个命令行解释器，用于将用户输入的命令转换为系统操作；</li>
<li>Shell 既是交互式命令语言（CMD），也是脚本编程语言（Script）；</li>
<li>Shell 有很多内置在其源代码中的命令。这些命令是内置的，所以 Shell 不必到磁盘上搜索它们，执行速度因此加快。不同的 Shell 内置命令有所不同；</li>
</ul>
<h1 id="有哪些-Shell-？"><a href="#有哪些-Shell-？" class="headerlink" title="有哪些 Shell ？"></a>有哪些 Shell ？</h1><h2 id="GUI-Graphical-User-Interface"><a href="#GUI-Graphical-User-Interface" class="headerlink" title="GUI (Graphical User Interface)"></a>GUI (Graphical User Interface)</h2><ul>
<li>GNOME</li>
<li>KDE</li>
<li>……</li>
</ul>
<h2 id="CLI-Command-Line-Interface"><a href="#CLI-Command-Line-Interface" class="headerlink" title="CLI (Command Line Interface)"></a>CLI (Command Line Interface)</h2><p>CLI 实际上是一个程序，比如 /bin/bash 。它是一个实实在在的程序，它打印提示符(PROMPT)，接受用户输入的命令，分析命令序列并执行然后返回结果。</p>
<ul>
<li>Bourne Shell (sh)<ul>
<li>即 sh，是影响最广的 shell 。 1977 年由 Stephen Bourne 在贝尔实验室编写。虽无明文规定，但已成为事实上的标准；</li>
<li>引入了 shell 通用的、基础的功能，例如管道、变量、条件判断、循环等；</li>
<li>全部类 Unix 系统，都至少有一个与 sh 兼容的shell；</li>
<li>sh 一般位于 /bin/sh。目前大部分系统，/bin/sh 都是一个链接，指向一个兼容 sh 的、功能更丰富的 shell，如 bash；</li>
</ul>
</li>
<li>C Shell (csh)<ul>
<li>即 csh，1978年由 Bill Joy 在伯克利大学毕业后编写；</li>
<li>Bill Joy，Sun 联合创始人，vi 作者，BSD 作者；</li>
<li>csh 更加注重交互式使用而非脚本应用，引入了历史功能、别名、目录栈、作业控制等功能；</li>
</ul>
</li>
<li>Bourne Again Shell (bash)<ul>
<li>即 bash，1989年由 Brian Fox 为 GNU 项目编写。</li>
<li>综合了 sh、csh、ksh 等各种 shell 的特性；</li>
<li>名字有双关含义，既是字面上的意思，用于替换 sh，也隐含为了 GNU 而 born again 的意思；</li>
<li>是 Mac OS X 和大部分 Linux 发行版的默认 shell；</li>
</ul>
</li>
<li>Korn Shell (ksh)</li>
<li>Z Shell (zsh)</li>
<li>TENEX C Shell (tcsh)</li>
<li>……</li>
</ul>
<h1 id="GUI-和-CLI-如何切换？"><a href="#GUI-和-CLI-如何切换？" class="headerlink" title="GUI 和 CLI 如何切换？"></a>GUI 和 CLI 如何切换？</h1><p>切换到 tty1 ~ tty6 终端：<code>Ctrl + Alt + [F1 ~ F6]</code></p>
<p>切换到 GUI：<code>Ctrl + Alt + [F7]</code></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2015/01/01/more-joel-on-software/" class="post-title-link">《软件随想录》读书笔记</a></h2><div class="post-info">2015-01-01<a href="/tags/读书笔记/" title="读书笔记" class="post-demo">读书笔记</a><a href="/tags/管理/" title="管理" class="post-demo">管理</a></div><div class="post-content"><p>《<a href="https://item.jd.com/10063970.html?dist=jd" target="_blank" rel="noopener">软件随想录</a>》是一本有趣的技术书籍，阮一峰翻译的，值得一读。它总结了作者多年的从业经验，读完之后，感觉是从另一个更高的维度去提升了程序员的思维境界。</p>
<p>下面摘录整理了一些读书笔记：</p>
<h1 id="人员管理"><a href="#人员管理" class="headerlink" title="人员管理"></a>人员管理</h1><ol>
<li>不懂编程的人管理软件公司，就好像不懂冲浪的人硬要去冲浪。</li>
<li>如同所有行业中最好的人才一样，那些优秀的程序员是不会出现在招聘市场上的。通常优秀的程序员在整个职业生涯中，可能会有 4 次求职。</li>
<li>找到优秀的程序员的 3 个基本方法：<ol>
<li>走出去，不要只会上招聘网站</li>
<li>实习生</li>
<li>建立自己的社区（community）</li>
</ol>
</li>
<li>员工推荐：小心陷阱。谨记仍然要要求应聘者通过剩下的所有面试，坚持高标准不变。</li>
<li>Aeron 牌电脑椅，靠背和坐垫都被设计成网状形，空气可以自由流通，所以坐着不会捂汗。带有腰部支撑和后部平衡装置的顶级系列新型号，再加上尺寸如果正确，并且调节到最合适的位置，那么大多数人坐一整天都不会感到不舒服。</li>
<li>当一个程序员抱怨“人际关系复杂”时，他们的意思明白无误，就是指任何<strong>个人因素超过技术因素的环境</strong>。</li>
<li>互联网公司的三种管理方法：<ol>
<li><strong>军事化管理法</strong><ol>
<li>在软件开发团队中，每个人干的活都不一样，所以如果想进行微观管理，就会变成抽风式 （hit-and-run） 的管理（大多数时候管理层对程序员不闻不问，偶尔却心血来潮介入，追问一些及其微小的细节，或坚持一定要百分之百按照他们的方式或需求做出来）。</li>
</ol>
</li>
<li><strong>经济利益驱动法</strong><ol>
<li>如果你使用经济利益驱动法，你就是在鼓励程序员与制度博弈。经济利益驱动法的问题是，它将内部激励变成了外部激励。认同法的作用恰恰相反，是为了设法创造出内部激励。</li>
</ol>
</li>
<li><strong>认同法</strong><ol>
<li>认同法要求你创造一个有凝聚力的、像胶水一样粘在一起的团队，就好像家庭一样。这样一来，人们就会对他们的同事产生忠诚感和义务感。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="写给未来程序员的建议"><a href="#写给未来程序员的建议" class="headerlink" title="写给未来程序员的建议"></a>写给未来程序员的建议</h1><ol>
<li>对于某些最激动人心的编程任务来说，指针仍然是非常重要的。比如说，如果不用指针，你根本没办法开发Linux的内核。如果你不是真正地理解了指针，你连一行Linux的代码也看不懂，说实话，任何操作系统的代码你都看不懂。</li>
<li>如果你不懂<strong>函数式编程</strong>，你就无法创造出 MapReduce，正是这种算法使得 Google 的可扩展性达到如此巨大的规模。术语“Map”（映射）和“Reduce”（化简）分别来自Lisp语言和函数式编程。</li>
<li>消灭软件代码中的缺陷是一件<strong>边际报酬递减</strong>（随着软件中的缺陷越来越少，修复每一个缺陷所带来的收益也在变小）的事情。</li>
<li>有一种恐怖的东西叫做“<strong>内部软件”（inhouse software）</strong>，做一个内部程序员（ in-house programmer ）糟透了：<ol>
<li>你永远无法用正确的方法、而是被迫用最保险的方法做事。</li>
<li>内部软件只要“能用了”就会停止开发，因此你永远做不出优秀的产品。但如果你开发的是一个商用软件，你就可以不断对它加工、打磨、优化和改良。</li>
<li>如果你在专业的软件公司中编程，你的工作与公司的主营业务直接相关，是能够为公司直接带来收入的。这至少意味着一件事情，就是管理层会想到你。也就是说，你能得到最好的福利、最舒适的办公环境和最佳的晋升机会。</li>
</ol>
</li>
<li>那些决定游戏规则的人都是<strong>善于写作的人</strong>。能不能清晰地写出技术内容的文章决定了你是一个口齿不清的程序员还是一个领袖。</li>
<li>读《微观经济学》，因为从经营一家公司的角度来看，比起那些不懂的程序员，一个理解基本商业规则的程序员将会更有价值，就是这么简单。</li>
</ol>
<h1 id="管理大型项目"><a href="#管理大型项目" class="headerlink" title="管理大型项目"></a>管理大型项目</h1><ol>
<li>网页设计师现在的处境，其实犹太人早在几十年前就体会到了，那就是所有人都同意遵守同一部法典并不能保证所有人的行为都符合同样的规范。因为法条太复杂、太深奥、太难懂了，想要完全正确地理解法条几乎是不可能的。</li>
<li>标准（如W3C）当然很重要的，但是你不能迷信标准，你必须理解由于人为犯错，所以标准有时候会引发误解、困惑、甚至是争议。</li>
<li>这是一个很好的例子，说明了“实用主义者”与“理想主义者”两大阵营之间存在的巨大鸿沟：用户升级新版IE后，无法“正常”浏览网站。他们不会为理想主义者那愚蠢的信仰叫好，不会理解为什么你们一定要网络浏览器符合某些神秘的、柏拉图式理想化的、实际上根本还没有实现的“标准”。他们不想听你们讲那些丑陋的Hack，他们只想要网络浏览器能够正常浏览现实中的网站。</li>
<li>理想主义者在大原则上是百分之百正确的。同样，实用主义者在现实中也是正确的。这场争论将精确地把世界分成两半，两大阵营之间的口水战将持续下去。</li>
<li>优秀的设计似乎是最容易复制的东西，但是做起来却又不是那么容易，因为做出优秀的设计本身就是一件“麻烦事”，实际上能够提供牢固得令人震惊的竞争优势。</li>
</ol>
<h1 id="编程建议"><a href="#编程建议" class="headerlink" title="编程建议"></a>编程建议</h1><ol>
<li>循证式日程规划(Evidence-Based Scheduling)<ol>
<li>循证式日程规划先收集历史数据，主要来源是过去的time sheet，然后统计分析，得到了一条概率分布曲线，显示在任一个给定日期你完成工作的可能性有多大。</li>
<li>蒙特卡洛方法(Monte Carlo method)模拟未来各种可能的结果。</li>
<li>将每个任务所需的时间控制在16小时之内，这就会迫使你好好地去规划你要造成的那个任务。</li>
<li>几条经验：<ol>
<li>只有第一线的程序员才能提出完成日期的估计值。任何管理层制定然后交给程序员去执行的日程规划，都注定会失败。只有真正负责开发的程序员才能估计出完成任务需要哪些步骤。</li>
<li>一发现错误就立即修正，将用时算入原始任务的用时之中。</li>
<li>防止管理层向程序员施加压力，被要求加快开发速度。如果程序员的进度落后于日程，就会感到惶惶不可终日，非常沮丧，这时再大的激励也是没用的。如果程序员的进度快于日程，则会感到欢欣鼓舞，工作效率非常高，这时根本不需要激励。日程规划并不是一个玩心理游戏的地方。</li>
<li>一份日程规划的好处之一，就是你会在工作开始之前，就被迫删去一些次要的或无用的功能，从而全力开发有用的或重要的功能。正是这种迫使你砍掉某些功能的压力，使得你最终做出一个更强大、更优秀的产品，它包括了很好的功能组合，而且能够在较早的日期完成。</li>
</ol>
</li>
<li>有效的日程规划是创造优秀软件的钥匙。它强迫你首先完成最重要的功能，让你做出正确的选择，思考要开发一个怎样的软件。这会使你的产品变得更出色，使你的老板感到更开心，使你的客户感到更满意，以及更重要的一点，那就是使你下午6点能够准时下班。</li>
</ol>
</li>
<li>战略问题<ol>
<li>从长远的观点来看，那些不关心效率、不关心程序是否臃肿、一个劲往软件中加入高级功能的程序员最终将拥有更好的产品。</li>
<li>过去的积累可能会变成＂历史包袱＂。</li>
</ol>
</li>
<li>编程<ol>
<li>将“循环操作”这个单独的步骤抽象出来，用任何你想用的方法完成这个步骤，其中就包括用额外的硬件将运算过程轻松地扩展（Scale）到多台服务器上。谷歌的许多应用程序都使用了这种MapReduce技术，所以一旦有人对底层的并行计算程序进行优化或消除bug，那么所有这些应用程序都会受益。</li>
<li>寻找一种代码的书写规范，让错误的代码变得容易被看出。让代码中的相关信息在显示屏上集中在一起，使你能够当场发现和改正某些种类的错误。</li>
<li>“应用型匈牙利命名法”（Apps Hungarian）是有价值的，它加强了代码之间的联结，使得代码更容易阅读、书写、除错和维护。最重要的是，它让错误的代码容易现形。</li>
</ol>
</li>
</ol>
<h1 id="开办软件公司"><a href="#开办软件公司" class="headerlink" title="开办软件公司"></a>开办软件公司</h1><ol>
<li>三点意见<ol>
<li>如果你说不清楚你的软件解决了什么棘手的问题，就不要去开软件公司。</li>
<li>不要独自一人创办公司。一个人创业十分孤独和压抑没有任何人与你交流思想，为你出谋划策。要是有两个人一起创业，你就会感到对你的合伙人负有义务，就会努力撑下去，渡过难关。</li>
<li>一开始不要抱有太高期望。</li>
</ol>
</li>
<li>为什么低成本的软件供应商就不能在软件业中生存下来呢？我们只雇用最便宜的程序员为什么就是不行？根本原因是软件的销售复制成本为 0。这意味着，程序员的劳动力成本分摊在你销售出去的所有软件中，对软件来说，如果销售量很大，质量的改进成本并不会造成单位软件成本的上升。相反，软件质量的改进还会创造出新价值，而且价值创造的速度要快于成本提升的速度。</li>
<li><strong>布鲁克斯法则（Brooks’ Law）</strong> ——向一个已经延误的软件项目增加人手，只会使它更加延误。一个优秀的程序员独自完成一项任务，就不需要额外的沟通和协调。如果同样的任务让 5 个程序员一起完成，他们之间就必须沟通和协调，这会花掉大量时间。开发团队越小，就越能获得额外的收益。人力与工时的互换只是一个神话。</li>
<li>用许多平庸的程序员取代少数优秀的程序员，这种做法的真正问题在于，不管平庸的程序员工作多长时间，他们做出来的东西都无法像优秀程序员做得那样好。</li>
<li>令人难过的是，内部软件很少重要到需要雇用巨星/优秀程序员来开发。这就是为什么最令人满意的职业生涯往往是在真正的软件公司里，而不是在银行担任 IT 技术人员。</li>
</ol>
<h1 id="经营软件公司"><a href="#经营软件公司" class="headerlink" title="经营软件公司"></a>经营软件公司</h1><ol>
<li>软件开发中，对你最重要、最关键的部分，一定要使用更原始的工具。至少也要使用<strong>开源/自由软件</strong>，这样至少出错的时候，你多多少少有机会解决问题，不会被解雇。</li>
<li>建立优质客服<ol>
<li>技术支持团队必须能够<strong>与开发团队直接沟通</strong>，这很关键，这意味着你不能把技术支持人员外包出去，他们必须与开发人员在同一个地址办公，必须有途径让问题得到直接和彻底的解决。</li>
<li>当软件每次发生问题都被彻底解决之后，所有常见和容易的问题都被消灭了，技术支持工作实际上就变成了处理疑难杂症，对程序来说这意味着要进行调试和除错。因此对技术支持人员的要求更高、培训力度要更大。</li>
<li>很多时候，为了避免冒犯客户，我们要求客户去检查某样东西，都可以这样表达：不是直接要求他们去检查某个设置，而是告诉他们先改变这个设置，然后再改回去，目的是“<strong>确保这个设置被成功保存</strong>”。</li>
<li>客户投诉的时候，人很容易就变得感情用事。解决方法是记住一些重要句子，不断练习把它们说出口。等到你需要用到它们的场合，你就会把冲动自动抛在脑后，转而让客户开心。</li>
<li>同客户争吵，你永远不会是赢家。</li>
</ol>
</li>
</ol>
<h1 id="挑选发布日期"><a href="#挑选发布日期" class="headerlink" title="挑选发布日期"></a>挑选发布日期</h1><ol>
<li>软件功能必须<strong>按照优先顺序</strong>排序，否则一切将会变糟。只要你一不注意，你手下的程序员就会按照趣味性的顺序开发各项功能，你就将因此无法按时发布软件，或者无法取消部署某项功能，因此你就会陷入很被动的局面。</li>
<li>市场分割，即根据你的客户愿意支付的价格将他们分成不同的组，从每个客户身上赚取最大的消费者剩余，是一种有效的定价手段。但是长远来看，这种价格歧视会对你的产品形象产生显著的负面影响。</li>
<li>当消费者对商品所知有限时，消费者通常就会认为比较贵的商品就是质量比较高。</li>
<li>当你在制定价格时，你就是在发出信号。</li>
</ol>
<h1 id="修订软件"><a href="#修订软件" class="headerlink" title="修订软件"></a>修订软件</h1><ol>
<li>如果通过测量某些无意义的静态指标来改进工作，那是无用的。我们真正需要的是一个能够不断改进工作质量的流程：先询问五个为什么，找到根本性的原因，告诉客户为了防止类似故障再次发生我们所采取的举措。书写一份标准、详细的操作流程和确认清单，所有操作步骤都严格按照流程一一操作。目标的：我们遇到的所有引起服务中断的故障都是真正由于极其罕见的、无法预料的＂黑天鹅因素＂而引起的。</li>
<li>不要开发那些销售人员无意间答应某个客户的功能，也不要因为＂反正迟早要做＂而先去开发那些不重要尽管有趣味性的功能。</li>
</ol>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/05/01/secret-of-great-management/" class="post-title-link">《门后的秘密：卓越管理的故事》读书笔记</a></h2><div class="post-info">2014-05-01<a href="/tags/读书笔记/" title="读书笔记" class="post-demo">读书笔记</a><a href="/tags/管理/" title="管理" class="post-demo">管理</a></div><div class="post-content"><p>《<a href="https://e.jd.com/30336925.html" target="_blank" rel="noopener">门后的秘密：卓越管理的故事</a>》是一本薄薄的书，前半部分，作者以讲故事、对话录的新颖形式生动地再现了软件行业技术管理工作的场景；后半部分，作者精心总结了各种工作的管理技巧和实用方法。不管你是管理新手还是老兵都可以学到一些管理技巧。</p>
<p>下面摘录整理了一些读书笔记：</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>差劲的经理好像总是忙忙碌碌，制造出高效率的假象；中等水平的经理能够完成工作，但却不一定是应该做的工作；卓越的经理不仅会达到工作目标，还能够培养员工。</li>
<li>敏捷项目团队可以管理自身的工作——为工作任务分配责任负责人、监控项目进展并且解决问题，这样经理就可以解放出来，将工作重点放在清除团队进程中的障碍、解决更加重大的问题上。</li>
<li>管理者会放大他人的工作结果，所以，失败的管理所耗费的人力资源成本甚至要高于经济成本。有些对组织至关重要的人选择离开团队，正是因为他们拒绝与差劲的经理共同工作，因为这些经理挫败团队士气、降低团队的工作效率。</li>
<li>管理者要与各种类型的人进行交流，这些人性格不同，技术水平不同，动机也不一样。因为这些交流大部分都是一对一的面谈，或者经理们聚集在会议室里关起门来讨论问题，所以其他人无法知晓这些工作是如何进行的。</li>
</ul>
<h1 id="了解部门成员和工作"><a href="#了解部门成员和工作" class="headerlink" title="了解部门成员和工作"></a>了解部门成员和工作</h1><ul>
<li><p>要想领导他人，首先要先了解他们。当你进入一个新的组织或开始新的工作时，首先要知道三件事：</p>
<ul>
<li>这些人是谁，他们的优点和兴趣是什么，他们正在从事什么工作；</li>
<li>团队的既定任务以及该团队如何产生价值；</li>
<li>你的团队是如何与整个组织机构相契合的。</li>
</ul>
</li>
<li><p>通过一对一的面谈，你的员工会了解你对他们的期待是什么。你肯花时间与他们相处，会让他们觉得你非常重视他们。</p>
</li>
<li><p>不建议大家整天坐在员工的办公室里监视他们的工作。这种做法，往好了说是令人生厌的微观管理法，往糟了说，是导致团队的生产效率下降的粗暴干预。</p>
</li>
<li><p>对下属进行人性化的关怀。当有人称赞在自己的上司时，说的第一句话就是：”它很有人情味，非常关心我。”</p>
</li>
<li><p>如果办不到，就不要主动提供帮助。</p>
</li>
<li><p>多重任务处理：</p>
<ul>
<li>同时进行两项相关的工作或任务时，工作效率和生产率可以得到提高。因为当一个人做一项工作的时候，可以将思维转到另一项工作上去。当他们做第二项工作时，其实思维还是会不自觉地停留在第一项工作上，这样就有可能会突然闪现出一个好的想法。人们同时进行两项细节大致相同的工作时，工作会更加有效率。因为他们不会闲坐着，而且两相类似的工作可以相互促进。</li>
<li>但是随着项目数量的增加，给工作效率就会降低。因为项目到项目之间的转变需要时间——人们需要时间归纳整理，弃旧迎新；需要时间来重新形成一连串的想法，并将想法重新组织和重新安置。项目越多，越来越多的时间就会花费在转变上，而不是用在有效率的工作上。</li>
</ul>
</li>
<li><p>你的团队很容易就会从事一些未经批准、无经费甚至毫无意义的工作，这种情况很常见。只有当你全盘了解团队的工作内容，已经清楚你的团队如何为该组织增加价值的时候，你才能决定工作的优先顺序，才能知道应该做什么，不应该做什么。</p>
</li>
<li><p>向每一位团队成员了解情况，了解他们到底在做什么，掌握他们的全部工作内容：</p>
<ul>
<li>项目工作：具备起点和终点，并且满足特定的组织目标。</li>
<li>临时性工作：起因无从说起，可能是由于一次危机、一个意外的要求，或者是计划外的其他工作。</li>
<li>持续性工作：指那些维持业务运转的工作。</li>
<li>周期性工作：在可知的时间段出现的工作。</li>
<li>管理工作：涉及剩余工作的计划和组织工作，如：招聘员工、员工发展以及留住人才，预算和报告工作，影响力通过团队工作创造价值。</li>
</ul>
</li>
</ul>
<h1 id="拨乱反正"><a href="#拨乱反正" class="headerlink" title="拨乱反正"></a>拨乱反正</h1><ul>
<li>了解每个人正在从事什么工作，分清工作的优先顺序，并且仅挑选那些帮助整个团队或组织实现最终目标的工作。</li>
<li>将项目归类。制定出完整饿项目列表后，参照部门目标，重新审视每一个项目，归为以下四类：<ul>
<li>确定要继续开展的项目和工作。</li>
<li>确定要停止的项目和工作——即”不做”名单。这些工作对组织中的任何人都无价值可言。即刻停止。</li>
<li>可能是重要的项目和工作，但并不适合你的团队。对这些工作，不能只是停下来，无人问津，需要将它们转交给其他更适合的团队。</li>
<li>你不知道适合哪一个团队去做的项目和工作。这类工作你不知道应该将其归在第二类还是第三类工作中。进行是深入调查，然后再决定是停止还是转交。</li>
<li>（就第三类和第四类工作，与你的上司进行讨论，并作出决定。与你的上司一起将不具有重要战略意义的工作——你不该做的工作——进行重新分配。是应该在他人接手前继续做这类工作，还是应该立刻停止？与你的上司和其他需要知道此情况的人就此进行交流，慎重地作出决定。）</li>
</ul>
</li>
<li>提供反馈信息。有时候人们工作表现欠佳，但没有人告诉他们。如果没有人提醒他们，他们根本就不知道需要做出改变，就更不用说在哪些方面做出改变了。不要急着下结论说某人工作表现不好，而要先检查自己的工作有没有做到位。你有没有明确的期望值，确定在某一合理的时间内可交付的成果，并且有没有就结果的质量表明你的态度：满意，或者不满意。</li>
<li>员工的表现还会收到环境和管理水平的影响。在你下结论认为某人”工作表现欠佳”之前，请先审视自己是否提供了这名员工成功所具备的环境。请思考以下问题。<ul>
<li>我是否向这名员工说明哪些工作要优先去做，这样他才能合理地安排工作顺序？</li>
<li>我是否让这名员工用自己的语言重复我的期望，以确保他确实明白了我的意思？</li>
<li>分配工作时，我是否清楚的表达出这项工作的约束条件和特定界限？</li>
<li>我是否给出了明确具体的反馈信息来帮助他根据我的期望做出改变？</li>
<li>我是否和他讨论过应该学习一些必要的技术，并为此提供选择？</li>
<li>（假如这些工作你都做了，这名员工还是不能给出你想要的结果，那就再看看环境方面的因素——工作程序、工作方法和奖金，还有系统问题。）</li>
</ul>
</li>
<li>设计行为描述问题。“当你⋯⋯的时候，是怎样的情况”，这种行为描述问题可以帮助应聘者描述之前的的工作情，而不是阐明他们想要如何工作。而“如果发生某某情况，你会怎样做”这类假设性问题，应聘者给出的答案实际上并不是他们应对此种情况时的真实反应。</li>
<li>团队成员知道他们要做什么工作，然后就去做。他们不需要也不想要上司每天都来指挥他们工作。上司的主要职责是去铲除障碍、对员工进行辅导以及开发团队的潜力。这不是魔术，如果上司使用某些技巧帮助员工认清工作状态——计划中的工作、进行中的工作和完成的工作，员工就知道应该做什么工作，然后去做。</li>
</ul>
<h1 id="团队建设"><a href="#团队建设" class="headerlink" title="团队建设"></a>团队建设</h1><ul>
<li>针对工作上的低效表现，或者敏感的人际关系问题给出反馈意见，是非常困难的。为此种谈话做准备会让我们感到非常紧张。但无论如何，这项工作是管理人士必须要做的。因为不能成功地给出反馈信息所造成的损失，要远远超出给出意见时暂时的不舒服。不能成功给予反馈信息的管理者会丧失信任，将工作效率，问题会恶化，同时也树立了仇恨。</li>
<li>及时给出反馈意见：<ul>
<li>人们都想要把工作做好，只是很多人并不知道该做什么或者如何做。这时，就需要有人进行指点，告诉他们哪些工作是正确的，哪些是并不奏效的。。你的反馈信息可以帮助他们改进工作。</li>
<li>尽可能及时地给出反馈信息。等到年底的工作总结时再给出反馈意见并不能起到帮助作用。即使是等到季度末或月末，也不妥当。如果你总是等待给出反馈意见的正式机会，那就说明你给出反馈意见的频率不够。经常给出反馈意见不会让人出于意料，而人们很讨厌这种出其不意的反馈。</li>
<li>描述行为或者结果。交谈时，你选择的言辞会极大地影响到对方能否真正理解你的意思。在进行纠正或者加强反馈意见时，语言要具有描述性，“好样的”或者“不错”这类言语，并不能告诉人们哪些工作是正确的。概括性词语并不能帮助你阐明自己的观点——只能让对方感到难过。人们更愿意接受详细的信息，用详细信息来开始对话。不要说“你的工作非常马虎”，可以说“我注意到在上一次的发布记录中，出现了很多拼写和打字错误”。</li>
</ul>
</li>
</ul>
<h1 id="逐日管理"><a href="#逐日管理" class="headerlink" title="逐日管理"></a>逐日管理</h1><ul>
<li>员工清楚地知道公司和部门的任务和目标后，才能确立合理的个人目标。如果不知晓这一大前提，在制定个人目标时，很容易就会只考虑个人利益和喜好，而忽略了整个组织的需要。</li>
<li>就团队目标而言，跟进执行效果会让下属知道这个目标是非常重要的。如果你对行动计划的执行过程不闻不问，那么其他人就会认为这个目标和行动计划并不重要。</li>
<li>指导是一种帮助。对下属进行指导，不单单意味着给他们解决问题。通过你的指导，下属应该可以看到更多解决问题的方法，并从中选择出最终方案。你的指导应该可以帮助他们培养新的能力。</li>
<li>要讨论利益，而不是立场。在谈话前，你可能已经想好了某种解决方案。但不要在谈话一开始就向对方阐明你的解决方案，要首先向对方说明解决此问题后，会给你们双方带来什么利益。一种解决方案代表一种立场；你的目的——你想要实现的目标——只能代表你的利益。应该找到双方的共识，这样你就可以谈论你们的利益。反过来也是一样。通过对利益进行讨论，可以找到双方的共识。</li>
<li>做一个出气筒：<ul>
<li>确定一个处理过激情绪的过程模式：询问详细的事实情况和对此情况的理解；询问可能出现的正面结果。明确说明，向组织里的其他人发牢骚、发表评论是起不到任何作用的。</li>
<li>你可以说“我听说这件事让你感到非常生气”来表明你已知道对方的感受。这种同情的方式没有必要表达出你的赞同、看法或者你自己的诠释。</li>
<li>但是如果情绪的发泄成为一种固定模式（总是对某一个人或者某件事不满），这就是另一个问题了。要对此提供反馈意见，并指导该员工这样做会造成怎样的影响。如果有需要，可以建议他求助专业咨询意见。</li>
</ul>
</li>
</ul>
<h1 id="发现潜在问题"><a href="#发现潜在问题" class="headerlink" title="发现潜在问题"></a>发现潜在问题</h1><ul>
<li><p>可持续的步伐</p>
<ul>
<li>不管表面现象是什么，当工作任务太多，时间不够充裕，以及员工（技术人员或者管理人员）想要一下子完成所有工作的时候，他们就会筋疲力尽。这种状态，特别是管理人员筋疲力尽的状态，会拖垮整个团队。</li>
<li>避免筋疲力尽的方法就是一次只做一项工作——杜绝同时处理多项任务，并以可持续的步伐工作。</li>
<li>大多数人每周可以工作40～45小时，来保证以可持续的步伐工作。偶尔一两周的周工作时间超过40小时是可以的，但这种情况不要超过两个星期，否则你就会感到筋疲力尽，不断地犯错误，工作效率也会下降。不要认为周40小时是娇气的表现。这是一个聪明的商业决策。你有责任保证以克持续的步伐工作。</li>
</ul>
</li>
<li><p>我们应该确定工作的优先顺序，这样就不会接到一件工作，就立刻去做，也没必要力争完成每件工作。确定工作的优先顺序，做到要事优先，对合理地配置员工是十分重要的。更重要的是，他可以使我们专注于正确的工作——对促进公司发展更具价值的工作。</p>
</li>
</ul>
<h1 id="能力培养"><a href="#能力培养" class="headerlink" title="能力培养"></a>能力培养</h1><ul>
<li>如何分配工作？<ul>
<li>决定可分排的工作。对管理者来说，分派工作是初级技术。首先思考分派技术类工作。分派完技术类工作后，再看管理类工作：看看哪些工作是全局战略性工作，哪些是策略性工作。举个例子，做管理报告的时候，选择衡量指标就是战略性工作；收集数据信息就是策略性工作。策略性工作适合用来进行分派。</li>
<li>寻找有能力完成工作的人。思考团队成员的技术和抱负，找到与待分派工作相匹配的员工。思考发展机会：如果团队中的某名成员想要担任领导角色，那这些策略性工作可能会是了解管理角色的好机会。（大部分的管理工作都属于全局战略性工作，但就有志于做经理的员工来说，从策略性工作做起，慢慢开始从事更多的战略性工作可以减少学习过程中走的弯路。）如果你的下属中，没有人具备完成此项工作的技术或者兴趣，那就考虑是否需要更多人手。</li>
<li>把分派任务看成是一种投资。分派任务的结果不是立即就会显现出来的。不要期待别人接受新工作时，一下就能达到百分之百的工作效率。除非这名员工具有此类工作的相关经验，，否则他可能不知道如何处理这项工作中的某部分内容。这时，你就应该进行指导。最终，你的这项投资（指导）会提高这名团队成员的能力，并降低失败的风险，因为他对这项工作的内容已经充分了解了。</li>
<li>思考你想要的具体结果。你心里可能有某个想要的具体结果，或者在某一范围内的结果你都可以接受。你应该与接手工作任务的员工沟通任务参数，包括时间和质量。注意，要关注结果，而不是方法。指导员工如何工作是一种微观管理法。将你的工作分派给其他人是需要勇气的，同时也需要信任。你必须相信对方能够很好地完成工作，即使他做的没你那么好，或没你那么准确。</li>
<li>检察工作进程。要定期检查工作进程。对经验尚少的员工，可以经常进行工作检查；对经验丰富的员工，就可以降低检查的频率。要对他们的工作给予鼓励，提供反馈信息，如果有需要，还应提供帮助。</li>
</ul>
</li>
<li>人们取得成绩时，都希望被别人注意到，并渴望得到赞许。别说“这是他们应该做的工作”，工作很艰难，所以当下属表现优秀时，让他们知道你注意到了。定期的赞许是留住最佳员工的重要因素。每周都要关注每名员工的工作，并对他们的成绩表示赞许。</li>
<li>很多刚刚成为经理的管理人士都是身兼二职：承担管理职责的同时，继续从事技术工作。他们不可避免地在管理类工作和技术类工作之间挣扎斗争。这样，对于经理本身和这个团队而言，失败的可能性就会大大增加。</li>
<li>为团队成员提供职业发展的指导？<ul>
<li>杰出的经理会为每一名员工的职业发展提供帮助。帮助员工发展技能以及实现他们的目标，可以提高整个组织的能力。支持员工的职业发展，可以让他们知道你关心他们，而不是只关心他们生产出来的产品。</li>
<li>当你帮助员工实现了他的职业目标后，即使他离开你的部门很久之后，都还是会记得你。我们帮助过的人，反过来给我们做过很好的工作，而且其中很多人已经成为了受人尊重的同事。相反，如果你阻碍员工的发展，他们也会记得——而且时间更长。</li>
<li>不要阻碍员工的发展。有时候，你无法使员工成功转型到另一个角色——在你的部门里不存在这个角色。如果是这样，这名员工可能会调到另一个部门工作，甚至会跳槽到另一家公司，你要做好准备。不要阻碍员工的发展，也不要等待另一个人来填补这个职位。职业培训有时意味着帮助员工找到一个新的职位。如果你为了方便自己的工作，而阻碍员工的发展，那么从长远角度看，结果往往是事与愿违的。</li>
</ul>
</li>
</ul>
<h1 id="有效地应对变化，不折腾"><a href="#有效地应对变化，不折腾" class="headerlink" title="有效地应对变化，不折腾"></a>有效地应对变化，不折腾</h1><ul>
<li>有时候我们会自己给自己制造麻烦。我们不想激怒上司，因此不敢直接说“不”。避免给自己挖坑，考虑以下几种可能的答复方式：<ul>
<li>对明知无法达成的任务，我无法给出承诺。我想某某工作是我们可以完成的。</li>
<li>我会和团队一起努力，看看我们能做到什么程度。</li>
<li>我们会首先攻克最重要的功能，每个月向你汇报我们的成果。</li>
<li>（这样说，接下来的谈话气氛很可能会不太和谐。但是你和你的上司都会面对现实。如果迟迟不讲明现实，只会暂时推迟痛苦，为达成商业目标可供选择的方法数量也会减少。）</li>
</ul>
</li>
<li>组织里的高层或者其他团队可能会希望你表现得像个英雄。但是接受超出你能力范围的工作并不是英雄主义，是殉难。当你接受无法应对的工作时，你就承担了所有的危险（总的来说，没有任何回报）。</li>
<li>避免仓促的决定。当高层通知你计划有了180度的大转变时，他们往往会希望你立刻就答复说可以按新计划完成工作，而你也很容易就会冒这个险。一些“简单”的答案——增加人手、加班工作、同时进行几个项目、“打破常规”⋯⋯都不会奏效。在你和团队成员进行讨论之前，不要给出任何承诺。</li>
<li>重新考虑选择余地，尽早做出回复。尽量在一两天内给出答复。对于一个正在承受巨大压力的高层来说，这样的期限已经是极限了。要承诺在这个期限内给出你团队的讨论结果。</li>
<li>用事实代替流言。当你听到某个流言，而它又影响到你的团队时，一定要调查清楚。不要任凭大家处于焦虑之中，或者用他们的担忧来填补缺失的信息。一旦你了解到事实后，就马上告诉你的团队，并带领团队努力适应改变。</li>
<li>什么是管理？<ul>
<li>坚持进行易理解但难操作的管理练习。</li>
<li>给员工以人文关怀。</li>
<li>与其他经理共同合作，作为一个团队来工作。</li>
<li>树立共同目标。</li>
<li>阐释目标。</li>
<li>为成功下定义。</li>
<li>处理高优先级的工作。</li>
<li>帮助大家有效率地合作。</li>
<li>制造信任的气氛。</li>
</ul>
</li>
</ul>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/03/14/self-coaching/" class="post-title-link">《自我训练》读书笔记</a></h2><div class="post-info">2014-03-14<a href="/tags/读书笔记/" title="读书笔记" class="post-demo">读书笔记</a></div><div class="post-content"><p>读完了《<a href="https://item.jd.com/11122849.html?dist=jd" target="_blank" rel="noopener">自我训练</a>》，是一本帮助认识焦虑的好书。它教人学会接受自己的不完美，坦然面对情绪，逐步放松心情。每个人都值得一读。</p>
<p>下面摘录整理了一些读书笔记：</p>
<ol>
<li>安全感始于你相信自己的意愿（<strong>期待定律</strong>）。</li>
<li>缺乏耐心，就像消极情绪一样，会将你吞噬，两者都是毒药。</li>
<li>区别“想要”和“必须要”的不同：<ol>
<li>“想要”受自我满足的愿望所驱动，并非是任何外在的、控制所驱动的动机。</li>
<li>“必须要”受不安全感所驱动。是强迫性的、顽固的努力，想要尽一切努力让自己感觉更有控制力。</li>
</ol>
</li>
<li>四种人格特征：<ol>
<li>刺猬型人格（敌意）</li>
<li>乌龟型人格（逃避）</li>
<li>变色龙型人格（操控）</li>
<li>完美主义型人格（过分要求）<ol>
<li>完美主义通常并不是渴求完美，只是为了<strong>避免不完美</strong>。如果不完美让你感觉焦虑，那么你的生活有可能受到了条件反射式的思维的控制。</li>
<li>狂热型完美主义所追求的是通过消除所有的错误，而使自己变得没有弱点，而且对生活中的每一个方面都具有典型的强迫症状、做事过头。一个小故障、一次失言、一次挫折都会让你沮丧和焦虑 ，想要赶忙重新控制自己的领域——要是不完美，就永远都不会快乐了（<strong>非此即彼的思维</strong>）。</li>
</ol>
</li>
</ol>
</li>
<li>孩子气的特点是受到威胁的时候就会强化自己的破坏作用。因此，评估你心中的孩子气在什么年龄段，这很有用 。</li>
<li>所有的事情都是有选择的，要学会如何发挥你的意志。</li>
<li><strong>不安全感＋控制＝毒药混合剂</strong><ol>
<li>不安全感会导致人想要对生活有所掌控。但消除焦虑和抑郁（不安全感）的关键不是更多的控制，而是培养自信，相信自己可以应付生活展示在我们面前的各种挑战。</li>
<li>焦虑和抑郁都是生长在不安全感这片肥沃土地上的杂草。它是一种由于不安全感而滋生出来的习惯，这种习惯会歪曲你对生活的看法和体验，逐渐耗尽你体内的化学成分。</li>
<li>并不是生活带给我们的种种挑战导致了临床上的焦虑或是抑郁，而是我们在面对挑战时所做出的反应导致的。</li>
<li>生命不是用来控制的，而是用来释放的。越没安全感，越怀疑生活，就越想控制生活，而不是去信任生活。</li>
</ol>
</li>
<li>不安全感的三种声音：<ol>
<li>怀疑</li>
<li>恐惧</li>
<li>消极</li>
</ol>
</li>
<li>常见的思维陷阱：<ol>
<li>“要是怎样”的预见思维</li>
<li>“不得不做”的强迫思维</li>
<li>“非此即彼”的冲动思维</li>
<li>“ 读心术 ”般的主观臆想</li>
</ol>
</li>
<li>强迫症（OCD）<ol>
<li>是由不安全感所引发的，不相信自己，不相信自己的行为和思维，所以也无法相信自己的记忆，觉得不安全（不能够掌控），并造成焦虑。</li>
<li>两个要素：<strong>反复出现，持续不断</strong>。侵入脑海的想法使得焦虑增加，让人感觉非要重复某个行为，或是反复出现某个念头，才能重新获得对生活的掌控，这稍微舒缓了自己的焦虑，但却没什么满足感。</li>
</ol>
</li>
<li>自我交谈的3个步骤：<ol>
<li>将事实与想象分开，学会倾听内心。 （ 焦虑和抑郁都不是以事实为基础的，而是由于错误和歪曲的认知而产生了捏造的想象。）</li>
<li>摆脱条件反射式的思维模式。</li>
<li>随它去 （Let it go）。当情绪来袭，不要被胡思乱想，或是说服自己非要做些什么（控制念头），可以尝试转移注意力。活在当下，感受各种感觉、印象、声音、味道和景象，想得更少，感受更多，这就是“随它去”的方法。你会及时地感受到越来越多的头脑之外的生活。</li>
</ol>
</li>
<li>自我训练的10个原则：<ol>
<li>每个人都会有不安全感。</li>
<li>想法先于感觉、焦虑和抑郁。</li>
<li>焦虑和抑郁是被误导的、想要控制生活的尝试。</li>
<li>控制是假象，不是解决问题的办法。</li>
<li>缺乏安全感是一种习惯，任何习惯都可以改变。</li>
<li>健康的思维方式是一种选择。</li>
<li>一个好的教练也是一个好的激励者。</li>
<li>你必须要挑战“别的人才能拯救我”的荒唐想法。</li>
<li>你必须承担起改变的责任。</li>
<li>你必须深信，自己真的有选择。</li>
</ol>
</li>
</ol>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2014/01/13/packing/" class="post-title-link">《佐藤可士和的超整理术》读书笔记</a></h2><div class="post-info">2014-01-13<a href="/tags/读书笔记/" title="读书笔记" class="post-demo">读书笔记</a></div><div class="post-content"><p>这本日本设计师写的书，从空间 &gt; 信息 &gt; 思考的三个维度逐步递进的介绍了一些整理之道。薄薄的一本书，有些观点还挺有意思的，可以一读。</p>
<p>下面摘录整理了一些读书笔记：</p>
<h1 id="解决问题的“超级”整理术"><a href="#解决问题的“超级”整理术" class="headerlink" title="解决问题的“超级”整理术"></a>解决问题的“超级”整理术</h1><ol>
<li>当思绪没有任何阴霾，焦点凝聚于目的，逻辑自然畅通无阻。</li>
<li>若能向对方条理分明地阐述自己采用该设计的心路历程，彻底整理自己的<strong>思考路径</strong>，作品自然不再混乱不清。</li>
<li>整理时，不可失去客观的角度。如果不与标的保持距离，冷静详察，就无法针对大量要素设定<strong>优先次序，毅然舍弃多余内容</strong>，逐步将焦点凝聚于重要的关键，细细琢磨，成为简练利索的有形之物。</li>
<li>要创造一个设计，就必须彻底整理目标对象，找出最重要的关键——本质，再将它化为有形之物。</li>
<li>本书阐述的“整理术”，并非为了整理而整理，而是一种“如何享受舒适生活”的根本方法论。</li>
</ol>
<h1 id="一切从整理开始"><a href="#一切从整理开始" class="headerlink" title="一切从整理开始"></a>一切从整理开始</h1><ol>
<li><p>整理术三阶段：</p>
<ol>
<li>空间（学会如何设定优先排序，认清重要事务）</li>
<li>信息（导入观点，掌握信息之间的因果关系）</li>
<li>思考（整理人类思绪，引导并组合，最终可视化）</li>
</ol>
</li>
<li><p>整理术步骤：</p>
<ol>
<li><p>掌握状况</p>
<ol>
<li>信息不可视的状态</li>
<li>将信息可视化</li>
<li>列出信息</li>
</ol>
</li>
<li><p>导入观点</p>
<ol>
<li>设定优先排序</li>
<li>理清因果关系，找出本质</li>
</ol>
</li>
<li><p>设定课题</p>
<ol>
<li>本质是正面的，则琢磨使之发亮，强调原本任其埋没的优势</li>
<li>本质是负面的，则进行反向思考，将负面扭转为正面，找出魅力所在。</li>
</ol>
</li>
</ol>
</li>
<li><p>掌握状况之后，为了查明问题本质，必须理清信息的因果关系。在掌握状况的阶段，各种信息呈现混乱不清的堆积状态，务必将这些信息相互对调，设定<strong>优先排序，舍弃多余信息</strong>，排除含糊暧昧的部分，找出<strong>关联性</strong>，整理成具有整合性的信息。</p>
</li>
<li><p>基于宏观视野理清信息的因果关系，就能认清前进的方向。</p>
</li>
<li><p>认清混沌的现状，保持解决问题的心理准备。同时，随时保持穷究问题本质的积极态度，才是整理术的最大前提。</p>
</li>
</ol>
<h1 id="第一阶段：“空间”整理术——设定优先排序"><a href="#第一阶段：“空间”整理术——设定优先排序" class="headerlink" title="第一阶段：“空间”整理术——设定优先排序"></a>第一阶段：“空间”整理术——设定优先排序</h1><ol>
<li>定期更新→防止东西增加。</li>
<li>决定物品的固定位置， 使用后立即物归原位→保持作业环境清爽。</li>
<li>决定“外框”，统一规格，成为某种套件→简单明了地进行分类。通过决定外框、统一规格，让分类更加简单明了。如此不但可将不同种类的东西收拾干净，而且是容易掌握的简约系统。</li>
</ol>
<h1 id="第二阶段：“信息”整理术——导入个人观点"><a href="#第二阶段：“信息”整理术——导入个人观点" class="headerlink" title="第二阶段：“信息”整理术——导入个人观点"></a>第二阶段：“信息”整理术——导入个人观点</h1><ol>
<li>退一步客观检视。</li>
<li>舍弃自以为是、想当然 。</li>
<li>转换观点，从各种角度观察。</li>
</ol>
<h1 id="第三阶段：“思考”整理术——将思绪信息化"><a href="#第三阶段：“思考”整理术——将思绪信息化" class="headerlink" title="第三阶段：“思考”整理术——将思绪信息化"></a>第三阶段：“思考”整理术——将思绪信息化</h1><ol>
<li>将自己和对方的思绪置换成语言。</li>
<li>建立假说，大胆向对方提问。</li>
<li>思考时要对于别人的事情视如己出。</li>
</ol>
</div></article></li></ul><div class="right-container"><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/DNS/" style="font-size: 12.5px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GNU-Linux/" style="font-size: 16.67px;">GNU/Linux</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 19.17px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 11.67px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10.83px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15.83px;">Spring</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 18.33px;">前端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">响应式编程</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 12.5px;">安全</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">并发编程</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 13.33px;">建站</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 12.5px;">管理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.17px;">读书笔记</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 12.5px;">金融</a></div></div><div class="widget"><div class="recent"><h4>最近文章</h4><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/02/26/cpp-io-library/">C/C++ 语言系列（十一）I/O 库总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/25/cpp-oop-inheritance-and-polymorphism/">C/C++ 语言系列（十）面向对象编程之继承与多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/20/cpp-oop-class/">C/C++ 语言系列（九）面向对象编程之类、类模板、类指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/18/cpp-type-aliases/">C/C++ 语言系列（八）复合数据类型之类型别名</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/16/cpp-struct/">C/C++ 语言系列（七）复合数据类型之结构体</a></li></ul></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/page/17/" class="prev">PREV</a></div><div class="copyright"><p>© 2014 - 2021 <a href="https://github.com/qidawu" target="_blank">Qida's Blog</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>