<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> Qida's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="学习笔记 知识总结 思考感悟"><meta name="keywords"><meta name="author" content="Qida's Blog"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://qidawu.github.io/atom.xml" title="Qida's Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><a href="/" class="title-link">Qida's Blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/07/08/gnu-findutils/" class="post-title-link">find 命令使用总结</a></h2><div class="post-info">2017-07-08<a href="/tags/GNU-Linux/" title="GNU/Linux" class="post-demo">GNU/Linux</a></div><div class="post-content"><p><code>find</code> 是最常见和最强大的查找命令，直接查找磁盘，缺点耗时长。命令格式如下：</p>
<p><code>find [path...] [expression]</code></p>
<p>The  expression  is made up of :</p>
<ul>
<li><code>options</code> (which affect overall operation rather than the processing of a specific file, and always return true)</li>
<li><code>tests</code> (which return a true or false value)</li>
<li><code>actions</code> (which have side effects and return a true or false value)</li>
</ul>
<p>all separated by <code>operators</code>.</p>
<h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><p>常用选项：</p>
<ul>
<li><code>-maxdepth 1</code> 只查找当前目录</li>
</ul>
<h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>常用条件：</p>
<ul>
<li><p><code>-name</code> 名称查找（例如：<code>find ./ -name &#39;struts*&#39;</code>）</p>
</li>
<li><p><code>-type</code> 类型查找</p>
<ul>
<li><code>d</code> 目录类型</li>
<li><code>f</code> 常规文件类型</li>
<li><code>l</code> 软链类型</li>
<li>……</li>
</ul>
</li>
<li><p><code>-user</code> 设定所属用户的名称</p>
</li>
<li><p><code>-group</code> 设定所属用户组的名称</p>
</li>
<li><p><code>-perm</code> 设定权限</p>
</li>
<li><p><code>-regex</code> 使用正则表达式进行匹配</p>
</li>
<li><p><code>-size</code> 表示文件大小</p>
</li>
<li><p><code>-empty</code> 空文件或空目录</p>
</li>
<li><p><code>-atime / -amin</code> File was last accessed n*24 hours/n minutes ago.</p>
</li>
<li><p><code>-ctime / -cmin</code> File’s status was last changed n*24hours/n minutes ago.</p>
</li>
<li><p><code>-mtime / -mmin</code> File’s data was last modified n*24hours/n minutes ago.</p>
</li>
</ul>
<h1 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h1><p>常用动作：</p>
<ul>
<li><code>-print</code> 输出结果（默认动作）</li>
<li><code>-ls</code> 输出详情</li>
<li><code>-delete</code> 执行删除</li>
<li><code>-exec</code> 执行指定命令</li>
</ul>
<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>操作符用于提高表达式的优先级，下列操作符的优先级以倒序排列：</p>
<ul>
<li><code>( expr )</code> 强制最高优先级</li>
<li><code>! expr</code> 求反操作</li>
<li><code>expr1 expr2</code> (or <code>expr1 -a expr2</code>) 求与操作</li>
<li><code>expr1 -o expr2</code> 求或操作</li>
</ul>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="按文件名查找"><a href="#按文件名查找" class="headerlink" title="按文件名查找"></a>按文件名查找</h2><p>查找当前目录树中，名字以 <code>fileA_</code> 或 <code>fileB_</code> 开头的所有文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name <span class="string">'fileA_*'</span> -o -name <span class="string">'fileB_*'</span></span><br></pre></td></tr></table></figure>

<p>查找当前目录树中的 <code>foo.cpp</code> 文件，查找过程中排查掉 <code>.svn</code> 子目录树：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name <span class="string">'foo.cpp'</span> <span class="string">'!'</span> -path <span class="string">'.svn'</span></span><br></pre></td></tr></table></figure>

<p>查找当前目录树中，以 <code>my</code> 开头的常规文件，并输出文件详情：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name <span class="string">'my*'</span> -<span class="built_in">type</span> f -ls</span><br></pre></td></tr></table></figure>

<h2 id="按大小查找"><a href="#按大小查找" class="headerlink" title="按大小查找"></a>按大小查找</h2><p>查找大小在 100k~500k 的文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -size +100k -a -size -500k</span><br></pre></td></tr></table></figure>

<p>查找空文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -size 0k</span><br></pre></td></tr></table></figure>

<p>查找非空文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . ! -size 0k</span><br></pre></td></tr></table></figure>

<h2 id="删除文件或目录"><a href="#删除文件或目录" class="headerlink" title="删除文件或目录"></a>删除文件或目录</h2><p>删除空文件或空目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -empty -delete</span><br><span class="line">$ find . -<span class="built_in">type</span> d -empty -delete</span><br></pre></td></tr></table></figure>

<p>根据 inode 号删除乱码文件：：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -inum &lt;inode-number&gt; -<span class="built_in">exec</span> rm -i &#123;&#125; \;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm `find ./ -inum &lt;inode-number&gt;`</span><br></pre></td></tr></table></figure>

<p><img src="/img/gnu-linux/find.jpg" alt="find -exec"></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/15/spring-factory-bean/" class="post-title-link">Spring Factory Bean 总结</a></h2><div class="post-info">2017-06-15<a href="/tags/Java/" title="Java" class="post-demo">Java</a><a href="/tags/Spring/" title="Spring" class="post-demo">Spring</a></div><div class="post-content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/FactoryBean.html" target="_blank" rel="noopener">org.springframework.beans.factory.FactoryBean</a> 用于在 IoC 容器中创建其它 Bean，该接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span>  <span class="comment">// Return an instance (possibly shared or independent) of the object managed by this factory.</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt; <span class="title">getObjectType</span><span class="params">()</span>  <span class="comment">// Return the type of object that this FactoryBean creates, or null if not known in advance.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span>  <span class="comment">// Is the object managed by this factory a singleton? That is, will getObject() always return the same object (a reference that can be cached)?</span></span></span><br></pre></td></tr></table></figure>

<p>有哪些现存的 <code>FactoryBean</code>？例如：</p>
<ul>
<li>当需要从 JNDI 查找对象（例如 <code>DataSource</code>）时，可以使用 <code>JndiObjectFactoryBean</code>。</li>
<li>当使用 Spring AOP 为 bean 创建代理时，可以使用 <code>ProxyFactoryBean</code>。</li>
<li>当需要在 IoC 容器中创建 Hibernate 的 <code>SessionFactory</code> 时，可以使用 <code>LocalSessionFactoryBean</code>。</li>
<li>当需要在 IoC 容器中创建 MyBatis 的 <code>SqlSessionFactory</code> 时，可以使用 <code>SqlSessionFactoryBean</code>。</li>
</ul>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>这里我们举一个例子：</p>
<p>如果要为某个接口生成 JDK 动态代理，且将该代理对象放入 Spring IoC 容器，以便后续依赖注入使用，可以自定义实现 <code>FactoryBean</code> 实现如下效果，如图：</p>
<p><img src="/img/spring/HttpApiService_example.png" alt="HttpApiService_example"></p>
<p>实现代码如下，首先创建接口及其代理类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Xxx 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpApiService</span> </span>&#123;</span><br><span class="line">    <span class="function">HttpRespDTO&lt;XxxRespDTO&gt; <span class="title">api1</span><span class="params">(XxxReqDTO reqDTO)</span></span>;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Xxx 接口的动态代理实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpApiServiceProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一、手工注册-1-0"><a href="#一、手工注册-1-0" class="headerlink" title="一、手工注册 1.0"></a>一、手工注册 1.0</h2><p>如果只需创建一个 <code>FactoryBean</code>，可以将其作为一个 Java Config 加上 <code>@Configuration</code> 即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Xxx 接口工厂，用于创建代理实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpApiServiceFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">HttpApiService</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt; API_INTERFACE = HttpApiService<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpApiService <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (HttpApiService) Proxy.newProxyInstance(</span><br><span class="line">            API_INTERFACE.getClassLoader(), <span class="keyword">new</span> Class[]&#123; API_INTERFACE &#125;, <span class="keyword">new</span> HttpApiServiceProxy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> API_INTERFACE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、手工注册-2-0"><a href="#二、手工注册-2-0" class="headerlink" title="二、手工注册 2.0"></a>二、手工注册 2.0</h2><p>如果需要创建多个 <code>FactoryBean</code>，可以使用泛型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpApiServiceFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; apiService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                apiService.getClassLoader(), <span class="keyword">new</span> Class[]&#123; apiService &#125;, <span class="keyword">new</span> HttpApiServiceProxy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> apiService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java Config 如下，手工创建多个 <code>FactoryBean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpApiServiceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpApiServiceFactoryBean&lt;UserHttpApiService&gt; <span class="title">userHttpApiService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpApiServiceFactoryBean(UserHttpApiService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpApiServiceFactoryBean&lt;RoleHttpApiService&gt; <span class="title">roleHttpApiService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpApiServiceFactoryBean(RoleHttpApiService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式参考了 <a href="https://mybatis.org/spring/zh/mappers.html#register" target="_blank" rel="noopener">Mybatis-Spring 注册映射器</a>。</p>
<h2 id="三、自动发现"><a href="#三、自动发现" class="headerlink" title="三、自动发现"></a>三、自动发现</h2><p>如果想进一步省略 Java Config，做到自动扫描并创建 <code>FactoryBean</code>，可以创建自动配置类。例如，为添加了 <code>@HttpApi</code> 注解的接口创建相应的 <code>FactoryBean</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HttpApi 动态代理自动配置类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AutoConfiguredHttpApiScannerRegistrar<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HttpApiServiceAutoConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义 ImportBeanDefinitionRegistrar</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoConfiguredHttpApiScannerRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描 Application 类所在的 classpath。也可以指定其它路径（如配合 @EnableHttpApi 注解使用）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_PKG = Application<span class="class">.<span class="keyword">class</span>.<span class="title">getPackage</span>().<span class="title">getName</span>()</span>;</span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"Searching for HttpApiService annotated with @HttpApi from &#123;&#125;"</span>, BASE_PKG);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 配置自定义的 ClassPathHttpApiScanner</span></span><br><span class="line">                ClassPathHttpApiScanner scanner = <span class="keyword">new</span> ClassPathHttpApiScanner(registry);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 扫描指定路径</span></span><br><span class="line">                scanner.doScan(BASE_PKG);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                log.debug(<span class="string">"Could not determine auto-configuration package, automatic @HttpApi scanning disabled."</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义 ClassPathHttpApiScanner</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassPathHttpApiScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathHttpApiScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(registry, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加过滤条件，这里是只要添加了 @HttpApi 注解的类或接口，就会被扫描到</span></span><br><span class="line">        addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(HttpApi<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 Spring 的扫描</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">            logger.warn( <span class="string">"No @HttpApi bean was found in '"</span> + Arrays.toString(basePackages) + <span class="string">"' package. Please check your configuration."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理扫到的 BeanDefinition</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            processBeanDefinitions(beanDefinitions);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">        GenericBeanDefinition definition;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">            definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">            String beanClassName = definition.getBeanClassName();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 修改 BeanDefinition 的 BeanClass 为 FactoryBean</span></span><br><span class="line">            definition.setBeanClass(HttpApiServiceFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为构造方法指定所需参数</span></span><br><span class="line">            <span class="comment">// definition.getPropertyValues().add("restTemplate", new RuntimeBeanReference("restTemplate"));</span></span><br><span class="line">            definition.getPropertyValues().add(<span class="string">"apiService"</span>, getClass(beanClassName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; getClass(String beanClassName)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(beanClassName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖原有策略，限定只需要接口类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式参考了 <a href="https://mybatis.org/spring/zh/mappers.html#scan" target="_blank" rel="noopener">Mybatis-Spring 发现映射器</a>。</p>
<p>需要用到 Spring 的几个类，待补充：</p>
<ul>
<li><code>ImportBeanDefinitionRegistrar</code></li>
<li><code>ClassPathBeanDefinitionScanner</code><ul>
<li><code>BeanDefinitionHolder</code></li>
<li><code>GenericBeanDefinition</code></li>
<li><code>AnnotatedBeanDefinition</code></li>
</ul>
</li>
</ul>
<p><img src="/img/spring/BeanDefinition.png" alt="BeanDefinition"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://www.jianshu.com/p/05c909c9beb0" target="_blank" rel="noopener">Spring BeanFactory和FactoryBean的区别</a>》</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/FactoryBean.html" target="_blank" rel="noopener">org.springframework.beans.factory.FactoryBean</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolExecutorFactoryBean.html" target="_blank" rel="noopener">ThreadPoolExecutorFactoryBean</a></p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/hibernate5/LocalSessionFactoryBean.html" target="_blank" rel="noopener">LocalSessionFactoryBean</a></p>
<p><a href="https://github.com/mybatis/spring/blob/master/src/main/java/org/mybatis/spring/SqlSessionFactoryBean.java" target="_blank" rel="noopener">SqlSessionFactoryBean</a></p>
<p><a href="https://mybatis.org/spring/zh/mappers.html#" target="_blank" rel="noopener">MyBatis-Spring 注入映射器</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/04/spring-bean-wiring/" class="post-title-link">Spring Bean 几种配置方式总结</a></h2><div class="post-info">2017-06-04<a href="/tags/Java/" title="Java" class="post-demo">Java</a><a href="/tags/Spring/" title="Spring" class="post-demo">Spring</a></div><div class="post-content"><p><img src="/img/spring/spring-bean.png" alt="spring-bean"></p>
<p>Spring 组件引入的两种推荐方式：</p>
<ul>
<li>非 Spring Boot 项目，显示引入  Java Config：<code>@Enable*</code> + <code>@Import</code></li>
<li>Spring Boot 项目，隐式引入  Java Config：<code>@EnableAutoConfiguration</code> + <code>META-INF/spring.factories</code></li>
</ul>
<p>Spring bean 的声明及装配的几种配置方式：</p>
<ul>
<li><del>基于 XML Config 的显式配置，不推荐</del></li>
<li>基于 Java Config 的显式配置，推荐用于声明第三方编写的组件</li>
<li>自动化配置，即组件扫描（隐式的 bean 发现机制） + 自动装配，推荐用于自己编写的组件</li>
</ul>
<p>用户可以选择其中一种方式使用，也可以混搭使用。使用时的最佳实践如下：</p>
<ul>
<li>建议尽可能地使用自动化配置的机制。显式配置越少越好，以避免显式配置所带来的维护成本。</li>
<li>当你必须要显式配置 bean 的时候（比如，有些源码不是由你来维护的，而当你需要为这些代码配置 bean 的时候），推荐使用类型安全并且比 XML Config 更加强大的 Java Config。</li>
<li>最后，只有当你想要使用便利的 XML 命名空间，并且在 JavaConfig 中没有同样的实现时，才应该使用 XML Config。</li>
</ul>
<p>这里提供一个例子，其接口和实现类如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompactDisc</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SgtPeppers</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h1><p>Spring 从两个角度来实现 bean 的自动化配置：</p>
<ul>
<li>组件扫描（component scanning）：Spring 会自动发现应用上下文中要创建的 bean。</li>
<li>自动装配（autowiring）：Spring 自动满足 bean 之间的依赖。</li>
</ul>
<p>组件扫描（隐式的 bean 发现机制）和自动装配组合在一起能够发挥出强大的威力，它们能够将你的显式配置降低到最少。</p>
<h2 id="声明组件"><a href="#声明组件" class="headerlink" title="声明组件"></a>声明组件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Component 注解表明该类会作为组件类，并告知 Spring 要为这个类创建 bean。因此没有必要在 XML 或 Java Config 中显式配置该 bean。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SgtPeppers</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式声明 Java Config 配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 组件扫描默认是不启用的。我们还需要显式配置一下 Spring，从而命令它去寻找带有 @Component 注解的类，并为其创建 bean。</span></span><br><span class="line"><span class="comment">// @ComponentScan 默认会扫描与配置类相同的包及其子包。有一个原因会促使我们明确地设置基础包，那就是我们想要将配置类放在单独的包中，使其与其他的应用代码区分开来。</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有显式地声明任何 bean，但由于开启了组件扫描，会在 Spring 容器中自动创建一个 SgtPeppers 类的 bean。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>为了测试组件扫描的功能，我们创建一个简单的 JUnit 单元测试。它会创建 Spring 上下文，并判断 bean 是否真的创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>) // 用于自动创建 <span class="title">Spring</span> 的应用上下文</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span></span>=CDPlayerConfig<span class="class">.<span class="keyword">class</span>) // 指定要加载的配置</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// @Autowired 是 Spring 特有的注解，也可以使用 Java 依赖注入规范的 @Inject</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotBeNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(cd); <span class="comment">// 测试通过</span></span><br><span class="line">        cd.play(); <span class="comment">// 输出 Hello world!</span></span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何处理自动装配的歧义性问题？有两种方案：</p>
<ul>
<li>使用 <code>@Primary</code> 注解将可选 bean 中的某一个设为首选的 bean。<code>@Primary</code> 能够与 <code>@Component</code> 组合用在组件扫描的 bean 上，也可以与 <code>@Bean</code> 组合用在 Java 配置的 bean 声明中。 </li>
<li>使用限定符注解 <code>@Qualifier</code> 来帮助 Spring 将可选的 bean 的范围缩小到只有一个 bean。</li>
</ul>
<h1 id="基于-Java-Config-的显式配置"><a href="#基于-Java-Config-的显式配置" class="headerlink" title="基于 Java Config 的显式配置"></a>基于 Java Config 的显式配置</h1><p>尽管在很多场景下通过组件扫描和自动装配实现 Spring 的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要显式配置 Spring。比如说，你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加 <code>@Component</code> 和 <code>@Autowired</code> 注解的，因此就不能使用自动化装配的方案了。</p>
<p>在这种情况下，就必须要采用显式装配的方式。在进行显式配置的时候，有两种可选方案：Java 和 XML。Java Config 的优缺点如下：</p>
<ul>
<li>优点：类型安全，对重构友好且不易出错。因为它就是 Java 代码，就像应用程序中的其它 Java 代码一样。</li>
<li>缺点：如果修改了 Java Config 类中的配置，就必须重新编译应用程序。</li>
</ul>
<p>同时，Java Config 与其它的 Java 代码又有所区别，在概念上，它与应用程序中的业务逻辑和领域代码是不同的。尽管它与其它的组件一样都使用相同的语言进行表述，但 Java Config 是配置代码。这意味着它不应该包含任何业务逻辑，Java Config 也不应该侵入到业务逻辑代码之中。尽管不是必须的，但通常会将 Java Config <strong>放到单独的包中</strong>，使它与其他的应用程序逻辑分离开来，这样对于它的意图就不会产生困惑了。</p>
<p>下面是一个 Java Config 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式声明 Java Config 配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式地声明 bean。@Bean 注解会告诉 Spring 这个方法将会返回一个对象，该对象要注册为 Spring 应用上下文中的 bean。方法体中包含了最终产生 bean 实例的逻辑。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">getCompactDisc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 装配方式一：Spring 将会拦截所有对 getCompactDisc() 的调用，并确保直接返回该方法所创建的 bean，而不是每次都对其进行实际的调用。且默认情况下，Spring 中的 bean 都是单例的，因此多次调用只会返回同一个实例。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CDPlayer <span class="title">getCDPlayer1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(getCompactDisc())；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 装配方式二：上述通过调用方法来引用 bean 的方式有点令人困惑。而下面这种方式的好处是：</span></span><br><span class="line">    <span class="comment">// 1.不要求将 CompactDisc 声明到同一个配置类之中。</span></span><br><span class="line">    <span class="comment">// 2.不关注 Bean 的配置方式，你可以将配置分散到多个配置类、XML 文件以及自动扫描和装配 bean 之中，只要功能完整健全即可。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CDPlayer <span class="title">getCDPlayer2</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(cd)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这个 Java Config 需要放在 <code>@ComponentScan</code> 能够扫描到的路径之下，否则配置中所声明的 bean 将无法被 Spring 容器所注册。</p>
<h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>有时候我们需要引入一些外部的 Java Config 配置，这些配置往往是在其它 package 下。此时可以通过 <code>@Import</code> 注解导入这些外部 Java Config。</p>
<h2 id="Enable"><a href="#Enable" class="headerlink" title="@Enable*"></a>@Enable*</h2><p><code>@Import</code> 注解导入 Java Config 的方式有时不够直观，主流的做法是为其包装一层 <code>@Enable*</code> 注解，其字面意思是“开启某个功能”，非常直观。Spring 框架中提供了大量这类注解：</p>
<p>Spring Framework：</p>
<ul>
<li>spring-context<ul>
<li><code>@EnableAsync</code> 开启对 <code>@Async</code> 注解的支持</li>
<li><code>@EnableScheduling</code> 开启对 <code>@Scheduled</code> 注解的支持</li>
<li><code>@EnableCaching</code> 开启对 <code>@Cacheable</code> 注解的支持</li>
<li><code>@EnableAspectJAutoProxy</code> 开启对 <code>@Aspect</code> 注解的支持</li>
<li><code>@EnableLoadTimeWeaving</code></li>
<li><code>@EnableMBeanExport</code></li>
</ul>
</li>
<li>spring-tx<ul>
<li><code>@EnableTransactionManagement</code> 开启对 <code>@Transactional</code> 注解的支持</li>
</ul>
</li>
<li>spring-webmvc<ul>
<li><code>@EnableWebMvc</code> 开启对 <code>@Controller</code> 注解的支持</li>
</ul>
</li>
<li>spring-webflux<ul>
<li><code>@EnableWebFlux</code></li>
</ul>
</li>
<li>spring-websocket<ul>
<li><code>@EnableWebSocket</code></li>
<li><code>@EnableWebSocketMessageBroker</code></li>
</ul>
</li>
<li>spring-jms<ul>
<li><code>@EnableJms</code></li>
</ul>
</li>
</ul>
<p>其它组件：</p>
<ul>
<li>spring-security<ul>
<li><code>@EnableWebSecurity</code></li>
</ul>
</li>
<li>spring-data-jpa<ul>
<li><code>@EnableJpaRepositories</code></li>
</ul>
</li>
<li>spring-boot-autoconfigure<ul>
<li><code>@EnableAutoConfiguration</code></li>
</ul>
</li>
</ul>
<p>通过简单的 <code>@Enable*</code> 即可开启一项功能的支持，从而避免大量配置，大大降低使用难度。通过观察这些 <code>@Enable*</code> 注解的源码，可以发现所有的注解都有一个 <code>@Import</code> 注解，<code>@Import</code> 是用来导入配置类的，这也就意味着这些自动开启的实现其实就是导入了一些自动配置的 Bean。这些导入的配置主要分为以下三类：</p>
<ol>
<li>直接导入配置类</li>
<li>依据条件选择配置类</li>
<li>动态注册 Bean</li>
</ol>
<h2 id="条件化的-bean"><a href="#条件化的-bean" class="headerlink" title="条件化的 bean"></a>条件化的 bean</h2><p>假设你希望一个或多个 bean 只有在应用的类路径下包含特定的库时才创建。或者我们希望某个 bean 只有当另外某个特定的 bean 也声明了之后才会创建。我们还可能要求只有某个特定的环境变量设置之后，才会创建某个 bean。<br>在 Spring 4 之前，很难实现这种级别的条件化配置，但是 Spring 4 引入了一个新的 <code>@Conditional</code> 注解，它可以用到带有 <code>@Bean</code>注解的方法上。如果给定的条件计算结果为 <code>true</code>，就会创建这个 bean，否则的话，这个 bean 会被忽略。</p>
<p>详情参考另一篇博文：《<a href="/2017/09/05/spring-conditional-bean/">Spring Bean 条件化配置总结</a>》</p>
<h1 id="基于-XML-的显式配置"><a href="#基于-XML-的显式配置" class="headerlink" title="基于 XML 的显式配置"></a>基于 XML 的显式配置</h1><p>XML 配置的缺点是比较复杂，且无法从编译期的类型检查中受益。除非是老项目维护，否则在新项目中已不再建议使用，此处不作过多介绍。</p>
<h1 id="混合配置"><a href="#混合配置" class="headerlink" title="混合配置"></a>混合配置</h1><p>在典型的 Spring 应用中，我们可能会同时使用自动化和显式配置。这些配置方案不是互斥的，可以将 Java Config 的组件扫描和自动装配和/或 XML 配置混合在一起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个全局的根配置，并组合各种配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 通常会在根配置中启用组件扫描</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="comment">// 导入 Java Config</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;FirstConfig<span class="class">.<span class="keyword">class</span>, <span class="title">SecondConfig</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">// 导入 <span class="title">XML</span> 配置</span></span><br><span class="line">@ImportResource("classpath:applicationContext.xml")</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">GlobalConfig</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://www.manning.com/books/spring-in-action-fourth-edition" target="_blank" rel="noopener">Spring in Action, 4th</a>》</p>
<p>《<a href="https://www.ibm.com/developerworks/cn/webservices/ws-springjava/" target="_blank" rel="noopener">使用 Java 配置进行 Spring bean 管理</a>》</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/package-summary.html" target="_blank" rel="noopener">Package org.springframework.context.annotation</a></p>
<blockquote>
<p>Annotation support for the Application Context, including JSR-250 “common” annotations, component-scanning, and Java-based metadata for creating Spring-managed objects.</p>
</blockquote>
<p>《<a href="http://blog.longjiazuo.com/archives/1366" target="_blank" rel="noopener">Spring4.x高级话题(六):@Enable*注解的工作原理</a>》</p>
<p>《<a href="http://blog.fawnanddoug.com/2012/08/how-those-spring-enable-annotations-work.html" target="_blank" rel="noopener">How those Spring @Enable* Annotations work</a>》</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/03/spring-bean-lifecycle/" class="post-title-link">Spring Bean 生命周期与作用域总结</a></h2><div class="post-info">2017-06-03<a href="/tags/Java/" title="Java" class="post-demo">Java</a><a href="/tags/Spring/" title="Spring" class="post-demo">Spring</a></div><div class="post-content"><h1 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h1><p>Spring Bean Factory 负责管理 bean 的生命周期，可以分为三个阶段：</p>
<p><img src="/img/spring/spring-bean-life-cycle.png" alt="Spring Bean Life Cycle"></p>
<p>一、初始化阶段：</p>
<ul>
<li>Instantiation：Spring 启动，查找并加载需要被 Spring 管理的bean，进行 Bean 的实例化，调用构造方法。</li>
<li>Populate Properties：属性注入，包括引用的 Bean 和值，调用 setter 方法。</li>
<li>调用该 Bean 实现的各种生命周期回调接口。</li>
</ul>
<p>二、就绪阶段：</p>
<ul>
<li>此时，Bean 已经准备就绪，可以被应用程序使用了。它们将一直驻留在应用上下文中，直到应用上下文被销毁。</li>
</ul>
<p>三、销毁阶段：</p>
<ul>
<li>调用该 Bean 实现的各种生命周期回调接口。</li>
</ul>
<h2 id="初始化和销毁方法"><a href="#初始化和销毁方法" class="headerlink" title="初始化和销毁方法"></a>初始化和销毁方法</h2><p>Spring 框架提供了以下几种方式指定 bean 生命周期的初始化和销毁回调方法：</p>
<table>
<thead>
<tr>
<th></th>
<th>初始化</th>
<th>销毁</th>
</tr>
</thead>
<tbody><tr>
<td>实现 Spring Boot 的接口</td>
<td><a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/ApplicationRunner.html" target="_blank" rel="noopener"><code>ApplicationRunner</code></a></td>
<td></td>
</tr>
<tr>
<td>实现 Spring Framework 的接口</td>
<td><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/InitializingBean.html" target="_blank" rel="noopener"><code>InitializingBean</code></a></td>
<td><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/DisposableBean.html" target="_blank" rel="noopener"><code>DisposableBean</code></a></td>
</tr>
<tr>
<td>在 Spring <code>@Bean</code> 注解中指定属性</td>
<td><code>@Bean(initMethod=&quot;xxx&quot;)</code></td>
<td><code>@Bean(destroyMethod=&quot;xxx&quot;)</code></td>
</tr>
<tr>
<td>在 Spring bean 配置文件指定属性</td>
<td><code>&lt;bean init-method=&quot;xxx&quot; /&gt;</code></td>
<td><code>&lt;bean destroy-method=&quot;xxx&quot; /&gt;</code></td>
</tr>
<tr>
<td>使用 JavaEE 规范 <code>javax.annotation</code> 包中提供的注解</td>
<td><code>@PostConstruct</code></td>
<td><code>@PreDestroy</code></td>
</tr>
</tbody></table>
<p>在 Spring 容器启动后执行一些初始化逻辑是一个很常见的场景，注意使用不同的方式，顺序不同：</p>
<p><img src="/img/spring/spring-bean-lifecycle-3.png" alt=""></p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/44786291" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44786291</a></p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OssUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;oss.endpoint&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;oss.access-key-id&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;oss.access-key-secret&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;oss.bucket-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OSS ossClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Aware-接口"><a href="#Aware-接口" class="headerlink" title="Aware 接口"></a>Aware 接口</h2><p>在日常的开发中，我们经常需要用到 Spring 容器本身的功能资源，可以通过 Spring 提供的一系列 <code>Aware (org.springframework.beans.factory)</code> 子接口来实现具体的功能。<code>Aware</code> 是一个具有标识作用的超级接口，实现该接口的 bean 具有被 Spring 容器通知的能力，而被通知的方式就是通过回调，以依赖注入的方式为 bean 设置相应属性，这是一个典型的依赖注入的使用场景。<code>Aware</code> 接口的继承关系如下：</p>
<p><img src="/img/spring/aware_interface.png" alt="Aware 接口"></p>
<p>这些 <code>*Aware</code> 子接口在 Spring Bean  的生命周期中被回调的顺序如下：</p>
<ol>
<li><code>BeanNameAware (org.springframework.beans.factory)</code></li>
<li><code>BeanClassLoaderAware (org.springframework.beans.factory)</code></li>
<li><code>BeanFactoryAware (org.springframework.beans.factory)</code></li>
<li><code>EnvironmentAware (org.springframework.context)</code></li>
<li><code>EmbeddedValueResolverAware (org.springframework.context)</code></li>
<li><code>ResourceLoaderAware (org.springframework.context)</code></li>
<li><code>ApplicationEventPublisherAware (org.springframework.context)</code></li>
<li><code>MessageSourceAware (org.springframework.context)</code></li>
<li><code>ApplicationContextAware (org.springframework.context)</code></li>
</ol>
<p><img src="/img/spring/spring-bean-lifecycle-2.jpg" alt=""></p>
<h1 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h1><p>使用 <code>@Scope</code> 注解定义 bean 的作用域，它可以与 <code>@Component</code> 或 <code>@Bean</code> 一起使用：</p>
<ul>
<li><p>单例(Singleton):在整个应用中，只创建bean的一个实例。</p>
</li>
<li><p>原型(Prototype):每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。注意，此时目标 bean 要使用代理模式，否则无法达到效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 目标 bean 为类</span><br><span class="line">@Scope(value &#x3D; ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode &#x3D; ScopedProxyMode.TARGET_CLASS)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 目标 bean 为接口</span><br><span class="line">@Scope(value &#x3D; ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode &#x3D; ScopedProxyMode.INTERFACES)</span><br></pre></td></tr></table></figure>
</li>
<li><p>会话(Session):在Web应用中，为每个会话创建一个bean实例。</p>
</li>
<li><p>请求(Rquest):在Web应用中，为每个请求创建一个bean实例。</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/Aware.html" target="_blank" rel="noopener">org.springframework.beans.factory.Aware</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/06/01/spring-application-context/" class="post-title-link">Spring 应用上下文总结</a></h2><div class="post-info">2017-06-01<a href="/tags/Java/" title="Java" class="post-demo">Java</a><a href="/tags/Spring/" title="Spring" class="post-demo">Spring</a></div><div class="post-content"><p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包为 Spring 框架 IoC 容器的提供基础。有两种形式的 Spring 容器：</p>
<ul>
<li>Bean Factory</li>
<li>Application Context<ul>
<li>spring-context 核心模块<ul>
<li><code>FileSystemXmlapplicationcontext</code></li>
<li><code>ClassPathXmlApplicationContext</code></li>
<li><code>AnnotationConfigApplicationContext</code></li>
</ul>
</li>
<li>spring-web 模块<ul>
<li><code>XmlWebApplicationContext</code></li>
<li><code>AnnotationConfigWebApplicationContext</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>继承结构如下：</p>
<p><img src="/img/spring/BeanFactory.png" alt="BeanFactory"></p>
<h1 id="Application-Context"><a href="#Application-Context" class="headerlink" title="Application Context"></a>Application Context</h1><p>Spring 通过应用上下文（Application Context）装载 bean 的定义并将它们装配起来。Spring 应用上下文全权负责对象的创建、装配、配置它们并管理它们的整个生命周期。Spring 自带了多种应用上下文的实现，它们之间主要的区别仅仅在于如何加载配置：</p>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><ul>
<li><p><code>FileSystemXmlapplicationcontext</code> 从文件系统下的一个或多个 XML 配置文件中加载上下文定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"c:/applicationContext.xml"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ClassPathXmlApplicationContext</code> 从类路径下的一个或多个 XML 配置文件中加载上下文定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"META-INF/spring/applicationContext.xml"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>XmlWebApplicationContext</code> 从 Web 应用下的一个或多个 XML 配置文件中加载上下文定义，是 Web 应用程序使用的默认上下文类，因此不必在 <code>web.xml</code> 文件中显式指定这个上下文类。以下代码描述了 <code>web.xml</code> 中指向将由 <code>ContextLoaderListener</code> 监听器类载入的外部 XML 上下文文件的元素：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.ContextLoaderListener</span><br><span class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>sampleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">        <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><ul>
<li><p><code>AnnotationConfigApplicationContext</code> 从一个或多个基于 Java 的配置类中加载 Spring 应用上下文：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造函数来注册配置类 DubboApplication</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(org.apache.dubbo.config.DubboApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此外，还可以使用 register 方法来注册配置类 OtherApplication</span></span><br><span class="line">ctx.register(OtherApplication<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.config；</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册配置类将自动注册 @Bean 注解的方法名称返回的 bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"dubbo-annotation-provider"</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>AnnotationConfigWebApplicationContext</code> 从一个或多个基于 Java 的配置类中加载 Spring Web 应用上下文，需要显示配置该类：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            demo.AppContext</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.ContextLoaderListener</span><br><span class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>sampleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">        <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">                org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">            <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Bean-Factory"><a href="#Bean-Factory" class="headerlink" title="Bean Factory"></a>Bean Factory</h1><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener">org.springframework.beans.factory.BeanFactory</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://www.manning.com/books/spring-in-action-fourth-edition" target="_blank" rel="noopener">Spring in Action, 4th</a>》</p>
<p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener">org.springframework.beans.factory.BeanFactory</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/29/spring-dependency-injection/" class="post-title-link">Spring 依赖注入总结</a></h2><div class="post-info">2017-05-29<a href="/tags/Java/" title="Java" class="post-demo">Java</a><a href="/tags/Spring/" title="Spring" class="post-demo">Spring</a></div><div class="post-content"><h1 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h1><p>按照传统的做法，每个对象负责管理与自己相互协作的对象（即它所依赖的对象）的引用，这将会导致高度耦合和难以测试的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">            +---+</span><br><span class="line">  +---new---&gt;Bar|</span><br><span class="line">  |         +---+</span><br><span class="line">+-+-+</span><br><span class="line">|Foo|</span><br><span class="line">+-+-+</span><br><span class="line">  |         +---+</span><br><span class="line">  +---new---&gt;Baz|</span><br><span class="line">            +---+</span><br></pre></td></tr></table></figure>

<p>通过依赖注入（Dependency Injection），对象的依赖关系将由系统中负责协调各对象的<strong>第三方组件</strong>在创建对象的时候进行设定。对象无需自行创建或管理它们的依赖关系，依赖关系将被自动注入到需要它们的对象当中去，即做到“控制反转（IoC）”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">             +---+</span><br><span class="line">  +--inject--+Bar|</span><br><span class="line">  |          +---+</span><br><span class="line">+-v-+</span><br><span class="line">|Foo|</span><br><span class="line">+-^-+</span><br><span class="line">  |          +---+</span><br><span class="line">  +--inject--+Baz|</span><br><span class="line">             +---+</span><br></pre></td></tr></table></figure>

<p>如果一个对象只通过接口（而不是具体实现或初始化过程）来表明依赖关系，那么这种依赖就能够在对象本身毫不知情的情况下，用不同的具体实现进行替换。这就是依赖注入所带来的最大收益——松耦合。</p>
<p>对依赖进行替换的一个最常用方法就是在测试的时候使用 mock 实现。</p>
<h1 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h1><p>在面向对象的编程中，有几种实现控制反转的基本技术：</p>
<ul>
<li>使用工厂模式（factory pattern）</li>
<li>使用服务定位模式（service locator pattern）</li>
<li>使用以下任何给定类型的<strong>依赖注入（DI）</strong>：<ul>
<li>构造方法注入（a constructor injection）</li>
<li>setter 方法注入（a setter injection）</li>
<li>接口注入（an interface injection）</li>
</ul>
</li>
</ul>
<h1 id="装配-Bean"><a href="#装配-Bean" class="headerlink" title="装配 Bean"></a>装配 Bean</h1><p>创建应用对象之间协作关系的行为通常称为装配（wiring），这也是依赖注入（DI）的本质。</p>
<p>Spring 通过它的配置，能够了解这些组成部分是如何装配起来的。这样的话，就可以在不改变所依赖的类的情况下，修改依赖关系。</p>
<p>Spring 提供几种配置方式，用于 bean 的声明及装配，详见《<a href="/2017/06/04/spring-bean-wiring/">Spring Bean 几种配置方式总结</a>》。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h2><p>通过依赖注入获取 Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring 会将 service 对象作为集合注入到 list</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> List&lt;DemoService&gt; demoServices;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring 会将 service 的名字作为 key，service 对象作为 value 注入到 Map</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, DemoService&gt; demoServiceMap;</span><br></pre></td></tr></table></figure>

<h2 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h2><p>通过 <code>BeanFactory</code> 主动获取 Bean：</p>
<p><img src="/img/spring/getBean.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxHandlerFactoryBean</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 通过注解获取 Beans</span></span><br><span class="line">        Map&lt;String, Object&gt; beans = applicationContext.getBeansWithAnnotation(PayMethod<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        beans.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line">            Class&lt;?&gt; beanClass = bean.getClass();</span><br><span class="line">            PayMethod payMethod = beanClass.getAnnotation(PayMethod<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            map.put(payMethod.code(), beanClass);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getBeanClass(String code) &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = map.get(code);</span><br><span class="line">        <span class="keyword">if</span> (aClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(<span class="string">"Not Implemented"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h2><p>下例通过 Collection Injection 实现自定义策略模式。</p>
<p>首先，创建策略注解。注意，此处还使用了 <code>@Service</code>，表示标注了 <code>@PayMethod</code> 注解的类都由 Spring Bean Factory 来创建对象并管理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PayMethod &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function">PayMethodEnum <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiredArgsConstructor</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">enum</span> PayMethodEnum &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建策略类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XxxHandler</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PayMethod</span>(code = PayMethod.PayMethodEnum.Aaa)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AaaHandler</span> <span class="keyword">implements</span> <span class="title">XxxHandler</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，创建工厂类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.NotImplementedException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxHandlerFactoryBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;PayMethod.PayMethodEnum, XxxHandler&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过构造方法注入策略实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XxxHandlerFactory</span><span class="params">(List&lt;XxxHandler&gt; handlers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = handlers.stream()</span><br><span class="line">                .filter(handler -&gt; getAnnotation(handler) != <span class="keyword">null</span>)</span><br><span class="line">                .collect(Collectors.toMap(handler -&gt; getAnnotation(handler).code(), Function.identity()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> PayMethod <span class="title">getAnnotation</span><span class="params">(XxxHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler.getClass().getAnnotation(PayMethod<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XxxHandler <span class="title">getHandler</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        PayMethod.PayMethodEnum payMethodEnum = PayMethod.PayMethodEnum.valueOfCode(code);</span><br><span class="line">        XxxHandler handler = map.get(payMethodEnum);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(<span class="string">"Not Implemented"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://www.manning.com/books/spring-in-action-fourth-edition" target="_blank" rel="noopener">Spring in Action, 4th</a>》</p>
<p>《<a href="https://www.manning.com/books/dependency-injection" target="_blank" rel="noopener">Dependency Injection, Design patterns using Spring and Guice</a>》</p>
<p>《<a href="https://www.cnblogs.com/fuchongjundream/p/3873073.html" target="_blank" rel="noopener">IoC模式（依赖、依赖倒置、依赖注入、控制反转）</a>》</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/28/maven-archetype/" class="post-title-link">Maven 实战系列（七）骨架快速搭建项目</a></h2><div class="post-info">2017-05-28<a href="/tags/Java/" title="Java" class="post-demo">Java</a></div><div class="post-content"><p>工作中经常需要为新开展的业务创建新工程，如果每次都重新搭建、或者拷贝老项目，这些重复工作会影响开发效率，也不利于维护（例如为新工程统一引入新组件、或升级配置文件等）。Maven 提供了 archetype 骨架插件，用于抽取这些重复的配置和代码，以模板的方式创建新项目。</p>
<p>Maven Archetype Plugin（骨架插件）能够让用户从现有的模板（即骨架）中创建 Maven 项目，也能够从现有的项目中创建骨架。其流程如下：</p>
<p><img src="/img/java/maven/archetype-overview.png" alt="Maven Archetype Plugin"></p>
<p>从上图可见，该插件提供了如下目标（即命令）：</p>
<ul>
<li><a href="http://maven.apache.org/archetype/maven-archetype-plugin/generate-mojo.html" target="_blank" rel="noopener"><code>archetype:generate</code></a> creates a Maven project from an archetype: asks the user to choose an archetype from the archetype catalog, and retrieves it from the remote repository. Once retrieved, it is processed to create a working Maven project.</li>
<li><a href="http://maven.apache.org/archetype/maven-archetype-plugin/create-from-project-mojo.html" target="_blank" rel="noopener"><code>archetype:create-from-project</code></a> creates an archetype from an existing project.（注意如果需要包含 yml 配置文件，需要加上参数 <code>-Darchetype.filteredExtentions=yml</code>）</li>
<li><a href="http://maven.apache.org/archetype/maven-archetype-plugin/crawl-mojo.html" target="_blank" rel="noopener"><code>archetype:crawl</code></a> search a repository for archetypes and updates a catalog.</li>
</ul>
<p>下面具体演示如何使用。</p>
<h1 id="创建-archetype-工程样例"><a href="#创建-archetype-工程样例" class="headerlink" title="创建 archetype 工程样例"></a>创建 archetype 工程样例</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>利用 Maven 内置的 <code>maven-archetype-archetype</code> 构件创建一个骨架工程样例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate</span><br><span class="line">  -DgroupId&#x3D;[your project&#39;s group id]</span><br><span class="line">  -DartifactId&#x3D;[your project&#39;s artifact id]</span><br><span class="line">  -DarchetypeArtifactId&#x3D;maven-archetype-archetype</span><br></pre></td></tr></table></figure>

<p>创建成功后，其目录结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">archetype</span><br><span class="line">|-- pom.xml  <span class="comment">// archetype pom</span></span><br><span class="line">`-- src</span><br><span class="line">    `-- main</span><br><span class="line">        `-- resources</span><br><span class="line">            |-- META-INF</span><br><span class="line">            |   `-- maven</span><br><span class="line">            |       `--archetype.xml  <span class="comment">// archetype descriptor</span></span><br><span class="line">            `-- archetype-resources  <span class="comment">// prototype files</span></span><br><span class="line">                |-- pom.xml  <span class="comment">// prototype pom</span></span><br><span class="line">                `-- src</span><br><span class="line">                    |-- main</span><br><span class="line">                    |   `-- java</span><br><span class="line">                    |       `-- App.java</span><br><span class="line">                    `-- test</span><br><span class="line">                        `-- java</span><br><span class="line">                            `-- AppTest.java</span><br></pre></td></tr></table></figure>

<p>骨架由以下四个部分组成，各文件作用如下：</p>
<table>
<thead>
<tr>
<th>组成部分</th>
<th>组成部分</th>
<th>路径</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>archetype pom</td>
<td>骨架的 POM</td>
<td>根目录下的 <code>pom.xml</code></td>
<td></td>
</tr>
<tr>
<td>archetype descriptor</td>
<td>骨架描述符文件</td>
<td><code>src/main/resources/META-INF/maven/archetype.xml</code></td>
<td>这个文件列出了包含在 archetype 中的所有文件并将这些文件分类，因此 archetype 生成机制才能正确的处理。</td>
</tr>
<tr>
<td>prototype pom</td>
<td>新工程的原型 POM</td>
<td><code>src/main/resources/archetype-resources/pom.xml</code></td>
<td>archetype 插件会直接复制这个 <code>pom.xml</code>，然后替换其中的占位符 <code>${artifactId}</code>、<code>${groupId}</code>、<code>${version}</code></td>
</tr>
<tr>
<td>prototype files</td>
<td>新工程的原型文件</td>
<td><code>src/main/resources/archetype-resources/</code></td>
<td>archetype 插件会直接复制这些文件</td>
</tr>
</tbody></table>
<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>利用公司现有模板项目创建骨架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create-from-project -Darchetype.filteredExtentions&#x3D;yml,xml,java,jsp</span><br></pre></td></tr></table></figure>

<p>创建成功后，其目录结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">youproject</span><br><span class="line">|-- pom.xml	<span class="comment">// 项目源文件</span></span><br><span class="line">`-- src	<span class="comment">// 项目源文件</span></span><br><span class="line">    `-- main</span><br><span class="line">    `-- test</span><br><span class="line">`-- target  <span class="comment">// 创建结果</span></span><br><span class="line">    `-- generated-sources</span><br><span class="line">        `-- archetype</span><br><span class="line">            <span class="comment">// 目录结构同方式一。后续安装 archetype 到本地仓库时，需要 cd 到本目录，执行 mvn install；如果是发布到远程仓库，则 mvn deploy</span></span><br></pre></td></tr></table></figure>

<p><code>-Darchetype.filteredExtentions</code> 用于指定要过滤的文件后缀名，被过滤的文件将会替换文件里面用到的占位符。在生成的 archetype.xml 文件时，命令将会扫描模板项目中所有的文件类型，为上述指定的文件类型添加 <code>filtered=&quot;true&quot;</code> 属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">packaged</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.jsp<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">packaged</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/test/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="配置骨架"><a href="#配置骨架" class="headerlink" title="配置骨架"></a>配置骨架</h1><h2 id="配置描述符-archetype-xml"><a href="#配置描述符-archetype-xml" class="headerlink" title="配置描述符 archetype.xml"></a>配置描述符 archetype.xml</h2><p>然后，配置 archetype.xml，详见：<a href="http://maven.apache.org/archetype/archetype-models/archetype-descriptor/archetype-descriptor.html" target="_blank" rel="noopener">archetype descriptor</a></p>
<h2 id="配置新工程的-pom-xml"><a href="#配置新工程的-pom-xml" class="headerlink" title="配置新工程的 pom.xml"></a>配置新工程的 pom.xml</h2><p>使用占位符 <code>${artifactId}</code>、<code>${groupId}</code>、<code>${version}</code>，这些变量都将在 <code>archetype:generate</code> 命令运行时被初始化：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>$&#123;groupId&#125;<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>$&#123;artifactId&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>A custom project<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.myorganization.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置新工程的相关文件"><a href="#配置新工程的相关文件" class="headerlink" title="配置新工程的相关文件"></a>配置新工程的相关文件</h2><p>将新工程所需文件，全部拷贝到 <code>src/main/resources/archetype-resources/</code> 目录下。</p>
<h1 id="安装本地仓库"><a href="#安装本地仓库" class="headerlink" title="安装本地仓库"></a>安装本地仓库</h1><p>创建骨架并配置完毕，首先安装到本地仓库：</p>
<ul>
<li>如果是使用 Maven 内置的 <code>maven-archetype-archetype</code> 构件创建的骨架工程样例，直接在该目录下执行安装命令即可。</li>
<li>如果是使用命令 <code>mvn archetype:create-from-project</code> 从现有的项目中创建骨架，需要先 <code>cd</code> 进入到 <code>target/generated-sources/archetype/</code> 目录，再运行 <code>mvn install</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure>

<p>执行如下插件 goal：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">maven-resources-plugin:resources  &#x2F;&#x2F; 拷贝资源文件</span><br><span class="line">maven-resources-plugin:testResources  &#x2F;&#x2F; 拷贝测试资源文件</span><br><span class="line">maven-archetype-plugin:jar  &#x2F;&#x2F; 在 target 目录下构建出 archetype jar</span><br><span class="line">maven-archetype-plugin:integration-test</span><br><span class="line">maven-install-plugin:install  &#x2F;&#x2F; 将构建出来的 jar 和 pom 安装到本地仓库</span><br><span class="line">maven-archetype-plugin:update-local-catalog  &#x2F;&#x2F; 更新本地仓库根目录下的 archetype-catalog.xml</span><br></pre></td></tr></table></figure>

<p>安装完毕，构建出来的 archetype jar <code>artifactId-archetype-version.jar</code> 将会安装到本地仓库。此时需要更新本地仓库根目录下的 <code>archetype-catalog.xml</code> ，插入一段骨架配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">archetype-catalog</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/plugins/maven-archetype-plugin/archetype-catalog/1.0.0 http://maven.apache.org/xsd/archetype-catalog-1.0.0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/plugins/maven-archetype-plugin/archetype-catalog/1.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">archetypes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 新插入的骨架 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">archetype</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>[your project's group id]<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>[your project's artifact id]<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">description</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">archetype</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">archetypes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">archetype-catalog</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以使用命令：<code>mvn archetype:crawl</code>，将自动搜索仓库中的骨架并更新骨架配置。</p>
<h1 id="发布到远程仓库"><a href="#发布到远程仓库" class="headerlink" title="发布到远程仓库"></a>发布到远程仓库</h1><p>骨架生成成功，并且一切符合预期之后，可以发布到远程仓库供他人使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy</span><br></pre></td></tr></table></figure>

<h1 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h1><h2 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h2><p>尝试创建项目，选择想要使用的骨架，并为新工程指定 <code>groupId</code> 和 <code>artifactId</code>，以及包名 <code>package</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate                                  \</span><br><span class="line">  -DarchetypeGroupId&#x3D;&lt;archetype-groupId&gt;                \</span><br><span class="line">  -DarchetypeArtifactId&#x3D;&lt;archetype-artifactId&gt;          \</span><br><span class="line">  -DarchetypeVersion&#x3D;&lt;archetype-version&gt;                \</span><br><span class="line">  -DgroupId&#x3D;&lt;my.groupid&gt;                                \</span><br><span class="line">  -DartifactId&#x3D;&lt;my-artifactId&gt;                          \</span><br><span class="line">  -Dversion&#x3D;&lt;my.version&gt;                                \</span><br><span class="line">  -Dpackage&#x3D;my.package</span><br></pre></td></tr></table></figure>

<p>输出日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Using property: groupId &#x3D; &lt;my.groupid&gt;</span><br><span class="line">[INFO] Using property: artifactId &#x3D; &lt;my-artifactId&gt;</span><br><span class="line">[INFO] Using property: version &#x3D; &lt;my.version&gt;</span><br><span class="line">[INFO] Using property: package &#x3D; my.package</span><br><span class="line">Confirm properties configuration:</span><br><span class="line">groupId: &lt;my.groupid&gt;</span><br><span class="line">artifactId: &lt;my-artifactId&gt;</span><br><span class="line">version: &lt;my.version&gt;</span><br><span class="line">package: my.package</span><br><span class="line"> Y:</span><br></pre></td></tr></table></figure>

<p>回复 <code>Y</code> 确认即可。</p>
<h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p>File &gt; New Module &gt; Maven，勾选 Create from archetype，点击 Add Archetype，配置如下：</p>
<p><img src="/img/java/maven/idea_add_archetype.png" alt="IDEA 中添加 archetype"></p>
<p>输入创建 archetype 工程时，定义的 GroupId、ArtifactId、Version，并选择你远程仓库的地址即可，例如：<a href="http://xxx/nexus/content/repositories/snapshots。" target="_blank" rel="noopener">http://xxx/nexus/content/repositories/snapshots。</a></p>
<p>配置完毕，创建新工程时，将会执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-DinteractiveMode&#x3D;false</span><br><span class="line">-DarchetypeGroupId&#x3D;</span><br><span class="line">-DarchetypeArtifactId&#x3D;</span><br><span class="line">-DarchetypeVersion&#x3D;</span><br><span class="line">-DarchetypeRepository&#x3D;http:&#x2F;&#x2F;xxx&#x2F;nexus&#x2F;content&#x2F;repositories&#x2F;snapshots </span><br><span class="line">-DgroupId&#x3D;</span><br><span class="line">-DartifactId&#x3D; </span><br><span class="line">-Dversion&#x3D;</span><br><span class="line">org.apache.maven.plugins:maven-archetype-plugin:RELEASE:generate</span><br></pre></td></tr></table></figure>

<p>goal <code>generate</code> 执行过程中会下载指定的 archetype jar，并根据指定参数创建新工程。</p>
<p>注意，由于这种方式只会下载指定的 archetype jar 到本地仓库，但不会将骨架添加到本地仓库根目录下的骨架目录文件  <code>archetype-catalog.xml</code> 之中。这将会导致在 IDEA 之外以命令行方式执行 <code>mvn archetype:generate</code> 生成新工程时，由于在骨架目录文件中找不到指定 archetype 而报错，因此需要将该 archetype 添加到骨架目录文件下。解决方法是执行命令：<code>mvn archetype:crawl</code> 遍历本地仓库搜索骨架并更新目录文件。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://maven.apache.org/guides/introduction/introduction-to-archetypes.html" target="_blank" rel="noopener">https://maven.apache.org/guides/introduction/introduction-to-archetypes.html</a></p>
<p><a href="https://maven.apache.org/guides/mini/guide-creating-archetypes.html" target="_blank" rel="noopener">https://maven.apache.org/guides/mini/guide-creating-archetypes.html</a></p>
<p><a href="http://maven.apache.org/archetype/maven-archetype-plugin/" target="_blank" rel="noopener">http://maven.apache.org/archetype/maven-archetype-plugin/</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/19/maven-plugins/" class="post-title-link">Maven 实战系列（六）插件总结</a></h2><div class="post-info">2017-05-19<a href="/tags/Java/" title="Java" class="post-demo">Java</a></div><div class="post-content"><p>Maven 本质上是一个插件框架，它的核心并不执行任何具体的构建任务，所有这些任务都交给插件来完成，例如编译源代码是由 <code>maven-compiler-plugin</code> 完成的。每个插件会有一个或者多个目标（goal），例如 <code>maven-compiler-plugin</code> 插件的 <code>compile</code> 目标用来编译位于 <code>src/main/java/</code> 目录下的主源码，<code>testCompile</code> 目标用来编译位于 <code>src/test/java/</code> 目录下的测试源码。</p>
<p>用户可以通过两种方式调用 Maven 插件目标：</p>
<ol>
<li>将插件目标与生命周期阶段（lifecycle phase）绑定，这样用户在命令行只是输入生命周期阶段而已，例如 Maven 默认将 <code>maven-compiler-plugin</code> 的 <code>compile</code> 目标与 <code>compile</code> 生命周期阶段绑定，因此命令 <code>mvn compile</code> 实际上是先定位到 <code>compile</code> 这一生命周期阶段，然后再根据绑定关系调用 <code>maven-compiler-plugin</code> 的 <code>compile</code> 目标。</li>
<li>直接在命令行指定要执行的插件目标（goal），例如 <code>mvn archetype:generate</code> 就表示调用 <code>maven-archetype-plugin</code> 的 <code>generate</code> 目标，<strong>这种带冒号的调用方式与生命周期无关</strong>。</li>
</ol>
<p>常用插件整理如下：</p>
<p><img src="/img/java/maven/plugins.png" alt="Maven 常用插件"></p>
<h1 id="核心插件"><a href="#核心插件" class="headerlink" title="核心插件"></a>核心插件</h1><h2 id="maven-clean-plugin"><a href="#maven-clean-plugin" class="headerlink" title="maven-clean-plugin"></a>maven-clean-plugin</h2><h2 id="maven-resources-plugin"><a href="#maven-resources-plugin" class="headerlink" title="maven-resources-plugin"></a>maven-resources-plugin</h2><h2 id="maven-compiler-plugin"><a href="#maven-compiler-plugin" class="headerlink" title="maven-compiler-plugin"></a>maven-compiler-plugin</h2><p>指定编译版本。</p>
<p>方式一</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="maven-surefire-plugin"><a href="#maven-surefire-plugin" class="headerlink" title="maven-surefire-plugin"></a>maven-surefire-plugin</h2><h2 id="maven-install-plugin"><a href="#maven-install-plugin" class="headerlink" title="maven-install-plugin"></a>maven-install-plugin</h2><h2 id="maven-deploy-plugin"><a href="#maven-deploy-plugin" class="headerlink" title="maven-deploy-plugin"></a>maven-deploy-plugin</h2><h1 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h1><h2 id="maven-jar-plugin"><a href="#maven-jar-plugin" class="headerlink" title="maven-jar-plugin"></a>maven-jar-plugin</h2><h2 id="maven-war-plugin"><a href="#maven-war-plugin" class="headerlink" title="maven-war-plugin"></a>maven-war-plugin</h2><h1 id="其它工具"><a href="#其它工具" class="headerlink" title="其它工具"></a>其它工具</h1><h2 id="maven-archetype-plugin"><a href="#maven-archetype-plugin" class="headerlink" title="maven-archetype-plugin"></a>maven-archetype-plugin</h2><p>用于生成骨架，详见：<a href="/2018/12/08/maven-archetype/">Maven 骨架快速搭建项目</a>。</p>
<h2 id="maven-assembly-plugin"><a href="#maven-assembly-plugin" class="headerlink" title="maven-assembly-plugin"></a>maven-assembly-plugin</h2><p>用于将项目输出及其依赖项、模块、站点文档和其它文件聚合构建成一个可执行的分发包。</p>
<p>项目简单配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.github.testproject.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                        jar-with-dependencies</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行 Goal <code>assembly:single</code>，将在 target 目录中生成一个 <code>artifactId-version-jar-with-dependencies.jar</code> 文件，内含所需的所有依赖，执行 <code>java -jar</code> 即可运行。</p>
<h2 id="maven-dependency-plugin"><a href="#maven-dependency-plugin" class="headerlink" title="maven-dependency-plugin"></a>maven-dependency-plugin</h2><p>用于分析项目依赖，例如通过 <code>mvn dependency:tree</code> 命令分析 Dubbo 默认依赖的第三方库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[INFO] +- com.alibaba:dubbo:jar:2.5.9-SNAPSHOT:compile</span><br><span class="line">[INFO] |  +- org.springframework:spring-context:jar:4.3.10.RELEASE:compile</span><br><span class="line">[INFO] |  +- org.javassist:javassist:jar:3.21.0-GA:compile</span><br><span class="line">[INFO] |  \- org.jboss.netty:netty:jar:3.2.5.Final:compile</span><br></pre></td></tr></table></figure>

<h1 id="Spring-Boot-插件"><a href="#Spring-Boot-插件" class="headerlink" title="Spring Boot 插件"></a>Spring Boot 插件</h1><p>Spring Boot 提供了 <code>spring-boot-maven-plugin</code> 插件，可用于本地快速编译并运行、及项目打包。参考：<a href="/2017/08/01/spring-boot-getting-started/">Maven 插件</a>。</p>
<h1 id="IDEA-Maven-插件"><a href="#IDEA-Maven-插件" class="headerlink" title="IDEA Maven 插件"></a>IDEA Maven 插件</h1><p>最后来看下 IDEA Maven 插件提供的 Maven Projects tool window 功能：</p>
<p><img src="/img/java/idea/maven_projects.png" alt="IDEA Maven Projects"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://maven.apache.org/plugins/index.html" target="_blank" rel="noopener">http://maven.apache.org/plugins/index.html</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/13/nginx-upstream/" class="post-title-link">Nginx 负载均衡</a></h2><div class="post-info">2017-05-13<a href="/tags/Nginx/" title="Nginx" class="post-demo">Nginx</a></div><div class="post-content"><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>Nginx 标准 HTTP 模块 <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html" target="_blank" rel="noopener">ngx_http_upstream_module</a> 内置了集群和负载均衡功能，使用其中的 <code>upstream</code> 配合 <code>proxy_pass</code> 指令即可快速实现一个集群：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server backend1.example.com       weight&#x3D;5;</span><br><span class="line">        server 127.0.0.1:8080             max_fails&#x3D;3 fail_timeout&#x3D;30s;</span><br><span class="line">        server unix:&#x2F;tmp&#x2F;backend3;</span><br><span class="line"></span><br><span class="line">        server backup1.example.com:8080   backup;</span><br><span class="line">        server backup2.example.com:8080   down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>server</code> 指令的常用参数描述如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>weight=number</code></td>
<td>设置服务器的轮询权重，默认为 1。用于后端服务器性能不均的情况。</td>
</tr>
<tr>
<td><code>max_conns=number</code></td>
<td>设置被代理服务器的最大可用并发连接数限制，默认为 0，表示没有限制。</td>
</tr>
<tr>
<td><code>max_fails=number</code></td>
<td>设置最大失败重试次数，默认为 1。设置为 0 表示禁用重试。</td>
</tr>
<tr>
<td><code>fail_timeout=time</code></td>
<td>设置失败时间，默认 10 秒。</td>
</tr>
<tr>
<td><code>backup</code></td>
<td>将服务器标记为备份服务器。当主服务器不可用时，它将被传递请求。</td>
</tr>
<tr>
<td><code>down</code></td>
<td>将服务器标记为永久不可用。</td>
</tr>
</tbody></table>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡（Load Balance），其意思就是将运算或存储负载按一定的算法分摊到多个运算或存储单元上，下面介绍 Nginx 几种常见的负载均衡方法：</p>
<ul>
<li>默认策略：加权轮询策略（weighted round-robin）。</li>
<li><code>random</code>，加权随机策略。</li>
<li><code>ip_hash</code>，基于客户端 IP 计算出哈希值，再根据服务器数量取模选取服务器（ip_hash % server_size = server_no）。</li>
<li><code>hash key [consistent]</code>，基于指定 key 计算出哈希值，再根据服务器数量取模选取服务器。可选一致性哈希算法缓解重映射问题。</li>
<li><code>least_conn</code>，基于最小活跃连接数（加权）。如果有多个服务器符合条件，则使用加权轮询策略依次响应。</li>
<li><code>least_time</code>，基于最小平均响应时间和最小活跃连接数（加权）。如果有多个服务器符合条件，则使用加权轮询策略依次响应。</li>
</ul>
<h2 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip hash"></a>ip hash</h2><p>使用 Nginx <code>ip_hash</code> 指令，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line"></span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">    server backend3.example.com down;</span><br><span class="line">    server backend4.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ip_hash</code> 指令指定集群使用基于<strong>客户端 IP 地址</strong>的负载均衡方法。 客户端 IPv4 地址的前三个八位字节或整个 IPv6 地址用作哈希键。 该方法确保来自同一客户端的请求将始终传递到同一台服务器，除非此服务器不可用，客户端请求则将被<strong>转发</strong>到另一台服务器（多数情况下，始终是同一台服务器）。<br>如果其中一台服务器需要临时删除，则应使用 <code>down</code> 参数标记，以便保留当前客户端 IP 地址的哈希值。</p>
<h2 id="一致性-hash"><a href="#一致性-hash" class="headerlink" title="一致性 hash"></a>一致性 hash</h2><p>使用 Nginx <code>hash</code> 指令，常用的例如基于来源 IP 进行哈希，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    hash $remote_addr consistent;</span><br><span class="line"></span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hash</code> 指令指定集群使用基于<strong>指定 hash 散列键</strong>的负载均衡方法。散列键可以包含文本，变量及其组合。请注意，从集群中添加或删除服务器可能会导致大量键被重新映射到不同的服务器。</p>
<p>解决办法是使用 <code>consistent</code> 参数启用  <a href="http://www.last.fm/user/RJ/journal/2007/04/10/392555/" target="_blank" rel="noopener">ketama</a> 一致性 hash 算法。 该算法将每个 server 虚拟成 n 个节点，均匀分布到 hash 环上。每次请求，根据配置的参数计算出一个 hash 值，在 hash 环上查找离这个 hash 最近的虚拟节点，对应的 server 作为该次请求的后端服务器。该算法确保在添加或删除服务器时，只会有少量键被重新映射到不同的服务器。这有助于为缓存服务器实现更高的缓存命中率。</p>
<h1 id="会话保持"><a href="#会话保持" class="headerlink" title="会话保持"></a>会话保持</h1><p>sticky cookie 粘滞会话（也称会话保持\会话绑定）是负载均衡的一个基本功能，为了确保与某个客户相关的所有应用请求能够由同一台服务器进行处理，我们需要在负载均衡上启用会话保持功能，以确保负载均衡的部署不会影响到正常的业务处理。</p>
<p>基于源地址的 ip_hash 进行会话保持的问题在于，当多个客户是通过代理或地址转换的方式来访问服务器时，由于都分配到同一台服务器上，会导致服务器之间的负载失衡。</p>
<p>通过 cookie 实现客户端与后端服务器的会话保持，在一定条件下可以保证同一个客户端访问的都是同一个后端服务器。使用 Nginx <code>sticky</code> 指令，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line"></span><br><span class="line">    sticky cookie srv_id expires&#x3D;1h domain&#x3D;.example.com path&#x3D;&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这份配置在同一域名下有两个 location，分别对应了两组集群服务。为了分别实现会话保持，将 cookie 写入了对应的 path 下，避免 cookie 互相干扰，也减少了数据传输量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend1 &#123;</span><br><span class="line">        server backup1.example.com:8080;</span><br><span class="line">        server backup1.example.com:8081;</span><br><span class="line">    	sticky cookie srv_backend1 path&#x3D;&#x2F;backend1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream backend2 &#123;</span><br><span class="line">        server backup2.example.com:8080;</span><br><span class="line">        server backup2.example.com:8081;</span><br><span class="line">    	sticky cookie srv_backend2 path&#x3D;&#x2F;backend2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        server_name example.com;</span><br><span class="line">        listen 80;</span><br><span class="line">    </span><br><span class="line">        location &#x2F;backend1&#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location &#x2F;backend2&#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h1><p>健康检查（Health Check）是保障集群可用性的重要手段，有三种常见的健康检查方法：</p>
<ul>
<li>使用社区版 Nginx 的 <code>max_fails</code> 和 <code>fail_timeout</code> 指令进行被动式检查，不推荐使用，详见：《<a href="https://segmentfault.com/a/1190000002446630" target="_blank" rel="noopener">nginx中健康检查(health_check)机制深入分析</a>》；</li>
<li>使用<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业版 Nginx Plus</a> 进行主动式检查，缺点是要收费；</li>
<li>使用 Nginx 第三方模块编译，例如：<a href="https://github.com/yaoweibin/nginx_upstream_check_module" target="_blank" rel="noopener">nginx_upstream_check_module</a> ；</li>
<li>使用 <a href="http://tengine.taobao.org/" target="_blank" rel="noopener">Tengine</a> 内置的<a href="http://tengine.taobao.org/document_cn/http_upstream_check_cn.html" target="_blank" rel="noopener">主动式健康检查</a>功能（该内置模块等同于第 3 点）。</li>
</ul>
<h2 id="主动式健康检查"><a href="#主动式健康检查" class="headerlink" title="主动式健康检查"></a>主动式健康检查</h2><p>以 <code>nginx_upstream_check_module</code> 第三方模块为例，演示配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend1 &#123;</span><br><span class="line">    check interval&#x3D;3000 rise&#x3D;2 fall&#x3D;5 timeout&#x3D;1000 type&#x3D;http;</span><br><span class="line">    check_keepalive_requests 100;</span><br><span class="line">    check_http_send &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1\r\nConnection: keep-alive\r\nHost: check.com\r\n\r\n&quot;;</span><br><span class="line">    check_http_expect_alive http_2xx http_3xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段配置表示：</p>
<ol>
<li><code>check</code> 指令配置：每隔 <code>interval</code> 毫秒主动发送一个 <code>http</code> 健康检查包给后端服务器。请求超时时间为 <code>timeout</code> 毫秒。如果连续失败次数达到 <code>fall_count</code>，服务器就被认为是 down；如果连续成功次数达到 <code>rise_count</code>，服务器就被认为是 up。</li>
<li><code>check_keepalive_requests</code> 指令配置：一个连接发送的请求数。</li>
<li><code>check_http_send</code> 指令配置：请求包的内容（注意，这里必须<a href="https://my.oschina.net/liuleidefeng/blog/786739" target="_blank" rel="noopener">配置 <code>Host</code> 请求头否则可能报错</a>）。</li>
<li><code>check_http_expect_alive</code> 指令配置：响应状态码为 <code>2XX</code> 和 <code>3XX</code> 表示请求成功、服务健康。</li>
</ol>
<p>查看 Tomcat access.log 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:30 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:33 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:36 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:39 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:42 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:45 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br></pre></td></tr></table></figure>

<p>此时关闭某台后端服务器，一段时间后再访问，请求会被路由到其它服务器；重启后，该服务器自动加入集群。通过健康状态页面 <code>/status</code> 可见：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Nginx http upstream check status</span><br><span class="line"></span><br><span class="line">Check upstream server number: 2, generation: 2</span><br><span class="line"></span><br><span class="line">Index	Upstream	Name	Status	Rise counts	Fall counts	Check type	Check port</span><br><span class="line">0	backend1	127.0.0.1:8080	up	4741	0	http	0</span><br><span class="line">1	backend1	127.0.0.1:8081	down	0	2340	http	0</span><br></pre></td></tr></table></figure>

<h1 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h1><h2 id="upstream-addr"><a href="#upstream-addr" class="headerlink" title="$upstream_addr"></a>$upstream_addr</h2><p>该模块中很常用的一个变量，用于标识集群中服务器的 IP 和端口。一般会加入到 Nginx 日志、同时脱敏后加入到响应头中，用于排查问题来源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;&quot;$http_x_forwarded_for&quot; - &quot;$upstream_addr&quot; - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                  &#39;&quot;$http_user_agent&quot; $remote_addr $request_time_msec&#39;</span><br><span class="line">    access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    map $upstream_addr $short_address &#123;</span><br><span class="line">        ~^\d+\.\d+\.\d+\.(.*) &#39;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        server_name example.com;</span><br><span class="line">        listen 80;</span><br><span class="line">        </span><br><span class="line">        upstream backend &#123;</span><br><span class="line">            server 127.0.0.1:81;</span><br><span class="line">            server 127.0.0.1:82;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            add_header X-From $short_address$1;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend&#x2F;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/05/07/nginx-ssl/" class="post-title-link">Nginx 加密通信（HTTPS）</a></h2><div class="post-info">2017-05-07<a href="/tags/Nginx/" title="Nginx" class="post-demo">Nginx</a></div><div class="post-content"><p>Nginx 中配置 HTTPS/SSL 加密是非常简单的，只需要将可选 HTTP 模块中的 <code>ngx_http_ssl_module</code> 编译进去即可。然后有两种方式开启 SSL 模式：</p>
<ul>
<li><code>ssl on</code> </li>
<li><code>listen 443 ssl</code> 此端口上接收的所有连接都工作在 SSL 模式。</li>
</ul>
<p>建议使用 <code>listen</code> 指令的 <code>ssl</code> 参数替代 <code>ssl on</code> 指令，这样可以为同时处理 HTTP 和 HTTPS 请求的服务器提供更加紧凑的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># http 和 https(ssl) 并存配置：</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        server_name example.com;</span><br><span class="line">        listen 80;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        </span><br><span class="line">        ssl_certificate      example.com.crt;</span><br><span class="line">        ssl_certificate_key  example.com.key;</span><br><span class="line">        </span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:81&#x2F;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果两个配置同时启用，HTTP 访问可能会报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">400 Bad Request</span><br><span class="line">The plain HTTP request was sent to HTTPS port</span><br></pre></td></tr></table></figure>

</div></article></li></ul><div class="right-container"><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/DNS/" style="font-size: 12.5px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GNU-Linux/" style="font-size: 16.67px;">GNU/Linux</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 19.17px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 11.67px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10.83px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15.83px;">Spring</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 18.33px;">前端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">响应式编程</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 12.5px;">安全</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">并发编程</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 13.33px;">建站</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 12.5px;">管理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.17px;">读书笔记</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 12.5px;">金融</a></div></div><div class="widget"><div class="recent"><h4>最近文章</h4><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/02/26/cpp-io-library/">C/C++ 语言系列（十一）I/O 库总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/25/cpp-oop-inheritance-and-polymorphism/">C/C++ 语言系列（十）面向对象编程之继承与多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/20/cpp-oop-class/">C/C++ 语言系列（九）面向对象编程之类、类模板、类指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/18/cpp-type-aliases/">C/C++ 语言系列（八）复合数据类型之类型别名</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/16/cpp-struct/">C/C++ 语言系列（七）复合数据类型之结构体</a></li></ul></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/page/10/" class="prev">PREV</a><a href="/page/12/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2021 <a href="https://github.com/qidawu" target="_blank">Qida's Blog</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>