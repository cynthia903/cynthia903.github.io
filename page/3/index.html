<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> Qida's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="学习笔记 知识总结 思考感悟"><meta name="keywords"><meta name="author" content="Qida's Blog"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://qidawu.github.io/atom.xml" title="Qida's Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><a href="/" class="title-link">Qida's Blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/05/01/java-concurrency-package/" class="post-title-link">并发编程系列（二）Java 并发包总结</a></h2><div class="post-info">2020-05-01<a href="/tags/Java/" title="Java" class="post-demo">Java</a><a href="/tags/并发编程/" title="并发编程" class="post-demo">并发编程</a></div><div class="post-content"><p>工作中常用到一些并发编程类，这里做一些总结。</p>
<p>JDK 中涉及到线程的包如下：</p>
<h1 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h1><blockquote>
<p>内含基础并发类。</p>
</blockquote>
<h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><p>无返回结果的异步任务。</p>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>程序中的执行线程。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>Thread</code> 对象中保存了一些<strong>属性</strong>能够帮助我们来辨别每一个线程，知道它的状态，调整控制其优先级等：</p>
<p><code>ID</code></p>
<blockquote>
<p>每个线程的独特标识。</p>
</blockquote>
<p><code>Name</code></p>
<blockquote>
<p>线程的名称。</p>
</blockquote>
<p><code>Priority</code></p>
<blockquote>
<p>线程对象的优先级。优先级别在 1-10 之间，1 是最低级，10 是最高级。不建议改变它们的优先级。</p>
</blockquote>
<p><code>Daemon</code></p>
<blockquote>
<p>是否为守护线程。</p>
<p>Java 有一种特别的线程叫做守护线程。这种线程的<strong>优先级非常低</strong>，通常在程序里没有其他线程运行时才会执行它。当守护线程是程序里唯一在运行的线程时，JVM 会结束守护线程并终止程序。</p>
<p>根据这些特点，守护线程通常用于在同一程序里给普通线程（也叫使用者线程）提供服务。它们通常无限循环的等待服务请求或执行线程任务。它们不能做重要的任务，因为我们不知道什么时候会被分配到 CPU 时间片，并且只要没有其他线程在运行，它们可能随时被终止。<strong>JAVA中最典型的这种类型代表就是垃圾回收器 GC</strong>。</p>
<p>只能在 start() 方法之前可以调用 setDaemon() 方法。一旦线程运行了，就不能修改守护状态。</p>
<p>可以使用 isDaemon() 方法来检查线程是否是守护线程。</p>
</blockquote>
<p><code>Thread.UncaughtExceptionHandler</code></p>
<blockquote>
<p>用于捕获和处理线程对象抛出的 Unchecked Exception 来避免程序终结。</p>
</blockquote>
<p><code>Thread.State</code></p>
<blockquote>
<p>线程的状态，共六种：<br>NEW<br>RUNNABLE<br>BLOCKED<br>WAITING<br>TIME_WAITING<br>TERMINATED</p>
</blockquote>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>Thread</code> 类提供了以下几类<strong>方法</strong>：</p>
<ul>
<li>线程睡眠 <code>Thread.sleep(...)</code></li>
<li>线程中断 <code>Thread.interrupt()</code></li>
<li>线程让步 <code>Thread.yield()</code></li>
<li>线程合并 <code>Thread.join(...)</code></li>
<li>……</li>
</ul>
<p><code>Object</code> 提供了一组线程协作方法：</p>
<ul>
<li>线程协作 <code>Object.wait/notify</code></li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal<T></h2><p><code>ThreadLocal</code> 存放的值是线程内共享的，线程间互斥的，主要用于在线程内共享一些数据。</p>
<p>可以通过实现 <code>AutoCloseable</code> 以使用 try-with-resources 语法简化 <code>ThreadLocal</code> 资源清理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (ChannelContext ctx = <span class="keyword">new</span> ChannelContext(channel)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelContext</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Channel&gt; CTX = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelContext</span><span class="params">(FundChannelDTO dto)</span> </span>&#123;</span><br><span class="line">        Channel channel = Channel.builder()</span><br><span class="line">                .appId(dto.getAppId().toString())</span><br><span class="line">                .build();</span><br><span class="line">        CTX.set(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelContext</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        CTX.set(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CTX.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CTX.remove();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String appId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ThreadGroup"><a href="#ThreadGroup" class="headerlink" title="ThreadGroup"></a>ThreadGroup</h2><h1 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h1><h2 id="TimerTask"><a href="#TimerTask" class="headerlink" title="TimerTask"></a>TimerTask</h2><p><code>Timer</code> 是 JDK 中提供的一个定时器工具类，使用的时候会在主线程之外起一个单独的线程执行指定的定时任务 <code>TimerTask</code>，可以指定执行一次或者反复执行多次。</p>
<p><code>TimerTask</code> 是一个实现了 <code>Runnable</code> 接口的抽象类，代表一个可以被 <code>Timer</code> 执行的任务。</p>
<p><img src="/img/java/concurrent/TimerTask.png" alt="TimerTask"></p>
<h1 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a>java.util.concurrent</h1><blockquote>
<p>JDK 5 引入的 Executor Framework ，用于取代传统的并发编程。</p>
</blockquote>
<p><img src="/img/java/concurrent/package_concurrent.png" alt="Package concurrent"></p>
<h2 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h2><p>通过提供不同的 <code>ThreadFactory</code> 接口实现，可以改变被创建线程 <code>Thread</code> 的<strong>属性</strong>。<code>ThreadFactory</code> 有几种创建方式：</p>
<p>1、完全自定义方式。缺点是需要在 <code>newThread</code> 方法中实现的代码较多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory threadFactory = runnable -&gt; &#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">    thread.setName(<span class="string">"..."</span>);</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2、使用 <code>Executors</code> 工具类，这也是 <code>Executors</code> 工具类中提供的几种默认线程池所使用的方式。</p>
<p>缺点是只能使用默认属性，无法修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br></pre></td></tr></table></figure>

<p>优点是实现了基本的线程名称自增，该实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default thread factory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">"-thread-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、通过 Guava 提供的 <code>ThreadFactoryBuilder</code>。优点是可以轻易自定义任何属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"wechat-notify-%d"</span>).build()</span><br></pre></td></tr></table></figure>

<p>该实现如下，如果未提供自定义的 <code>ThreadFactory</code>，将使用 <code>Executors</code> 工具类提供的默认 <code>ThreadFactory</code> 并进行二次修改：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory <span class="title">build</span><span class="params">(ThreadFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String nameFormat = builder.nameFormat;</span><br><span class="line">  <span class="keyword">final</span> Boolean daemon = builder.daemon;</span><br><span class="line">  <span class="keyword">final</span> Integer priority = builder.priority;</span><br><span class="line">  <span class="keyword">final</span> UncaughtExceptionHandler uncaughtExceptionHandler = builder.uncaughtExceptionHandler;</span><br><span class="line">  <span class="keyword">final</span> ThreadFactory backingThreadFactory = (builder.backingThreadFactory != <span class="keyword">null</span>)</span><br><span class="line">          ? builder.backingThreadFactory</span><br><span class="line">          : Executors.defaultThreadFactory();</span><br><span class="line">  <span class="keyword">final</span> AtomicLong count = (nameFormat != <span class="keyword">null</span>) ? <span class="keyword">new</span> AtomicLong(<span class="number">0</span>) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">      Thread thread = backingThreadFactory.newThread(runnable);</span><br><span class="line">      <span class="keyword">if</span> (nameFormat != <span class="keyword">null</span>) &#123;</span><br><span class="line">        thread.setName(format(nameFormat, count.getAndIncrement()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (daemon != <span class="keyword">null</span>) &#123;</span><br><span class="line">        thread.setDaemon(daemon);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (priority != <span class="keyword">null</span>) &#123;</span><br><span class="line">        thread.setPriority(priority);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (uncaughtExceptionHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        thread.setUncaughtExceptionHandler(uncaughtExceptionHandler);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>有返回结果的异步任务。Executor Framework 的一个重要优点是提供了 <code>java.util.concurrent.Callable&lt;V&gt;</code> 接口用于返回异步任务的结果。它的用法跟 <code>Runnable</code> 接口很相似，但它提供了两种改进：</p>
<ul>
<li>这个接口中主要的方法叫 <code>call()</code> ，可以返回结果。</li>
<li>当你提交 <code>Callable</code> 对象到 <code>Executor</code> 执行者，你可以获取一个实现 <code>Future</code> 接口的对象，你可以用这个对象来控制和获取 <code>Callable</code> 对象的状态和结果。</li>
</ul>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><p><code>CountDownLatch</code></p>
<p><code>CyclicBarrier</code></p>
<p><code>Phaser</code></p>
<p><code>CompletableFuture</code></p>
<p><code>Semaphore</code></p>
<p><code>Exchanger</code></p>
<p><code>Executors</code></p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>参考另一篇《Java 并发编程系列（二）线程池总结》。</p>
<h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><p>详见另一个篇《Java 集合框架系列（三）并发实现总结》。</p>
<h2 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h2><p>java.util.concurrent.locks</p>
<blockquote>
<p>用于实现线程安全与通信。</p>
</blockquote>
<p><img src="/img/java/concurrent/package_locks.png" alt="Package locks"></p>
<h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>java.util.concurrent.atomic</p>
<blockquote>
<p>使用这些数据结构可以避免在并发程序中使用同步代码块（synchronized 或 Lock）。</p>
</blockquote>
<p><img src="/img/java/concurrent/package_atomic.png" alt="Package atomic"></p>
<p>JDK 5 新增的原子类，底层基于魔术类 <code>Unsafe</code> 进行 CAS 无锁操作。实现类按功能分组如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>Integer</th>
<th>Long</th>
<th>Boolean</th>
<th>引用类型</th>
</tr>
</thead>
<tbody><tr>
<td>基本类</td>
<td><code>AtomicInteger</code></td>
<td><code>AtomicLong</code></td>
<td><code>AtomicBoolean</code></td>
<td></td>
</tr>
<tr>
<td>引用类型</td>
<td></td>
<td></td>
<td></td>
<td><code>AtomicReference</code><br/><code>AtomicStampedReference</code><br/><code>AtomicMarkableReference</code></td>
</tr>
<tr>
<td>数组类型</td>
<td><code>AtomicIntegerArray</code></td>
<td><code>AtomicLongArray</code></td>
<td></td>
<td><code>AtomicReferenceArray</code></td>
</tr>
<tr>
<td>属性原子修改器</td>
<td><code>AtomicIntegerFieldUpdater</code></td>
<td><code>AtomicLongFieldUpdater</code></td>
<td></td>
<td><code>AtomicReferenceFieldUpdater</code></td>
</tr>
</tbody></table>
<p>JDK 8 新增 <code>Striped64</code> 累加计数器这个并发组件，64 指的是计数 64 bit 的数，即 <code>Long</code> 和 <code>Double</code> 类型。其实现类如下：</p>
<table>
<thead>
<tr>
<th>Long</th>
<th>Double</th>
</tr>
</thead>
<tbody><tr>
<td><code>LongAdder</code></td>
<td><code>DoubleAdder</code></td>
</tr>
<tr>
<td><code>LongAccumulator</code></td>
<td><code>DoubleAccumulator</code></td>
</tr>
</tbody></table>
<p>性能对比参考：<a href="http://www.manongjc.com/article/105666.html" target="_blank" rel="noopener">http://www.manongjc.com/article/105666.html</a></p>
<h1 id="Spring-包简介"><a href="#Spring-包简介" class="headerlink" title="Spring 包简介"></a>Spring 包简介</h1><h2 id="org-springframework-scheduling"><a href="#org-springframework-scheduling" class="headerlink" title="org.springframework.scheduling"></a>org.springframework.scheduling</h2><p>Spring Framework 中并发编程相关的类主要位于 <code>spring-context</code> 下的 <code>org.springframework.scheduling</code>，例如其子包 <code>concurrent</code>：</p>
<p><img src="/img/java/concurrent/package_spring_concurrent.png" alt="org.springframework.scheduling.concurrent"></p>
<p>其中，顶层的 <code>org.springframework.scheduling.concurrent.CustomizableThreadFactory</code> 结构如下：</p>
<p><img src="/img/java/concurrent/CustomizableThreadFactory.png" alt="org.springframework.util.CustomizableThreadFactory"></p>
<ul>
<li><p><code>CustomizableThreadFactory</code> 实现了 <code>java.util.concurrent.ThreadFactory</code> 线程工厂接口，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors.defaultThreadFactory 方法提供了一个实用的简单实现，为新线程设置了上下文，详见源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>CustomizableThreadFactory</code> 继承了 <code>org.springframework.util.CustomizableThreadCreator</code> 类，用于创建新线程，并提供各种线程属性自定义配置（如线程名前缀、线程优先级等）。</p>
</li>
</ul>
<p>然后重点看下最常用的 <code>org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor</code> 类，提供的方法列表如下：</p>
<p><img src="/img/java/concurrent/ThreadPoolTaskExecutor.png" alt="ThreadPoolTaskExecutor 方法列表"></p>
<p>当我们在实例化 <code>ThreadPoolTaskExecutor</code> 类的时候，其调用堆栈如下：</p>
<p><img src="/img/java/concurrent/ThreadPoolTaskExecutor_threads.png" alt=""></p>
<p>可见，实际上是先调用了抽象父类 <code>ExecutorConfigurationSupport</code> 的 <code>afterPropertiesSet()</code> 和 <code>initialize()</code> 方法，最后再调用 <code>ThreadPoolTaskExecutor#initializeExecutor(...)</code>，该方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ExecutorService <span class="title">initializeExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BlockingQueue&lt;Runnable&gt; queue = createQueue(<span class="keyword">this</span>.queueCapacity);</span><br><span class="line"></span><br><span class="line">    ThreadPoolExecutor executor;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.taskDecorator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="keyword">this</span>.corePoolSize, <span class="keyword">this</span>.maxPoolSize, <span class="keyword">this</span>.keepAliveSeconds, TimeUnit.SECONDS,</span><br><span class="line">                queue, threadFactory, rejectedExecutionHandler) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.execute(taskDecorator.decorate(command));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="keyword">this</span>.corePoolSize, <span class="keyword">this</span>.maxPoolSize, <span class="keyword">this</span>.keepAliveSeconds, TimeUnit.SECONDS,</span><br><span class="line">                queue, threadFactory, rejectedExecutionHandler);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowCoreThreadTimeOut) &#123;</span><br><span class="line">        executor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.threadPoolExecutor = executor;</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上就是通过构造方法实例化 <code>java.util.concurrent.ThreadPoolExecutor</code> 对象，并设置相应参数。</p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/04/25/relational-data-model/" class="post-title-link">关系数据模型总结</a></h2><div class="post-info">2020-04-25<a href="/tags/MySQL/" title="MySQL" class="post-demo">MySQL</a></div><div class="post-content"><h1 id="数据特征"><a href="#数据特征" class="headerlink" title="数据特征"></a>数据特征</h1><p>数据具有两种特征：</p>
<blockquote>
<p>静态特征，指的是数据结构、数据间的联系、对数据取值范围的约束。</p>
<p>动态特征，指的是对数据可以进行符合一定规则的操作</p>
</blockquote>
<h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><h2 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h2><p><img src="/img/db/data-model/composition_of_data_model.png" alt="composition_of_data_model"></p>
<h2 id="模型分类"><a href="#模型分类" class="headerlink" title="模型分类"></a>模型分类</h2><p><img src="/img/db/data-model/classification_of_data_model.png" alt="classification_of_data_model"></p>
<h1 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h1><h2 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h2><p><img src="/img/db/data-model/data_structure_of_relational_data_model.png" alt="data_structure_of_relational_data_model"></p>
<h2 id="关系的完整性约束"><a href="#关系的完整性约束" class="headerlink" title="关系的完整性约束"></a>关系的完整性约束</h2><p><img src="/img/db/data-model/data_check_of_relational_data_model.png" alt="data_check_of_relational_data_model"></p>
<h2 id="关系数据语言"><a href="#关系数据语言" class="headerlink" title="关系数据语言"></a>关系数据语言</h2><p>关系语言是一种声明式的查询语言，基于声明式编程范式（Declarative），有别于命令式编程范式（Imperative），特点（优点）是：<strong>高度非过程化</strong>！</p>
<p><img src="/img/db/data-model/relational_language_of_relational_data_model.png" alt="relational_language_of_relational_data_model"></p>
<h1 id="关系数据库的规范化理论"><a href="#关系数据库的规范化理论" class="headerlink" title="关系数据库的规范化理论"></a>关系数据库的规范化理论</h1><p><img src="/img/db/data-model/normalized_form.png" alt="normalized_form"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8" target="_blank" rel="noopener">数学符号表（维基百科）</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0_(%E6%95%B0%E6%8D%AE%E5%BA%93)" target="_blank" rel="noopener">关系代数（维基百科）</a></p>
<p><a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0" target="_blank" rel="noopener">关系代数（百度百度）</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/03/24/distributed-id-generator/" class="post-title-link">分布式 ID 之雪花算法实现</a></h2><div class="post-info">2020-03-24<a href="/tags/Java/" title="Java" class="post-demo">Java</a></div><div class="post-content"><h1 id="雪花算法介绍"><a href="#雪花算法介绍" class="headerlink" title="雪花算法介绍"></a>雪花算法介绍</h1><p>雪花算法（Snowflake）是 Twitter 提出来的一个算法，其目的是生成一个 64 bit 的整数：</p>
<p><img src="/img/distribute/Snowflake.png" alt="Snowflake"></p>
<p>转换为十进制和十六进制如下。其中十进制的最大长度为 19 位：</p>
<p><img src="/img/distribute/max_id.png" alt=""></p>
<p>其中：</p>
<ul>
<li><p>42 bit：用来记录时间戳，表示自 1970-01-01T00:00:00Z 之后经过的毫秒数，其中 1 bit 是符号位。由于精确到毫秒，相比有符号 32 bit 整型所存储的时间戳需要多 10 bit 来记录毫秒数（0-999）。42 bit 可以记录 69 年，如果设置好起始时间比如今年是2018年，那么可以用到2089年。42 bit 时间戳范围如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="keyword">long</span> a = <span class="number">0b00_00000000_00000000_00000000_00000000_00000000L</span>;</span><br><span class="line"><span class="comment">// 999</span></span><br><span class="line"><span class="keyword">long</span> b = <span class="number">0b00_00000000_00000000_00000000_00000011_11100111L</span>;</span><br><span class="line"><span class="comment">// 2^41-1, 2199023255551</span></span><br><span class="line"><span class="keyword">long</span> c = <span class="number">0b01_11111111_11111111_11111111_11111111_11111111L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1970-01-01T00:00:00.000Z</span></span><br><span class="line">Instant.ofEpochMilli(a).atZone(ZoneOffset.of(<span class="string">"-00:00"</span>)).toLocalDateTime();</span><br><span class="line"><span class="comment">// 1970-01-01T00:00:00.999Z</span></span><br><span class="line">Instant.ofEpochMilli(b).atZone(ZoneOffset.of(<span class="string">"-00:00"</span>)).toLocalDateTime();</span><br><span class="line"><span class="comment">// 2039-09-07T15:47:35.551Z</span></span><br><span class="line">Instant.ofEpochMilli(c).atZone(ZoneOffset.of(<span class="string">"-00:00"</span>)).toLocalDateTime();</span><br></pre></td></tr></table></figure>
</li>
<li><p>10 bit：用来记录机器 ID，总共可以记录 1024 台机器，一般用前 5 位代表数据中心，后面 5 位是某个数据中心的机器 ID</p>
</li>
<li><p>12 bit：循环位，用来对同一个毫秒之内产生不同的 ID，12 位可以最多记录 4095 个，也就是在同一个机器同一毫秒最多记录 4095 个，多余的需要进行等待下个毫秒。</p>
</li>
</ul>
<p>上面只是一个将 64 bit 划分的标准，当然也不一定这么做，可以根据不同业务的具体场景来划分，比如下面给出一个业务场景：</p>
<ul>
<li>服务目前 QPS10 万，预计几年之内会发展到百万。</li>
<li>当前机器三地部署，上海，北京，深圳都有。</li>
<li>当前机器 10 台左右，预计未来会增加至百台。</li>
</ul>
<p>这个时候我们根据上面的场景可以再次合理的划分 64 bit，QPS几年之内会发展到百万，那么每毫秒就是千级的请求，目前10台机器那么每台机器承担百级的请求（100 W / 1000 ms / 10 台）。为了保证扩展，后面的循环位可以限制到 1024，也就是 2^10，那么循环位 10 位就足够了。</p>
<p>机器三地部署我们可以用 3 bit 总共 8 来表示机房位置；当前机器 10 台，为了保证能够扩展到百台那么可以用 7 bit 总共 128 来表示；时间位依然是 42 bit。那么还剩下 64-10-3-7-42 = 2 bit，剩下 2 bit 可以用来进行扩展。</p>
<h1 id="雪花算法实现"><a href="#雪花算法实现" class="headerlink" title="雪花算法实现"></a>雪花算法实现</h1><p>下面是我的对雪花算法的实现，涉及几点思考：</p>
<ol>
<li>为了节省空间、提升运算性能，主要使用到位运算，而不是字符串操作。</li>
<li>为了提高可配置性，将每一部分的位数抽取成了常量，以便自定义。</li>
<li>解决时间回拨问题。如果回拨时长较短（可配置，代码中配了 5 ms），线程等待；如果较长，则利用扩展位避免生成重复 ID（扩展位可配，代码中配置了 3 位，即最多支持 3 次回拨，超出则抛异常）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGeneratorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> initialCapacity = <span class="number">1000</span>;</span><br><span class="line">        Set&lt;Long&gt; ids = <span class="keyword">new</span> HashSet&lt;&gt;(initialCapacity);</span><br><span class="line">        IdGenerator idGenerator = <span class="keyword">new</span> IdGenerator(<span class="number">3</span>, <span class="number">31</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialCapacity; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> id = idGenerator.nextId();</span><br><span class="line">            ids.add(id);</span><br><span class="line"></span><br><span class="line">            IdGenerator.log(id);</span><br><span class="line">        &#125;</span><br><span class="line">        assertEquals(ids.size(), initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">    <span class="comment">// 数据中心</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dataCenterNo;</span><br><span class="line">    <span class="comment">// 机器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNo;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seqNo;</span><br><span class="line">    <span class="comment">// 扩展位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据中心 取值范围（十进制）：0~3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA_CENTER_NO_BITS = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 机器 取值范围（十进制）：0~31</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_NO_BITS = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 序列号 取值范围（十进制）：0~4095</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEQ_NO_BITS = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">// 扩展位 取值范围（十进制）：0~7</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXT_BITS = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据中心 最大值（十进制）：3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DATA_CENTER_NO = (<span class="number">1</span> &lt;&lt; DATA_CENTER_NO_BITS) - <span class="number">0B1</span>;</span><br><span class="line">    <span class="comment">// 机器 最大值（十进制）：31</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NO = (<span class="number">1</span> &lt;&lt; WORKER_NO_BITS) - <span class="number">0B1</span>;</span><br><span class="line">    <span class="comment">// 序列号 最大值（十进制）：4095</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEQ_NO = (<span class="number">1</span> &lt;&lt; SEQ_NO_BITS) - <span class="number">0B1</span>;</span><br><span class="line">    <span class="comment">// 扩展位 最大值（十进制）：7</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_EXT = (<span class="number">1</span> &lt;&lt; EXT_BITS) - <span class="number">0B1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 时间戳 左移 22 位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMESTAMP_SHIFT = DATA_CENTER_NO_BITS + WORKER_NO_BITS + SEQ_NO_BITS + EXT_BITS;</span><br><span class="line">    <span class="comment">// 数据中心 左移 20 位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA_CENTER_NO_SHIFT = WORKER_NO_BITS + SEQ_NO_BITS + EXT_BITS;</span><br><span class="line">    <span class="comment">// 机器 左移 15 位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_NO_SHIFT = SEQ_NO_BITS + EXT_BITS;</span><br><span class="line">    <span class="comment">// 序列号 左移 3 位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEQ_NO_SHIFT = EXT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大回拨毫秒数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_BACKWARD_MILLIS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataCenterNo 数据中心编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerNo 机器编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdGenerator</span><span class="params">(<span class="keyword">int</span> dataCenterNo, <span class="keyword">int</span> workerNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Integer.toBinaryString(dataCenterNo).length() &gt; DATA_CENTER_NO_BITS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"当前数据中心编号 %s 超限，最大支持 %s"</span>, dataCenterNo, MAX_DATA_CENTER_NO));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.toBinaryString(workerNo).length() &gt; WORKER_NO_BITS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"当前机器编号 %s 超限，最大支持 %s"</span>, workerNo, MAX_WORKER_NO));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.dataCenterNo = dataCenterNo;</span><br><span class="line">        <span class="keyword">this</span>.workerNo = workerNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成分布式 ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分布式 ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// init or reset</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp == <span class="number">0</span> || timestamp &lt; now) &#123;</span><br><span class="line">            timestamp = now;</span><br><span class="line">            seqNo = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// seqNo increment</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timestamp == now) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seqNo &lt; MAX_SEQ_NO) &#123;</span><br><span class="line">                seqNo++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">"序列号已耗尽，等待重新生成。seqNo = &#123;&#125;, MAX_SEQ_NO = &#123;&#125;"</span>, seqNo, MAX_SEQ_NO);</span><br><span class="line">                <span class="keyword">return</span> sleepAndNextId(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// clock backward</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIdForBackward(now);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; TIMESTAMP_SHIFT</span><br><span class="line">                | dataCenterNo &lt;&lt; DATA_CENTER_NO_SHIFT</span><br><span class="line">                | workerNo &lt;&lt; WORKER_NO_SHIFT</span><br><span class="line">                | seqNo &lt;&lt; SEQ_NO_SHIFT</span><br><span class="line">                | ext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">nextIdForBackward</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"发生时间回拨，timestamp = &#123;&#125;, now = &#123;&#125;"</span>, timestamp, now);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> duration = timestamp - now;</span><br><span class="line">        <span class="comment">// 回拨不多，直接等待并重试</span></span><br><span class="line">        <span class="keyword">if</span> (duration &lt;= MAX_BACKWARD_MILLIS) &#123;</span><br><span class="line">            <span class="keyword">return</span> sleepAndNextId(duration);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回拨过多，则使用扩展位</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ext &lt; MAX_EXT) &#123;</span><br><span class="line">                <span class="comment">// 将时间戳修正为回拨时间，为防止重复生成 ID，扩展位加一，并重试</span></span><br><span class="line">                ext++;</span><br><span class="line">                timestamp = now;</span><br><span class="line">                <span class="keyword">return</span> nextId();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">"扩展位已耗尽。ext = %s, MAX_EXT = %s"</span>, ext, MAX_EXT));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">sleepAndNextId</span><span class="params">(<span class="keyword">long</span> millis)</span> </span>&#123;</span><br><span class="line">        Thread.sleep(millis);</span><br><span class="line">        <span class="keyword">return</span> nextId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = id &gt;&gt; TIMESTAMP_SHIFT;</span><br><span class="line">        <span class="keyword">long</span> dataCenterNo = id &gt;&gt; DATA_CENTER_NO_SHIFT &amp; MAX_DATA_CENTER_NO;</span><br><span class="line">        <span class="keyword">long</span> workerNo = id &gt;&gt; WORKER_NO_SHIFT &amp; MAX_WORKER_NO;</span><br><span class="line">        <span class="keyword">long</span> seqNo = id &gt;&gt; SEQ_NO_SHIFT &amp; MAX_SEQ_NO;</span><br><span class="line">        <span class="keyword">long</span> ext = id &amp; MAX_EXT;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"Binary is &#123;&#125;, id is &#123;&#125;"</span>, Long.toBinaryString(id), id);</span><br><span class="line">        log.info(<span class="string">"Binary is &#123;&#125;, time is &#123;&#125;"</span>, Long.toBinaryString(timestamp), getLocalDateTime(timestamp));</span><br><span class="line">        log.info(<span class="string">"Binary is &#123;&#125;, dataCenterNo is &#123;&#125;"</span>, Long.toBinaryString(dataCenterNo), dataCenterNo);</span><br><span class="line">        log.info(<span class="string">"Binary is &#123;&#125;, workerNo is &#123;&#125;"</span>, Long.toBinaryString(workerNo), workerNo);</span><br><span class="line">        log.info(<span class="string">"Binary is &#123;&#125;, seqNo is &#123;&#125;"</span>, Long.toBinaryString(seqNo), seqNo);</span><br><span class="line">        log.info(<span class="string">"Binary is &#123;&#125;, ext is &#123;&#125;"</span>, Long.toBinaryString(ext), ext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> LocalDateTime <span class="title">getLocalDateTime</span><span class="params">(<span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Instant.ofEpochMilli(timestamp).atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Binary is 101111000100100011111011111000111010101011111111000000000000000, id is 6783685416349302784</span><br><span class="line">&#x2F;&#x2F; Binary is 10111100010010001111101111100011101010101, time is 2021-04-02T17:43:58.037</span><br><span class="line">&#x2F;&#x2F; Binary is 11, dataCenterNo is 3</span><br><span class="line">&#x2F;&#x2F; Binary is 11111, workerNo is 31</span><br><span class="line">&#x2F;&#x2F; Binary is 0, seqNo is 0</span><br><span class="line">&#x2F;&#x2F; Binary is 0, ext is 0</span><br></pre></td></tr></table></figure>

<p>二进制分段如下：<code>10111100010010001111101111100011101010101_11_11111_000000000000_000</code></p>
<h1 id="延伸阅读：位运算"><a href="#延伸阅读：位运算" class="headerlink" title="延伸阅读：位运算"></a>延伸阅读：位运算</h1><p>位运算符如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;：按位与。</span><br><span class="line">|：按位或。</span><br><span class="line">~：按位非。</span><br><span class="line">^：按位异或。</span><br><span class="line">&lt;&lt;：左位移运算符（M &lt;&lt; n &#x3D; M * 2^n）。</span><br><span class="line">&gt;&gt;：右位移运算符（M &gt;&gt; n &#x3D; M &#x2F; 2*n）。</span><br><span class="line">&gt;&gt;&gt;：无符号右移运算符。</span><br></pre></td></tr></table></figure>

<p>例如，Java 中求 key 应当放到散列表的哪个位置（offset）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getOffset</span><span class="params">(Object key, <span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> hashcode</span>;</span><br><span class="line">    <span class="keyword">int</span> hash = (hashcode = key.hashCode()) ^ (hashcode &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">int</span> offset = hash &amp; (length - <span class="number">1</span>);</span><br><span class="line">    log.info(<span class="string">"key: &#123;&#125;, hashcode: &#123;&#125;, hash: &#123;&#125;, offset: &#123;&#125;"</span>, key, Integer.toBinaryString(hashcode), Integer.toBinaryString(hash), offset);</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/SunArmy/p/9837348.html" target="_blank" rel="noopener">《Java 位运算符 &amp;、|、^、~、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;》</a></li>
<li><a href="https://blog.csdn.net/qq_39705793/article/details/81237005" target="_blank" rel="noopener">《异或的用途》</a></li>
</ul>
<h1 id="UNIX-时间戳"><a href="#UNIX-时间戳" class="headerlink" title="UNIX 时间戳"></a>UNIX 时间戳</h1><p>参考：<a href="/2020/02/28/unix-timestamp/">UNIX 时间戳总结</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/02/28/unix-timestamp/" class="post-title-link">UNIX 时间戳总结</a></h2><div class="post-info">2020-02-28<a href="/tags/GNU-Linux/" title="GNU/Linux" class="post-demo">GNU/Linux</a></div><div class="post-content"><h1 id="UNIX-时间戳"><a href="#UNIX-时间戳" class="headerlink" title="UNIX 时间戳"></a>UNIX 时间戳</h1><p><img src="/img/gnu-linux/unix_timestamp.png" alt="unix_timestamp"></p>
<h1 id="延伸阅读：Y2K38-错误"><a href="#延伸阅读：Y2K38-错误" class="headerlink" title="延伸阅读：Y2K38 错误"></a>延伸阅读：Y2K38 错误</h1><p>2038年问题又叫Unix千年臭虫或Y2K38错误。在时间值以带符号的32位整数来存储或计算的数据存储情况下，这个错误就有可能引发问题。</p>
<p>可以用Unix带符号的32位整数时间格式来表示的最大时间是 2038年1月19日03:14:07UTC（2038-01-19T03:14:07Z），这是自 1970-01-01T00:00:00Z 之后过了 2147483647 秒，值的边界如下：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>时间戳</th>
<th>二进制字面量</th>
</tr>
</thead>
<tbody><tr>
<td>1970-01-01T00:00:00Z</td>
<td>0</td>
<td>00000000 00000000 00000000 00000000</td>
</tr>
<tr>
<td>2038-01-19T03:14:07Z</td>
<td>2^31-1, 2147483647</td>
<td>01111111 11111111 11111111 11111111</td>
</tr>
</tbody></table>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="keyword">long</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 2^31-1, 2147483647</span></span><br><span class="line"><span class="keyword">long</span> b = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1970-01-01T00:00:00.000Z</span></span><br><span class="line">Instant.ofEpochSecond(a).atZone(ZoneOffset.of(<span class="string">"-00:00"</span>)).toLocalDateTime()</span><br><span class="line"><span class="comment">// 2038-01-19T03:14:07.000Z</span></span><br><span class="line">Instant.ofEpochSecond(b).atZone(ZoneOffset.of(<span class="string">"-00:00"</span>)).toLocalDateTime()</span><br></pre></td></tr></table></figure>

<p>过了最大时间后，由于整数溢出，时间值将作为负数来存储，系统会将日期读为1901年12月13日，而不是2038年1月19日。</p>
<p>用简单的语言来说，Unix机器最终将会耗尽存储空间来列举秒数。所以，到那一天，使用标准时间库的C程序会开始出现日期问题。你可以在维基百科上详细阅读更多的相关内容（<a href="https://en.wikipedia.org/wiki/Year_2038_problem）。" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Year_2038_problem）。</a></p>
<p>下面这个动画显示了2038年错误将如何重置日期：</p>
<p><img src="/img/distribute/Y2K38.GIF" alt="Y2K38"></p>
<p>资料来源：维基百科</p>
<p>目前，2038年错误没有什么通行的解决方案。如果对用于存储时间值的time_t数据类型的定义进行更改，依赖带符号的32位time_t整数性质的应用程序就会出现一些代码兼容性问题。假设time_t的类型被更改为不带符号的32位整数，那将加大最新的时间限制。但是，这会对由负整数表示的1970年之前的日期造成混乱。</p>
<p>使用64位架构的操作系统和程序使用64位time_t整数。使用带符号的64位值可以将日期延长至今后的2920亿年。</p>
<p>已有人提出了许多建议，包括以带符号的64位整数来存储自某个时间点（1970年1月1日或2000年1月1日）以来的毫秒/微秒，以获得至少30万年的时间范围。其他建议包括用新的库重新编译程序，等等。这方面的工作正在开展之中；据专家们声称，2038年问题解决起来应该不难。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zh.wikipedia.org/zh/UNIX%E6%97%B6%E9%97%B4" target="_blank" rel="noopener">UNIX时间 - 维基百科</a></p>
<p><a href="https://time.is/UTC" target="_blank" rel="noopener">https://time.is/UTC</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/01/15/mysql-innodb-features/" class="post-title-link">MySQL InnoDB 特性总结</a></h2><div class="post-info">2020-01-15<a href="/tags/MySQL/" title="MySQL" class="post-demo">MySQL</a></div><div class="post-content"><p><img src="/img/mysql/InnoDB_features.png" alt="InnoDB_features"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-introduction.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-introduction.html</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2020/01/03/mysql-primary-key-and-foreign-key/" class="post-title-link">MySQL 主键与外键总结</a></h2><div class="post-info">2020-01-03<a href="/tags/MySQL/" title="MySQL" class="post-demo">MySQL</a></div><div class="post-content"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>MySQL 原生支持外键（即允许跨表交叉引用相关数据）和外键约束（用于保持<strong>数据一致性</strong>！）。</p>
<p>外键关系涉及包含初值的父表，以及引用父表值的子表。而外键约束就定义在子表之上。</p>
<blockquote>
<p>A foreign key relationship involves a <strong>parent table</strong> that holds the initial column values, and a <strong>child table</strong> with column values that reference the parent column values. A foreign key constraint is defined on the child table.</p>
</blockquote>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>在 <code>CREATE TABLE</code> 或 <code>ALTER TABLE</code> 语句中定义外键约束的基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT [fk_symbol]] FOREIGN KEY</span><br><span class="line">    [index_name] (col_name, ...)</span><br><span class="line">    REFERENCES tbl_name (col_name,...)</span><br><span class="line">    [ON <span class="keyword">DELETE</span> reference_option]</span><br><span class="line">    [<span class="keyword">ON</span> <span class="keyword">UPDATE</span> reference_option]</span><br><span class="line"></span><br><span class="line">reference_option:</span><br><span class="line">    RESTRICT | <span class="keyword">CASCADE</span> | <span class="keyword">SET</span> <span class="literal">NULL</span> | <span class="keyword">NO</span> <span class="keyword">ACTION</span> | <span class="keyword">SET</span> <span class="keyword">DEFAULT</span></span><br></pre></td></tr></table></figure>

<p>删除外键约束：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> fk_symbol;</span><br></pre></td></tr></table></figure>

<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建父表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_parent`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_unicode_ci <span class="keyword">COMMENT</span>=<span class="string">'父表'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建子表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_child`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`parent_id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`fk_parent_id`</span> (<span class="string">`parent_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`fk_parent_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`parent_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`t_parent`</span> (<span class="string">`id`</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_unicode_ci <span class="keyword">COMMENT</span>=<span class="string">'子表'</span>;</span><br></pre></td></tr></table></figure>

<p>可视化界面如下：</p>
<p><img src="/img/mysql/foreign_key_constraint.png" alt="foreign_key_constraint"></p>
<p>注意：</p>
<ul>
<li><p>创建外键约束时，如果主外键之间的数据类型不一致（例如长度、无符号），会报错：<code>1215 - Cannot add the foreign key constraint</code>。</p>
</li>
<li><p>创建外键约束后，MySQL 会为子表自动创建普通索引 <code>fk_parent_id</code>，以提升 <code>join</code> 查询性能。</p>
</li>
<li><p>创建外键不一定只能引用父表的主键，也能引用普通列。如果引用普通列，MySQL 则会在父表和子表同时为该列创建普通索引。如果删除该索引会报错：<code>1553 - Cannot drop index &#39;...&#39;: needed in a foreign key constraint</code>。</p>
</li>
<li><p><code>reference_option</code> 的几种情况总结如下：</p>
<ul>
<li><p>操作父表：</p>
<ul>
<li><code>RESTRICT</code> 在 <code>UPDATE</code> 或者 <code>DELETE</code> 父表记录时，对子表进行<strong>一致性检查</strong>。</li>
<li><code>CASCADE</code> 在 <code>UPDATE</code> 或者 <code>DELETE</code> 父表记录时，对子表进行<strong>级联操作</strong>。</li>
<li><code>SET NULL</code> 在 <code>UPDATE</code> 或者 <code>DELETE</code> 父表记录时，对子表进行 <strong>SET NULL 操作</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th><code>RESTRICT</code> (<code>NO ACTION</code>)</th>
<th><code>CASCADE</code></th>
<th><code>SET NULL</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>INSERT</code></td>
<td>正常插入</td>
<td>正常插入</td>
<td>正常插入</td>
</tr>
<tr>
<td><code>UPDATE</code></td>
<td>更新父表值，会报错 <code>1451 - Cannot delete or update a parent row: a foreign key constraint fails</code></td>
<td>更新父表值，子表值级联更新</td>
<td>更新父表值，子表值 SET NULL</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td>删除父表行，会报错 <code>1451 - Cannot delete or update a parent row: a foreign key constraint fails</code></td>
<td>删除父表行，子表行级联删除</td>
<td>删除父表行，子表值 SET NULL</td>
</tr>
</tbody></table>
</li>
<li><p>操作子表：</p>
<ul>
<li><code>INSERT</code>、<code>UPDATE</code> 触发一致性检查。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th><code>RESTRICT</code> (<code>NO ACTION</code>)</th>
<th><code>CASCADE</code></th>
<th><code>SET NULL</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>INSERT</code></td>
<td>无论哪个 option，插入子表行为父表不存在的值，都会报错 <code>1452 - Cannot add or update a child row: a foreign key constraint fails</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>UPDATE</code></td>
<td>同上</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td>无论哪个 option，删除子表行都 ok</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/img/mysql/primary_key_and_foreign_key.png" alt="primary_key_and_foreign_key"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/create-table-foreign-keys.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/create-table-foreign-keys.html</a></p>
<p><a href="https://mp.weixin.qq.com/s/jOF1rohb6OvA3Pb5rL6Ilg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/jOF1rohb6OvA3Pb5rL6Ilg</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/12/02/oauth2/" class="post-title-link">OAuth 2.0 几种授权类型总结</a></h2><div class="post-info">2019-12-02<a href="/tags/安全/" title="安全" class="post-demo">安全</a></div><div class="post-content"><p>OAuth 协议解决了以下问题：</p>
<ul>
<li>密码泄露风险</li>
<li>无法控制授权范围、有效期</li>
</ul>
<p>OAuth 协议中，术语“授权类型（<a href="https://oauth.net/2/grant-types/" target="_blank" rel="noopener">Grant Types</a>）”是指应用获取“访问令牌（Access Token）”的方式。OAuth 2.0 定义了以下几种授权类型：</p>
<ul>
<li>用户类资源：需要用户先授权<ul>
<li>授权码模式（<a href="https://oauth.net/2/grant-types/authorization-code/" target="_blank" rel="noopener">Authorization Code</a>），需要用户授权</li>
<li>简化模式（<a href="https://oauth.net/2/grant-types/implicit/" target="_blank" rel="noopener">Implicit</a>），不建议使用</li>
<li>密码模式（<a href="https://oauth.net/2/grant-types/password/" target="_blank" rel="noopener">Password</a>）</li>
<li>设备码模式（<a href="https://oauth.net/2/grant-types/device-code/" target="_blank" rel="noopener">Device Code</a>）</li>
</ul>
</li>
<li>商户类资源，无需用户授权<ul>
<li>客户端模式（<a href="https://oauth.net/2/grant-types/client-credentials/" target="_blank" rel="noopener">Client Credentials</a>），也叫商户模式接入</li>
</ul>
</li>
<li>其它<ul>
<li>令牌刷新模式（<a href="https://oauth.net/2/grant-types/refresh-token/" target="_blank" rel="noopener">Refresh Token</a>）</li>
</ul>
</li>
</ul>
<p>几种授权类型都有其对应的使用场景，各有利弊，但目的都是为了获取访问令牌。访问令牌是一个用于访问已授权资源的临时凭据。</p>
<p>商户在接入认证服务器之前，需要先申请一套专用的 <code>client_id</code>、<code>client_secret</code>，据此再申请 <code>access_token</code>。下表总结了其中三种主流授权类型下，申请 <code>access_token</code> 令牌的前置条件：</p>
<table>
<thead>
<tr>
<th>授权方式</th>
<th>grant_type</th>
<th>授权的前置条件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>授权码模式</td>
<td><code>authorization_code</code></td>
<td>授权码</td>
<td>这种模式是最常见、功能最完整、流程最严密的授权模式，第三方应用需要先获取授权码，才能申请到令牌。它的特点就是通过第三方应用的后台服务器，与“服务提供商”的认证服务器进行互动，<strong>通过授权码（<code>authorization_code</code>）交换访问令牌（<code>access_token</code>）</strong>，第三方应用不接触用户密码，安全性高。</td>
</tr>
<tr>
<td>密码模式</td>
<td><code>password</code></td>
<td>用户的账号、密码</td>
<td>这种模式通常用在用户对该应用高度信任的情况下，或者所有服务都由同一家公司提供。在这种模式下，用户必须把自己的<strong>用户名和密码</strong>发给应用。应用使用这些信息，再向“服务提供商”索要授权，其风险在于应用获知了密码。但应用无需存储密码，而是存储和使用令牌即可。<br/>密码模式还有一种主流的变种，即使用<strong>用户手机号和短信验证码</strong>申请令牌，相比密码模式会更安全些。为了区分，可以自定义一个 <code>grant_type</code> 为 <code>sms_verify_code</code>。</td>
</tr>
<tr>
<td>客户端模式</td>
<td><code>client_credentials</code></td>
<td>无</td>
<td>第三方应用以自己的名义，而不是以用户的名义，向“服务提供商”进行认证，并获取商户类资源，而不是用户类资源。</td>
</tr>
</tbody></table>
<h1 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h1><p>OAuth 旨在让用户能够对第三方应用授予有限的访问权限。第三方应用首先需要确定所需的权限，然后将用户导向浏览器以获得其授权。简单回顾下：</p>
<p><img src="/img/security/oauth2.webp" alt="OAuth2 Authorization Code Flow"></p>
<p>要开始授权流程，第三方应用需要先构建 URL。这里附一张流程图，详细总结下授权码模式的整个流程：</p>
<p><img src="/img/security/oauth2.png" alt="OAuth 2.0 授权码模式"></p>
<p>报文如下：</p>
<p><img src="/img/security/grant_type_of_authorization_code.png" alt="OAuth 2.0 授权码模式"></p>
<p>交互方式上特别注意浏览器会进行几次 302 重定向。流程总结如下：</p>
<ol>
<li>第三方应用首先向服务提供商申请 <code>client_id</code> 应用唯一标识、<code>client_secret</code> 密钥，用于后续获取令牌时提供身份校验；</li>
<li>获取授权码：此时要提供预分配好的 <code>client_id</code> 标识来源，提供 <code>scope</code> 标识要申请的权限，提供 <code>redirect_uri</code> 标识授权完毕后要回跳的第三方应用的链接。</li>
<li>第一次 302 重定向：认证服务器展示登录授权页。</li>
<li>第二次 302 重定向：在用户提交授权，认证服务器认证成功后，会分配授权码 <code>code</code>，并重定向回第三方应用的 <code>redirect_uri</code> 。</li>
<li>建议第三方应用要根据当前用户会话生成随机且唯一的 <code>state</code> 参数，并在接收到授权码时先进行校验，避免 CSRF 攻击。</li>
<li>最后，第三方应用会向认证服务器申请令牌 <code>access_token</code>，此时要提供预分配好的 <code>code</code>、<code>client_id</code>、<code>client_secret</code> 以便认证。这一步是在后端之间完成的，对用户不可见。</li>
<li><code>access_token</code> 是有有效期的，过期后需要刷新。</li>
<li>拿到令牌 <code>access_token</code> 后，第三方应用就可以访问资源方，获取所需资源。<code>access_token</code> 相当于用户的 session id。</li>
</ol>
<p>以微信公众平台为例，<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842" target="_blank" rel="noopener">微信网页授权</a> 就是使用了“授权码模式（<code>grant_type=authorization_code</code>）”。商户在完成接入并获取<strong>用户</strong>的 <code>access_token</code> 之后，可用于如下场景：</p>
<ul>
<li>获取用户 openid</li>
<li>获取用户信息（如昵称、头像、性别、所在地）</li>
<li>……</li>
</ul>
<h1 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h1><p>报文如下：</p>
<p><img src="/img/security/grant_type_of_password.png" alt="OAuth 2.0 密码模式"></p>
<h1 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h1><p>客户端授权模式用于请求商户资源，而不是用户资源，报文如下：</p>
<p><img src="/img/security/grant_type_of_client_credentials.png" alt="OAuth 2.0 客户端模式"></p>
<p>以微信公众平台为例，<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140183" target="_blank" rel="noopener">获取公众号的 access_token</a> 就是使用了“客户端模式（<code>grant_type=client_credential</code>）”。商户在完成接入并获取<strong>应用</strong>的 <code>access_token</code> 之后，可用于如下场景：</p>
<ul>
<li>自定义菜单的配置</li>
<li>消息推送</li>
<li>素材管理</li>
<li>用户管理</li>
<li>帐户管理</li>
<li>数据统计</li>
<li>…… 大量服务</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://oauth.net/2/" target="_blank" rel="noopener">https://oauth.net/2/</a></p>
<p><a href="https://developer.okta.com/blog/2017/06/21/what-the-heck-is-oauth" target="_blank" rel="noopener">What the Heck is OAuth?</a></p>
<p><a href="https://developer.linkedin.com/zh-cn/docs/oauth2" target="_blank" rel="noopener">https://developer.linkedin.com/zh-cn/docs/oauth2</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p>
<p><a href="https://www.jianshu.com/p/c7c8f51713b6" target="_blank" rel="noopener">移花接木：针对OAuth2的CSRF攻击</a></p>
<p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842" target="_blank" rel="noopener">微信网页授权（授权码模式）</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/11/26/mysql-deferred-join/" class="post-title-link">MySQL 延迟关联优化超多分页场景</a></h2><div class="post-info">2019-11-26<a href="/tags/MySQL/" title="MySQL" class="post-demo">MySQL</a></div><div class="post-content"><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>场景：</p>
<ul>
<li>订单表数据量：3000 万。</li>
<li>查询最近 7 天的订单，并做分页、分片。</li>
</ul>
<p>表结构：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_order`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`order_no`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uk_order_no`</span> (<span class="string">`order_no`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_create_time`</span> (<span class="string">`create_time`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure>

<p>超多分页场景如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_order </span><br><span class="line"><span class="keyword">where</span> create_time <span class="keyword">between</span> <span class="string">'2019-10-17'</span> <span class="keyword">and</span> <span class="string">'2019-10-25'</span> </span><br><span class="line"><span class="keyword">limit</span> <span class="number">1000000</span>, <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+---------+-------+-----------------+-----------------+---------+------+---------+-----------------------+</span></span><br><span class="line">| id | select_type | table   | type  | possible_keys   | key             | key_len | ref  | rows    | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+---------+-------+-----------------+-----------------+---------+------+---------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t_order | range | idx_create_time | idx_create_time | 5       | NULL | 3775048 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+---------+-------+-----------------+-----------------+---------+------+---------+-----------------------+</span></span><br></pre></td></tr></table></figure>

<p>虽然走了 <code>idx_create_time</code> 索引，但仍然是个慢查询，扫描行数过多。</p>
<h1 id="超多分页的问题是什么？"><a href="#超多分页的问题是什么？" class="headerlink" title="超多分页的问题是什么？"></a>超多分页的问题是什么？</h1><blockquote>
<p>随着偏移量 <code>offset</code> 的增加，MySQL 需要花费大量的时间来扫描需要丢弃的数据。本质上就是 <code>offset</code> 过大导致的大量回表 I/O 查询。</p>
</blockquote>
<p>如果能减少这种大量的回表查询，就能提升查询性能。</p>
<h1 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h1><h2 id="什么是延迟关联优化？"><a href="#什么是延迟关联优化？" class="headerlink" title="什么是延迟关联优化？"></a>什么是延迟关联优化？</h2><p>什么是“延迟关联”？</p>
<blockquote>
<p> 通过使用覆盖索引查询返回需要的主键，再根据主键关联原表获得需要的数据。 </p>
</blockquote>
<p>参考两个材料：</p>
<p>《高性能 MySQL》P194：</p>
<p><img src="/img/mysql/deferred_join_1.png" alt="deferred_join_1"></p>
<p>《阿里巴巴 Java 开发手册》：</p>
<p><img src="/img/mysql/deferred_join_2.png" alt="deferred_join_2"></p>
<h2 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h2><p>查询的列被所建的辅助索引所覆盖，无需回表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t_order </span><br><span class="line"><span class="keyword">where</span> create_time <span class="keyword">between</span> <span class="string">'2019-10-17'</span> <span class="keyword">and</span> <span class="string">'2019-10-25'</span> </span><br><span class="line"><span class="keyword">limit</span> <span class="number">1000000</span>, <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+---------+-------+-----------------+-----------------+---------+------+---------+--------------------------+</span></span><br><span class="line">| id | select_type | table   | type  | possible_keys   | key             | key_len | ref  | rows    | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+---------+-------+-----------------+-----------------+---------+------+---------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t_order | range | idx_create_time | idx_create_time | 5       | NULL | 3775048 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+---------+-------+-----------------+-----------------+---------+------+---------+--------------------------+</span></span><br></pre></td></tr></table></figure>

<p>上述查询字段改为 <code>id</code> 后，执行计划中新增： <code>Extra=Using index</code>，表示走覆盖索引，无需回表，查询速度快了 N 倍。</p>
<h1 id="延迟关联优化"><a href="#延迟关联优化" class="headerlink" title="延迟关联优化"></a>延迟关联优化</h1><p>延迟关联优化涉及到了 SQL 优化的两个重要概念：覆盖索引和回表。</p>
<ul>
<li>通过覆盖索引在辅助索引上完成所有扫描、过滤、排序（利用索引有序）和分页；</li>
<li>最后通过主键回表查询，最大限度减少回表查询的 I/O 次数。</li>
</ul>
<p>SQL 改造如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_order t </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t_order </span><br><span class="line">    <span class="keyword">where</span> create_time <span class="keyword">between</span> <span class="string">'2019-10-17'</span> <span class="keyword">and</span> <span class="string">'2019-10-25'</span> </span><br><span class="line">    <span class="keyword">limit</span> <span class="number">1000000</span>, <span class="number">10</span></span><br><span class="line">) e </span><br><span class="line"><span class="keyword">on</span> t.id = e.id;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+---------------+--------+-----------------+-----------------+---------+------+---------+--------------------------+</span></span><br><span class="line">| id | select_type | table         | type   | possible_keys   | key             | key_len | ref  | rows    | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+---------------+--------+-----------------+-----------------+---------+------+---------+--------------------------+</span></span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt;    | ALL    | NULL            | NULL            | NULL    | NULL | 1000010 | NULL                     |</span><br><span class="line">|  1 | PRIMARY     | t             | eq_ref | PRIMARY         | PRIMARY         | 8       | e.id |       1 | NULL                     |</span><br><span class="line">|  2 | DERIVED     | t_order       | range  | idx_create_time | idx_create_time | 5       | NULL | 3775048 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+---------------+--------+-----------------+-----------------+---------+------+---------+--------------------------+</span></span><br></pre></td></tr></table></figure>

<p>优化前：</p>
<ol>
<li>辅助索引查询，得到 id</li>
<li>id 逐一回表查询<strong>（1000000  + 10 次回表）</strong></li>
<li>查询结果放弃前 offset 行，返回 limit 行</li>
</ol>
<p>优化后：</p>
<ol>
<li>辅助查询覆盖查询，得到 id</li>
<li>查询结果放弃前 offset 行，返回 limit 行</li>
<li><strong>只需 limit 条 id 回表查询</strong>，大大减少回表查询的 I/O 次数</li>
</ol>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/derived-tables.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/derived-tables.html</a></p>
<p><a href="http://mysql.taobao.org/monthly/2017/03/05/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2017/03/05/</a></p>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/11/09/mysql-join/" class="post-title-link">MySQL JOIN 表连接总结</a></h2><div class="post-info">2019-11-09<a href="/tags/MySQL/" title="MySQL" class="post-demo">MySQL</a></div><div class="post-content"><p><img src="/img/mysql/join.png" alt="join"></p>
<h1 id="连接语法"><a href="#连接语法" class="headerlink" title="连接语法"></a>连接语法</h1><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单的等值语法创建内联结</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Vendors, Products</span><br><span class="line"><span class="keyword">WHERE</span> Vendors.vend_id = Products.vend_id;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ANSI SQL 规范首选 INNER JOIN 语法创建内联结</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Products</span><br><span class="line"><span class="keyword">ON</span> Vendors.vend_id = Products.vend_id;</span><br></pre></td></tr></table></figure>

<p>在内连接两个表时，实际要做的是将第一个表中的每一行与第二个表中的每一行配对，<code>WHERE</code> 或 <code>ON</code> 子句作为过滤条件，<strong>只包含那些匹配连接条件的行</strong>。</p>
<p>由没有连接条件的表关系返回的结果为<strong>笛卡儿积（cartesian product）</strong>。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。因此应当总是提供连接条件。</p>
<h2 id="外连接（左、右）"><a href="#外连接（左、右）" class="headerlink" title="外连接（左、右）"></a>外连接（左、右）</h2><p>许多连接将一个表中的行与另一个表中的行相关联，但有时候需要<strong>包含没有关联行</strong>的那些行，例如：</p>
<ul>
<li><p>对每个顾客下的订单进行计数，包括那些至今尚未下订单的顾客；</p>
</li>
<li><p>列出所有产品以及订购数量，包括没有人订购的产品；</p>
</li>
<li><p>计算平均销售规模，包括那些至今尚未下订单的顾客。</p>
</li>
</ul>
<p>在上述例子中，连接包含了那些在相关表中没有关联行的行。这种连接称为外连接。</p>
<p>例如，要检索出所有顾客+订单，包括那些还未下单的顾客：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">cust_id    order_num</span><br><span class="line"><span class="comment">---------- ---------</span></span><br><span class="line">1000000001 20005</span><br><span class="line">1000000001 20009</span><br><span class="line">1000000002 NULL</span><br><span class="line">1000000003 20006</span><br><span class="line">1000000004 20007</span><br><span class="line">1000000005 20008</span><br></pre></td></tr></table></figure>

<p>上例如果使用内连接，将不包含 <em>1000000002</em> 顾客，因为他还未下单（即连接条件不匹配）。</p>
<p>作为对比，下例使用内连接 <code>INNER JOIN</code> 和聚集函数 <code>COUNT()</code> 统计出所有顾客的订单数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, <span class="keyword">COUNT</span>(Orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Customers.cust_id;</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">cust_id    num_ord</span><br><span class="line"><span class="comment">---------- --------</span></span><br><span class="line">1000000001 2</span><br><span class="line">1000000003 1</span><br><span class="line">1000000004 1</span><br><span class="line">1000000005 1</span><br></pre></td></tr></table></figure>

<p>但如果使用左外连接 <code>LEFT OUTER JOIN</code> 和聚集函数 <code>COUNT()</code> 进行相同统计，将会包括那些还未下单的顾客，例如顾客 <em>1000000002</em>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, <span class="keyword">COUNT</span>(Orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Customers.cust_id;</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">cust_id    num_ord</span><br><span class="line"><span class="comment">---------- -------</span></span><br><span class="line">1000000001 2</span><br><span class="line">1000000002 0</span><br><span class="line">1000000003 1</span><br><span class="line">1000000004 1</span><br><span class="line">1000000005 1</span><br></pre></td></tr></table></figure>

<p>由于 <code>COUNT(column)</code> 计数会忽略 <code>NULL</code> 值，因此顾客 <em>1000000002</em> 的统计结果为 0。</p>
<p>注意，左、右外连接之间的唯一差别是所关联的表的顺序。换句话说，调整 <code>FROM</code> 或 <code>WHERE</code> 子句中表的顺序，左外连接可以转换为右外连接。因此，这两种外连接可以互换使用，哪个方便就用哪个。</p>
<h1 id="连接算法"><a href="#连接算法" class="headerlink" title="连接算法"></a>连接算法</h1><p>MySQL 使用下面两种算法执行表连接：</p>
<ul>
<li>嵌套循环连接算法（Nested-Loop Join（NLJ）），在被驱动表 <code>join</code> 字段有索引时使用。</li>
<li>基于块的嵌套循环连接算法（Block Nested-Loop Join（BNL）），在被驱动表 <code>join</code> 字段无索引时使用，以减少被驱动表的全表扫描次数。</li>
</ul>
<h2 id="NLJ"><a href="#NLJ" class="headerlink" title="NLJ"></a>NLJ</h2><p>Nested-Loop Join (NLJ) :</p>
<blockquote>
<p>A simple nested-loop join (NLJ) algorithm reads rows from the first table in a loop one at a time, passing each row to a nested loop that processes the next table in the join. This process is repeated as many times as there remain tables to be joined.</p>
</blockquote>
<p>例如，使用以下 <code>join type</code> 执行 <code>t1</code>、<code>t2</code> 和  <code>t3</code> 三个表之间的表连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table   Join Type</span><br><span class="line">t1      range</span><br><span class="line">t2      ref</span><br><span class="line">t3      ALL</span><br></pre></td></tr></table></figure>

<p>使用 NLJ 算法，则按以下方式处理连接：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each row <span class="keyword">in</span> t1 matching range &#123;</span><br><span class="line">  <span class="keyword">for</span> each row <span class="keyword">in</span> t2 matching reference key &#123;</span><br><span class="line">    <span class="keyword">for</span> each row <span class="keyword">in</span> t3 &#123;</span><br><span class="line">      <span class="keyword">if</span> row satisfies join conditions, send to client</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BNL"><a href="#BNL" class="headerlink" title="BNL"></a>BNL</h2><p>BNL 算法将外层循环的检索行缓存到 <code>join_buffer</code>（无序数组）中，以减少内层循环的全表扫描次数。例如，如果外层循环先将 10 行数据读入缓冲区，并将其传递给下一个内层循环，内层循环只需全表扫描一次，即可将读取到的每一行与缓冲区中的所有 10 行在内存中进行比较。这将使得内层循环表的全表扫描次数减少一个数量级。</p>
<p>MySQL <code>join buffer</code> 具有以下特征：</p>
<ul>
<li>当 <code>join type</code> 为 <code>ALL</code>、<code>index</code>、<code>range</code> 使用 <code>join buffer</code>。</li>
<li><code>join buffer</code> 同样适用于外连接，详见：<a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html" target="_blank" rel="noopener">Section 8.2.1.11, “Block Nested-Loop and Batched Key Access Joins”</a></li>
<li>系统变量 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_join_buffer_size" target="_blank" rel="noopener"><code>join_buffer_size</code></a> 用于配置每次查询每个 BNL 连接的缓冲区大小，因此一个查询可能用到多个 <code>join buffer</code>。</li>
<li>在执行连接之前分配 <code>join buffer</code>，并在查询完成后释放。</li>
</ul>
<p>使用 BNL 算法，伪代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each row <span class="keyword">in</span> t1 matching range &#123;</span><br><span class="line">  <span class="keyword">for</span> each row <span class="keyword">in</span> t2 matching reference key &#123;</span><br><span class="line">    store used columns <span class="keyword">from</span> t1, t2 <span class="keyword">in</span> join buffer</span><br><span class="line">    <span class="keyword">if</span> buffer is full &#123;</span><br><span class="line">      <span class="keyword">for</span> each row <span class="keyword">in</span> t3 &#123;</span><br><span class="line">        <span class="keyword">for</span> each t1, t2 combination <span class="keyword">in</span> join buffer &#123;</span><br><span class="line">          <span class="keyword">if</span> row satisfies join conditions, send to client</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      empty join buffer</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> buffer is not empty &#123;</span><br><span class="line">  <span class="keyword">for</span> each row <span class="keyword">in</span> t3 &#123;</span><br><span class="line">    <span class="keyword">for</span> each t1, t2 combination <span class="keyword">in</span> join buffer &#123;</span><br><span class="line">      <span class="keyword">if</span> row satisfies join conditions, send to client</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设 <code>S</code> 为每行 <code>used columns from t1, t2</code> 的大小， <code>C</code> 为其行数，则 <code>t3</code> 全表扫描的次数为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t3_scanned_count &#x3D; </span><br><span class="line">  (S * C) % join_buffer_size &#x3D;&#x3D; 0 ? </span><br><span class="line">    (S * C) &#x2F; join_buffer_size : </span><br><span class="line">    (S * C) &#x2F; join_buffer_size + 1</span><br></pre></td></tr></table></figure>

<p>因此，随着 <code>join_buffer_size</code> 增加，<code>t3</code> 全表扫描的次数反比减少，直到 <code>join_buffer_size=(S * C)</code> 时则无法再优化。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/join.html" target="_blank" rel="noopener">JOIN Syntax</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/select-optimization.html" target="_blank" rel="noopener">Optimizing SELECT Statements</a></p>
<ul>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html" target="_blank" rel="noopener">Nested-Loop Join Algorithms</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/nested-join-optimization.html" target="_blank" rel="noopener">Nested Join Optimization</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/outer-join-optimization.html" target="_blank" rel="noopener">Outer Join Optimization</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/outer-join-simplification.html" target="_blank" rel="noopener">Outer Join Simplification</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html" target="_blank" rel="noopener">Multi-Range Read Optimization</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html" target="_blank" rel="noopener">Block Nested-Loop and Batched Key Access Joins</a></p>
</li>
</ul>
</div></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2019/10/25/mysql-order-by/" class="post-title-link">MySQL 几种排序机制分析及优化</a></h2><div class="post-info">2019-10-25<a href="/tags/MySQL/" title="MySQL" class="post-demo">MySQL</a></div><div class="post-content"><h1 id="排序流程"><a href="#排序流程" class="headerlink" title="排序流程"></a>排序流程</h1><p>四种排序情况的流程（参考《极客时间》专栏）：</p>
<p><img src="/img/mysql/order_by_process.png" alt="order_by_process"></p>
<p><img src="/img/mysql/order_by_process_2.png" alt="order_by_process"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>排序总结：</p>
<p><img src="/img/mysql/order_by.png" alt="order_by"></p>
<p>外部排序总结：</p>
<ul>
<li>MySQL 会给每个线程分配一块内存用于排序，称为 <code>sort_buffer</code>。对 <code>sort_buffer</code> 中的数据按照排序字段做<strong>快速排序</strong>；</li>
<li>排序可能在内存中完成，也可能需要使用磁盘排序，取决于排序所需的内存和参数 <code>sort_buffer_size</code>。</li>
<li>内存放不下时，使用外部磁盘排序，外部磁盘排序一般使用<strong>归并排序</strong>算法。可以简单理解，MySQL 将需要排序的数据分成 N 份，每一份单独排序后存在这些临时文件中。然后把这 N 个有序文件再合并成一个有序的大文件。</li>
</ul>
<p>优化方式：</p>
<ul>
<li>将 <code>WHERE</code> 和 <code>ORDER BY</code> 子句用到的字段，添加联合索引（注意字段顺序）；</li>
<li>如果 <code>GROUP BY</code> 结果无需排序，可以加上 <code>ORDER BY NULL</code>。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html</a></p>
</div></article></li></ul><div class="right-container"><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/DNS/" style="font-size: 12.5px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GNU-Linux/" style="font-size: 16.67px;">GNU/Linux</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 19.17px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 11.67px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10.83px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15.83px;">Spring</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 18.33px;">前端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">响应式编程</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 12.5px;">安全</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">并发编程</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 13.33px;">建站</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 12.5px;">管理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.17px;">读书笔记</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 12.5px;">金融</a></div></div><div class="widget"><div class="recent"><h4>最近文章</h4><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/02/26/cpp-io-library/">C/C++ 语言系列（十一）I/O 库总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/25/cpp-oop-inheritance-and-polymorphism/">C/C++ 语言系列（十）面向对象编程之继承与多态</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/20/cpp-oop-class/">C/C++ 语言系列（九）面向对象编程之类、类模板、类指针</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/18/cpp-type-aliases/">C/C++ 语言系列（八）复合数据类型之类型别名</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/02/16/cpp-struct/">C/C++ 语言系列（七）复合数据类型之结构体</a></li></ul></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/page/2/" class="prev">PREV</a><a href="/page/4/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2021 <a href="https://github.com/qidawu" target="_blank">Qida's Blog</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>