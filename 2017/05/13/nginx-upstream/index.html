<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> Nginx 负载均衡 · Qida's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Nginx 负载均衡 - Qida's Blog"><meta name="keywords"><meta name="author" content="Qida's Blog"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://qidawu.github.io/atom.xml" title="Qida's Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><a href="/" class="title-link">Qida's Blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">Nginx 负载均衡</h1><div class="post-info">2017-05-13<a href="/tags/Nginx/" title="Nginx" class="post-demo">Nginx</a></div><div class="post-content"><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>Nginx 标准 HTTP 模块 <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html" target="_blank" rel="noopener">ngx_http_upstream_module</a> 内置了集群和负载均衡功能，使用其中的 <code>upstream</code> 配合 <code>proxy_pass</code> 指令即可快速实现一个集群：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server backend1.example.com       weight&#x3D;5;</span><br><span class="line">        server 127.0.0.1:8080             max_fails&#x3D;3 fail_timeout&#x3D;30s;</span><br><span class="line">        server unix:&#x2F;tmp&#x2F;backend3;</span><br><span class="line"></span><br><span class="line">        server backup1.example.com:8080   backup;</span><br><span class="line">        server backup2.example.com:8080   down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>server</code> 指令的常用参数描述如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>weight=number</code></td>
<td>设置服务器的轮询权重，默认为 1。用于后端服务器性能不均的情况。</td>
</tr>
<tr>
<td><code>max_conns=number</code></td>
<td>设置被代理服务器的最大可用并发连接数限制，默认为 0，表示没有限制。</td>
</tr>
<tr>
<td><code>max_fails=number</code></td>
<td>设置最大失败重试次数，默认为 1。设置为 0 表示禁用重试。</td>
</tr>
<tr>
<td><code>fail_timeout=time</code></td>
<td>设置失败时间，默认 10 秒。</td>
</tr>
<tr>
<td><code>backup</code></td>
<td>将服务器标记为备份服务器。当主服务器不可用时，它将被传递请求。</td>
</tr>
<tr>
<td><code>down</code></td>
<td>将服务器标记为永久不可用。</td>
</tr>
</tbody></table>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡（Load Balance），其意思就是将运算或存储负载按一定的算法分摊到多个运算或存储单元上，下面介绍 Nginx 几种常见的负载均衡方法：</p>
<ul>
<li>默认策略：加权轮询策略（weighted round-robin）。</li>
<li><code>random</code>，加权随机策略。</li>
<li><code>ip_hash</code>，基于客户端 IP 计算出哈希值，再根据服务器数量取模选取服务器（ip_hash % server_size = server_no）。</li>
<li><code>hash key [consistent]</code>，基于指定 key 计算出哈希值，再根据服务器数量取模选取服务器。可选一致性哈希算法缓解重映射问题。</li>
<li><code>least_conn</code>，基于最小活跃连接数（加权）。如果有多个服务器符合条件，则使用加权轮询策略依次响应。</li>
<li><code>least_time</code>，基于最小平均响应时间和最小活跃连接数（加权）。如果有多个服务器符合条件，则使用加权轮询策略依次响应。</li>
</ul>
<h2 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip hash"></a>ip hash</h2><p>使用 Nginx <code>ip_hash</code> 指令，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line"></span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">    server backend3.example.com down;</span><br><span class="line">    server backend4.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ip_hash</code> 指令指定集群使用基于<strong>客户端 IP 地址</strong>的负载均衡方法。 客户端 IPv4 地址的前三个八位字节或整个 IPv6 地址用作哈希键。 该方法确保来自同一客户端的请求将始终传递到同一台服务器，除非此服务器不可用，客户端请求则将被<strong>转发</strong>到另一台服务器（多数情况下，始终是同一台服务器）。<br>如果其中一台服务器需要临时删除，则应使用 <code>down</code> 参数标记，以便保留当前客户端 IP 地址的哈希值。</p>
<h2 id="一致性-hash"><a href="#一致性-hash" class="headerlink" title="一致性 hash"></a>一致性 hash</h2><p>使用 Nginx <code>hash</code> 指令，常用的例如基于来源 IP 进行哈希，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    hash $remote_addr consistent;</span><br><span class="line"></span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>hash</code> 指令指定集群使用基于<strong>指定 hash 散列键</strong>的负载均衡方法。散列键可以包含文本，变量及其组合。请注意，从集群中添加或删除服务器可能会导致大量键被重新映射到不同的服务器。</p>
<p>解决办法是使用 <code>consistent</code> 参数启用  <a href="http://www.last.fm/user/RJ/journal/2007/04/10/392555/" target="_blank" rel="noopener">ketama</a> 一致性 hash 算法。 该算法将每个 server 虚拟成 n 个节点，均匀分布到 hash 环上。每次请求，根据配置的参数计算出一个 hash 值，在 hash 环上查找离这个 hash 最近的虚拟节点，对应的 server 作为该次请求的后端服务器。该算法确保在添加或删除服务器时，只会有少量键被重新映射到不同的服务器。这有助于为缓存服务器实现更高的缓存命中率。</p>
<h1 id="会话保持"><a href="#会话保持" class="headerlink" title="会话保持"></a>会话保持</h1><p>sticky cookie 粘滞会话（也称会话保持\会话绑定）是负载均衡的一个基本功能，为了确保与某个客户相关的所有应用请求能够由同一台服务器进行处理，我们需要在负载均衡上启用会话保持功能，以确保负载均衡的部署不会影响到正常的业务处理。</p>
<p>基于源地址的 ip_hash 进行会话保持的问题在于，当多个客户是通过代理或地址转换的方式来访问服务器时，由于都分配到同一台服务器上，会导致服务器之间的负载失衡。</p>
<p>通过 cookie 实现客户端与后端服务器的会话保持，在一定条件下可以保证同一个客户端访问的都是同一个后端服务器。使用 Nginx <code>sticky</code> 指令，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line"></span><br><span class="line">    sticky cookie srv_id expires&#x3D;1h domain&#x3D;.example.com path&#x3D;&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这份配置在同一域名下有两个 location，分别对应了两组集群服务。为了分别实现会话保持，将 cookie 写入了对应的 path 下，避免 cookie 互相干扰，也减少了数据传输量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend1 &#123;</span><br><span class="line">        server backup1.example.com:8080;</span><br><span class="line">        server backup1.example.com:8081;</span><br><span class="line">    	sticky cookie srv_backend1 path&#x3D;&#x2F;backend1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream backend2 &#123;</span><br><span class="line">        server backup2.example.com:8080;</span><br><span class="line">        server backup2.example.com:8081;</span><br><span class="line">    	sticky cookie srv_backend2 path&#x3D;&#x2F;backend2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        server_name example.com;</span><br><span class="line">        listen 80;</span><br><span class="line">    </span><br><span class="line">        location &#x2F;backend1&#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location &#x2F;backend2&#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h1><p>健康检查（Health Check）是保障集群可用性的重要手段，有三种常见的健康检查方法：</p>
<ul>
<li>使用社区版 Nginx 的 <code>max_fails</code> 和 <code>fail_timeout</code> 指令进行被动式检查，不推荐使用，详见：《<a href="https://segmentfault.com/a/1190000002446630" target="_blank" rel="noopener">nginx中健康检查(health_check)机制深入分析</a>》；</li>
<li>使用<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业版 Nginx Plus</a> 进行主动式检查，缺点是要收费；</li>
<li>使用 Nginx 第三方模块编译，例如：<a href="https://github.com/yaoweibin/nginx_upstream_check_module" target="_blank" rel="noopener">nginx_upstream_check_module</a> ；</li>
<li>使用 <a href="http://tengine.taobao.org/" target="_blank" rel="noopener">Tengine</a> 内置的<a href="http://tengine.taobao.org/document_cn/http_upstream_check_cn.html" target="_blank" rel="noopener">主动式健康检查</a>功能（该内置模块等同于第 3 点）。</li>
</ul>
<h2 id="主动式健康检查"><a href="#主动式健康检查" class="headerlink" title="主动式健康检查"></a>主动式健康检查</h2><p>以 <code>nginx_upstream_check_module</code> 第三方模块为例，演示配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend1 &#123;</span><br><span class="line">    check interval&#x3D;3000 rise&#x3D;2 fall&#x3D;5 timeout&#x3D;1000 type&#x3D;http;</span><br><span class="line">    check_keepalive_requests 100;</span><br><span class="line">    check_http_send &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1\r\nConnection: keep-alive\r\nHost: check.com\r\n\r\n&quot;;</span><br><span class="line">    check_http_expect_alive http_2xx http_3xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段配置表示：</p>
<ol>
<li><code>check</code> 指令配置：每隔 <code>interval</code> 毫秒主动发送一个 <code>http</code> 健康检查包给后端服务器。请求超时时间为 <code>timeout</code> 毫秒。如果连续失败次数达到 <code>fall_count</code>，服务器就被认为是 down；如果连续成功次数达到 <code>rise_count</code>，服务器就被认为是 up。</li>
<li><code>check_keepalive_requests</code> 指令配置：一个连接发送的请求数。</li>
<li><code>check_http_send</code> 指令配置：请求包的内容（注意，这里必须<a href="https://my.oschina.net/liuleidefeng/blog/786739" target="_blank" rel="noopener">配置 <code>Host</code> 请求头否则可能报错</a>）。</li>
<li><code>check_http_expect_alive</code> 指令配置：响应状态码为 <code>2XX</code> 和 <code>3XX</code> 表示请求成功、服务健康。</li>
</ol>
<p>查看 Tomcat access.log 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:30 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:33 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:36 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:39 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:42 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:45 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br></pre></td></tr></table></figure>

<p>此时关闭某台后端服务器，一段时间后再访问，请求会被路由到其它服务器；重启后，该服务器自动加入集群。通过健康状态页面 <code>/status</code> 可见：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Nginx http upstream check status</span><br><span class="line"></span><br><span class="line">Check upstream server number: 2, generation: 2</span><br><span class="line"></span><br><span class="line">Index	Upstream	Name	Status	Rise counts	Fall counts	Check type	Check port</span><br><span class="line">0	backend1	127.0.0.1:8080	up	4741	0	http	0</span><br><span class="line">1	backend1	127.0.0.1:8081	down	0	2340	http	0</span><br></pre></td></tr></table></figure>

<h1 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h1><h2 id="upstream-addr"><a href="#upstream-addr" class="headerlink" title="$upstream_addr"></a>$upstream_addr</h2><p>该模块中很常用的一个变量，用于标识集群中服务器的 IP 和端口。一般会加入到 Nginx 日志、同时脱敏后加入到响应头中，用于排查问题来源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;&quot;$http_x_forwarded_for&quot; - &quot;$upstream_addr&quot; - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                  &#39;&quot;$http_user_agent&quot; $remote_addr $request_time_msec&#39;</span><br><span class="line">    access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    map $upstream_addr $short_address &#123;</span><br><span class="line">        ~^\d+\.\d+\.\d+\.(.*) &#39;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        server_name example.com;</span><br><span class="line">        listen 80;</span><br><span class="line">        </span><br><span class="line">        upstream backend &#123;</span><br><span class="line">            server 127.0.0.1:81;</span><br><span class="line">            server 127.0.0.1:82;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            add_header X-From $short_address$1;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend&#x2F;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="right-container"><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/DNS/" style="font-size: 12.5px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GNU-Linux/" style="font-size: 16.67px;">GNU/Linux</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 19.17px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 11.67px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10.83px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15.83px;">Spring</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 18.33px;">前端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">响应式编程</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 12.5px;">安全</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">并发编程</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 13.33px;">建站</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 12.5px;">管理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.17px;">读书笔记</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 12.5px;">金融</a></div></div><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2017/05/19/maven-plugins/" class="prev">PREV</a><a href="/2017/05/07/nginx-ssl/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2021 <a href="https://github.com/qidawu" target="_blank">Qida's Blog</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>