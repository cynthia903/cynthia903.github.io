<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> 并发编程系列（三）Java 线程池总结 · Qida's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="并发编程系列（三）Java 线程池总结 - Qida's Blog"><meta name="keywords"><meta name="author" content="Qida's Blog"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://qidawu.github.io/atom.xml" title="Qida's Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><a href="/" class="title-link">Qida's Blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">并发编程系列（三）Java 线程池总结</h1><div class="post-info">2020-05-03<a href="/tags/Java/" title="Java" class="post-demo">Java</a><a href="/tags/并发编程/" title="并发编程" class="post-demo">并发编程</a></div><div class="post-content"><p>为什么要用线程池？</p>
<blockquote>
<p>线程的创建和销毁是有代价的。</p>
<p>如果请求的到达率非常高且请求的处理过程是轻量级的，那么为每个请求创建一个新线程将消耗大量的计算资源。</p>
<p>活跃的线程会消耗系统资源，尤其是内存。大量空闲线程会占用许多内存，给垃圾回收器带来压力，而且大量线程竞争 CPU 资源还会产生其它的性能开销。</p>
<p>可创建线程的数量上存在限制，如果创建太多线程，会使系统饱和甚至抛出 <code>OutOfMemoryException</code> 。</p>
</blockquote>
<p>问题如下：</p>
<p><img src="/img/java/concurrent/no_thread_pool_design.png" alt="no_thread_pool_design"></p>
<p>为了解决以上问题，从 Java 5 开始 JDK 并发 API 提供了 Executor Framework，用于<strong>将任务的创建与执行分离</strong>，避免使用者直接与 <code>Thread</code> 对象打交道，通过池化设计与阻塞队列保护系统资源：</p>
<p><img src="/img/java/concurrent/thread_pool_design.png" alt="thread_pool_design"></p>
<p>使用 Executor Framework 的第一步就是创建一个 <code>ThreadPoolExecutor</code> 类的对象。你可以使用这个类提供的 <strong>四个构造方法</strong>或 <code>Executors</code> <strong>工厂类</strong>来创建 <code>ThreadPoolExecutor</code> 。一旦有了执行者，你就可以提交 <code>Runnable</code> 或 <code>Callable</code> 对象给执行者来执行。</p>
<h1 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h1><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p><code>Executor</code> 接口的实现类如下：</p>
<p><img src="/img/java/concurrent/subtypes_of_Executor.png" alt="subtypes_of_Executor"></p>
<p>其中，<code>ThreadPoolExecutor</code> 类实现了两个核心接口 <code>Executor</code> 和 <code>ExecutorService</code>，方法如下：</p>
<p><img src="/img/java/concurrent/Executor.png" alt="ThreadPoolExecutor"></p>
<p><code>ThreadPoolExecutor</code> 类的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 线程池使用一个int变量存储线程池状态和工作线程数</span></span><br><span class="line"><span class="comment">  * int4个字节，32位，用高三位存储线程池状态，低29位存储工作线程数</span></span><br><span class="line"><span class="comment">  * 为什么使用一个变量来同时表示线程状态和线程数？就是节省空间。咨询了一下写c的朋友，他们经常这么写</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//COUNT_BITS=29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//理论上线程池最大线程数量CAPACITY=(2^29)-1，即 536,870,911</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程池状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">//获取工作线程数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">//初始化ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 线程池状态转换</span></span><br><span class="line"><span class="comment">  * RUNNING -&gt; SHUTDOWN</span></span><br><span class="line"><span class="comment">  * RUNNING or SHUTDOWN -&gt; STOP</span></span><br><span class="line"><span class="comment">  * SHUTDOWN or STOP -&gt; TIDYING</span></span><br><span class="line"><span class="comment">  * TIDYING -&gt; TERMINATED  terminated()执行完后变为该TERMINATED</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//接受新任务，可以处理阻塞队列里的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//不接受新任务，可以处理阻塞队列里的任务。执行shutdown()会变为SHUTDOWN</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//不接受新的任务，不处理阻塞队列里的任务，中断正在处理的任务。执行shutdownNow()会变为STOP</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//临时过渡状态，所有的任务都执行完了，当前线程池有效的线程数量为0，这个时候线程池的状态是TIDYING，执行terminated()变为TERMINATED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//终止状态，terminated()调用完成后的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重入锁，更新线程池核心大小、线程池最大大小等都有用到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//用于存储woker</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">//用于终止线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"><span class="comment">//记录线程池中曾经出现过的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">//完成任务数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心线程数</span></span><br><span class="line"><span class="comment"> * 核心线程会一直存活，即使没有任务需要处理，当线程数小于核心线程数时。</span></span><br><span class="line"><span class="comment"> * 即使现有的线程空闲，线程池也会优先创建新线程来处理任务，而不是直接交给现有的线程处理。</span></span><br><span class="line"><span class="comment"> * 核心线程数在初始化时不会创建，只有提交任务的时候才会创建。核心线程在allowCoreThreadTimeout为true的时候超时会退出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"> <span class="comment">/** 最大线程数</span></span><br><span class="line"><span class="comment">   * 当线程数大于或者等于核心线程，且任务队列已满时，线程池会创建新的线程，直到线程数量达到maxPoolSize。</span></span><br><span class="line"><span class="comment">   * 如果线程数已等于maxPoolSize，且任务队列已满，则已超出线程池的处理能力，线程池会采取拒绝操作。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 线程空闲时间</span></span><br><span class="line"><span class="comment">  * 当线程空闲时间达到keepAliveTime，该线程会退出，直到线程数量等于corePoolSize。</span></span><br><span class="line"><span class="comment">  * 如果allowCoreThreadTimeout设置为true，则所有线程均会退出。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">//是否允许核心线程空闲超时退出，默认值为false。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"><span class="comment">//线程工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"><span class="comment">//用于保存等待执行的任务的阻塞队列。比如LinkedBlockQueue，SynchronousQueue等</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  rejectedExecutionHandler：任务拒绝策略</span></span><br><span class="line"><span class="comment"> *  DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务</span></span><br><span class="line"><span class="comment"> *  AbortPolicy：抛出异常。这也是默认的策略</span></span><br><span class="line"><span class="comment"> *  CallerRunsPolicy：用调用者所在线程来运行任务</span></span><br><span class="line"><span class="comment"> *  DiscardPolicy：不处理，丢弃掉</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">//默认的拒绝策略：抛出异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">    <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission shutdownPerm =</span><br><span class="line">    <span class="keyword">new</span> RuntimePermission(<span class="string">"modifyThread"</span>);</span><br></pre></td></tr></table></figure>

<p><code>ThreadPoolExecutor</code> 提供了四个构造方法，以参数最多的为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> || maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面分别介绍源码中涉及的重要属性。</p>
<h2 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h2><p>作为一个线程池，有两个关键属性：</p>
<ul>
<li>线程池状态 <code>runState</code></li>
<li>工作线程数 <code>workerCnt</code></li>
</ul>
<p>这两个关键属性保存在名为 <code>ctl</code> 的 <code>AtomicInteger</code> 类型属性之中，高 3 位表示 <code>runState</code>，低 29 位表示 <code>workerCnt</code>，如下：</p>
<p><img src="/img/java/concurrent/ctl.png" alt="ctl"></p>
<p>为什么要用 3 位来表示线程池的状态呢，原因是线程池一共有 5 种状态，而 2 位只能表示出 4 种情况，所以至少需要 3 位才能表示得了 5 种状态，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">runState workerCnt                       runState workerCnt</span><br><span class="line">     000 00000000000000000000000000000   SHUTDOWN empty</span><br><span class="line">‭‭     001 00000000000000000000000000000       STOP empty</span><br><span class="line">     010 00000000000000000000000000000    TIDYING empty</span><br><span class="line">     ‭011 00000000000000000000000000000‬ TERMINATED empty</span><br><span class="line">     111 00000000000000000000000000000    RUNNING empty</span><br><span class="line">‭     111 11111111111111111111111111111    RUNNING full</span><br></pre></td></tr></table></figure>

<p>通过 <code>ctlOf</code> 方法初始化 <code>ctl</code> 属性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或运算符(|)规则：1|1=1</span></span><br><span class="line"><span class="comment">//                 1|0=1</span></span><br><span class="line"><span class="comment">//                 0|1=1</span></span><br><span class="line"><span class="comment">//                 0|0=0</span></span><br><span class="line"><span class="comment">// 以初始化参数 ctlOf(RUNNING, 0) 为例：</span></span><br><span class="line">  <span class="number">11100000000000000000000000000000</span></span><br><span class="line">| <span class="number">00000000000000000000000000000000</span></span><br><span class="line">= <span class="number">11100000000000000000000000000000</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>runStateOf</code> 方法获取线程池状态 <code>runState</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取线程池状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取反运算符(~)规则：~1=0</span></span><br><span class="line"><span class="comment">//                   ~0=1</span></span><br><span class="line"><span class="comment">// 以 c = 111 11111111111111111111111111111（RUNNING full）为例：</span></span><br><span class="line">     ~<span class="number">11111111111111111111111111111</span></span><br><span class="line">=     <span class="number">00000000000000000000000000000</span></span><br><span class="line">&amp; <span class="number">111</span> <span class="number">11111111111111111111111111111</span></span><br><span class="line">= <span class="number">111</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>workerCountOf</code> 方法获取工作线程数 <code>workerCnt</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取工作线程数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与运算符(&amp;)规则：1&amp;1=1</span></span><br><span class="line"><span class="comment">//                 1&amp;0=0</span></span><br><span class="line"><span class="comment">//                 0&amp;1=0</span></span><br><span class="line"><span class="comment">//                 0&amp;0=0</span></span><br><span class="line"><span class="comment">// 以 c = 111 11111111111111111111111111111（RUNNING full）为例：</span></span><br><span class="line">  <span class="number">111</span> <span class="number">11111111111111111111111111111</span></span><br><span class="line">&amp;     <span class="number">11111111111111111111111111111</span></span><br><span class="line">=     <span class="number">11111111111111111111111111111</span></span><br></pre></td></tr></table></figure>

<h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>线程池状态用于标识线程池内部的一些运行情况，线程池的开启到关闭的过程就是线程池状态的一个流转的过程。</p>
<p>线程池共有五种状态：</p>
<p><img src="/img/java/concurrent/run_state.png" alt="run_state"></p>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th><code>runState</code></th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>RUNNING</code></td>
<td>111</td>
<td align="left">运行状态，该状态下线程池可以接受新的任务，也可以处理阻塞队列中的任务。<br/>执行 <code>shutdown</code> 方法可进入 <code>SHUTDOWN</code> 状态。<br/>执行 <code>shutdownNow</code> 方法可进入 <code>STOP</code> 状态。</td>
</tr>
<tr>
<td align="left"><code>SHUTDOWN</code></td>
<td>000</td>
<td align="left">待关闭状态，不再接受新的任务，继续处理阻塞队列中的任务。<br/>当阻塞队列中的任务为空，并且工作线程数为 0 时，进入 <code>TIDYING</code> 状态。</td>
</tr>
<tr>
<td align="left"><code>STOP</code></td>
<td>001</td>
<td align="left">停止状态，不接收新任务，也不处理阻塞队列中的任务，并且会尝试结束执行中的任务。<br/>当工作线程数为 0 时，进入 <code>TIDYING</code> 状态。</td>
</tr>
<tr>
<td align="left"><code>TIDYING</code></td>
<td>010</td>
<td align="left">整理状态，此时任务都已经执行完毕，并且也没有工作线程 执行 <code>terminated</code> 方法后进入 <code>TERMINATED</code> 状态。</td>
</tr>
<tr>
<td align="left"><code>TERMINATED</code></td>
<td>011</td>
<td align="left">终止状态，此时线程池完全终止了，并完成了所有资源的释放。</td>
</tr>
</tbody></table>
<h3 id="工作线程数"><a href="#工作线程数" class="headerlink" title="工作线程数"></a>工作线程数</h3><p>尽管理论上线程池最大线程数量可达 <code>CAPACITY</code> 数，但是实际上都会通过 <code>maximumPoolSize</code> 限制最大线程数。因此工作线程数 <code>workerCnt</code> 的个数可能在 0 至 <code>maximumPoolSize</code> 之间变化。</p>
<p>当工作线程的空闲时间达到 <code>keepAliveTime</code>，该工作线程会退出，直到工作线程数 <code>workerCnt</code> 等于 <code>corePoolSize</code>。如果 <code>allowCoreThreadTimeout</code> 设置为 <code>true</code>，则所有工作线程均会退出。</p>
<p><img src="/img/java/concurrent/worker_count.png" alt="worker_count"></p>
<p>注意：</p>
<ul>
<li>整个线程池的基本执行过程：创建核心线程（Core Thread） &gt; 任务排队 &gt; 创建临时线程（Temp Thread）。</li>
<li>如果将 <code>maximumPoolSize</code> 设置为基本的无界值（如 Integer.MAX_VALUE），可能会创建大量的线程，从而导致 OOM。因此要限定 <code>maximumPoolSize</code> 的大小。</li>
<li>如果将 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 设置为相同值，则创建了 Fixed 固定大小的线程池。</li>
</ul>
<h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h3><p>通过提供不同的 <code>ThreadFactory</code> 接口实现，可以改变被创建线程 <code>Thread</code> 的名称、线程组、优先级、守护进程状态，等等。</p>
<p>参考《<a href="/2018/07/10/java-concurrent-package/#ThreadFactory">Java 并发编程系列（一）常用包总结</a>》</p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列的使用详见另一篇《<a href="/2018/04/21/java-collections-framework-concurrent-impl/">Java 集合框架系列（三）并发实现总结</a>》。</p>
<p><img src="/img/java/concurrent/work_queue.png" alt="work_queue"></p>
<h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>拒绝策略，默认有四种实现：</p>
<ul>
<li><code>AbortPolicy</code>：抛出异常，默认的策略。</li>
<li><code>DiscardPolicy</code>：不处理，丢弃掉。</li>
<li><code>DiscardOldestPolicy</code>：丢弃队列中最近的一个任务，并执行该任务。</li>
<li><code>CallerRunsPolicy</code>：用调用者所在线程来执行该任务。</li>
</ul>
<p><img src="/img/java/concurrent/RejectedExecutionHandler.png" alt="RejectedExecutionHandler"></p>
<p>通过 <code>RejectedExecutionHandler</code> 接口可以实现更多策略，例如记录日志或持久化不能处理的任务，或者发出告警。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><code>execute</code> 方法的整体执行流程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Proceed in 3 steps:</span><br><span class="line"> *</span><br><span class="line"> * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line"> * start a new thread with the given command as its first</span><br><span class="line"> * task.  The call to addWorker atomically checks runState and</span><br><span class="line"> * workerCount, and so prevents false alarms that would add</span><br><span class="line"> * threads when it shouldn&#39;t, by returning false.</span><br><span class="line"> *</span><br><span class="line"> * 2. If a task can be successfully queued, then we still need</span><br><span class="line"> * to double-check whether we should have added a thread</span><br><span class="line"> * (because existing ones died since last checking) or that</span><br><span class="line"> * the pool shut down since entry into this method. So we</span><br><span class="line"> * recheck state and if necessary roll back the enqueuing if</span><br><span class="line"> * stopped, or start a new thread if there are none.</span><br><span class="line"> *</span><br><span class="line"> * 3. If we cannot queue task, then we try to add a new</span><br><span class="line"> * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line"> * and so reject the task.</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>

<p><img src="/img/java/concurrent/work_flow_of_execute_method.png" alt="work_flow_of_execute_method"></p>
<h1 id="使用工厂类创建线程池"><a href="#使用工厂类创建线程池" class="headerlink" title="使用工厂类创建线程池"></a>使用工厂类创建线程池</h1><p><code>java.util.concurrent.ThreadPoolExecutor</code> 提供了四个不同的构造方法，但由于它们的复杂性（参数较多），Java 并发 API 提供了 <code>java.util.concurrent.Executors</code> 工厂类来简化线程池的构造，常用方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(...)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO, LIFO, 优先级）执行。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(...)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(...)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 创建一个定长线程池，支持定时及周期性任务执行。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(...)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种方式并不推荐使用，参考《阿里巴巴 Java 开发手册》：    </p>
<p><img src="/img/java/concurrent/principal_of_executors.png" alt="principal of executors"></p>
<p><code>java.util.concurrent.Executors</code> 源码分析如下，首先是 <code>newFixedThreadPool(...)</code> 和 <code>newSingleThreadExecutor(...)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fixed 限定 corePoolSize 和 maximumPoolSize 为相同大小，即线程池大小固定（意味着无法扩展）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Single 其实就是 Fixed 为 1 的变种</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法中，关键在于对 <code>java.util.concurrent.LinkedBlockingQueue</code> 的构造，使用了默认的无参构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许的请求队列长度（capacity）为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是 <code>newCachedThreadPool(...)</code> 和 <code>newScheduledThreadPool(...)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许的创建线程数量（maximumPoolSize）为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题在于 ScheduledThreadPoolExecutor 构造方法的默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下 <code>java.util.concurrent.ScheduledThreadPoolExecutor</code> 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScheduledThreadPoolExecutor 构造方法中，允许的创建线程数量（maximumPoolSize）为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="right-container"><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/DNS/" style="font-size: 12.5px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GNU-Linux/" style="font-size: 16.67px;">GNU/Linux</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 19.17px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 11.67px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10.83px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15.83px;">Spring</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 18.33px;">前端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">响应式编程</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 12.5px;">安全</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">并发编程</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 13.33px;">建站</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 12.5px;">管理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.17px;">读书笔记</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 12.5px;">金融</a></div></div><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2020/08/01/java-reactive-programming/" class="prev">PREV</a><a href="/2020/05/01/java-concurrency-package/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2021 <a href="https://github.com/qidawu" target="_blank">Qida's Blog</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>