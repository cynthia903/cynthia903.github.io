<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> Git 实战系列（六）git rebase 命令衍合分支 · Qida's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Git 实战系列（六）git rebase 命令衍合分支 - Qida's Blog"><meta name="keywords"><meta name="author" content="Qida's Blog"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://qidawu.github.io/atom.xml" title="Qida's Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><a href="/" class="title-link">Qida's Blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">Git 实战系列（六）git rebase 命令衍合分支</h1><div class="post-info">2015-08-20<a href="/tags/Git/" title="Git" class="post-demo">Git</a></div><div class="post-content"><p>本文介绍一个生僻但相当好用的命令 <code>rebase</code>（衍合）。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>衍合的两个使用场景：</p>
<ol>
<li>生成干净历史、补丁</li>
<li>整理当前分支</li>
</ol>
<h2 id="生成干净历史"><a href="#生成干净历史" class="headerlink" title="生成干净历史"></a>生成干净历史</h2><p>开发过程中，常常需要定期将最新的远程分支拉取（<code>pull</code>）到本地分支，保持本地代码最新（up to date）。如果拉取频繁，<code>pull</code> 默认的 <code>merge</code> 行为会造成祖先图谱（ancestry graph）无谓的复杂：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master    &#x2F;&#x2F; pull &#x3D; fetch + merge</span><br><span class="line"></span><br><span class="line">*   ab900eb - 三方合并版本（注意这里！）</span><br><span class="line">|\</span><br><span class="line">| * 756ba83 - 本地分支提交的版本</span><br><span class="line">* | 915fe84 - 先被推送到远程分支的版本</span><br><span class="line">|&#x2F;</span><br><span class="line">*   e7ce3f8 - 基准版本（共同祖先）</span><br></pre></td></tr></table></figure>

<p>解决方案是改用 <code>rebase</code> 命令，其产生的祖先图谱如下，非常简洁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   dc6baf3 - 本地分支提交的版本（注意这个提交被改写了！）</span><br><span class="line">|</span><br><span class="line">*   915fe84 - 先被推送到远程分支的版本</span><br><span class="line">|</span><br><span class="line">*   e7ce3f8 - 基准版本（共同祖先）</span><br></pre></td></tr></table></figure>

<p>可见，这个神奇的命令功能类似 <code>merge</code> ，但它避免了上述无谓的合并节点，从而产生一个更为整洁的提交历史。如果视察一个衍合过的分支历史，仿佛所有的提交都是在一根时间轴上先后进行的，尽管实际上它们原本是同时并行发生的。这么做的好处是，非常便于项目管理人员按时间轴进行<strong>代码审查</strong>。</p>
<h3 id="命令用法"><a href="#命令用法" class="headerlink" title="命令用法"></a>命令用法</h3><p>可以在 <code>pull</code> 时主动加上 <code>--rebase</code> 参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull --rebase origin master</span><br></pre></td></tr></table></figure>

<p>甚至推荐将 <code>rebase</code> 设为 <code>pull</code> 命令的默认行为，从而应用于所有新建分支：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global branch.autosetuprebase always</span><br></pre></td></tr></table></figure>

<p>注意，对于应用上述命令前已存在的分支（例如 <code>master</code>），需要补充执行如下配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config branch.master.rebase <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="命令原理"><a href="#命令原理" class="headerlink" title="命令原理"></a>命令原理</h3><p> 下面进一步介绍 <code>rebase</code> 命令的原理：</p>
<ol>
<li>把本地分支从上一次 <code>pull</code> 之后的变更暂存起来；</li>
<li>恢复到上一次 <code>pull</code> 时的情况；</li>
<li>合并远程分支的提交；</li>
<li>最后再逐一合并刚暂存下来的本地提交（相当于重放一遍）。</li>
</ol>
<h2 id="生成干净补丁"><a href="#生成干净补丁" class="headerlink" title="生成干净补丁"></a>生成干净补丁</h2><p>使用衍合的另一个目的，是想要得到一个能在远程分支上干净应用的补丁 — 比如某些项目、或些分支你不是维护者，但想帮点忙的话，最好用衍合：先在自己的一个独立分支中进行开发，当准备向主项目提交补丁的时候，根据最新的 <code>origin/master</code> 进行一次 <code>git rebase</code> 衍合操作然后再提交，这样维护者就<strong>不需要做任何整合工作</strong>（实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。），只需根据你提供的仓库地址作一次<strong>快进合并</strong>，或者直接采纳你提交的补丁。</p>
<h2 id="整理当前分支"><a href="#整理当前分支" class="headerlink" title="整理当前分支"></a>整理当前分支</h2><p>衍合的另一个用法是整理当前分支，使用 <code>git rebase [-i | --interactive]</code> 命令。</p>
<p>首先选取提交范围，<code>e7ce3f8</code> 为当前分支的历史提交：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   dc6baf3 - commit3</span><br><span class="line">|</span><br><span class="line">*   915fe84 - commit2</span><br><span class="line">|</span><br><span class="line">*   e7ce3f8 - commit1</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i e7ce3f8</span><br><span class="line"></span><br><span class="line">  1 pick dc6baf3 本地分支提交的版本</span><br><span class="line">  2 pick 915fe84 先被推送到远程分支的版本</span><br><span class="line">  3</span><br><span class="line">  4 <span class="comment"># Rebase 1ff20826..61527529 onto 1ff20826 (2 commands)</span></span><br><span class="line">  5 <span class="comment">#</span></span><br><span class="line">  6 <span class="comment"># Commands:</span></span><br><span class="line">  7 <span class="comment"># p, pick = use commit</span></span><br><span class="line">  8 <span class="comment"># r, reword = use commit, but edit the commit message</span></span><br><span class="line">  9 <span class="comment"># e, edit = use commit, but stop for amending</span></span><br><span class="line"> 10 <span class="comment"># s, squash = use commit, but meld into previous commit</span></span><br><span class="line"> 11 <span class="comment"># f, fixup = like "squash", but discard this commit's log message</span></span><br><span class="line"> 12 <span class="comment"># x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"> 13 <span class="comment"># d, drop = remove commit</span></span><br><span class="line"> 14 <span class="comment">#</span></span><br><span class="line"> 15 <span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"> 16 <span class="comment">#</span></span><br><span class="line"> 17 <span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"> 18 <span class="comment">#</span></span><br><span class="line"> 19 <span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"> 20 <span class="comment">#</span></span><br><span class="line"> 21 <span class="comment"># Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure>

<p>可见，我们可以选取、编辑、合并、丢弃指定提交，达到整理分支的目的。</p>
<h1 id="使用风险"><a href="#使用风险" class="headerlink" title="使用风险"></a>使用风险</h1><p>注意，衍合必须遵守的准则：<strong>一旦本地分支中的提交（commit）已经被推送到远程仓库，就千万不要对该分支进行衍合操作。</strong>如果把衍合当成一种<strong>在推送（<code>push</code>）代码之前</strong>整理提交历史的手段，而且仅仅衍合那些<strong>尚未推送</strong>的本地提交，就没问题。如果衍合那些已经推送的提交，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《<a href="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E8%A1%8D%E5%90%88#%E8%A1%8D%E5%90%88%E7%9A%84%E9%A3%8E%E9%99%A9" target="_blank" rel="noopener">Git-分支-分支的衍合#衍合的风险</a>》</li>
<li>《<a href="http://segmentfault.com/q/1010000000430041" target="_blank" rel="noopener">团队开发里频繁使用 git rebase 来保持树的整洁好吗?</a>》</li>
</ul>
</div></article></div><div class="right-container"><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/DNS/" style="font-size: 12.5px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GNU-Linux/" style="font-size: 16.67px;">GNU/Linux</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 19.17px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 11.67px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10.83px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15.83px;">Spring</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 18.33px;">前端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">响应式编程</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 12.5px;">安全</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">并发编程</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 13.33px;">建站</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 12.5px;">管理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.17px;">读书笔记</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 12.5px;">金融</a></div></div><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2015/08/21/git-cherry-pick/" class="prev">PREV</a><a href="/2015/08/17/git-merge/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2021 <a href="https://github.com/qidawu" target="_blank">Qida's Blog</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>