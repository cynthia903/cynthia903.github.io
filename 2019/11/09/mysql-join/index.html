<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> MySQL JOIN 表连接总结 · Qida's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="MySQL JOIN 表连接总结 - Qida's Blog"><meta name="keywords"><meta name="author" content="Qida's Blog"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://qidawu.github.io/atom.xml" title="Qida's Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><a href="/" class="title-link">Qida's Blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">MySQL JOIN 表连接总结</h1><div class="post-info">2019-11-09<a href="/tags/MySQL/" title="MySQL" class="post-demo">MySQL</a></div><div class="post-content"><p><img src="/img/mysql/join.png" alt="join"></p>
<h1 id="连接语法"><a href="#连接语法" class="headerlink" title="连接语法"></a>连接语法</h1><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单的等值语法创建内联结</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Vendors, Products</span><br><span class="line"><span class="keyword">WHERE</span> Vendors.vend_id = Products.vend_id;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ANSI SQL 规范首选 INNER JOIN 语法创建内联结</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Products</span><br><span class="line"><span class="keyword">ON</span> Vendors.vend_id = Products.vend_id;</span><br></pre></td></tr></table></figure>

<p>在内连接两个表时，实际要做的是将第一个表中的每一行与第二个表中的每一行配对，<code>WHERE</code> 或 <code>ON</code> 子句作为过滤条件，<strong>只包含那些匹配连接条件的行</strong>。</p>
<p>由没有连接条件的表关系返回的结果为<strong>笛卡儿积（cartesian product）</strong>。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。因此应当总是提供连接条件。</p>
<h2 id="外连接（左、右）"><a href="#外连接（左、右）" class="headerlink" title="外连接（左、右）"></a>外连接（左、右）</h2><p>许多连接将一个表中的行与另一个表中的行相关联，但有时候需要<strong>包含没有关联行</strong>的那些行，例如：</p>
<ul>
<li><p>对每个顾客下的订单进行计数，包括那些至今尚未下订单的顾客；</p>
</li>
<li><p>列出所有产品以及订购数量，包括没有人订购的产品；</p>
</li>
<li><p>计算平均销售规模，包括那些至今尚未下订单的顾客。</p>
</li>
</ul>
<p>在上述例子中，连接包含了那些在相关表中没有关联行的行。这种连接称为外连接。</p>
<p>例如，要检索出所有顾客+订单，包括那些还未下单的顾客：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">cust_id    order_num</span><br><span class="line"><span class="comment">---------- ---------</span></span><br><span class="line">1000000001 20005</span><br><span class="line">1000000001 20009</span><br><span class="line">1000000002 NULL</span><br><span class="line">1000000003 20006</span><br><span class="line">1000000004 20007</span><br><span class="line">1000000005 20008</span><br></pre></td></tr></table></figure>

<p>上例如果使用内连接，将不包含 <em>1000000002</em> 顾客，因为他还未下单（即连接条件不匹配）。</p>
<p>作为对比，下例使用内连接 <code>INNER JOIN</code> 和聚集函数 <code>COUNT()</code> 统计出所有顾客的订单数：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, <span class="keyword">COUNT</span>(Orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Customers.cust_id;</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">cust_id    num_ord</span><br><span class="line"><span class="comment">---------- --------</span></span><br><span class="line">1000000001 2</span><br><span class="line">1000000003 1</span><br><span class="line">1000000004 1</span><br><span class="line">1000000005 1</span><br></pre></td></tr></table></figure>

<p>但如果使用左外连接 <code>LEFT OUTER JOIN</code> 和聚集函数 <code>COUNT()</code> 进行相同统计，将会包括那些还未下单的顾客，例如顾客 <em>1000000002</em>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, <span class="keyword">COUNT</span>(Orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Customers.cust_id;</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">cust_id    num_ord</span><br><span class="line"><span class="comment">---------- -------</span></span><br><span class="line">1000000001 2</span><br><span class="line">1000000002 0</span><br><span class="line">1000000003 1</span><br><span class="line">1000000004 1</span><br><span class="line">1000000005 1</span><br></pre></td></tr></table></figure>

<p>由于 <code>COUNT(column)</code> 计数会忽略 <code>NULL</code> 值，因此顾客 <em>1000000002</em> 的统计结果为 0。</p>
<p>注意，左、右外连接之间的唯一差别是所关联的表的顺序。换句话说，调整 <code>FROM</code> 或 <code>WHERE</code> 子句中表的顺序，左外连接可以转换为右外连接。因此，这两种外连接可以互换使用，哪个方便就用哪个。</p>
<h1 id="连接算法"><a href="#连接算法" class="headerlink" title="连接算法"></a>连接算法</h1><p>MySQL 使用下面两种算法执行表连接：</p>
<ul>
<li>嵌套循环连接算法（Nested-Loop Join（NLJ）），在被驱动表 <code>join</code> 字段有索引时使用。</li>
<li>基于块的嵌套循环连接算法（Block Nested-Loop Join（BNL）），在被驱动表 <code>join</code> 字段无索引时使用，以减少被驱动表的全表扫描次数。</li>
</ul>
<h2 id="NLJ"><a href="#NLJ" class="headerlink" title="NLJ"></a>NLJ</h2><p>Nested-Loop Join (NLJ) :</p>
<blockquote>
<p>A simple nested-loop join (NLJ) algorithm reads rows from the first table in a loop one at a time, passing each row to a nested loop that processes the next table in the join. This process is repeated as many times as there remain tables to be joined.</p>
</blockquote>
<p>例如，使用以下 <code>join type</code> 执行 <code>t1</code>、<code>t2</code> 和  <code>t3</code> 三个表之间的表连接：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table   Join Type</span><br><span class="line">t1      range</span><br><span class="line">t2      ref</span><br><span class="line">t3      ALL</span><br></pre></td></tr></table></figure>

<p>使用 NLJ 算法，则按以下方式处理连接：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each row <span class="keyword">in</span> t1 matching range &#123;</span><br><span class="line">  <span class="keyword">for</span> each row <span class="keyword">in</span> t2 matching reference key &#123;</span><br><span class="line">    <span class="keyword">for</span> each row <span class="keyword">in</span> t3 &#123;</span><br><span class="line">      <span class="keyword">if</span> row satisfies join conditions, send to client</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BNL"><a href="#BNL" class="headerlink" title="BNL"></a>BNL</h2><p>BNL 算法将外层循环的检索行缓存到 <code>join_buffer</code>（无序数组）中，以减少内层循环的全表扫描次数。例如，如果外层循环先将 10 行数据读入缓冲区，并将其传递给下一个内层循环，内层循环只需全表扫描一次，即可将读取到的每一行与缓冲区中的所有 10 行在内存中进行比较。这将使得内层循环表的全表扫描次数减少一个数量级。</p>
<p>MySQL <code>join buffer</code> 具有以下特征：</p>
<ul>
<li>当 <code>join type</code> 为 <code>ALL</code>、<code>index</code>、<code>range</code> 使用 <code>join buffer</code>。</li>
<li><code>join buffer</code> 同样适用于外连接，详见：<a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html" target="_blank" rel="noopener">Section 8.2.1.11, “Block Nested-Loop and Batched Key Access Joins”</a></li>
<li>系统变量 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_join_buffer_size" target="_blank" rel="noopener"><code>join_buffer_size</code></a> 用于配置每次查询每个 BNL 连接的缓冲区大小，因此一个查询可能用到多个 <code>join buffer</code>。</li>
<li>在执行连接之前分配 <code>join buffer</code>，并在查询完成后释放。</li>
</ul>
<p>使用 BNL 算法，伪代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each row <span class="keyword">in</span> t1 matching range &#123;</span><br><span class="line">  <span class="keyword">for</span> each row <span class="keyword">in</span> t2 matching reference key &#123;</span><br><span class="line">    store used columns <span class="keyword">from</span> t1, t2 <span class="keyword">in</span> join buffer</span><br><span class="line">    <span class="keyword">if</span> buffer is full &#123;</span><br><span class="line">      <span class="keyword">for</span> each row <span class="keyword">in</span> t3 &#123;</span><br><span class="line">        <span class="keyword">for</span> each t1, t2 combination <span class="keyword">in</span> join buffer &#123;</span><br><span class="line">          <span class="keyword">if</span> row satisfies join conditions, send to client</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      empty join buffer</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> buffer is not empty &#123;</span><br><span class="line">  <span class="keyword">for</span> each row <span class="keyword">in</span> t3 &#123;</span><br><span class="line">    <span class="keyword">for</span> each t1, t2 combination <span class="keyword">in</span> join buffer &#123;</span><br><span class="line">      <span class="keyword">if</span> row satisfies join conditions, send to client</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设 <code>S</code> 为每行 <code>used columns from t1, t2</code> 的大小， <code>C</code> 为其行数，则 <code>t3</code> 全表扫描的次数为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t3_scanned_count &#x3D; </span><br><span class="line">  (S * C) % join_buffer_size &#x3D;&#x3D; 0 ? </span><br><span class="line">    (S * C) &#x2F; join_buffer_size : </span><br><span class="line">    (S * C) &#x2F; join_buffer_size + 1</span><br></pre></td></tr></table></figure>

<p>因此，随着 <code>join_buffer_size</code> 增加，<code>t3</code> 全表扫描的次数反比减少，直到 <code>join_buffer_size=(S * C)</code> 时则无法再优化。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/join.html" target="_blank" rel="noopener">JOIN Syntax</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/select-optimization.html" target="_blank" rel="noopener">Optimizing SELECT Statements</a></p>
<ul>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html" target="_blank" rel="noopener">Nested-Loop Join Algorithms</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/nested-join-optimization.html" target="_blank" rel="noopener">Nested Join Optimization</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/outer-join-optimization.html" target="_blank" rel="noopener">Outer Join Optimization</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/outer-join-simplification.html" target="_blank" rel="noopener">Outer Join Simplification</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html" target="_blank" rel="noopener">Multi-Range Read Optimization</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html" target="_blank" rel="noopener">Block Nested-Loop and Batched Key Access Joins</a></p>
</li>
</ul>
</div></article></div><div class="right-container"><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/DNS/" style="font-size: 12.5px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GNU-Linux/" style="font-size: 16.67px;">GNU/Linux</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 19.17px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 11.67px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10.83px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15.83px;">Spring</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 18.33px;">前端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">响应式编程</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 12.5px;">安全</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">并发编程</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 13.33px;">建站</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 12.5px;">管理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.17px;">读书笔记</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 12.5px;">金融</a></div></div><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2019/11/26/mysql-deferred-join/" class="prev">PREV</a><a href="/2019/10/25/mysql-order-by/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2021 <a href="https://github.com/qidawu" target="_blank">Qida's Blog</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>