<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> MySQL 加锁读（Locking Reads）机制总结 · Qida's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="MySQL 加锁读（Locking Reads）机制总结 - Qida's Blog"><meta name="keywords"><meta name="author" content="Qida's Blog"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://qidawu.github.io/atom.xml" title="Qida's Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><a href="/" class="title-link">Qida's Blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">MySQL 加锁读（Locking Reads）机制总结</h1><div class="post-info">2019-02-20<a href="/tags/MySQL/" title="MySQL" class="post-demo">MySQL</a></div><div class="post-content"><p>MySQL 支持两种读机制：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener">一致性非加锁读（Consistent Non-locking Reads）</a>，是 InnoDB 在 <code>RR</code> 隔离级别下处理 SELECT 查询语句的默认模式，用于实现多版本并发控制（MVCC）以解决不可重复读问题。由于无锁，并发性能高。</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="noopener">加锁读（Locking Reads）</a>，是 InnoDB 在 <code>SERIALIZABLE</code>  隔离级别下处理 SELECT 查询语句的默认模式，查询默认加共享锁读（S-Locking reads）。由于有锁，并发性能低（因为获取写锁需阻塞等待读锁释放）。</li>
</ul>
<h1 id="加锁读机制"><a href="#加锁读机制" class="headerlink" title="加锁读机制"></a>加锁读机制</h1><p><code>InnoDB</code> 支持两种类型的 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking_read" target="_blank" rel="noopener">加锁读（Locking Reads）</a>，为事务操作提供额外的<strong>安全性</strong>：</p>
<ul>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_shared_lock" target="_blank" rel="noopener">共享锁（Shared Lock, S-Lock）</a>，也叫读锁（Read Lock）<ul>
<li>语法：<code>SELECT ... LOCK IN SHARE MODE</code> or <code>SELECT ... FOR SHARE</code> in MySQL 8.0.1，在检索行上设置共享锁（s-lock）</li>
<li>其它事务允许读取检索行，但不允许更新或删除，更新或删除会一直阻塞等待，直到该事务结束。</li>
</ul>
</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_exclusive_lock" target="_blank" rel="noopener">排它锁（Exclusive Lock, X-Lock）</a>，也叫写锁（Write Lock）<ul>
<li>语法：<code>SELECT ... FOR UPDATE</code> 在检索行上设置排它锁（x-lock）</li>
<li>其它事务不允许更新或删除</li>
<li>不允许加共享锁读取 <code>SELECT ... LOCK IN SHARE MODE</code></li>
<li>如果事务隔离级别为 <code>SERIALIZABLE</code>，不允许读取（因为该级别的读取默认需要获得共享读锁）</li>
<li>上述操作将一直阻塞等待，直到该事务结束。</li>
</ul>
</li>
</ul>
<p>共享锁和排它锁之间存在冲突的四种情况总结如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>T1 持有共享锁（S-Lock）</th>
<th>T1 持有排它锁（X-Lock）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>T2 获取共享锁（S-Lock）</strong></td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td><strong>T2 获取排它锁（X-Lock）</strong></td>
<td>冲突</td>
<td>冲突</td>
</tr>
</tbody></table>
<p>下面进一步分析共享锁和排它锁：</p>
<h2 id="共享锁（读锁）"><a href="#共享锁（读锁）" class="headerlink" title="共享锁（读锁）"></a>共享锁（读锁）</h2><p>共享锁是共享性的，或者说是相互不阻塞的。持有该锁的多个事务允许同时读取同一个资源，而互不干扰。</p>
<p>举个例子，如果事务 <code>T1</code> 持有对行 <code>r</code> 的共享锁，那么来自另一个事务 <code>T2</code> 的锁请求，将按如下两种方式处理：</p>
<ul>
<li><code>T2</code> 的共享锁请求能够立即授予。其结果是，<code>T1</code> 和 <code>T2</code> 都持有对行 <code>r</code> 的共享锁。</li>
<li><code>T2</code> 的排它锁请求不被授予。</li>
</ul>
<h2 id="排它锁（写锁）"><a href="#排它锁（写锁）" class="headerlink" title="排它锁（写锁）"></a>排它锁（写锁）</h2><p>排它锁是排它性的，也就是说一个排它锁会阻塞其它的共享锁和排它锁，这是出于安全策略的考虑，只有这样，才能确保在给定的时间里，有且只有一个持有该锁的事务执行更新或删除操作，并防止其它事务读取正在操作的同一资源。</p>
<p>举个例子，如果事务 <code>T1</code> 持有对行 <code>r</code> 的排它锁，那么来自另一个事务 <code>T2</code> 的<strong>任一锁请求都不被授予</strong>。相反，事务 <code>T2</code> 必须等待事务 <code>T1</code> 直到其释放对行 <code>r</code> 的锁定。</p>
<h1 id="锁定方式"><a href="#锁定方式" class="headerlink" title="锁定方式"></a>锁定方式</h1><p>大多数时候，MySQL 锁的内部管理都是透明的，其表现如下：</p>
<ul>
<li><code>SELECT</code> 在 <code>InnoDB</code> 的读已提交（READ COMMITTED）、可重复读（REPEATABLE READ）这两种事务隔离级别下，默认采用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener">一致性非加锁读取</a>，因此<strong>无需加锁即可读取所需数据</strong>。</li>
<li>如果需要使用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="noopener">加锁读</a>提升数据安全性，实现悲观并发控制，可采用共享锁（<code>LOCK IN SHARE MODE</code>）或排它锁（<code>FOR UDPATE</code>）进行显式锁定。</li>
<li><code>UPDATE</code>、<code>DELETE</code> 默认采用排它锁，隐式锁定。</li>
</ul>
<p>总结如下：</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>锁的类型</th>
<th>锁定方式</th>
</tr>
</thead>
<tbody><tr>
<td><code>SELECT ... FROM</code></td>
<td>如果事务隔离为 SERIALIZABLE，使用共享锁。否则无锁。</td>
<td>隐式锁定</td>
</tr>
<tr>
<td><code>SELECT ... LOCK IN SHARE MODE</code></td>
<td>共享锁（shared next-key lock）</td>
<td>显式锁定</td>
</tr>
<tr>
<td><code>SELECT ... FOR UDPATE</code></td>
<td>排它锁（exclusive next-key lock）</td>
<td>显式锁定</td>
</tr>
<tr>
<td><code>UPDATE ... WHERE ...</code></td>
<td>排它锁（exclusive next-key lock）</td>
<td>隐式锁定</td>
</tr>
<tr>
<td><code>DELETE FROM ... WHERE ...</code></td>
<td>排它锁（exclusive next-key lock）</td>
<td>隐式锁定</td>
</tr>
<tr>
<td><code>INSERT</code></td>
<td>排它锁（exclusive index-record lock）</td>
<td>隐式锁定</td>
</tr>
</tbody></table>
<h2 id="隐式锁定"><a href="#隐式锁定" class="headerlink" title="隐式锁定"></a>隐式锁定</h2><p><code>InnoDB</code> 采用的是两阶段锁定协议（Two-phase locking protocol）。在事务执行过程中，随时都可以执行锁定，锁只有在执行 <code>COMMIT</code> 或者 <code>ROLLBACK</code> 的时候才会释放，并且所有的锁是在同一时刻被释放。<code>InnoDB</code> 会根据隔离级别在需要的时候自动加锁，例如下列操作：</p>
<ul>
<li><code>UPDATE</code>、<code>DELETE</code> </li>
</ul>
<h2 id="显式锁定"><a href="#显式锁定" class="headerlink" title="显式锁定"></a>显式锁定</h2><p><code>InnoDB</code> 也支持通过特定语句进行显式锁定，这些语句不属于 SQL 规范：</p>
<ul>
<li><code>SELECT ... LOCK IN SHARE MODE</code>（共享锁）</li>
<li><code>SELECT ... FOR UDPATE</code>（排它锁）</li>
</ul>
<p>MySQL 也支持 <code>LOCK TABLES</code> 和 <code>UNLOCK TABLE</code> 语句，这是在服务器层实现的，和存储引擎无关。它们有自己的用途，但并不能替代事务。如果应用需要用到事务，还是应该选择事务型存储引擎。</p>
<p>经常可以发现，应用已经将表从 <code>MyISAM</code> 转换到 <code>InnoDB</code>，但还是显示地使用 <code>LOCK TABLE</code> 语句。这不但没有必要，还会严重影响性能，实际上 <code>InnoDB</code> 的行级锁工作得更好。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>这里举个例子，有一张 parent 和 child 表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- parnet 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`parent`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- child 表，其中 parent_id 字段外键关联 parent 表的 id 主键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`child`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`parent_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`fk_parent_id`</span> (<span class="string">`parent_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`fk_parent_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`parent_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`parent`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<p>如果在同一事务中先查询、后插入或更新相关数据，常规的 <code>SELECT</code> 语句无法得到足够保护。因为在此期间其它事务可能对同一资源进行更新或删除。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--开启事务 T1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">--为变量@id赋值</span></span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">id</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">id</span>:=<span class="keyword">id</span> <span class="keyword">FROM</span> <span class="keyword">parent</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Heikki'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--在此期间，某个事务 T2 成功删除了同一资源</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">parent</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Heikki'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--事务 T1 插入失败：外键关联错误</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">child</span>(parend_id, <span class="keyword">name</span>) <span class="keyword">VALUES</span>(@<span class="keyword">id</span>, <span class="string">'Baby'</span>);</span><br><span class="line">1452 - Cannot add or <span class="keyword">update</span> a <span class="keyword">child</span> <span class="keyword">row</span>: a <span class="keyword">foreign</span> <span class="keyword">key</span> <span class="keyword">constraint</span> fails (<span class="string">`test`</span>.<span class="string">`child`</span>, <span class="keyword">CONSTRAINT</span> <span class="string">`fk_parent_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`parent_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`parent`</span> (<span class="string">`id`</span>))</span><br></pre></td></tr></table></figure>

<p>下面分别看下如何用共享锁和排它锁解决这个问题：</p>
<h2 id="LOCK-IN-SHARE-MODE"><a href="#LOCK-IN-SHARE-MODE" class="headerlink" title="LOCK IN SHARE MODE"></a>LOCK IN SHARE MODE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--开启事务 T1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> parent_id = <span class="number">2</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | parent_id | name  |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 |         2 | Baby  |</span><br><span class="line">|  2 |         2 | Baby5 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--在此期间，某个事务 T2 能够成功删除同一资源</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line"></span><br><span class="line"><span class="comment">--事务 T1 如果继续使用一致性非加锁读，将会得到第一次读取时的快照，因为 InnoDB 当前隔离级别为 RR</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> parent_id = <span class="number">2</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | parent_id | name  |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 |         2 | Baby  |</span><br><span class="line">|  2 |         2 | Baby5 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--事务 T1 如果使用加锁读，将会得到最新快照。同时事务 T1 获取该行的共享锁，其它任何事务都只能读、不能写该行，直到事务 T1 结束，释放共享锁</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> parent_id = <span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | parent_id | name  |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  2 |         2 | Baby5 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--在此期间，事务 T3 可以删除未被锁定的行</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line"></span><br><span class="line"><span class="comment">--在此期间，事务 T3 无法删除带锁的行。因为它无法获取该行的排它锁，因此会阻塞直到事务 T1 解锁该行。如果等待超时，则事务回滚</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span></span><br><span class="line"><span class="number">1205</span> - <span class="keyword">Lock</span> <span class="keyword">wait</span> <span class="keyword">timeout</span> exceeded; try restarting transaction</span><br><span class="line"></span><br><span class="line"><span class="comment">--事务 T1 提交，释放共享锁</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--事务 T3 如果没有超时，则操作成功</span></span><br><span class="line">Query OK, 1 row affected</span><br></pre></td></tr></table></figure>

<h2 id="FOR-UPDATE"><a href="#FOR-UPDATE" class="headerlink" title="FOR UPDATE"></a>FOR UPDATE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--开启事务 T1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">--事务 T1 获取该行的排它锁</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> parent_id = <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--在此期间，事务 T2 可以非加锁读，因为无需先获取该行的锁</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> parent_id = <span class="number">2</span>;</span><br><span class="line"><span class="comment">--也可以加共享锁读非锁定行</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> parent_id = <span class="number">3</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="comment">--但无法加共享锁读锁定行</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> parent_id = <span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="comment">--也无法获取排它锁进行修改</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'Hello'</span> <span class="keyword">where</span> parent_id = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>————分割线————</p>
<p>可见，通过共享锁和排它锁都能解决这个问题。下例演示通过 <code>SELECT ... LOCK IN SHARE MODE</code> 设置共享锁解决开头那个问题：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--开启事务 T1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">--为变量@id赋值</span></span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">id</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">id</span>:=<span class="keyword">id</span> <span class="keyword">FROM</span> <span class="keyword">parent</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = <span class="string">'Heikki'</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--在此期间，某个事务 T2 无法删除同一资源。因为 T2 会一直等待，直到 T1 事务完成，所有数据都处于一致状态，并释放共享锁之后，T2 才能获取排它锁，并对数据进行修改</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">parent</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Heikki'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--事务 T1 插入成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">child</span>(parend_id, <span class="keyword">name</span>) <span class="keyword">VALUES</span>(@<span class="keyword">id</span>, <span class="string">'Baby'</span>);</span><br><span class="line"><span class="comment">--提交事务 T1，写库</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>T1</code> 成功提交事务并释放共享锁之后，<code>T2</code> 获得排它锁。但由于 <code>T1</code> 在 <code>child</code> 表中写入了一条对 <code>parent</code> 表的外键关联记录，所以 <code>T2</code> 删除失败：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1451 - Cannot <span class="keyword">delete</span> <span class="keyword">or</span> <span class="keyword">update</span> a <span class="keyword">parent</span> <span class="keyword">row</span>: a <span class="keyword">foreign</span> <span class="keyword">key</span> <span class="keyword">constraint</span> fails (<span class="string">`test`</span>.<span class="string">`child`</span>, <span class="keyword">CONSTRAINT</span> <span class="string">`fk_parent_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`parent_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`parent`</span> (<span class="string">`id`</span>))</span><br></pre></td></tr></table></figure>

<p>最后，提几个注意点：</p>
<ul>
<li>只有在通过以下方式之一禁用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html" target="_blank" rel="noopener">自动提交（autocommit）</a>时，才能加锁读：<ul>
<li>通过 <a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener"><code>START TRANSACTION</code></a> 语句，显式开启事务；</li>
<li>通过设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_autocommit" target="_blank" rel="noopener"><code>autocommit</code></a>为 <code>0</code>，显式关闭自动提交。</li>
</ul>
</li>
<li>加锁读有可能产生<strong>死锁</strong>，具体取决于事务的隔离级别。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高性能 MySQL》</p>
<p><a href="https://en.wikipedia.org/wiki/Two-phase_locking" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Two-phase_locking</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html</a></p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html</a></p>
<p><a href="https://blog.csdn.net/claram/article/details/54023216" target="_blank" rel="noopener">https://blog.csdn.net/claram/article/details/54023216</a></p>
</div></article></div><div class="right-container"><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/DNS/" style="font-size: 12.5px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GNU-Linux/" style="font-size: 16.67px;">GNU/Linux</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 19.17px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 11.67px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10.83px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15.83px;">Spring</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 18.33px;">前端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">响应式编程</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 12.5px;">安全</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">并发编程</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 13.33px;">建站</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 12.5px;">管理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.17px;">读书笔记</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 12.5px;">金融</a></div></div><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2019/02/22/mysql-locking-and-index/" class="prev">PREV</a><a href="/2019/02/18/concurrency-control/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2021 <a href="https://github.com/qidawu" target="_blank">Qida's Blog</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>