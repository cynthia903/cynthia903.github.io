<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C/C++ 语言系列（十一）I/O 库总结</title>
      <link href="2021/02/26/cpp-io-library/"/>
      <url>2021/02/26/cpp-io-library/</url>
      
        <content type="html"><![CDATA[<h1 id="Input-Output-library"><a href="#Input-Output-library" class="headerlink" title="Input/Output library"></a>Input/Output library</h1><p>下图是 C++ 提供的输入/输出库，其中：</p><ul><li><code>&lt;xxx&gt;</code> 表示：头文件</li><li>白框表示：类（Classes）</li><li>黑框表示：对象（Objects）</li></ul><p><img src="/img/cpp/iostream.gif" alt="Input/Output library"></p><blockquote><p>The iostream library is an object-oriented library that provides input and output functionality using streams.</p></blockquote><blockquote><p>A stream is an abstraction that represents a device on which input and ouput operations are performed. A stream can basically be represented as a source or destination of characters of indefinite length.</p></blockquote><blockquote><p>Streams are generally associated to a physical source or destination of characters, like a disk file, the keyboard, or the console, so the characters gotten or written to/from our abstraction called stream are physically input/output to the physical device. For example, file streams are C++ objects to manipulate and interact with files; Once a file stream is used to open a file, any input or output operation performed on that stream is physically reflected in the file.</p></blockquote><p>To operate with streams, C++ provides the standard <code>iostream</code> library, which contains the following elements:</p><p>Basic class templates</p><blockquote><p>The base of the iostream library is the hierarchy of class templates. The class templates provide most of the functionality of the library in a type-independent fashion.</p></blockquote><p>Class template instantiations</p><blockquote><p>The library incorporates two standard sets of instantiations of the entire iostream class template hierarchy: </p><ul><li><p>The narrow-oriented (<code>char</code> type) instantiation is probably the better known part of the iostream library. Classes like <code>ios</code>, <code>istream</code> and <code>ofstream</code> are narrow-oriented. The diagram on top of this page shows the names and relationships of narrow-oriented classes.</p></li><li><p>The classes of the wide-oriented (<code>wchar_t</code>) instatiation follow the same naming conventions as the narrow-oriented instantiation but with the name of each class and object prefixed with a <code>w</code> character, forming <code>wios</code>, <code>wistream</code> and <code>wofstream</code>, as an example.</p></li></ul></blockquote><p>Standard objects</p><blockquote><p>As part of the iostream library, the header file <code>&lt;iostream&gt;</code> declares certain objects that are used to perform input and output operations on the standard input and output.</p><p>They are divided in two sets: </p><ul><li>narrow-oriented objects: <code>cin</code>, <code>cout</code>, <code>cerr</code> and <code>clog</code> </li><li>wide-oriented objects: <code>wcin</code>, <code>wcout</code>, <code>wcerr</code> and <code>wclog</code></li></ul></blockquote><p>Manipulators</p><blockquote><p>Manipulators are global functions designed to be used together with insertion (<code>&lt;&lt;</code>) and extraction (<code>&gt;&gt;</code>) operators performed on <code>iostream</code> stream objects. They generally modify properties and formatting settings of the streams.</p></blockquote><p>下表摘录了 iostream 库中常见的元素：</p><p><img src="/img/cpp/elements_of_the_iostream_library.png" alt="Elements of the iostream library"></p><p>其中，下列这些头文件在 C++ 编程中很重要。</p><table><thead><tr><th align="left">头文件</th><th align="left">函数和描述</th></tr></thead><tbody><tr><td align="left"><code>&lt;iostream&gt;</code></td><td align="left">该文件定义了 <code>cin</code>、<code>cout</code>、<code>cerr</code> 和 <code>clog</code> 对象，用于输入输出。</td></tr><tr><td align="left"><code>&lt;iomanip&gt;</code></td><td align="left">该文件通过所谓的参数化的流操纵器（比如 <code>setw</code>、<code>setfill</code>、<code>setprecision</code>），来声明对执行标准化 I/O 有用的服务。</td></tr><tr><td align="left"><code>&lt;fstream&gt;</code></td><td align="left">该文件定义了 <code>ifstream</code>、<code>ofstream</code>、<code>fstream</code> 对象，用于文件读写。</td></tr></tbody></table><h2 id="lt-iostream-gt"><a href="#lt-iostream-gt" class="headerlink" title="&lt;iostream&gt;"></a>&lt;iostream&gt;</h2><p>下图摘录了 <code>iostream</code> 类的继承关系及成员函数，如下：</p><p><img src="/img/cpp/iostream_class.png" alt="iostream classes"></p><p><a href="http://www.cplusplus.com/doc/tutorial/basic_io/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/basic_io/</a></p><p><a href="http://www.cplusplus.com/reference/iolibrary/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/iolibrary/</a></p><h3 id="output-stream"><a href="#output-stream" class="headerlink" title="output stream"></a>output stream</h3><p>输出流与流插入运算符 <code>&lt;&lt;</code> 配合使用。<code>&lt;iostream&gt;</code> 提供了下列三种输出流对象：</p><ul><li><code>cout</code> 标准输出流（默认设备是显示器屏幕）</li><li><code>cerr</code> 无缓冲标准错误输出流（默认设备是显示器屏幕）</li><li><code>clog</code> 有缓冲标准错误输出流（默认设备是打印机）</li></ul><p>此外，<code>&lt;iostream&gt;</code> 还提供了一个常用的操纵符：</p><ul><li><code>endl</code> Insert newline and flush</li></ul><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一些头文件，这些头文件包含了程序中必需的或有用的信息。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。使用该命名空间之后，std::cout 可以简写为：cout</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，程序从这里开始执行。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 在屏幕上输出 "Hello World"</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 终止 main() 函数，并向调用进程返回值 0。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 g++ 编译器，编译 cpp 源文件为可执行文件，并执行之</span></span><br><span class="line"><span class="comment">// cd "/Users/wuqd/Documents/workspace/cpp/" &amp;&amp; g++ HelloWorld.cpp -o HelloWorld &amp;&amp; "/Users/wuqd/Documents/workspace/cpp/"HelloWorld</span></span><br></pre></td></tr></table></figure><p>运行结果：<code>hello world</code></p><h3 id="input-stream"><a href="#input-stream" class="headerlink" title="input stream"></a>input stream</h3><p>输入流与流提取运算符 <code>&gt;&gt;</code> 配合使用。<code>&lt;iostream&gt;</code> 提供了下列一种输入流对象：</p><ul><li><code>cin</code> 标准输入流（默认设备是键盘）</li></ul><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; age;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流提取运算符 &gt;&gt; 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句:</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name &gt;&gt; age;</span><br></pre></td></tr></table></figure><h2 id="lt-iomanip-gt-流操纵器"><a href="#lt-iomanip-gt-流操纵器" class="headerlink" title="&lt;iomanip&gt; 流操纵器"></a>&lt;iomanip&gt; 流操纵器</h2><p>常用流操纵器函数如下：</p><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><a href="http://www.cplusplus.com/reference/iomanip/setw/" target="_blank" rel="noopener"><code>setw</code></a></td><td>Set field width</td></tr><tr><td><a href="http://www.cplusplus.com/reference/iomanip/setfill/" target="_blank" rel="noopener"><code>setfill</code></a></td><td>Set fill character</td></tr><tr><td><a href="http://www.cplusplus.com/reference/iomanip/setprecision/" target="_blank" rel="noopener"><code>setprecision</code></a></td><td>Set decimal precision</td></tr><tr><td>…</td><td></td></tr></tbody></table><p><code>setw</code> 函数用于设置字段的宽度，只对紧接着的输出产生作用。当后面紧跟着的输出字段长度小于 <code>n</code> 的时候，在该字段前面默认用<strong>空格补齐</strong>，当输出字段长度大于 <code>n</code> 时，全部整体输出。如下：</p><p><img src="/img/cpp/cpp-setw.svg" alt="setw"></p><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 测试 I/O</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">double</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 默认右补位，可以使用 setf() 进行左补位</span></span><br><span class="line">  <span class="built_in">cout</span>.setf(ios::left);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setprecision() 包含小数点</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; setfill(<span class="string">'*'</span>) &lt;&lt; setw(<span class="number">5</span>) &lt;&lt; setprecision(<span class="number">3</span>) &lt;&lt; pi &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<code>3.14*</code></p><p>参考：</p><p><a href="https://www.runoob.com/w3cnote/cpp-func-setw.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/cpp-func-setw.html</a></p><h2 id="lt-fstream-gt-文件读写"><a href="#lt-fstream-gt-文件读写" class="headerlink" title="&lt;fstream&gt; 文件读写"></a>&lt;fstream&gt; 文件读写</h2><p><code>&lt;fstream&gt;</code> 定义了下面三个对象，用于文件读写：</p><table><thead><tr><th align="left">数据类型</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>ofstream</code></td><td align="left">该数据类型表示输出文件流，用于创建文件并向文件写入信息。</td></tr><tr><td align="left"><code>ifstream</code></td><td align="left">该数据类型表示输入文件流，用于从文件读取信息。</td></tr><tr><td align="left"><code>fstream</code></td><td align="left">该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。</td></tr></tbody></table><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ofstream myfile;</span><br><span class="line">  <span class="comment">// 打开文件</span></span><br><span class="line">  myfile.<span class="built_in">open</span>(<span class="string">"/Users/wuqd/Desktop/test"</span>, ios::app);  <span class="comment">// ios::app 表示追加模式。所有写入都追加到文件末尾。</span></span><br><span class="line">  <span class="comment">// 写入文件</span></span><br><span class="line">  myfile &lt;&lt; <span class="string">"helloworld"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  myfile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ifstream in;</span><br><span class="line">  <span class="comment">// 打开文件</span></span><br><span class="line">  in.<span class="built_in">open</span>(<span class="string">"/Users/wuqd/Desktop/test"</span>);</span><br><span class="line">  <span class="keyword">char</span> data[<span class="number">100</span>];</span><br><span class="line">  <span class="comment">// 读取文件</span></span><br><span class="line">  <span class="keyword">while</span> (in &gt;&gt; data) &#123;</span><br><span class="line">    <span class="comment">// 输出到屏幕</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 关闭文件</span></span><br><span class="line">  in.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  output();</span><br><span class="line">  input();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.cplusplus.com/doc/oldtutorial/files/" target="_blank" rel="noopener">https://www.cplusplus.com/doc/oldtutorial/files/</a></p><p><a href="https://www.runoob.com/cplusplus/cpp-files-streams.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-files-streams.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 语言系列（十）面向对象编程之继承与多态</title>
      <link href="2021/02/25/cpp-oop-inheritance-and-polymorphism/"/>
      <url>2021/02/25/cpp-oop-inheritance-and-polymorphism/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>C++ 继承的语法如下，支持单继承和多继承：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Single inheritance 单继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived_class</span>:</span> access_specifier base_class</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple inheritance 多重继承，各个基类之间用逗号分隔</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived_class</span>:</span> access_specifier base_class_1, access_specifier base_class_2, ...</span><br></pre></td></tr></table></figure><h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><p>继承类型通过访问修饰符 access_specifier 来指定：</p><table><thead><tr><th>继承类型</th><th>基类的 <code>public</code> 成员</th><th>基类的 <code>protected</code> 成员</th><th>基类的 <code>private</code> 成员</th></tr></thead><tbody><tr><td>公有继承（<code>public</code>）</td><td>派生类的 <code>public</code> 成员</td><td>派生类的 <code>protected</code> 成员</td><td>无法继承</td></tr><tr><td>保护继承（<code>protected</code>）</td><td>派生类的 <code>protected</code> 成员</td><td>派生类的 <code>protected</code> 成员</td><td>无法继承</td></tr><tr><td>私有继承（<code>private</code>）</td><td>派生类的 <code>private</code> 成员</td><td>派生类的 <code>private</code> 成员</td><td>无法继承</td></tr></tbody></table><p>通常使用 <code>public</code> 继承，几乎不使用 <code>protected</code> 或 <code>private</code> 继承。</p><blockquote><p>In principle, a publicly derived class inherits access to every member of a base class <strong>except</strong>:</p><ul><li>its constructors and its destructor</li><li>its assignment operator members (operator=)</li><li>its friends</li><li>its private members</li></ul></blockquote><h2 id="继承的访问控制属性"><a href="#继承的访问控制属性" class="headerlink" title="继承的访问控制属性"></a>继承的访问控制属性</h2><table><thead><tr><th align="left">Access</th><th align="left"><code>public</code></th><th align="left"><code>protected</code></th><th align="left"><code>private</code></th></tr></thead><tbody><tr><td align="left">members of the same class</td><td align="left">yes</td><td align="left">yes</td><td align="left">yes</td></tr><tr><td align="left">members of derived class</td><td align="left">yes</td><td align="left">yes</td><td align="left">no</td></tr><tr><td align="left">not members</td><td align="left">yes</td><td align="left">no</td><td align="left">no</td></tr></tbody></table><h2 id="构造、析构函数执行顺序"><a href="#构造、析构函数执行顺序" class="headerlink" title="构造、析构函数执行顺序"></a>构造、析构函数执行顺序</h2><blockquote><p>Even though access to the constructors and destructor of the base class is not inherited, they are automatically called by the constructors and destructor of the derived class.</p><p>Unless otherwise specified, the constructors of a derived class calls the default constructor of its base classes (i.e., the constructor taking no arguments).</p></blockquote><p>继承后，执行顺序如下：</p><ul><li>构造函数：先父后子</li><li>析构函数：先子后父</li></ul><h2 id="子类调用父类方法"><a href="#子类调用父类方法" class="headerlink" title="子类调用父类方法"></a>子类调用父类方法</h2><p><code>BaseClass::Function()</code></p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><blockquote><p>One of the key features of class inheritance is that a pointer to a derived class is type-compatible with a pointer to its base class. <em>Polymorphism</em> is the art of taking advantage of this simple but powerful and versatile feature.</p></blockquote><p>类继承的关键特性之一，就是指向派生类的指针与指向其基类的指针在类型上兼容。 多态是利用这一简单但强大而通用的功能的艺术。</p><p>下面使用指针来演示多态这一特性。</p><p>UML 类图如下：</p><p><img src="/img/cpp/class_inheritance.png" alt="UML 类图"></p><p>类声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pointers to base class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Shape(<span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">width</span> = <span class="built_in">width</span>;</span><br><span class="line">      <span class="keyword">this</span>-&gt;<span class="built_in">height</span> = <span class="built_in">height</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Rectangle(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : Shape(x, y) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">width</span> * <span class="built_in">height</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> :</span> <span class="keyword">public</span> Shape &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Triangle(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : Shape(x, y) &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">width</span> * <span class="built_in">height</span> / <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用方式一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">Triangle <span class="title">trgl</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  Shape * p1 = &amp;<span class="built_in">rect</span>;</span><br><span class="line">  Shape * p2 = &amp;trgl;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"rectangle area is "</span> &lt;&lt; p1-&gt;area() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// rectangle area is 6</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"triangle area is "</span> &lt;&lt; p2-&gt;area() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// triangle area is 3</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式二，参考：<a href="http://www.cplusplus.com/doc/tutorial/dynamic/" target="_blank" rel="noopener">Dynamic memory</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  Shape * p1 = <span class="keyword">new</span> Rectangle(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  Shape * p2 = <span class="keyword">new</span> Triangle(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"rectangle area is "</span> &lt;&lt; p1-&gt;area() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// rectangle area is 6</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"triangle area is "</span> &lt;&lt; p2-&gt;area() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// triangle area is 3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> p3;</span><br><span class="line">  <span class="keyword">delete</span> p4;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>描述如下：</p><blockquote><p>Function <code>main</code> declares two pointers to <code>Shape</code> (named <code>p1</code> and <code>p2</code>). These are assigned the addresses of <code>rect</code> and <code>trgl</code>, respectively, which are objects of type <code>Rectangle</code> and <code>Triangle</code>. Such assignments are valid, since both <code>Rectangle</code> and <code>Triangle</code> are classes derived from <code>Shape</code>.</p><p>Dereferencing <code>p1</code> and <code>p2</code> (with <code>p1-&gt;</code> and <code>p2-&gt;</code>) is valid and allows us to access the members of their pointed objects. For example, the following two statements would be equivalent in the previous example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rect</span>.area();</span><br><span class="line">p1-&gt;area();</span><br></pre></td></tr></table></figure></blockquote><h2 id="虚函数（virtual）"><a href="#虚函数（virtual）" class="headerlink" title="虚函数（virtual）"></a>虚函数（virtual）</h2><p>虚函数是在基类中使用 <code>virtual</code> 关键字声明的函数，是可以在派生类中<strong>重定义</strong>的成员函数。虚函数用于实现<strong>运行时多态</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">| Base Class         |</span><br><span class="line">|   virtual function |</span><br><span class="line">+---------^----------+</span><br><span class="line">          |</span><br><span class="line">          |class inheritance</span><br><span class="line">          |</span><br><span class="line">+---------+----------+</span><br><span class="line">| Derived class      |</span><br><span class="line">|  redefined function|</span><br><span class="line">+--------------------+</span><br><span class="line"></span><br><span class="line">运行时多态的实现手段：虚函数 + 继承 + 函数重定义</span><br></pre></td></tr></table></figure><p>派生类也可以重定义基类的非虚函数，但无法通过基类的引用来访问派生类的该函数。即：如果移除上述基类中 <code>area</code> 函数声明的 <code>virtual</code> 关键字，下面的函数调用将返回 0，因为实际调用的是基类的版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"rectangle area is "</span> &lt;&lt; p1-&gt;area() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// rectangle area is 0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"triangle area is "</span> &lt;&lt; p2-&gt;area() &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// triangle area is 0</span></span><br></pre></td></tr></table></figure><blockquote><p>Therefore, essentially, what the <code>virtual</code> keyword does is to allow a member of a derived class with the same name as one in the base class to be appropriately called from a pointer, and more precisely when the type of the pointer is a pointer to the base class that is pointing to an object of the derived class, as in the above example.</p><p>A class that declares or inherits a virtual function is called a <em>polymorphic class</em>.</p></blockquote><p>注意，尽管成员之一是 <code>virtual</code> 的，但 <code>Sharp</code> 仍然是一个常规类，可以实例化对象。</p><h2 id="纯虚函数（抽象类）"><a href="#纯虚函数（抽象类）" class="headerlink" title="纯虚函数（抽象类）"></a>纯虚函数（抽象类）</h2><p>Classes that contain at least one <em>pure virtual function</em> are known as <em>abstract base classes</em>. The syntax of <em>pure virtual function</em> is to replace their definition by <code>=0</code> (an equal sign and a zero):</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abstract class CPolygon</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> &#123;</span></span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span> <span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Abstract base classes cannot be used to instantiate objects:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不允许使用抽象类类型 "Shape" 的对象: -- 函数 "Shape::area" 是纯虚函数</span></span><br><span class="line"><span class="comment">// variable type 'Shape' is an abstract class</span></span><br><span class="line">Shape shape;</span><br></pre></td></tr></table></figure><p>But an <em>abstract base class</em> is not totally useless. It can be used to create pointers to it, and take advantage of all its polymorphic abilities.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the following pointer declarations would be valid</span></span><br><span class="line">Shape * p1 = &amp;<span class="built_in">rect</span>;</span><br><span class="line">Shape * p2 = &amp;trgl;</span><br></pre></td></tr></table></figure><p>Virtual members and abstract classes grant C++ polymorphic characteristics, most useful for object-oriented projects.</p><p>C++ 接口是使用<strong>抽象类</strong>来实现的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cplusplus.com/doc/tutorial/inheritance/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/inheritance/</a></p><p><a href="http://www.cplusplus.com/doc/tutorial/polymorphism/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/polymorphism/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 语言系列（九）面向对象编程之类、类模板、类指针</title>
      <link href="2021/02/20/cpp-oop-class/"/>
      <url>2021/02/20/cpp-oop-class/</url>
      
        <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_name</span> &#123;</span></span><br><span class="line">  access_specifier_1:</span><br><span class="line">    member1;</span><br><span class="line">  access_specifier_2:</span><br><span class="line">    member2;</span><br><span class="line">  ...</span><br><span class="line">&#125; object_names;</span><br></pre></td></tr></table></figure><p><img src="/img/cpp/cpp-classes-objects.png" alt=""></p><h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><ul><li><code>private</code> members of a class are accessible only from within other members of the same class (or from their <code>friend</code>). By default, all members of a class have private access for all its members.</li><li><code>protected</code> members are accessible from other members of the same class (or from their <code>friend</code>), but also from members of their derived classes.</li><li>Finally, <code>public</code> members are accessible from anywhere where the object is visible.</li></ul><h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><p>在 C++ 中，每一个对象都能通过 <code>this</code> 指针来访问自己的地址。<code>this</code> 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p><p>友元函数没有 <code>this</code> 指针，因为友元不是类的成员。只有成员函数才有 <code>this</code> 指针。</p><h2 id="静态成员（static）"><a href="#静态成员（static）" class="headerlink" title="静态成员（static）"></a>静态成员（static）</h2><p><img src="/img/cpp/cpp-static-members.png" alt=""></p><p><code>static</code> 关键字用于修饰静态成员变量或函数。限制如下：</p><ul><li>无法访问类的非静态成员变量或函数；</li><li>无法使用 <code>this</code> 指针。</li></ul><p>静态成员的引用方式：<code>Runoob:runoob_age</code></p><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>有两种方式定义类的成员函数：</p><ul><li>内联成员函数（<em>inline</em> member function）</li><li>普通成员函数（not-inline member function）</li></ul><p>两种方式并不会导致行为上的差异，而只会导致可能的编译器优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// classes example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// declaration of a member function within the class</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_values</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="comment">// defining a member function completely within the class definition</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">width</span>*<span class="built_in">height</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// definition of a member function of a class outside the class itself.</span></span><br><span class="line"><span class="comment">// The scope operator (::) specifies the class to which the member being defined belongs, granting exactly the same scope properties as if this function definition was directly included within the class definition.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rectangle::set_values</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">width</span> = x;</span><br><span class="line">  <span class="built_in">height</span> = y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  Rectangle <span class="built_in">rect</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// public members of object can be accessed by dot operator (.)</span></span><br><span class="line">  <span class="built_in">rect</span>.set_values (<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"area: "</span> &lt;&lt; <span class="built_in">rect</span>.area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h3><p>To specify that a member is a <code>const</code> member, the <code>const</code> keyword shall follow the function prototype, after the closing parenthesis for its parameters:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;        <span class="comment">// const member function</span></span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>类的<strong>构造函数</strong>是类的一种特殊的成员函数，构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回<code>void</code>。它会在每次创建类的新对象时执行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用有参构造函数</span></span><br><span class="line"><span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;<span class="comment">// Object is being created, width=1, height=2</span></span><br><span class="line"><span class="comment">// 调用默认构造函数</span></span><br><span class="line">Rectangle rectb;      <span class="comment">// Object is being created</span></span><br></pre></td></tr></table></figure><h3 id="构造函数重载"><a href="#构造函数重载" class="headerlink" title="构造函数重载"></a>构造函数重载</h3><blockquote><p>Overloading constructors</p><p>Like any other function, a constructor can also be overloaded with different versions taking different parameters: with a different number of parameters and/or parameters of different types. The compiler will automatically call the one whose parameters match the arguments:</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明一个无参构造函数</span></span><br><span class="line">    Rectangle();</span><br><span class="line">    <span class="comment">// 声明一个有参构造函数</span></span><br><span class="line">    Rectangle(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个无参构造函数</span></span><br><span class="line">Rectangle::Rectangle() &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个有参构造函数</span></span><br><span class="line">Rectangle::Rectangle(<span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;<span class="built_in">width</span> = <span class="built_in">width</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;<span class="built_in">height</span> = <span class="built_in">height</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created, width="</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">width</span> &lt;&lt; <span class="string">", height="</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">height</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>This example introduces a special kind constructor: the <em>default constructor</em>. The <em>default constructor</em> is the constructor that takes no parameters, and it is special because it is called when an object is declared but is not initialized with any arguments. In the example above, the <em>default constructor</em> is called for <code>rectb</code>. Note how <code>rectb</code> is not even constructed with an empty set of parentheses - in fact, empty parentheses cannot be used to call the default constructor:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rectangle rectb;   <span class="comment">// ok, default constructor called</span></span><br><span class="line"><span class="function">Rectangle <span class="title">rectc</span><span class="params">()</span></span>; <span class="comment">// oops, default constructor NOT called, empty parentheses interpreted as a function declaration</span></span><br></pre></td></tr></table></figure><p>This is because the empty set of parentheses would make of <code>rectc</code> a function declaration instead of an object declaration: It would be a function that takes no arguments and returns a value of type <code>Rectangle</code>.</p></blockquote><h3 id="在构造函数中初始化成员变量"><a href="#在构造函数中初始化成员变量" class="headerlink" title="在构造函数中初始化成员变量"></a>在构造函数中初始化成员变量</h3><p>使用构造函数初始化其他成员变量时，有下面两种方式：</p><blockquote><p>Member initialization in constructors</p><p>When a constructor is used to initialize other members, these other members can be initialized directly, without resorting to statements in its body. This is done by inserting, before the constructor’s body, a colon (<code>:</code>) and a list of initializations for class members. For example, consider a class with the following declaration:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"> <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Rectangle(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">width</span>*<span class="built_in">height</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>The constructor for this class could be defined, as usual, as:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rectangle::Rectangle(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="built_in">width</span>=x; <span class="built_in">height</span>=y; &#125;</span><br></pre></td></tr></table></figure><p>But it could also be defined using <em>member initialization</em> as:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rectangle::Rectangle(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : <span class="built_in">width</span>(x), <span class="built_in">height</span>(y) &#123; &#125;</span><br></pre></td></tr></table></figure><p>Or even:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rectangle::Rectangle(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : Shape(x, y) &#123; &#125;</span><br></pre></td></tr></table></figure><p>Note how in this last case, the constructor does nothing else than initialize its members, hence it has an empty function body.</p></blockquote><h2 id="析构函数（-）"><a href="#析构函数（-）" class="headerlink" title="析构函数（~）"></a>析构函数（~）</h2><p>类的<strong>析构函数</strong>是类的一种特殊的成员函数，它会在每次删除对象时执行，有助于在跳出程序前释放资源（比如关闭文件、释放内存等）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Rectangle();</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Rectangle();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Rectangle::Rectangle()&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Rectangle::~Rectangle()&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being deleted"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>析构函数要点：</p><ul><li>析构函数名称与类的名称完全相同，前缀使用关键字 <code>~</code>；</li><li>一个类中只能声明一个析构函数（destructor cannot be redeclared）；</li><li>析构函数无参数（destructor cannot have any parameters）；</li><li>析构函数无返回值（destructor cannot have a return type）；</li><li>不可重载。</li></ul><h2 id="友元函数（friend）"><a href="#友元函数（friend）" class="headerlink" title="友元函数（friend）"></a>友元函数（friend）</h2><p>类的友元函数（<code>friend</code> 关键字），有权访问类的所有私有（<code>private</code>）和保护（<code>protected</code>）成员变量。尽管友元函数在类中声明，但是<strong>友元函数并不是类的成员函数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">(Rectangle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Rectangle <span class="built_in">rect</span>)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">rect</span>.<span class="built_in">height</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">(Rectangle <span class="built_in">rect</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">rect</span>.<span class="built_in">width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Rectangle <span class="title">rect1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"width: "</span> &lt;&lt; getWidth(rect1) &lt;&lt; <span class="string">" height: "</span> &lt;&lt; getHeight(rect1) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// width: 1 height: 2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>友元函数破坏了类的封装性，实践中不建议使用。</p><h2 id="重载（overload）"><a href="#重载（overload）" class="headerlink" title="重载（overload）"></a>重载（overload）</h2><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>一、支持重载的运算符：</p><p>C++ allows most operators to be overloaded so that their behavior can be defined for just about any type, including classes. Here is a list of all the operators that can be overloaded:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+    -    *    &#x2F;    &#x3D;    &lt;    &gt;    +&#x3D;   -&#x3D;   *&#x3D;   &#x2F;&#x3D;   &lt;&lt;   &gt;&gt;</span><br><span class="line">&lt;&lt;&#x3D;  &gt;&gt;&#x3D;  &#x3D;&#x3D;   !&#x3D;   &lt;&#x3D;   &gt;&#x3D;   ++   --   %    &amp;    ^    !    |</span><br><span class="line">~    &amp;&#x3D;   ^&#x3D;   |&#x3D;   &amp;&amp;   ||   %&#x3D;   []   ()   ,    -&gt;*  -&gt;   new </span><br><span class="line">delete    new[]     delete[]</span><br></pre></td></tr></table></figure><p>Operators are overloaded by means of <code>operator</code> functions, which are regular functions with special names: their name begins by the <code>operator</code> keyword followed by the <em>operator sign</em> that is overloaded. The syntax is: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">type <span class="keyword">operator</span> <span class="title">sign</span> <span class="params">(parameters)</span> </span>&#123; <span class="comment">/*... body ...*/</span> &#125;</span><br></pre></td></tr></table></figure><p>二、重载运算符的不同形式：</p><p>There is a table with a summary of the parameters needed for each of the different operators than can be overloaded (please, replace <code>@</code> by the operator in each case):</p><table><thead><tr><th>Expression</th><th>Operator</th><th>Member function</th><th>Non-member function</th></tr></thead><tbody><tr><td><code>@a</code></td><td><code>+ - * &amp; ! ~ ++ --</code></td><td><code>A::operator@()</code></td><td><code>operator@(A)</code></td></tr><tr><td><code>a@</code></td><td><code>++ --</code></td><td><code>A::operator@(int)</code></td><td><code>operator@(A,int)</code></td></tr><tr><td><code>a@b</code></td><td><code>+ - * / % ^ &amp; | &lt; &gt; == != &lt;= &gt;= &lt;&lt; &gt;&gt; &amp;&amp; || ,</code></td><td><code>A::operator@(B)</code></td><td><code>operator@(A,B)</code></td></tr><tr><td><code>a@b</code></td><td><code>= += -= *= /= %= ^= &amp;= |= &lt;&lt;= &gt;&gt;= []</code></td><td><code>A::operator@(B)</code></td><td>-</td></tr><tr><td><code>a(b,c...)</code></td><td><code>()</code></td><td><code>A::operator()(B,C...)</code></td><td>-</td></tr><tr><td><code>a-&gt;b</code></td><td><code>-&gt;</code></td><td><code>A::operator-&gt;()</code></td><td>-</td></tr><tr><td><code>(TYPE) a</code></td><td><code>TYPE</code></td><td><code>A::operator TYPE()</code></td><td>-</td></tr></tbody></table><p>Where <code>a</code> is an object of class <code>A</code>, <code>b</code> is an object of class <code>B</code> and <code>c</code> is an object of class <code>C</code>. <code>TYPE</code> is just any type (that operators overloads the conversion to type <code>TYPE</code>).</p><p>Notice that some operators may be overloaded in two forms: either as a member function or as a non-member function.</p><p>三、例子：</p><p>For example, <em>cartesian vectors</em> are sets of two coordinates: <code>x</code> and <code>y</code>. The addition operation of two <em>cartesian vectors</em> is defined as the addition both <code>x</code> coordinates together, and both <code>y</code> coordinates together. For example, adding the <em>cartesian vectors</em> <code>(3,1)</code> and <code>(1,2)</code> together would result in <code>(3+1,1+2) = (4,3)</code>. This could be implemented in C++ with the following code:</p><p><img src="/img/cpp/overloading_operators.png" alt="Overloading operators"></p><p>The function <code>operator+</code> of class <code>CVector</code> overloads the addition operator (<code>+</code>) for that type. Once declared, this function can be called either implicitly using the operator, or explicitly using its functional name:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called either implicitly using the operator</span></span><br><span class="line">c = a + b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or explicitly using its functional name</span></span><br><span class="line">c = a.<span class="keyword">operator</span>+ (b);</span><br></pre></td></tr></table></figure><p>Both expressions are equivalent.</p><p>四、注意点：</p><blockquote><p>Attention</p><p>The operator overloads are just regular functions which can have any behavior; there is actually no requirement that the operation performed by that overload bears a relation to the mathematical or usual meaning of the operator, although it is strongly recommended. For example, a class that overloads <code>operator+</code> to actually subtract or that overloads <code>operator==</code> to fill the object with zeros, is perfectly valid, although using such a class could be challenging.</p></blockquote><h2 id="函数重定义（redefine）"><a href="#函数重定义（redefine）" class="headerlink" title="函数重定义（redefine）"></a>函数重定义（redefine）</h2><p>即 Java 语言中的方法重写（rewrite）。</p><h1 id="类指针"><a href="#类指针" class="headerlink" title="类指针"></a>类指针</h1><p>Objects can also be pointed to by pointers: Once declared, a class becomes a valid type, so it can be used as the type pointed to by a pointer. For example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a pointer to an object of class Rectangle.</span></span><br><span class="line">Rectangle * prect;</span><br></pre></td></tr></table></figure><p>Similarly as with plain data structures, the members of an object can be accessed directly from a pointer by using the arrow operator (<code>-&gt;</code>). Here is an example with some possible combinations:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pointer to classes example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Rectangle(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : <span class="built_in">width</span>(x), <span class="built_in">height</span>(y) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">width</span> * <span class="built_in">height</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Rectangle <span class="title">obj</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">  Rectangle * foo, * bar;  <span class="comment">// 类指针（Pointers to classes）</span></span><br><span class="line">  foo = &amp;obj;</span><br><span class="line">  bar = <span class="keyword">new</span> Rectangle (<span class="number">5</span>, <span class="number">6</span>);  <span class="comment">// 参考：http://www.cplusplus.com/doc/tutorial/dynamic/</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"obj's area: "</span> &lt;&lt; obj.area() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"*foo's area: "</span> &lt;&lt; foo-&gt;area() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"*foo's area: "</span> &lt;&lt; (*foo).area() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"*bar's area: "</span> &lt;&lt; bar-&gt;area() &lt;&lt; <span class="string">'\n'</span>;    </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"*bar's area: "</span> &lt;&lt; (*bar).area() &lt;&lt; <span class="string">'\n'</span>;    </span><br><span class="line">  <span class="keyword">delete</span> bar;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This example makes use of several operators to operate on objects and pointers (operators <code>*</code>, <code>&amp;</code>, <code>.</code>, <code>-&gt;</code>). They can be interpreted as:</p><table><thead><tr><th>expression</th><th>can be read as</th></tr></thead><tbody><tr><td><code>*x</code></td><td>pointed to by <code>x</code></td></tr><tr><td><code>&amp;x</code></td><td>address of <code>x</code></td></tr><tr><td><code>x.y</code></td><td>member <code>y</code> of object <code>x</code></td></tr><tr><td><code>x-&gt;y</code></td><td>member <code>y</code> of object pointed to by <code>x</code></td></tr><tr><td><code>(*x).y</code></td><td>member <code>y</code> of object pointed to by <code>x</code> (equivalent to the previous one)</td></tr></tbody></table><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>模板是<strong>泛型</strong>编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function templates</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">getmax</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T retval;</span><br><span class="line">  retval = a &gt; b ? a : b;</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> maxInt = getmax(<span class="number">100</span>, <span class="number">75</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; maxInt &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> maxDouble = getmax(<span class="number">3.3</span>, <span class="number">2.18</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; maxDouble &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 3.3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// no matching function for call to 'getmax'</span></span><br><span class="line">  <span class="comment">// char maxChar = getmax('a', 1.99);</span></span><br><span class="line">  <span class="comment">// cout &lt;&lt; maxChar &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>Just like we can create <em>function templates</em>, we can also create <em>class templates</em>, allowing classes to have members that use <em>template parameters</em> as types. For example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class templates</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyPair</span> &#123;</span></span><br><span class="line">    T a, b;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    MyPair (T first, T second)</span><br><span class="line">      &#123;a=first; b=second;&#125;</span><br><span class="line">    <span class="function">T <span class="title">getmax</span> <span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In case that a member function is defined outside the defintion of the class template, it shall be preceded with the template &lt;...&gt; prefix</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">MyPair</span>&lt;T&gt;:</span>:getmax ()</span><br><span class="line">&#123;</span><br><span class="line">  T retval;</span><br><span class="line">  retval = a &gt; b ? a : b;</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MyPair&lt;<span class="keyword">int</span>&gt; <span class="title">myobject</span><span class="params">(<span class="number">100</span>, <span class="number">75</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; myobject.getmax() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">  <span class="function">MyPair&lt;<span class="keyword">double</span>&gt; <span class="title">myfloats</span><span class="params">(<span class="number">3.3</span>, <span class="number">2.18</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; myfloats.getmax() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 3.3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// implicit conversion from 'double' to 'char' changes value from 1.99 to 1</span></span><br><span class="line">  <span class="comment">// MyPair&lt;char&gt; mychars('a', 1.99);</span></span><br><span class="line">  <span class="comment">// cout &lt;&lt; mychars.getmax() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice the syntax of the definition of member function <code>getmax</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">mypair</span>&lt;T&gt;:</span>:getmax ()</span><br></pre></td></tr></table></figure><p>There are three <code>T</code>‘s in this declaration: The first one is the template parameter. The second <code>T</code> refers to the type returned by the function. And the third <code>T</code> (the one between angle brackets) is also a requirement: It specifies that this function’s template parameter is also the class template parameter.</p><h2 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h2><p>模板类是类模板实例化后的一个产物。</p><p>It is possible to define a different implementation for a template when a specific type is passed as template argument. This is called a <em>template specialization</em>.</p><p>For example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template specialization</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class template:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">mycontainer</span> &#123;</span></span><br><span class="line">    T element;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    mycontainer (T arg) &#123;element=arg;&#125;</span><br><span class="line">    <span class="function">T <span class="title">increase</span> <span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++element;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class template specialization:</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span> &lt;char&gt; &#123;</span></span><br><span class="line">    <span class="keyword">char</span> element;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    mycontainer (<span class="keyword">char</span> arg) &#123;element=arg;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">uppercase</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ((element&gt;=<span class="string">'a'</span>)&amp;&amp;(element&lt;=<span class="string">'z'</span>))</span><br><span class="line">      element+=<span class="string">'A'</span>-<span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">mycontainer&lt;<span class="keyword">int</span>&gt; <span class="title">myint</span> <span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">  <span class="function">mycontainer&lt;<span class="keyword">char</span>&gt; <span class="title">mychar</span> <span class="params">(<span class="string">'j'</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; myint.increase() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 8</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; mychar.uppercase() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// J</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This is the syntax used for the class template specialization:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span> &lt;char&gt; &#123;</span> ... &#125;;</span><br></pre></td></tr></table></figure><p>First of all, notice that we precede the class name with <code>template&lt;&gt;</code> , including an empty parameter list. This is because all types are known and no template arguments are required for this specialization, but still, it is the specialization of a class template, and thus it requires to be noted as such.</p><p>But more important than this prefix, is the <code>&lt;char&gt;</code> specialization parameter after the class template name. This specialization parameter itself identifies the type for which the template class is being specialized (<code>char</code>). Notice the differences between the generic class template and the specialization:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">mycontainer</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span> &lt;char&gt; &#123;</span> ... &#125;;</span><br></pre></td></tr></table></figure><p>The first line is the <em>generic template</em>, and the second one is the <em>specialization</em>.</p><p>When we declare specializations for a template class, we must also define all its members, even those identical to the generic template class, because there is no “inheritance” of members from the generic template to the specialization.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cplusplus.com/doc/tutorial/classes/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/classes/</a></p><p><a href="http://www.cplusplus.com/doc/tutorial/templates/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/templates/</a></p><p><a href="http://www.cplusplus.com/doc/tutorial/classes2/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/classes2/</a></p><p><a href="https://www.cplusplus.com/doc/oldtutorial/templates/" target="_blank" rel="noopener">https://www.cplusplus.com/doc/oldtutorial/templates/</a></p><p><a href="https://www.runoob.com/cplusplus/cpp-classes-objects.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-classes-objects.html</a></p><p><a href="https://www.runoob.com/cplusplus/cpp-templates.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-templates.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 语言系列（八）复合数据类型之类型别名</title>
      <link href="2021/02/18/cpp-type-aliases/"/>
      <url>2021/02/18/cpp-type-aliases/</url>
      
        <content type="html"><![CDATA[<blockquote><p>A type alias is a different name by which a type can be identified. In C++, any valid type can be aliased so that it can be referred to with a different identifier.</p></blockquote><p>在 C++ 中，有两种创建类型别名的语法：</p><ol><li><p>从 C 语言继承而来，使用 <code>typedef</code> 关键字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> existing_type new_type_name ;</span><br></pre></td></tr></table></figure></li><li><p>由 C++ 语言引入，使用 <code>using</code> 关键字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> new_type_name = existing_type ;</span><br></pre></td></tr></table></figure></li></ol><p><code>existing_type</code> 可以是任何类型，无论是基本类型还是复合类型，例如：</p><table><thead><tr><th><code>typedef</code></th><th><code>using</code></th></tr></thead><tbody><tr><td><code>typedef char C;</code></td><td><code>using C = char;</code></td></tr><tr><td><code>typedef unsigned int WORD;</code></td><td><code>using WORD = unsigned int;</code></td></tr><tr><td><code>typedef char * pChar;</code></td><td><code>using pChar = char *;</code></td></tr><tr><td><code>typedef char field [50];</code></td><td><code>using field = char [50];</code></td></tr></tbody></table><p><code>new_type_name</code> 作为该类型的别名，用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C mychar, anotherchar, *ptc1;</span><br><span class="line">WORD myword;</span><br><span class="line">pChar ptc2;</span><br><span class="line">field name;</span><br></pre></td></tr></table></figure><p>一旦定义了这些别名，就可以像其它有效类型一样，在任何声明中使用。尤其常见于与结构体搭配使用。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cplusplus.com/doc/tutorial/other_data_types/" target="_blank" rel="noopener">https://www.cplusplus.com/doc/tutorial/other_data_types/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 语言系列（七）复合数据类型之结构体</title>
      <link href="2021/02/16/cpp-struct/"/>
      <url>2021/02/16/cpp-struct/</url>
      
        <content type="html"><![CDATA[<h1 id="声明语法"><a href="#声明语法" class="headerlink" title="声明语法"></a>声明语法</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_name</span> &#123;</span></span><br><span class="line">  member_type1 member_name1;</span><br><span class="line">  member_type2 member_name2;</span><br><span class="line">  member_type3 member_name3;</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">&#125; object_names;</span><br></pre></td></tr></table></figure><h1 id="定义用法"><a href="#定义用法" class="headerlink" title="定义用法"></a>定义用法</h1><h2 id="结构体对象"><a href="#结构体对象" class="headerlink" title="结构体对象"></a>结构体对象</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare three objects (variables) of this type (product): apple, banana, and melon.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">product</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> weight;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">&#125; apple, banana, melon;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct requires either a type_name or at least one name in object_names, but not necessarily both.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> weight;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">&#125; apple, banana, melon;</span><br><span class="line"></span><br><span class="line"><span class="comment">// declare three objects (variables) of this type (product): apple, banana, and melon.</span></span><br><span class="line">product apple, banana, melon;</span><br></pre></td></tr></table></figure><h2 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// because structures are types, they can also be used as the type of arrays.</span></span><br><span class="line">product banana[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">product * p = &amp;apple;</span><br></pre></td></tr></table></figure><p>创建结构体指针之后，可以使用以下运算符访问其成员变量：</p><table><thead><tr><th>Operator</th><th>Expression</th><th>What is evaluated</th><th>Equivalent</th></tr></thead><tbody><tr><td>dot operator (<code>.</code>)</td><td><code>a.b</code></td><td>Member <code>b</code> of object <code>a</code></td><td></td></tr><tr><td>arrow operator (<code>-&gt;</code>)<br/>(dereference operator)</td><td><code>a-&gt;b</code></td><td>Member <code>b</code> of object pointed to by  <code>a</code></td><td><code>(*a).b</code></td></tr></tbody></table><p>例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apple.weight;  <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// The arrow operator (-&gt;) is a dereference operator that is used exclusively with pointers to objects that have members. This operator serves to access the member of an object directly from its address.</span></span><br><span class="line">p-&gt;weight;     <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// equivalent to:</span></span><br><span class="line">(*p).weight;   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h1 id="结构体作为参数传值"><a href="#结构体作为参数传值" class="headerlink" title="结构体作为参数传值"></a>结构体作为参数传值</h1><p>完整例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">product</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> weight;</span><br><span class="line">  <span class="keyword">double</span> price;</span><br><span class="line">&#125; melon, lemon;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(product prd)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"weight: "</span> &lt;&lt; prd.weight &lt;&lt; <span class="string">" price: "</span> &lt;&lt; prd.price &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  melon.weight = <span class="number">1</span>;</span><br><span class="line">  melon.price = <span class="number">2</span>;</span><br><span class="line">  show(melon);  <span class="comment">// weight: 1 price: 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  product apple;</span><br><span class="line">  apple.weight = <span class="number">3</span>;</span><br><span class="line">  apple.price = <span class="number">4</span>;</span><br><span class="line">  show(apple);  <span class="comment">// weight: 3 price: 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  product banana[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    banana[i].weight = i;</span><br><span class="line">    banana[i].price = i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// weight: 0 price: 0</span></span><br><span class="line">    <span class="comment">// weight: 1 price: 1</span></span><br><span class="line">    <span class="comment">// weight: 2 price: 2</span></span><br><span class="line">    show(banana[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  product apple;</span><br><span class="line">  apple.weight = <span class="number">3</span>;</span><br><span class="line">  apple.price = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  product * p_apple = &amp;apple;</span><br><span class="line">  show(*p_apple);                                   <span class="comment">// weight: 3 price: 4</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"weight: "</span> &lt;&lt; (*p_apple).weight &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// weight: 3</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"weight: "</span> &lt;&lt; p_apple-&gt;weight &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// weight: 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  test();</span><br><span class="line">  test2();</span><br><span class="line">  test3();</span><br><span class="line">  test4();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cplusplus.com/doc/tutorial/structures/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/structures/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 语言系列（六）复合数据类型之字符串</title>
      <link href="2021/02/12/cpp-character-sequences/"/>
      <url>2021/02/12/cpp-character-sequences/</url>
      
        <content type="html"><![CDATA[<p>重点：区分下述四种形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符数组（Character sequences）</span></span><br><span class="line"><span class="keyword">char</span> str[] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">' '</span>, <span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>, <span class="string">'d'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="comment">// 字符串指针</span></span><br><span class="line"><span class="keyword">char</span> *str = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="comment">// 字符串类（string）</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure><h1 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h1><p>字符数组（Character sequences）：<a href="http://www.cplusplus.com/doc/tutorial/ntcs/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/ntcs/</a></p><p>字符串实际上是使用 <a href="https://baike.baidu.com/item/Null/19660386" target="_blank" rel="noopener">null 字符</a> <code>\0</code> 终止的一维字符数组，如下：</p><p><img src="/img/cpp/c-strings.png" alt="C 字符串"></p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串实际上是使用 null 字符 \0 终止的一维字符数组</span></span><br><span class="line"><span class="keyword">char</span> str[] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">' '</span>, <span class="string">'w'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>, <span class="string">'d'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="comment">// 依据数组初始化规则，简化如下：</span></span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="comment">// conversion from string literal to 'char *' is deprecated</span></span><br><span class="line"><span class="keyword">char</span> *str3 = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str: hello world size: 12</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str: "</span>  &lt;&lt; str &lt;&lt; <span class="string">" size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(str) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// str2: hello world size: 12</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str2: "</span> &lt;&lt; str2 &lt;&lt; <span class="string">" size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(str2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 'sizeof (str3)' will return the size of the pointer, not the array itself</span></span><br><span class="line"><span class="comment">// str3: hello world size: 8</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"str3: "</span> &lt;&lt; str3 &lt;&lt; <span class="string">" size: "</span> &lt;&lt; <span class="keyword">sizeof</span>(str3) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h1 id="字符串指针"><a href="#字符串指针" class="headerlink" title="字符串指针"></a>字符串指针</h1><p>用字符数组和字符串指针都可实现字符串的存储和运算，但是两者是有区别的：</p><ul><li>字符数组是一个数组，每个元素的值都可以改变。</li><li>而字符串指针指向的是一个<strong>常量字符串</strong>，它被存放在程序的<strong>静态数据区，一旦定义就不能改变</strong>。</li></ul><p>这是最重要的区别。下面的代码在运行期间将会出错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str2[<span class="number">1</span>] = <span class="string">'a'</span>;      <span class="comment">// hallo world</span></span><br><span class="line">*(str3 + <span class="number">1</span>) = <span class="string">'a'</span>;  <span class="comment">// 运行时出错。因为不能改变字符串常量的值</span></span><br></pre></td></tr></table></figure><h1 id="string-字符串类"><a href="#string-字符串类" class="headerlink" title="string 字符串类"></a>string 字符串类</h1><p><code>string</code> 头文件提供了 <code>string</code> 类，参考：<a href="http://www.cplusplus.com/reference/string/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/string/</a></p><h1 id="cstring-操纵器"><a href="#cstring-操纵器" class="headerlink" title="cstring 操纵器"></a>cstring 操纵器</h1><p><code>cstring</code> 头文件提供了大量的函数，用来操纵 <em>C strings</em> and arrays，参考：<a href="http://www.cplusplus.com/reference/cstring/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/cstring/</a></p><p>例如：</p><ul><li>Copying:<ul><li><a href="http://www.cplusplus.com/reference/cstring/strcpy/" target="_blank" rel="noopener"><code>strcpy</code></a> Copy string</li></ul></li><li>Concatenation:<ul><li><a href="http://www.cplusplus.com/reference/cstring/strcat/" target="_blank" rel="noopener"><code>strcat</code></a> Concatenate strings</li></ul></li><li>Comparison:<ul><li><a href="http://www.cplusplus.com/reference/cstring/strcmp/" target="_blank" rel="noopener"><code>strcmp</code></a> Compare two strings</li></ul></li><li>Searching:<ul><li><a href="http://www.cplusplus.com/reference/cstring/strchr/" target="_blank" rel="noopener"><code>strchr</code></a> Locate first occurrence of character in string</li><li><a href="http://www.cplusplus.com/reference/cstring/strrchr/" target="_blank" rel="noopener"><code>strrchr</code></a> Locate last occurrence of character in string</li></ul></li><li>Other:<ul><li><a href="http://www.cplusplus.com/reference/cstring/strlen/" target="_blank" rel="noopener"><code>strlen</code></a> Get string length</li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cplusplus.com/doc/tutorial/ntcs/" target="_blank" rel="noopener">https://www.cplusplus.com/doc/tutorial/ntcs/</a></p><p><a href="https://www.runoob.com/cplusplus/cpp-strings.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-strings.html</a></p><p><a href="https://blog.csdn.net/u014082714/article/details/45498527" target="_blank" rel="noopener">C++输出char型变量与字符串的地址</a></p><p><a href="https://stackoverflow.com/questions/1524356/c-deprecated-conversion-from-string-constant-to-char" target="_blank" rel="noopener">https://stackoverflow.com/questions/1524356/c-deprecated-conversion-from-string-constant-to-char</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 语言系列（五）复合数据类型之数组</title>
      <link href="2021/02/10/cpp-array/"/>
      <url>2021/02/10/cpp-array/</url>
      
        <content type="html"><![CDATA[<h1 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h1><p>一维数组声明：<code>type arrayName[ arraySize ];</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明数组</span></span><br><span class="line"><span class="keyword">int</span> array1[<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>一维数组初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数组</span></span><br><span class="line"><span class="keyword">float</span> array1[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 初始化数组（省略数组大小声明，默认大小为初始化时元素的个数）</span></span><br><span class="line"><span class="keyword">float</span> array2[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>一维数组访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过索引逐个访问数组元素，并赋值</span></span><br><span class="line">array1[<span class="number">0</span>];  <span class="comment">// 1</span></span><br><span class="line">array1[<span class="number">1</span>];  <span class="comment">// 2</span></span><br><span class="line">array1[<span class="number">2</span>];  <span class="comment">// 3</span></span><br><span class="line">array1[<span class="number">3</span>];  <span class="comment">// 4</span></span><br><span class="line">array1[<span class="number">4</span>];  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h1 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h1><p>多维数组声明：<code>type name[ size1 ][ size2 ]...[ sizeN ];</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个三维 5 . 10 . 4 整型数组</span></span><br><span class="line"><span class="keyword">int</span> array1[<span class="number">5</span>][<span class="number">10</span>][<span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>二维数组初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  初始化索引号为 0 的行 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  初始化索引号为 1 的行 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;   <span class="comment">/*  初始化索引号为 2 的行 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部嵌套的括号是可选的，下面的初始化与上面是等同的：</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br></pre></td></tr></table></figure><p>二维数组访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]); i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(a[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>]); j++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维数组大小及长度获取：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组总大小：48</span></span><br><span class="line"><span class="keyword">sizeof</span>(a)</span><br><span class="line"><span class="comment">// 数组第一维大小：16</span></span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 数组第一维长度：3</span></span><br><span class="line"><span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>])</span><br><span class="line"><span class="comment">// 数组第二维长度：4</span></span><br><span class="line"><span class="keyword">sizeof</span>(a[<span class="number">0</span>]) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure><h1 id="数组名"><a href="#数组名" class="headerlink" title="数组名"></a>数组名</h1><p><strong>数组名</strong>是指向数组中第一个元素的<strong>常指针（常量指针）</strong>，因此 <code>arrayName</code> 等价于 <code>&amp;arrayName[0]</code>，验证如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arrayName[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arrayName &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// 0x7ffeec364620</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;arrayName[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 0x7ffeec364620</span></span><br></pre></td></tr></table></figure><p>由于数组是<strong>常指针</strong>，因此自身无法执行算术运算：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表达式必须是可修改的左值</span></span><br><span class="line"><span class="comment">// invalid operands to binary expression</span></span><br><span class="line">arrayName += <span class="number">1</span>;</span><br><span class="line">arrayName -= <span class="number">1</span>;</span><br><span class="line">arrayName++;</span><br><span class="line">arrayName--;</span><br><span class="line">++arrayName;</span><br><span class="line">--arrayName;</span><br></pre></td></tr></table></figure><h1 id="数组构成"><a href="#数组构成" class="headerlink" title="数组构成"></a>数组构成</h1><ul><li>存储一个<strong>固定大小</strong>的<strong>相同数据类型</strong>元素的顺序集合。</li><li>由<strong>连续的内存地址</strong>组成。</li></ul><p>验证如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; &amp;arrayName[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x7ffeec364620</span><br><span class="line">0x7ffeec364624</span><br><span class="line">0x7ffeec364628</span><br><span class="line">0x7ffeec36462c</span><br><span class="line">0x7ffeec364630</span><br></pre></td></tr></table></figure><p>分析上述输出结果，由于 1 个内存单元的大小是 <code>8 bits</code>，即一个字节。而一个 <code>int</code> 类型的变量占用 4 个字节，因此上述 16 进制表示的内存地址的递增步长为 4。</p><h1 id="获取数组大小"><a href="#获取数组大小" class="headerlink" title="获取数组大小"></a>获取数组大小</h1><p>通过 <code>sizeof</code> 运算符，确认该数组大小为 20 字节：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(arrayName) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><h1 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h1><p><code>sizeof</code> 运算符用于获取变量的存储大小（即所占内存字节数），由于数组中每个元素的类型都是一样的、所占字节数亦然，因此可以计算如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(arrayName) / <span class="keyword">sizeof</span>(arrayName[<span class="number">0</span>]);  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>参考：<a href="https://zhuanlan.zhihu.com/p/104531696VVV" target="_blank" rel="noopener">C 语言数组传入函数获取数组长度的方法</a></p><h1 id="遍历数组元素"><a href="#遍历数组元素" class="headerlink" title="遍历数组元素"></a>遍历数组元素</h1><p>使用数组索引访问数组元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; arrayName[i] &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指针数组-VS-数组指针"><a href="#指针数组-VS-数组指针" class="headerlink" title="指针数组 VS 数组指针"></a>指针数组 VS 数组指针</h1><p><img src="/img/cpp/pointer_array.jpg" alt="指针数据 VS 数组指针"></p><h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>指针数组，表示“存储指针的数组”，即定义一个数组，其每个元素都是指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h2 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h2><p>数组指针，表示“指向数组的指针”，即定义一个指针，指向数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>常用于定义函数的<strong>形式参数</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p)</span></span>;</span><br></pre></td></tr></table></figure><p>优点：数组作为<strong>常指针</strong>不能执行算术运算，但<strong>数组指针</strong>可以。下面通过递增指针，以顺序访问数组元素：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arrayName[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// &amp;arrayName = 0x7ffee7376620</span></span><br><span class="line"><span class="keyword">int</span> *p = arrayName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 0x7ffee7376620 0x7ffee7376624 0x7ffee7376628 0x7ffee737662c 0x7ffee7376630</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; *p++ &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="传递数组给函数"><a href="#传递数组给函数" class="headerlink" title="传递数组给函数"></a>传递数组给函数</h1><h2 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h2><p>有三种方式传递数组给函数。</p><p>方式一：形式参数是一个<strong>数组指针</strong>（指向数组的指针）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 返回指针长度 8 bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：形式参数是一个已定义大小的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> p[<span class="number">5</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// sizeof on array function parameter will return size of 'int *' instead of 'int [5]'</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 返回指针长度 8 bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式三：形式参数是一个未定义大小的数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// sizeof on array function parameter will return size of 'int *' instead of 'int []'</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(p) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 返回指针长度 8 bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>无论使用何种方式，<strong>函数内都无法获取数组长度</strong>，需要使用单独变量将数组长度作为参数传入。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> p[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p[i] &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cplusplus.com/doc/tutorial/arrays/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/arrays/</a></p><p><a href="https://www.runoob.com/cplusplus/cpp-arrays.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-arrays.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 语言系列（四）复合数据类型之指针、引用</title>
      <link href="2021/02/06/cpp-pointer-and-reference/"/>
      <url>2021/02/06/cpp-pointer-and-reference/</url>
      
        <content type="html"><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用是一个别名，也就是说，它是某个已存在变量的另一个名字。修改引用等同于修改被引用变量自身。</p><p>一个变量可以有多个引用。</p><h2 id="声明引用"><a href="#声明引用" class="headerlink" title="声明引用"></a>声明引用</h2><p>不存在<strong>空引用</strong>。声明引用的同时，必须初始化，否则报编译错误如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;ref;  <span class="comment">// declaration of reference variable 'ref' requires an initializer</span></span><br></pre></td></tr></table></figure><p>引用一旦初始化，就不能再指向另一个变量。修改引用等同于修改被引用变量本身。</p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。</p><h2 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h2><p>一元运算符 <code>*</code> 用于声明一个指针变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span>   *bp;    <span class="comment">// 声明一个布尔型的空指针</span></span><br><span class="line"><span class="keyword">char</span>   *ch;    <span class="comment">// 声明一个字符型的空指针</span></span><br><span class="line"><span class="keyword">int</span>    *ip;    <span class="comment">// 声明一个整型的空指针</span></span><br><span class="line"><span class="keyword">double</span> *dp;    <span class="comment">// 声明声明一个 double 型的空指针</span></span><br><span class="line"><span class="keyword">float</span>  *fp;    <span class="comment">// 声明一个浮点型的空指针</span></span><br></pre></td></tr></table></figure><ul><li>可以声明空指针。</li><li>除了常指针，其它指针可以在任何时间被初始化。</li><li>所有指针的值的实际数据类型，不管是布尔型、字符型、整型、浮点型，还是其它的数据类型，都是一样的，其值都是一个<strong>代表内存地址</strong>的<strong>十六进制数</strong>。</li><li>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同，<strong>因此执行递增或递减时的步长不同</strong>。</li></ul><h2 id="获取指针大小"><a href="#获取指针大小" class="headerlink" title="获取指针大小"></a>获取指针大小</h2><table><thead><tr><th>操作系统</th><th>指针变量的存储大小</th></tr></thead><tbody><tr><td>32 位</td><td>4 个字节</td></tr><tr><td>64 位</td><td>8 个字节</td></tr></tbody></table><p>本机为 64 位操作系统，验证如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">bool</span>*)  <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">char</span>*)  <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>*)    <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">float</span>*)  <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">double</span>*) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h2 id="指针的算数运算"><a href="#指针的算数运算" class="headerlink" title="指针的算数运算"></a>指针的算数运算</h2><p>可以对指针进行四种算术运算：<code>++</code>、<code>--</code>、<code>+</code>、<code>-</code>。运算后，指针保存新的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> * p = &amp;a;</span><br><span class="line"></span><br><span class="line">p = &amp;b;</span><br><span class="line">p += <span class="number">1</span>;</span><br><span class="line">p -= <span class="number">1</span>;</span><br><span class="line">p++;</span><br><span class="line">p--;</span><br><span class="line">++p;</span><br><span class="line">--p;</span><br></pre></td></tr></table></figure><h2 id="重点考点"><a href="#重点考点" class="headerlink" title="重点考点"></a>重点考点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常指针</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向常量的指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向常量的常指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br></pre></td></tr></table></figure><h3 id="常指针"><a href="#常指针" class="headerlink" title="常指针"></a>常指针</h3><p>顾名思义，指针本身是个常量，不能修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式必须是可修改的左值</span></span><br><span class="line"><span class="comment">// cannot assign to variable 'p' with const-qualified type 'int *const'</span></span><br><span class="line">p = &amp;b;</span><br><span class="line">p += <span class="number">1</span>;</span><br><span class="line">p -= <span class="number">1</span>;</span><br><span class="line">p++;</span><br><span class="line">p--;</span><br><span class="line">++p;</span><br><span class="line">--p;</span><br></pre></td></tr></table></figure><p>常见的常指针，例如：</p><ul><li>数组名</li></ul><h3 id="指向常量的指针"><a href="#指向常量的指针" class="headerlink" title="指向常量的指针"></a>指向常量的指针</h3><p>顾名思义，指针指向的是常量，不能修改其值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针本身可以重新赋值</span></span><br><span class="line">p = &amp;b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但不能修改指针指向的常量的值，否则报编译错误：</span></span><br><span class="line"><span class="comment">// 表达式必须是可修改的左值</span></span><br><span class="line"><span class="comment">// read-only variable is not assignable</span></span><br><span class="line">*p += <span class="number">1</span>;</span><br><span class="line">*p -= <span class="number">1</span>;</span><br><span class="line">(*p)++;</span><br><span class="line">(*p)--;</span><br><span class="line">++(*p);</span><br><span class="line">--(*p);</span><br></pre></td></tr></table></figure><h3 id="指向常量的常指针"><a href="#指向常量的常指针" class="headerlink" title="指向常量的常指针"></a>指向常量的常指针</h3><p>结合了上述两种特性。</p><h2 id="常见指针"><a href="#常见指针" class="headerlink" title="常见指针"></a>常见指针</h2><h3 id="字符串指针"><a href="#字符串指针" class="headerlink" title="字符串指针"></a>字符串指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串指针（指向一个常量字符串，它被存放在程序的静态数据区，一旦定义就不能改变）</span></span><br><span class="line"><span class="keyword">char</span> * str = <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure><h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arrayName[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// &amp;arrayName = 0x7ffee7376620</span></span><br><span class="line"><span class="keyword">int</span> * p = arrayName;  <span class="comment">// // 数组指针（Pointers to array，即指向数组中第一个元素的地址）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 0x7ffee7376620 0x7ffee7376624 0x7ffee7376628 0x7ffee737662c 0x7ffee7376630</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; *p++ &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">product apple;</span><br><span class="line"><span class="comment">// 结构体指针（Pointers to struct）</span></span><br><span class="line">product * p = &amp;apple;</span><br><span class="line"><span class="comment">// The arrow operator (-&gt;) is a dereference operator that is used exclusively with pointers to objects that have members. This operator serves to access the member of an object directly from its address.</span></span><br><span class="line">p-&gt;weight;</span><br><span class="line"><span class="comment">// equivalent to:</span></span><br><span class="line">(*p).weight;</span><br></pre></td></tr></table></figure><h3 id="类指针"><a href="#类指针" class="headerlink" title="类指针"></a>类指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="comment">// 类指针（Pointers to classes），主要用于多态性</span></span><br><span class="line">Shape * p = &amp;<span class="built_in">rect</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member y of object x</span></span><br><span class="line"><span class="built_in">rect</span>.area();  <span class="comment">// 12</span></span><br><span class="line"><span class="comment">// member y of object pointed to by x</span></span><br><span class="line">p-&gt;area();    <span class="comment">// 12</span></span><br><span class="line"><span class="comment">// equivalent to:</span></span><br><span class="line">(*p).area();  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h1 id="引用与指针对比"><a href="#引用与指针对比" class="headerlink" title="引用与指针对比"></a>引用与指针对比</h1><p>常见问题，下列代码的区别？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*p</span><br><span class="line">&amp;p</span><br><span class="line">*&amp;p</span><br><span class="line">&amp;*p</span><br></pre></td></tr></table></figure><p>要解决这个问题，首先需要了解这两个运算符的区别：</p><table><thead><tr><th></th><th>在赋值运算符左侧</th><th>在赋值运算符右侧</th></tr></thead><tbody><tr><td><code>*</code></td><td>表示声明指针</td><td>表示<strong>取值运算符</strong></td></tr><tr><td><code>&amp;</code></td><td>表示声明引用</td><td>表示<strong>取址运算符</strong></td></tr></tbody></table><p>代码示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", &amp;a = "</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">", *&amp;a = "</span> &lt;&lt; *&amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="string">", &amp;b = "</span> &lt;&lt; &amp;b &lt;&lt; <span class="string">", *&amp;b = "</span> &lt;&lt; *&amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p = "</span> &lt;&lt; p &lt;&lt; <span class="string">", &amp;p = "</span> &lt;&lt; &amp;p &lt;&lt; <span class="string">", *p = "</span> &lt;&lt; *p &lt;&lt; <span class="string">", &amp;*p = "</span> &lt;&lt; &amp;*p &lt;&lt; <span class="string">", *&amp;p = "</span> &lt;&lt; *&amp;p &lt;&lt; <span class="built_in">endl</span></span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 10, &amp;a &#x3D; 0x7ffee483763c, *&amp;a &#x3D; 10</span><br><span class="line">b &#x3D; 10, &amp;b &#x3D; 0x7ffee483763c, *&amp;b &#x3D; 10</span><br><span class="line">p &#x3D; 0x7ffee483763c, &amp;p &#x3D; 0x7ffee4837628, *p &#x3D; 10, &amp;*p &#x3D; 0x7ffee483763c, *&amp;p &#x3D; 0x7ffee483763c</span><br></pre></td></tr></table></figure><p>总结如下：</p><table><thead><tr><th>指针变量</th><th>结果</th><th>描述</th></tr></thead><tbody><tr><td><code>p</code></td><td>0x7ffee483763c</td><td>返回指针变量 <code>p</code> 保存的地址</td></tr><tr><td><code>*p</code></td><td>10</td><td>返回指针变量 <code>p</code> 保存的地址的实际值</td></tr><tr><td><code>&amp;p</code></td><td>0x7ffee4837628</td><td>返回指针变量 <code>p</code> 自身的地址</td></tr><tr><td><code>&amp;*p</code></td><td>0x7ffee483763c</td><td>返回指针变量 <code>p</code> 保存的地址的实际值的地址</td></tr><tr><td><code>*&amp;p</code></td><td>0x7ffee483763c</td><td>返回指针变量 <code>p</code> 自身的地址的实际值</td></tr></tbody></table><p>引用与指针的区别，如下图：</p><p><img src="/img/cpp/pointer_and_reference.png" alt="引用与指针对比"></p><h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配<strong>堆内存（memory heap）</strong>，这会返回所分配的空间<strong>地址</strong>。</p><p>动态内存分配使用 <code>new</code> 运算符，后面跟上一个数据类型，语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocate memory to contain one single element of specified type</span></span><br><span class="line">pointer = <span class="keyword">new</span> type</span><br><span class="line">  </span><br><span class="line"><span class="comment">// allocate a block (an array) of elements of specified type, where `number_of_elements` is an integer value representing the amount of these.</span></span><br><span class="line"><span class="comment">// it returns a pointer to the beginning of the new block of memory allocated.</span></span><br><span class="line">pointer = <span class="keyword">new</span> type [number_of_elements]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * bar = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>); <span class="comment">// int bar = 5</span></span><br><span class="line"><span class="keyword">int</span> * foo = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">// int foo[5]</span></span><br></pre></td></tr></table></figure><p><img src="/img/cpp/dynamic_memory.png" alt=""></p><blockquote><p>In this case, the system dynamically allocates space for five elements of type <code>int</code> and returns a pointer to the first element of the sequence, which is assigned to <code>foo</code> (a pointer). Therefore, <code>foo</code> now points to a valid block of memory with space for five elements of type <code>int</code>.</p><p>Here, <code>foo</code> is a pointer, and thus, the first element pointed to by <code>foo</code> can be accessed either with the expression <code>foo[0]</code> or the expression <code>*foo</code> (both are equivalent). The second element can be accessed either with <code>foo[1]</code> or <code>*(foo+1)</code>, and so on…</p></blockquote><p>由于使用动态内存分配机制，因此 <code>number_of_elements</code> 可以是一个变量，变量值在运行时才决定，例如：<code>p = new int[i];</code>。</p><hr><p>声明普通数组与使用 <code>new</code> 分配动态内存的区别：</p><blockquote><p>There is a substantial difference between declaring a normal array and allocating dynamic memory for a block of memory using <code>new</code>. The most important difference is that the size of a regular array needs to be a <em>constant expression</em>, and thus its size has to be determined at the moment of designing the program, before it is run, whereas the dynamic memory allocation performed by <code>new</code> allows to assign memory during runtime using any variable value as size.</p></blockquote><hr><p>C++ 提供了两种标准机制来检查堆内存分配是否成功：</p><blockquote><p>The dynamic memory requested by our program is allocated by the system from the memory heap. However, computer memory is a limited resource, and it can be exhausted. Therefore, there are no guarantees that all requests to allocate memory using operator <code>new</code> are going to be granted by the system.</p><p>C++ provides two standard mechanisms to check if the allocation was successful:</p></blockquote><p>机制一：异常机制</p><blockquote><p>One is by handling exceptions. Using this method, an exception of type <code>bad_alloc</code> is thrown when the allocation fails. If this exception is thrown and it is not handled by a specific handler, the program execution is terminated.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">5</span>];  <span class="comment">// if allocation fails, an exception is thrown</span></span><br></pre></td></tr></table></figure></blockquote><p>机制二：返回空指针</p><blockquote><p>The other method is known as <code>nothrow</code>, and what happens when it is used is that when a memory allocation fails, instead of throwing a <code>bad_alloc</code> exception or terminating the program, the pointer returned by <code>new</code> is a <em>null pointer</em>, and the program continues its execution normally.</p><p>This method can be specified by using a special object called <code>nothrow</code>, declared in header <a href="http://www.cplusplus.com/%3Cnew%3E" target="_blank" rel="noopener"><code>&lt;new&gt;</code></a>, as argument for <code>new</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span> [<span class="number">5</span>];</span><br></pre></td></tr></table></figure><p>In this case, if the allocation of this block of memory fails, the failure can be detected by checking if <code>foo</code> is a null pointer:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * foo;</span><br><span class="line">foo = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span> [<span class="number">5</span>];</span><br><span class="line"><span class="keyword">if</span> (foo == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// error assigning memory. Take measures.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>This <code>nothrow</code> method is likely to produce less efficient code than exceptions, since it implies explicitly checking the pointer value returned after each and every allocation. Therefore, the exception mechanism is generally preferred, at least for critical allocations. But <code>nothrow</code> mechanism is more simplicity.</p><p>It is considered good practice for programs to always be able to handle failures to allocate memory, either by checking the pointer value (if <code>nothrow</code>) or by catching the proper exception.</p></blockquote><h2 id="动态内存回收"><a href="#动态内存回收" class="headerlink" title="动态内存回收"></a>动态内存回收</h2><p>如果您不再需要动态分配的内存空间，可以使用 <code>delete</code> 运算符，删除之前由 <code>new</code> 运算符分配的内存，以便该内存可再次用于其它动态内存分配。语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// releases the memory of a single element allocated using new</span></span><br><span class="line"><span class="keyword">delete</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// releases the memory allocated for arrays of elements using new and a size in brackets ([])</span></span><br><span class="line"><span class="keyword">delete</span> [] foo; <span class="comment">// 不管所删除数组的维数多少，指针名前只用一对方括号 []</span></span><br></pre></td></tr></table></figure><h2 id="Dynamic-memory-in-C"><a href="#Dynamic-memory-in-C" class="headerlink" title="Dynamic memory in C"></a>Dynamic memory in C</h2><blockquote><p>C++ integrates the operators <code>new</code> and <code>delete</code> for allocating dynamic memory. But these were not available in the C language; instead, it used a library solution, with the functions <code>malloc</code>, <code>calloc</code>, <code>realloc</code> and <code>free</code>, defined in the header <a href="http://www.cplusplus.com/%3Ccstdlib%3E" target="_blank" rel="noopener"><code>&lt;cstdlib&gt;</code></a> (known as <code>&lt;stdlib.h&gt;</code> in C). The functions are also available in C++ and can also be used to allocate and deallocate dynamic memory.</p><p>Note, though, that the memory blocks allocated by these functions are not necessarily compatible with those returned by <code>new</code>, so they should not be mixed; each one should be handled with its own set of functions or operators.</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cplusplus.com/doc/tutorial/pointers/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/pointers/</a></p><p><a href="http://www.cplusplus.com/doc/tutorial/dynamic/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/dynamic/</a></p><p><a href="https://stackoverflow.com/questions/4995899/difference-between-pointer-and-reference-in-c" target="_blank" rel="noopener">Difference between pointer and reference in C ?</a></p><p><a href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%BC%A0%E5%80%BC%E3%80%81%E4%BC%A0%E5%9C%B0%E5%9D%80%E3%80%81%E4%BC%A0%E5%BC%95%E7%94%A8%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">C++ 中的参数传递方式：传值、传地址、传引用总结</a></p><p><a href="https://www.crucial.cn/learn-with-crucial/memory/how-much-memory-does-your-windows-support" target="_blank" rel="noopener">32/64 位系统支持多大内存？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 语言系列（三）函数总结</title>
      <link href="2021/02/04/cpp-function/"/>
      <url>2021/02/04/cpp-function/</url>
      
        <content type="html"><![CDATA[<h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><p>函数定义形式如下：</p><ul><li><p>函数头</p><ul><li><p>返回类型</p></li><li><p>函数名称</p></li><li><p>形式参数</p><ul><li><p>无参数函数</p></li><li><p>有参数函数</p><ul><li><p>参数默认值（必须从右到左赋默认值）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数默认值，必须从右到左</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2 = <span class="number">100</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 &gt; num2 ? num1 : num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则报编译错误：missing default argument on parameter 'num2'</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max3</span><span class="params">(<span class="keyword">int</span> num1 = <span class="number">100</span>, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 &gt; num2 ? num1 : num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>函数体</p></li></ul><h1 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h1><p>函数必须<strong>先声明后使用</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数必须先声明后使用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"result is "</span> &lt;&lt; max1(<span class="number">1</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 否则报错：未定义标识符 use of undeclared identifier 'max1'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 &gt; num2 ? num1 : num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h1><p>函数的实际参数有三种传递方式：</p><table><thead><tr><th>调用类型</th><th align="left">调用类型</th><th>例子</th><th align="left">描述</th></tr></thead><tbody><tr><td>传值</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-value.html" target="_blank" rel="noopener">传值调用</a></td><td><code>void swap(int x, y)</code></td><td align="left">把实际参数的实际值<strong>复制</strong>一份给形式参数。修改函数内的形式参数<strong>对实际参数没有影响</strong>。</td></tr><tr><td>传址</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-pointer.html" target="_blank" rel="noopener">指针调用</a></td><td><code>void swap(int * x, int * y)</code></td><td align="left">把实际参数的<strong>地址</strong>赋值给形式参数。在函数内，该指针用于访问实际参数的<strong>地址</strong>。这意味着，修改形式参数<strong>会影响实际参数</strong>。</td></tr><tr><td>传引用</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-function-call-by-reference.html" target="_blank" rel="noopener">引用调用</a></td><td><code>void swap(int &amp;x, &amp;y)</code></td><td align="left">把实际参数的引用赋值给形式参数。在函数内，该引用作为实际参数的<strong>别名</strong>。这意味着，修改形式参数<strong>会影响实际参数</strong>。</td></tr></tbody></table><p>传址与传引用的使用区别，如下：</p><p><img src="/img/cpp/compare_with_pointer_and_reference.png" alt="指针与引用的使用区别"></p><h1 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h1><p>函数的调用方式：</p><ul><li>嵌套调用</li><li>递归调用（直接递归， 间接递归）</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cplusplus.com/doc/tutorial/functions/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/functions/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 语言系列（二）基础语法入门</title>
      <link href="2021/02/02/cpp-basics/"/>
      <url>2021/02/02/cpp-basics/</url>
      
        <content type="html"><![CDATA[<h1 id="一、预处理器"><a href="#一、预处理器" class="headerlink" title="一、预处理器"></a>一、预处理器</h1><table><thead><tr><th align="left">指令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>#include</code></td><td align="left">包含一个源代码文件（<a href="https://www.runoob.com/cprogramming/c-header-files.html" target="_blank" rel="noopener">扩展名为 <code>.h</code> 的头文件</a>）</td></tr><tr><td align="left"><code>#define</code><br/><code>#undef</code></td><td align="left">定义宏<br/>取消已定义的宏</td></tr><tr><td align="left"><code>#if</code><br/><code>#else</code><br/><code>#elif</code><br/><code>#endif</code></td><td align="left">条件编译</td></tr></tbody></table><p>参考：</p><ul><li><a href="https://www.runoob.com/cprogramming/c-preprocessors.html" target="_blank" rel="noopener">C 预处理器</a></li><li><a href="http://www.cplusplus.com/doc/tutorial/preprocessor/" target="_blank" rel="noopener">Preprocessor directives</a></li></ul><h1 id="二、基础语法"><a href="#二、基础语法" class="headerlink" title="二、基础语法"></a>二、基础语法</h1><h2 id="1、标识符（identifier）"><a href="#1、标识符（identifier）" class="headerlink" title="1、标识符（identifier）"></a>1、标识符（identifier）</h2><p>是用来标识<strong>变量、函数、类、模块</strong>，或任何其他用户<strong>自定义项目</strong>的名称。</p><p>一个标识符只能以：</p><ul><li>字母 <code>A-Z</code> 或 <code>a-z</code> 或下划线 <code>_</code> 开始；</li><li>后跟零个或多个字母、下划线和数字（<code>0-9</code>）。</li></ul><h2 id="2、保留字（关键字）"><a href="#2、保留字（关键字）" class="headerlink" title="2、保留字（关键字）"></a>2、保留字（关键字）</h2><h2 id="3、注释"><a href="#3、注释" class="headerlink" title="3、注释"></a>3、注释</h2><p>单行注释（行注释）：<code>//</code></p><p>多行注释（块注释）：<code>/* ... */</code></p><h2 id="4、变量与常量"><a href="#4、变量与常量" class="headerlink" title="4、变量与常量"></a>4、变量与常量</h2><p><a href="https://www.runoob.com/cplusplus/cpp-variable-types.html" target="_blank" rel="noopener">C++ 变量类型</a></p><p><a href="https://www.runoob.com/cplusplus/cpp-data-types.html" target="_blank" rel="noopener">C++ 数据类型</a></p><p><a href="https://www.runoob.com/cplusplus/cpp-modifier-types.html" target="_blank" rel="noopener">C++ 修饰符类型</a></p><p><a href="https://www.runoob.com/cplusplus/cpp-variable-scope.html" target="_blank" rel="noopener">C++ 变量作用域</a></p><h3 id="4-1、基本数据类型"><a href="#4-1、基本数据类型" class="headerlink" title="4.1、基本数据类型"></a>4.1、基本数据类型</h3><p>C/C++ 基本数据类型：</p><ul><li>一种<strong>布尔类型</strong></li><li>一种<strong>字符类型</strong></li><li>一种<strong>整数型</strong></li><li>两种<strong>浮点型</strong></li></ul><table><thead><tr><th align="left">类型</th><th align="left">关键字</th><th>存储大小</th><th>备注</th></tr></thead><tbody><tr><td align="left">布尔型</td><td align="left"><code>bool</code></td><td><code>sizeof(bool)</code> = <code>1</code> 字节</td><td></td></tr><tr><td align="left">字符型</td><td align="left"><code>char</code></td><td><code>sizeof(char)</code> = <code>1</code> 字节</td><td></td></tr><tr><td align="left">整型</td><td align="left"><code>int</code></td><td><code>sizeof(int)</code> = <code>4</code> 字节</td><td></td></tr><tr><td align="left">浮点型</td><td align="left"><code>float</code></td><td><code>sizeof(float)</code> = <code>4</code> 字节</td><td>C++ 中，小数默认为浮点型。</td></tr><tr><td align="left">双浮点型</td><td align="left"><code>double</code></td><td><code>sizeof(double)</code> = <code>8</code> 字节</td><td></td></tr></tbody></table><p><img src="/img/cpp/data_type.png" alt="基本数据类型"></p><h3 id="4-2、修饰符"><a href="#4-2、修饰符" class="headerlink" title="4.2、修饰符"></a>4.2、修饰符</h3><p>C++ 允许在 <code>char</code>、<code>int</code> 和 <code>double</code> 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。</p><table><thead><tr><th>修饰符</th><th><code>int</code></th><th><code>double</code></th><th><code>char</code></th></tr></thead><tbody><tr><td><code>signed</code></td><td>Y</td><td></td><td>Y</td></tr><tr><td><code>unsigned</code></td><td>Y</td><td></td><td>Y</td></tr><tr><td><code>long</code></td><td>Y</td><td>Y</td><td></td></tr><tr><td><code>short</code></td><td>Y</td><td></td><td></td></tr></tbody></table><h3 id="4-3、作用域"><a href="#4-3、作用域" class="headerlink" title="4.3、作用域"></a>4.3、作用域</h3><ul><li>作用域可分为：<ul><li>全局作用域</li><li>局部作用域</li><li>语句作用域</li></ul></li><li>作用域优先级：范围越小，优先级越高</li><li>如果希望在局部作用域中使用同名的全局变量，可以在该变量前使用：<strong>作用域运算符</strong> <code>::</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 局部变量</span></span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 100</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ::x &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4、常量定义"><a href="#4-4、常量定义" class="headerlink" title="4.4、常量定义"></a>4.4、常量定义</h3><p>在 C++ 中，有两种简单的定义 <a href="https://www.runoob.com/cplusplus/cpp-constants-literals.html" target="_blank" rel="noopener">C++ 常量</a>的方式：</p><ul><li>使用 <code>#define</code> 预处理器进行<strong>宏定义</strong>。</li><li>使用 <code>const</code> 关键字。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义常量（使用预处理器）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LENGTH 10   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH  5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEWLINE <span class="meta-string">'\n'</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 定义常量（使用 const 关键字）</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>  LENGTH = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span>  WIDTH  = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> NEWLINE = <span class="string">'\n'</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、运算符"><a href="#5、运算符" class="headerlink" title="5、运算符"></a>5、运算符</h2><h3 id="5-1、位运算符"><a href="#5-1、位运算符" class="headerlink" title="5.1、位运算符"></a>5.1、位运算符</h3><h3 id="5-2、算术运算符"><a href="#5-2、算术运算符" class="headerlink" title="5.2、算术运算符"></a>5.2、算术运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left"><code>+</code></td><td align="left">把两个操作数相加</td><td align="left">A + B 将得到 30</td></tr><tr><td align="left"><code>-</code></td><td align="left">从第一个操作数中减去第二个操作数</td><td align="left">A - B 将得到 -10</td></tr><tr><td align="left"><code>*</code></td><td align="left">把两个操作数相乘</td><td align="left">A * B 将得到 200</td></tr><tr><td align="left"><code>/</code></td><td align="left">分子除以分母</td><td align="left">B / A 将得到 2</td></tr><tr><td align="left"><code>%</code></td><td align="left">取模运算符，整除后的余数</td><td align="left">B % A 将得到 0</td></tr><tr><td align="left"><code>++</code></td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html" target="_blank" rel="noopener">自增运算符</a>，整数值增加 1</td><td align="left">A++ 将得到 11</td></tr><tr><td align="left"><code>--</code></td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-increment-decrement-operators.html" target="_blank" rel="noopener">自减运算符</a>，整数值减少 1</td><td align="left">A– 将得到 9</td></tr></tbody></table><h3 id="5-3、赋值运算符"><a href="#5-3、赋值运算符" class="headerlink" title="5.3、赋值运算符"></a>5.3、赋值运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left"><code>=</code></td><td align="left">简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td align="left">C = A + B 将把 A + B 的值赋给 C</td></tr><tr><td align="left"><code>+=</code></td><td align="left">加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td align="left">C += A 相当于 C = C + A</td></tr><tr><td align="left"><code>-=</code></td><td align="left">减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td align="left">C -= A 相当于 C = C - A</td></tr><tr><td align="left"><code>*=</code></td><td align="left">乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td align="left">C *= A 相当于 C = C * A</td></tr><tr><td align="left"><code>/=</code></td><td align="left">除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td align="left">C /= A 相当于 C = C / A</td></tr><tr><td align="left"><code>%=</code></td><td align="left">求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td align="left">C %= A 相当于 C = C % A</td></tr><tr><td align="left"><code>&lt;&lt;=</code></td><td align="left">左移且赋值运算符</td><td align="left">C &lt;&lt;= 2 等同于 C = C &lt;&lt; 2</td></tr><tr><td align="left"><code>&gt;&gt;=</code></td><td align="left">右移且赋值运算符</td><td align="left">C &gt;&gt;= 2 等同于 C = C &gt;&gt; 2</td></tr><tr><td align="left"><code>&amp;=</code></td><td align="left">按位与且赋值运算符</td><td align="left">C &amp;= 2 等同于 C = C &amp; 2</td></tr><tr><td align="left"><code>^=</code></td><td align="left">按位异或且赋值运算符</td><td align="left">C ^= 2 等同于 C = C ^ 2</td></tr><tr><td align="left"><code>|=</code></td><td align="left">按位或且赋值运算符</td><td align="left">C |= 2 等同于 C = C | 2</td></tr></tbody></table><h3 id="5-4、关系运算符"><a href="#5-4、关系运算符" class="headerlink" title="5.4、关系运算符"></a>5.4、关系运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left"><code>==</code></td><td align="left">检查两个操作数的值是否相等，如果相等则条件为真。</td><td align="left">(A == B) 不为真。</td></tr><tr><td align="left"><code>!=</code></td><td align="left">检查两个操作数的值是否相等，如果不相等则条件为真。</td><td align="left">(A != B) 为真。</td></tr><tr><td align="left"><code>&gt;</code></td><td align="left">检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td><td align="left">(A &gt; B) 不为真。</td></tr><tr><td align="left"><code>&lt;</code></td><td align="left">检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td><td align="left">(A &lt; B) 为真。</td></tr><tr><td align="left"><code>&gt;=</code></td><td align="left">检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td><td align="left">(A &gt;= B) 不为真。</td></tr><tr><td align="left"><code>&lt;=</code></td><td align="left">检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td><td align="left">(A &lt;= B) 为真。</td></tr></tbody></table><h3 id="5-5、逻辑运算符"><a href="#5-5、逻辑运算符" class="headerlink" title="5.5、逻辑运算符"></a>5.5、逻辑运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left"><code>&amp;&amp;</code></td><td align="left">称为逻辑与运算符。如果两个操作数都 true，则条件为 true。</td><td align="left">(A &amp;&amp; B) 为 false。</td></tr><tr><td align="left"><code>||</code></td><td align="left">称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。</td><td align="left">(A || B) 为 true。</td></tr><tr><td align="left"><code>!</code></td><td align="left">称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。</td><td align="left">!(A &amp;&amp; B) 为 true。</td></tr></tbody></table><h3 id="5-6、其它运算符"><a href="#5-6、其它运算符" class="headerlink" title="5.6、其它运算符"></a>5.6、其它运算符</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>::</code></td><td align="left">作用域运算符 Scope operator，用于引用全局变量 <code>::code</code>、引用某个命名空间的函数或变量 <code>namespace::code</code> 等等。</td></tr><tr><td align="left"><code>&amp;</code></td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html" target="_blank" rel="noopener">取地址运算符 Address-of operator (&amp;)</a> 返回变量的地址。例如 <code>&amp;a</code> 将给出变量的实际内存地址。</td></tr><tr><td align="left"><code>*</code></td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-pointer-operators.html" target="_blank" rel="noopener">间接寻址运算符 Dereference operator (*)</a> 指向一个变量。例如，<code>*var</code> 返回操作数所指定地址的变量的值。</td></tr><tr><td align="left"><code>.</code>（点）和 <code>-&gt;</code>（箭头）</td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-member-operators.html" target="_blank" rel="noopener">成员运算符</a>用于引用<strong>类</strong>、<strong>结构体</strong>和<strong>共用体</strong>的成员。</td></tr><tr><td align="left"><code>sizeof</code></td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-sizeof-operator.html" target="_blank" rel="noopener">sizeof 运算符</a>返回变量的存储大小。例如，<code>sizeof(int)</code> 返回 <code>4</code> 个字节。</td></tr><tr><td align="left"><code>Cast</code></td><td align="left"><a href="https://www.runoob.com/cplusplus/cpp-casting-operators.html" target="_blank" rel="noopener">强制转换运算符</a>把一种数据类型转换为另一种数据类型。例如，<code>int(2.2000)</code> 将返回 2。</td></tr><tr><td align="left"><code>new</code></td><td align="left">在堆上动态内存分配。参考：<a href="http://www.cplusplus.com/doc/tutorial/dynamic/" target="_blank" rel="noopener">Dynamic memory</a></td></tr><tr><td align="left"><code>delete</code></td><td align="left">在堆上进行内存回收。</td></tr></tbody></table><p>提取运算符 <code>&gt;&gt;</code></p><p>插入运算符 <code>&lt;&lt;</code></p><h2 id="6、控制语句"><a href="#6、控制语句" class="headerlink" title="6、控制语句"></a>6、控制语句</h2><p>C 语言有九种控制语句。 可分成以下三类：</p><h3 id="6-1、选择语句"><a href="#6-1、选择语句" class="headerlink" title="6.1、选择语句"></a>6.1、选择语句</h3><ul><li><code>if</code>、<code>else</code> 语句</li><li><code>switch</code> 语句</li></ul><h3 id="6-2、循环语句"><a href="#6-2、循环语句" class="headerlink" title="6.2、循环语句"></a>6.2、循环语句</h3><ul><li><code>while</code> 语句</li><li><code>do while</code> 语句</li><li><code>for</code> 语句</li></ul><h3 id="6-3、跳转语句"><a href="#6-3、跳转语句" class="headerlink" title="6.3、跳转语句"></a>6.3、跳转语句</h3><ul><li><code>break</code> 语句</li><li><code>continue</code> 语句</li><li><code>goto</code>语句（此语句尽量少用，因为这不利<strong>结构化程序设计</strong>，滥用它会使程序流程无规律、可读性差）</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cplusplus.com/doc/tutorial/" target="_blank" rel="noopener">https://www.cplusplus.com/doc/tutorial/</a></p><p><a href="https://www.cplusplus.com/doc/tutorial/variables/" target="_blank" rel="noopener">https://www.cplusplus.com/doc/tutorial/variables/</a></p><p><a href="https://www.cplusplus.com/doc/tutorial/namespaces/" target="_blank" rel="noopener">https://www.cplusplus.com/doc/tutorial/namespaces/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 语言系列（一）IDE 准备</title>
      <link href="2021/02/01/cpp-ide/"/>
      <url>2021/02/01/cpp-ide/</url>
      
        <content type="html"><![CDATA[<h1 id="VS-Code-运行-C"><a href="#VS-Code-运行-C" class="headerlink" title="VS Code 运行 C++"></a>VS Code 运行 C++</h1><p>打开 VScode，进入 <code>Extensions</code> 模块，搜索以下扩展并安装： </p><ul><li>C/C++</li><li>C/C++ Clang Command Adapter</li><li>C++ Intellisense</li><li>Code Runner</li></ul><p>安装完成后，扩展将会自动激活。此时<strong>重启</strong> VScode。 </p><p>重启后，打开 VScode，新建一个文件，输入如下代码： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello, world\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存为 <code>.cpp</code> 格式文件，点击 <strong>运行</strong> 按钮，观察 “Terminal” 中的成功输出：<code>hello, world</code>。至此，配置全部完成。 </p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>cannot edit in read-only editor</p><p><img src="/img/cpp/auto_guess_encoding.png" alt=""></p><p>GBK to UTF-8 乱码问题：</p><p><a href="https://www.cnblogs.com/kingsonfu/p/11010086.html" target="_blank" rel="noopener">https://www.cnblogs.com/kingsonfu/p/11010086.html</a></p><p><img src="/img/cpp/cannot_edit_in_read-only_editor.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cplusplus.com/doc/tutorial/introduction/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/introduction/</a></p><p><a href="http://www.dooccn.com/cpp/" target="_blank" rel="noopener">C++ 在线编译器</a></p><p><a href="https://cppinsights.io/" target="_blank" rel="noopener">C++ Insights</a></p><p><a href="https://gcc.godbolt.org/" target="_blank" rel="noopener">C++ Compiler Explorer</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jakarta EE 系列（四）XML Binding 规范与实践总结</title>
      <link href="2020/10/10/jakarta-xml-binding/"/>
      <url>2020/10/10/jakarta-xml-binding/</url>
      
        <content type="html"><![CDATA[<h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><blockquote><p>The Jakarta XML Binding provides an API and tools that automate the mapping between XML documents and Java objects.</p></blockquote><p>规范文档：<a href="https://jakarta.ee/specifications/xml-binding/" target="_blank" rel="noopener">https://jakarta.ee/specifications/xml-binding/</a></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>官方认证实现：<a href="https://eclipse-ee4j.github.io/jaxb-ri/" target="_blank" rel="noopener">https://eclipse-ee4j.github.io/jaxb-ri/</a></p><p>依赖下载：<a href="https://mvnrepository.com/artifact/com.sun.xml.bind/jaxb-ri，将传递依赖：" target="_blank" rel="noopener">https://mvnrepository.com/artifact/com.sun.xml.bind/jaxb-ri，将传递依赖：</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.xml.bind-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>本文演示如何生成和解析 XML，主要涉及以下常用注解，更多注解可以自行尝试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@XmlRootElement</span></span><br><span class="line"><span class="meta">@XmlElement</span></span><br><span class="line"><span class="meta">@XmlAttribute</span></span><br><span class="line"><span class="meta">@XmlValue</span></span><br></pre></td></tr></table></figure><p>实体类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Setter 会报错 com.sun.xml.internal.bind.v2.runtime.IllegalAnnotationsException: 4 counts of IllegalAnnotationExceptions</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@XmlRootElement</span>(name = <span class="string">"head"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Head</span> </span>&#123;</span><br><span class="line">    <span class="meta">@XmlElement</span>(name = <span class="string">"trade_code"</span>)</span><br><span class="line">    <span class="keyword">private</span> String tradeCode;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XmlElement</span>(name = <span class="string">"trade_date"</span>)</span><br><span class="line">    <span class="keyword">private</span> String tradeDate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XmlElement</span>(name = <span class="string">"trade_time"</span>)</span><br><span class="line">    <span class="keyword">private</span> String tradeTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XmlElement</span>(name = <span class="string">"serial_no"</span>)</span><br><span class="line">    <span class="keyword">private</span> String serialNo;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XmlElement</span>(name = <span class="string">"parent"</span>)</span><br><span class="line">    <span class="keyword">private</span> Parent parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@XmlRootElement</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@XmlElement</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Child&gt; child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">    <span class="meta">@XmlAttribute</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@XmlValue</span></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XML-工具类"><a href="#XML-工具类" class="headerlink" title="XML 工具类"></a>XML 工具类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, JAXBContext&gt; JAXB_CONTEXT_MAP = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传入一个对象，生成对应的 XML</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">toXml</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.warn(<span class="string">"[XmlUtils toXml] params is null"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JAXBContext jaxbContext = getJAXBContext(t.getClass());</span><br><span class="line">        Marshaller jaxbMarshaller;</span><br><span class="line">        <span class="keyword">try</span> (StringWriter stringWriter = <span class="keyword">new</span> StringWriter()) &#123;</span><br><span class="line">            jaxbMarshaller = jaxbContext.createMarshaller();</span><br><span class="line">            jaxbMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);</span><br><span class="line">            jaxbMarshaller.setProperty(Marshaller.JAXB_ENCODING, <span class="string">"UTF-8"</span>);</span><br><span class="line">            jaxbMarshaller.marshal(t, stringWriter);</span><br><span class="line">            <span class="keyword">return</span> stringWriter.toString();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JAXBException | IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"[XmlUtils toXml] exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 XML 解析成指定对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">unXml</span><span class="params">(String xml, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xml == <span class="keyword">null</span> || xml.isEmpty()) &#123;</span><br><span class="line">            log.warn(<span class="string">"[XmlUtils unXml] xml is null"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JAXBContext jaxbContext = getJAXBContext(clazz);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();</span><br><span class="line">            StringReader reader = <span class="keyword">new</span> StringReader(xml);</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T unmarshal = (T) unmarshaller.unmarshal(reader);</span><br><span class="line">            <span class="keyword">return</span> unmarshal;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JAXBException e) &#123;</span><br><span class="line">            log.error(<span class="string">"[XmlUtils unXml] exception"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类名称获取 JAXBContext</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> JAXBContext <span class="title">getJAXBContext</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        JAXBContext jaxbContext = JAXB_CONTEXT_MAP.get(clazz.getName());</span><br><span class="line">        <span class="keyword">if</span> (jaxbContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                jaxbContext = JAXBContext.newInstance(clazz);</span><br><span class="line">                JAXB_CONTEXT_MAP.put(clazz.getName(), jaxbContext);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JAXBException e) &#123;</span><br><span class="line">                log.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jaxbContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成-XML"><a href="#生成-XML" class="headerlink" title="生成 XML"></a>生成 XML</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToXml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LocalDateTime now = LocalDateTime.now();</span><br><span class="line">    Child child = Child.builder()</span><br><span class="line">        .key(<span class="string">"key"</span>)</span><br><span class="line">        .value(<span class="string">"value"</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    Parent parent = Parent.builder()</span><br><span class="line">        .child(Arrays.asList(child, child))</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    Head head = Head.builder()</span><br><span class="line">        .tradeCode(<span class="string">"XT-001"</span>)</span><br><span class="line">        .tradeDate(now.format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>)))</span><br><span class="line">        .tradeTime(now.format(DateTimeFormatter.ofPattern(<span class="string">"HH:mm:ss"</span>)))</span><br><span class="line">        .serialNo(UUID.randomUUID().toString())</span><br><span class="line">        .parent(parent)</span><br><span class="line">        .build();</span><br><span class="line">    String xml = XmlUtils.toXml(head);</span><br><span class="line">    log.info(xml);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trade_code</span>&gt;</span>XT-001<span class="tag">&lt;/<span class="name">trade_code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trade_date</span>&gt;</span>2020-03-19<span class="tag">&lt;/<span class="name">trade_date</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">trade_time</span>&gt;</span>18:39:28<span class="tag">&lt;/<span class="name">trade_time</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">serial_no</span>&gt;</span>114d2c0c-30a8-4275-982c-f8eba86cbadb<span class="tag">&lt;/<span class="name">serial_no</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">key</span>=<span class="string">"key"</span>&gt;</span>value<span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">key</span>=<span class="string">"key"</span>&gt;</span>value<span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="解析-XML"><a href="#解析-XML" class="headerlink" title="解析 XML"></a>解析 XML</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUnXml</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String xml = <span class="string">"&lt;?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;head&gt;\n"</span> +</span><br><span class="line">        <span class="string">"    &lt;trade_code&gt;XT-001&lt;/trade_code&gt;\n"</span> +</span><br><span class="line">        <span class="string">"    &lt;trade_date&gt;2020-03-19&lt;/trade_date&gt;\n"</span> +</span><br><span class="line">        <span class="string">"    &lt;trade_time&gt;18:39:28&lt;/trade_time&gt;\n"</span> +</span><br><span class="line">        <span class="string">"    &lt;serial_no&gt;114d2c0c-30a8-4275-982c-f8eba86cbadb&lt;/serial_no&gt;\n"</span> +</span><br><span class="line">        <span class="string">"    &lt;parent&gt;\n"</span> +</span><br><span class="line">        <span class="string">"        &lt;child key=\"key\"&gt;value&lt;/child&gt;\n"</span> +</span><br><span class="line">        <span class="string">"        &lt;child key=\"key\"&gt;value&lt;/child&gt;\n"</span> +</span><br><span class="line">        <span class="string">"    &lt;/parent&gt;\n"</span> +</span><br><span class="line">        <span class="string">"&lt;/head&gt;"</span>;</span><br><span class="line">    Head head = XmlUtils.unXml(xml, Head<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    log.info(head.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Head(tradeCode&#x3D;XT-001, tradeDate&#x3D;2020-03-19, tradeTime&#x3D;18:39:28, serialNo&#x3D;114d2c0c-30a8-4275-982c-f8eba86cbadb, parent&#x3D;Parent(child&#x3D;[Child(key&#x3D;key, value&#x3D;value), Child(key&#x3D;key, value&#x3D;value)]))</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://jakarta.ee/specifications/xml-binding/" target="_blank" rel="noopener">https://jakarta.ee/specifications/xml-binding/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jakarta EE 系列（三）Bean Validation 规范与实践总结</title>
      <link href="2020/10/05/jakarta-bean-validation/"/>
      <url>2020/10/05/jakarta-bean-validation/</url>
      
        <content type="html"><![CDATA[<h1 id="Bean-Validation-规范"><a href="#Bean-Validation-规范" class="headerlink" title="Bean Validation 规范"></a>Bean Validation 规范</h1><p>Bean Validation 为 JavaBean 和方法验证定义了一组元数据模型和 API 规范，常用于后端数据的声明式校验。</p><h2 id="RoadMap"><a href="#RoadMap" class="headerlink" title="RoadMap"></a>RoadMap</h2><p>Bean Validation 规范最早在 Oracle Java EE 下维护。</p><p>2017 年 11 月，Oracle 将 Java EE 移交给 Eclipse 基金会。 2018 年 3 月 5 日，Eclipse 基金会宣布 Java EE (Enterprise Edition) 被更名为 Jakarta EE。因此 Bean Validation 规范经历了下面两个阶段：</p><h3 id="JavaEE-Bean-Validation"><a href="#JavaEE-Bean-Validation" class="headerlink" title="JavaEE Bean Validation"></a>JavaEE Bean Validation</h3><blockquote><p>Bean Validation 1.0 (<a href="https://www.jcp.org/en/jsr/detail?id=303" target="_blank" rel="noopener">JSR 303</a>) was the first version of Java’s standard for object validation.</p><p>It was released in 2009 and is part of <a href="https://docs.oracle.com/javaee/6/index.html" target="_blank" rel="noopener">Java EE 6</a>.</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.validation/validation-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0.GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Bean Validation 1.1 (<a href="https://www.jcp.org/en/jsr/detail?id=349" target="_blank" rel="noopener">JSR 349</a>) was finished in 2013. <a href="https://beanvalidation.org/1.1/" target="_blank" rel="noopener">Changes between Bean Validation 1.0 and 1.1</a></p><p>It is part of <a href="https://docs.oracle.com/javaee/7/index.html" target="_blank" rel="noopener">Java EE 7</a>.</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.validation/validation-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Bean Validation 2.0 (<a href="https://www.jcp.org/en/jsr/detail?id=380" target="_blank" rel="noopener">JSR 380</a>) was finished in August 2017. <a href="https://beanvalidation.org/2.0-jsr380/" target="_blank" rel="noopener">Changes between Bean Validation 2.0 and 1.1</a></p><p>It’s part of <a href="https://www.oracle.com/java/technologies/java-ee-8.html" target="_blank" rel="noopener">Java EE 8</a> (but can of course be used with plain Java SE as the previous releases).</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.validation/validation-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Jakarta-Bean-Validation"><a href="#Jakarta-Bean-Validation" class="headerlink" title="Jakarta Bean Validation"></a>Jakarta Bean Validation</h3><blockquote><p><a href="https://jakarta.ee/specifications/bean-validation/2.0/" target="_blank" rel="noopener">Jakarta Bean Validation 2.0</a> was published in August 2019. There are no changes between Jakarta Bean Validation 2.0 and Bean Validation 2.0 except for the GAV: it is now <code>jakarta.validation:jakarta.validation-api</code>.</p><p>It’s part of <a href="https://projects.eclipse.org/releases/jakarta-ee-8" target="_blank" rel="noopener">Jakarta EE 8</a> (but can of course be used with plain Java SE as the previous releases).</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/jakarta.validation/jakarta.validation-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://jakarta.ee/specifications/bean-validation/3.0/" target="_blank" rel="noopener">Jakarta Bean Validation 3.0</a> was released in Wednesday, October 7, 2020.</p><p>This release is part of <a href="https://projects.eclipse.org/releases/jakarta-ee-9" target="_blank" rel="noopener">Jakarta EE 9</a>.</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/jakarta.validation/jakarta.validation-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jakarta.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jakarta.validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><p>Constraints 约束是 Bean Validation 规范的核心。约束是通过<strong>约束注解</strong>和一系列<strong>约束验证实现</strong>的组合来定义的。约束注解可应用于类型、字段、方法、构造函数、参数、容器元素或其它约束注解。</p><blockquote><p>一个 constraint 通常由 annotation 和相应的 constraint validator 组成，它们是一对多的关系。也就是说可以有多个 constraint validator 对应一个 annotation。在运行时，Bean Validation 框架本身会根据被注释元素的类型来选择合适的 constraint validator 对数据进行验证。</p><p>有些时候，在用户的应用中需要一些更复杂的 constraint。Bean Validation 提供扩展 constraint 的机制。可以通过两种方法去实现，一种是组合现有的 constraint 来生成一个更复杂的 constraint，另外一种是开发一个全新的 constraint。</p></blockquote><p>下表列出了常用 Constraints：</p><h3 id="官方-Constraints"><a href="#官方-Constraints" class="headerlink" title="官方 Constraints"></a>官方 Constraints</h3><p>表 1. Bean Validation 1.x 中内置的 Constraints，更多官方 Constraints 详见官方新版规范：<a href="https://jakarta.ee/specifications/bean-validation/3.0/jakarta-bean-validation-spec-3.0.html" target="_blank" rel="noopener">Jakarta Bean Validation specification</a></p><table><thead><tr><th align="left"><strong>Constraint</strong></th><th align="left"><strong>详细信息</strong></th></tr></thead><tbody><tr><td align="left"><code>@Null</code></td><td align="left">被注释的元素必须为 <code>null</code></td></tr><tr><td align="left"><code>@NotNull</code></td><td align="left">被注释的元素必须不为 <code>null</code></td></tr><tr><td align="left"><code>@AssertTrue</code></td><td align="left">被注释的元素必须为 <code>true</code></td></tr><tr><td align="left"><code>@AssertFalse</code></td><td align="left">被注释的元素必须为 <code>false</code></td></tr><tr><td align="left"><code>@Min(value)</code></td><td align="left">被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td></tr><tr><td align="left"><code>@Max(value)</code></td><td align="left">被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td></tr><tr><td align="left"><code>@DecimalMin(value)</code></td><td align="left">被注释的元素必须是一个数字，其值必须大于等于指定的最小值</td></tr><tr><td align="left"><code>@DecimalMax(value)</code></td><td align="left">被注释的元素必须是一个数字，其值必须小于等于指定的最大值</td></tr><tr><td align="left"><code>@Size(max, min)</code></td><td align="left">被注释的元素的大小必须在指定的范围内</td></tr><tr><td align="left"><code>@Digits (integer, fraction)</code></td><td align="left">被注释的元素必须是一个数字，其值必须在可接受的范围内</td></tr><tr><td align="left"><code>@Past</code></td><td align="left">被注释的元素必须是一个过去的日期</td></tr><tr><td align="left"><code>@Future</code></td><td align="left">被注释的元素必须是一个将来的日期</td></tr><tr><td align="left"><code>@Pattern(value)</code></td><td align="left">被注释的元素必须符合指定的正则表达式</td></tr></tbody></table><h3 id="第三方-Constraints"><a href="#第三方-Constraints" class="headerlink" title="第三方 Constraints"></a>第三方 Constraints</h3><p>表 2. Hibernate Validator 附加的 Constraints，更多 Constraints 详见：<a href="https://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#validator-defineconstraints-hv-constraints" target="_blank" rel="noopener">Additional constraints</a></p><table><thead><tr><th align="left"><strong>Constraint</strong></th><th align="left"><strong>详细信息</strong></th></tr></thead><tbody><tr><td align="left"><code>@Email</code></td><td align="left">被注释的元素必须是电子邮箱地址</td></tr><tr><td align="left"><code>@Length</code></td><td align="left">被注释的字符串的大小必须在指定的范围内</td></tr><tr><td align="left"><code>@NotEmpty</code></td><td align="left">被注释的字符串的必须非空</td></tr><tr><td align="left"><code>@Range</code></td><td align="left">被注释的元素必须在合适的范围内</td></tr></tbody></table><p>其它第三方 Constraints：</p><ul><li><a href="https://github.com/nomemory/java-bean-validation-extension" target="_blank" rel="noopener">Java Bean Validation Extension</a> offers a set of useful constraints (<code>@Alphanumeric</code>, <code>@IPv6</code>, <code>@StartsWith</code>…).</li><li><a href="https://github.com/jirutka/validator-collection" target="_blank" rel="noopener">Collection Validators</a> allows to define constraints on elements of collections.</li><li>……</li></ul><h2 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h2><p>核心类 <a href="https://docs.oracle.com/javaee/7/api/javax/validation/Validation.html" target="_blank" rel="noopener"><code>javax.validation.Validation</code></a> 作为 Bean Validation 的入口点，提供了三种引导方式。下面代码演示了以最简单的方式创建默认的 <a href="https://docs.oracle.com/javaee/7/api/javax/validation/ValidatorFactory.html" target="_blank" rel="noopener"><code>ValidatorFactory</code></a>，并获取 <code>Validator</code> 用以验证 Java Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.experimental.UtilityClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.ConstraintViolation;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Validation;</span><br><span class="line"><span class="keyword">import</span> javax.validation.ValidatorFactory;</span><br><span class="line"><span class="keyword">import</span> javax.validation.Validator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JavaBean 校验器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UtilityClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidatorUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Validator VALIDATOR = Validation.buildDefaultValidatorFactory().getValidator();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 校验参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj 参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 校验结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Set&lt;ConstraintViolation&lt;T&gt;&gt; validate(T obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> VALIDATOR.validate(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及的 API 如下：</p><ul><li><p>核心类 <code>javax.validation.Validation</code>：</p><blockquote><p>Note:</p><ul><li>The <code>ValidatorFactory</code> object built by the bootstrap process should be cached and shared amongst <code>Validator</code> consumers.</li><li>This class is <strong>thread-safe</strong>.</li></ul></blockquote></li><li><p>接口 <code>javax.validation.ValidatorFactory</code>：</p><blockquote><p>Factory returning initialized <code>Validator</code> instances.</p><p>Implementations are <strong>thread-safe</strong> and instances are typically cached and reused.</p></blockquote></li><li><p>接口 <code>javax.validation.Validator</code>：</p><blockquote><p>Validates bean instances. Implementations of this interface must be <strong>thread-safe</strong>.</p></blockquote></li></ul><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="Hibernate-Validator-实现"><a href="#Hibernate-Validator-实现" class="headerlink" title="Hibernate Validator 实现"></a>Hibernate Validator 实现</h2><p>Hibernate 框架提供了各种子项目，如下：</p><p><img src="/img/hibernate/hibernate_projects.png" alt="Hibernate Projects"></p><p>其中，子项目 Hibernate Validator 是 Bean Validation 规范的<strong>官方认证实现</strong>。</p><p>要在 Maven 项目中使用 Hibernate Validator，需要添加如下依赖项：</p><ul><li><p>新版实现，由于该 artifact 已被移至此新 group，6.x 及以上新版建议优先使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>遗留实现，可以下载到 5.x 及之前的老版本，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.4.3.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>Hibernate Validator 版本兼容性如下：</p><table><thead><tr><th>Hibernate Validator</th><th>Java</th><th>Bean Validation 规范</th><th>Expression Language (EL) 规范</th></tr></thead><tbody><tr><td><a href="http://hibernate.org/validator/releases/7.0/" target="_blank" rel="noopener">7.0 series</a></td><td>8 or 11</td><td><a href="https://jakarta.ee/specifications/bean-validation/3.0/" target="_blank" rel="noopener">Jakarta EE 9 - Bean Validation 3.0</a></td><td><a href="https://jakarta.ee/specifications/expression-language/4.0/" target="_blank" rel="noopener">Jakarta EE 9 - Expression Language 4.0</a></td></tr><tr><td><a href="http://hibernate.org/validator/releases/6.0/" target="_blank" rel="noopener">6.1 series</a></td><td>8 or 11</td><td><a href="https://jakarta.ee/specifications/bean-validation/2.0/" target="_blank" rel="noopener">Jakarta EE 8 - Bean Validation 2.0</a></td><td><a href="https://jakarta.ee/specifications/expression-language/3.0/" target="_blank" rel="noopener">Jakarta EE 8 - Expression Language 3.0</a></td></tr><tr><td><a href="http://hibernate.org/validator/releases/5.0/" target="_blank" rel="noopener">5.0 series</a></td><td>6 or 7</td><td><a href="https://beanvalidation.org/1.1/" target="_blank" rel="noopener">JavaEE 7 - Bean Validation 1.1 (JSR 349)</a></td><td>Java EE 7 - Expression Language 3.0 (JSR 341)</td></tr></tbody></table><p>引入 Hibernate Validator 后，将传递依赖 Bean Validation API 规范相应的版本，无需重复引入：</p><blockquote><p>Hibernate’s Jakarta Bean Validation reference implementation. This transitively pulls in the dependency to the Bean Validation API.</p></blockquote><p>详见 <a href="https://repo1.maven.org/maven2/org/hibernate/" target="_blank" rel="noopener">/org/hibernate</a> 该子项目 parent pom.xml 的版本号定义</p><h2 id="Dubbo-参数验证"><a href="#Dubbo-参数验证" class="headerlink" title="Dubbo 参数验证"></a>Dubbo 参数验证</h2><p><a href="https://dubbo.apache.org/zh/docs/v2.7/user/examples/parameter-validation/" target="_blank" rel="noopener">https://dubbo.apache.org/zh/docs/v2.7/user/examples/parameter-validation/</a></p><h2 id="Spring-MVC-参数验证"><a href="#Spring-MVC-参数验证" class="headerlink" title="Spring MVC 参数验证"></a>Spring MVC 参数验证</h2><p><a href="/2016/06/25/spring-mvc/#方法参数验证">参考：Spring MVC 方法参数验证</a></p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="缺少依赖"><a href="#缺少依赖" class="headerlink" title="缺少依赖"></a>缺少依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HV000183: Unable to load &#39;javax.el.ExpressionFactory&#39;. Check that you have the EL dependencies on the classpath, or use ParameterMessageInterpolator instead</span><br></pre></td></tr></table></figure><p>原因：缺少 <code>Unified Expression Language (EL)</code> 规范的实现依赖，即 Glassfish。</p><p>如果查看 Hibernate Validator 的 pom.xml，会发现该依赖被声明为 <code>provided</code>（如下），表示该依赖在运行时由 Java EE container 容器提供，因此无须重复引入。而对于 Spring Boot 应用来说，则需要添加此依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解决方案详见如下：</p><blockquote><p>Hibernate Validator also requires an implementation of the Unified Expression Language (<a href="http://jcp.org/en/jsr/detail?id=341" target="_blank" rel="noopener">JSR 341</a>) for evaluating dynamic expressions in constraint violation messages.</p><p>When your application runs in a Java EE container such as <a href="http://wildfly.org/" target="_blank" rel="noopener">WildFly</a>, an EL implementation is already provided by the container.</p><p>In a Java SE environment, however, you have to add an implementation as dependency to your POM file. For instance, you can add the following dependency to use the JSR 341 reference implementation:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.glassfish&lt;&#x2F;groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;jakarta.el&lt;&#x2F;artifactId&gt;</span><br><span class="line">     &lt;version&gt;$&#123;version.jakarta.el-api&#125;&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></blockquote><p>注意，要使用与 Hibernate Validator 匹配的 <code>Unified Expression Language (EL)</code> 的依赖版本，详见《Hibernate Validator 版本兼容性》。</p><p>参考：<a href="https://stackoverflow.com/questions/24386771/javax-validation-validationexception-hv000183-unable-to-load-javax-el-express" target="_blank" rel="noopener">https://stackoverflow.com/questions/24386771/javax-validation-validationexception-hv000183-unable-to-load-javax-el-express</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.oracle.com/javaee/7/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javaee/7/index.html</a></p><p><a href="https://docs.oracle.com/javaee/7/api/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javaee/7/api/index.html</a></p><p><a href="https://jakarta.ee/" target="_blank" rel="noopener">https://jakarta.ee/</a></p><p><a href="https://jakarta.ee/specifications/bean-validation/" target="_blank" rel="noopener">https://jakarta.ee/specifications/bean-validation/</a></p><p><a href="https://beanvalidation.org/" target="_blank" rel="noopener">https://beanvalidation.org/</a></p><p><a href="http://hibernate.org/validator/" target="_blank" rel="noopener">http://hibernate.org/validator/</a></p><p><a href="https://blog.csdn.net/qq2413273056/article/details/84378194" target="_blank" rel="noopener">后台表单校验（JSR303）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jakarta EE 系列（二）Annotations 通用注解规范总结</title>
      <link href="2020/10/03/jakarta-annotations/"/>
      <url>2020/10/03/jakarta-annotations/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Jakarta Annotations defines a collection of annotations representing common semantic concepts that enable a declarative style of programming that applies across a variety of Java technologies.</p></blockquote><p>通过在 Java 平台中添加 JSR 175（Java 编程语言的元数据工具），我们设想各种技术将使用注解来实现声明式编程风格。如果这些技术各自为共同概念独立定义自己的注解，那将是不幸的。在 Jakarta EE 和 Java SE 组件技术中保持一致性很有价值，但在 Jakarta EE 和 Java SE 之间实现一致性也很有价值。</p><p>本规范的目的是定义一小组通用注解，这些注解可在其它规范中使用。希望这将有助于避免在不同 Jakarta EE 规范中定义的注解之间不必要的冗余或重复。这将允许我们将通用注解集中在一个地方，让技术引用此规范，而不是在多个规范中指定它们。这样，所有技术都可以使用相同版本的注解，并且跨平台使用的注解将保持一致。</p><p>这些通用注解详见如下：</p><ul><li><a href="https://jakarta.ee/specifications/annotations/1.3/apidocs/" target="_blank" rel="noopener">javax.annotation</a></li><li><a href="https://jakarta.ee/specifications/annotations/2.0/apidocs/" target="_blank" rel="noopener">jakarta.annotation</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jakarta EE 系列（一）Web 技术的相关规范总结</title>
      <link href="2020/10/01/jakarta-web/"/>
      <url>2020/10/01/jakarta-web/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>Specifications</th><th>Description</th><th>Compatible Implementations</th></tr></thead><tbody><tr><td><a href="https://jakarta.ee/specifications/servlet/" target="_blank" rel="noopener">Jakarta Servlet</a></td><td>A server-side API for handling HTTP requests and responses</td><td><a href="https://eclipse-ee4j.github.io/glassfish/" target="_blank" rel="noopener">Eclipse GlassFish</a></td></tr><tr><td><a href="https://jakarta.ee/specifications/pages/" target="_blank" rel="noopener">Jakarta Server Pages (JSP)</a></td><td>Defines a template engine for web applications</td><td><a href="https://eclipse-ee4j.github.io/glassfish/" target="_blank" rel="noopener">Eclipse GlassFish</a></td></tr><tr><td><a href="https://jakarta.ee/specifications/tags/" target="_blank" rel="noopener">Jakarta Standard Tag Library (JSTL)</a></td><td>Provides a set of tags to simplify the JSP development</td><td><a href="https://eclipse-ee4j.github.io/glassfish/" target="_blank" rel="noopener">Eclipse GlassFish</a></td></tr><tr><td><a href="https://jakarta.ee/specifications/expression-language/" target="_blank" rel="noopener">Jakarta Expression Language (EL)</a></td><td>Defines an expression language for Java applications</td><td><a href="https://eclipse-ee4j.github.io/el-ri/" target="_blank" rel="noopener">Eclipse Expression Language</a></td></tr><tr><td><a href="https://jakarta.ee/specifications/faces/" target="_blank" rel="noopener">Jakarta Server Faces (JSF)</a></td><td>MVC framework for building user interfaces for web apps</td><td><a href="https://eclipse-ee4j.github.io/mojarra/" target="_blank" rel="noopener">Eclipse Mojarra</a></td></tr><tr><td><a href="https://jakarta.ee/specifications/mvc/" target="_blank" rel="noopener">Jakarta MVC</a></td><td>Standardizes the action-based model-view-controller pattern</td><td><a href="https://eclipse-ee4j.github.io/krazo/" target="_blank" rel="noopener">Eclipse Krazo</a></td></tr><tr><td><a href="https://jakarta.ee/specifications/restful-ws/" target="_blank" rel="noopener">Jakarta RESTful Web Services (JAX-RS)</a></td><td>API to develop web services following the REST pattern</td><td><a href="https://eclipse-ee4j.github.io/jersey/" target="_blank" rel="noopener">Eclipse Jersey</a></td></tr><tr><td><a href="https://jakarta.ee/specifications/enterprise-ws/" target="_blank" rel="noopener">Jakarta Enterprise Web Services</a></td><td>Web Services for Jakarta EE architecture</td><td><a href="https://eclipse-ee4j.github.io/glassfish/" target="_blank" rel="noopener">Eclipse GlassFish</a></td></tr><tr><td><a href="https://jakarta.ee/specifications/websocket/" target="_blank" rel="noopener">Jakarta WebSocket</a></td><td>API for Server and Client Endpoints for WebSocket protocol</td><td><a href="https://eclipse-ee4j.github.io/tyrus/" target="_blank" rel="noopener">Eclipse Tyrus</a></td></tr><tr><td>……</td><td></td><td></td></tr></tbody></table><p>一点关于 EL 的历史：</p><blockquote><p>Expression Language (EL) 最初受到 ECMAScript 和 XPath 表达式语言的启发。在其成立之初，参与的专家非常不愿意设计另一种表达语言，并试图使用这些语言中的每一种，但他们在不同的领域都有所欠缺。</p><p>因此，JSP Standard Tag Library (JSTL) version 1.0 (based on JSP 1.2) 首先引入了一种表达式语言，使前端页面开发者可以轻松访问和操作应用程序数据，而无需掌握如 Java、JavaScript 等编程语言相关的复杂性。</p><p>鉴于其成功，EL 随后被移入 JSP 规范（JSP 2.0/JSTL 1.1），使其在 JSP 页面中普遍可用（而不仅仅用于 JSTL 标记库的属性）。</p><p>JavaServer Faces 1.0 定义了用于构建用户界面组件的标准框架，并且构建在 JSP 1.2 技术之上。由于 JSP 1.2 技术没有集成的表达语言，并且 JSP 2.0 EL 不能满足 Faces 的所有需求，因此为 Faces 1.0 开发了一个 EL 变体。Faces 专家组试图使该语言尽可能与 JSP 2.0 兼容，但是还是有一些区别。</p><p>显然需要一种单一、统一的表达语言来满足各种 Web 层技术的需求。因此，Faces 和 JSP 专家组共同制定了统一表达式语言的规范，该规范在 JSR 245 中定义，并在 JSP 2.1 和 Faces 1.2 版本中生效。</p><p>JSP/JSTL/Faces 专家组也意识到 EL 的用处超出了他们自己的规范。3.0 规范是第一个将表达式语言定义为独立规范的 JSR，不依赖于其它技术。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="/2015/05/01/java-jsp/">JSP 标签总结</a></p><p><a href="/2015/05/02/java-jstl/">JSP 标准标签库（JSTL）总结</a></p><p><a href="/2015/05/03/java-el/">JSP EL 表达式总结</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 学习资源总结</title>
      <link href="2020/09/15/java/"/>
      <url>2020/09/15/java/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.oracle.com/en/java/index.html" target="_blank" rel="noopener">Java Documentation</a></p><h1 id="Standard-Edition"><a href="#Standard-Edition" class="headerlink" title="Standard Edition"></a>Standard Edition</h1><p><a href="https://docs.oracle.com/en/java/javase/index.html" target="_blank" rel="noopener">Java Platform, Standard Edition Documentation</a></p><h2 id="Roadmap"><a href="#Roadmap" class="headerlink" title="Roadmap"></a>Roadmap</h2><p>详见：<a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html" target="_blank" rel="noopener">Oracle Java SE Support Roadmap</a></p><table><thead><tr><th align="left">Release</th><th align="left">GA Date</th><th align="left">Premier Support Until</th><th align="left">Extended Support Until</th><th align="left">Sustaining Support</th></tr></thead><tbody><tr><td align="left">6</td><td align="left">December 2006</td><td align="left">December 2015</td><td align="left">December 2018</td><td align="left">Indefinit</td></tr><tr><td align="left">7</td><td align="left">July 2011</td><td align="left">July 2019</td><td align="left">July 2022*****</td><td align="left">Indefinite</td></tr><tr><td align="left">8﻿**</td><td align="left">March 2014</td><td align="left">March 2022</td><td align="left">December 2030*****</td><td align="left">Indefinite</td></tr><tr><td align="left">9 (non‑LTS)</td><td align="left">September 2017</td><td align="left">March 2018</td><td align="left">Not Available</td><td align="left">Indefinite</td></tr><tr><td align="left">10 (non‑LTS)</td><td align="left">March 2018</td><td align="left">September 2018</td><td align="left">Not Available</td><td align="left">Indefinite</td></tr><tr><td align="left">11 (LTS)</td><td align="left">September 2018</td><td align="left">September 2023</td><td align="left">September 2026</td><td align="left">Indefinite</td></tr><tr><td align="left">12 (non‑LTS)</td><td align="left">March 2019</td><td align="left">September 2019</td><td align="left">Not Available</td><td align="left">Indefinite</td></tr><tr><td align="left">13 (non‑LTS)</td><td align="left">September 2019</td><td align="left">March 2020</td><td align="left">Not Available</td><td align="left">Indefinite</td></tr><tr><td align="left">14 (non‑LTS)</td><td align="left">March 2020</td><td align="left">September 2020</td><td align="left">Not Available</td><td align="left">Indefinite</td></tr><tr><td align="left">15 (non‑LTS)</td><td align="left">September 2020</td><td align="left">March 2021</td><td align="left">Not Available</td><td align="left">Indefinite</td></tr><tr><td align="left">16 (non-LTS)</td><td align="left">March 2021</td><td align="left">September 2021</td><td align="left">Not Available</td><td align="left">Indefinite</td></tr><tr><td align="left">17 (LTS)</td><td align="left">September 2021***</td><td align="left">September 2026****</td><td align="left">September 2029****</td><td align="left">Indefinite</td></tr></tbody></table><p><img src="/img/java/basics/java_2019Q3_graph.png" alt=""></p><h2 id="Java-SE-8"><a href="#Java-SE-8" class="headerlink" title="Java SE 8"></a>Java SE 8</h2><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/" target="_blank" rel="noopener">Java Platform, Standard Edition (Java SE) Overview</a></p><p>Reference</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener">Java SE API Documentation</a></li><li><a href="http://www.oracle.com/pls/topic/lookup?ctx=javase80&id=JFXAP" target="_blank" rel="noopener">JavaFX API Documentation</a></li><li><a href="https://docs.oracle.com/javase/8/docs/index.html" target="_blank" rel="noopener">Developer Guides</a></li><li><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">Java Language and Virtual Machine Specifications</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/index.html" target="_blank" rel="noopener">Java SE Tools Reference for UNIX</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/index.html" target="_blank" rel="noopener">Java SE Tools Reference for Windows</a></li></ul><blockquote><p>Oracle has two products that implement Java Platform Standard Edition (Java SE) 8: </p><ul><li><p>Java SE Development Kit (JDK) 8. JDK 8 is a superset of JRE 8, and contains everything that is in JRE 8, plus tools such as the compilers and debuggers necessary for developing applets and applications. </p></li><li><p>Java SE Runtime Environment (JRE) 8. JRE 8 provides the libraries, the Java Virtual Machine (JVM), and other components to run applets and applications written in the Java programming language. Note that the JRE includes components not required by the Java SE specification, including both standard and non-standard Java components.</p></li></ul><p>The following conceptual diagram illustrates the components of Oracle’s Java SE products:</p></blockquote><p><img src="/img/java/basics/description_of_java_conceptual_diagram.png" alt="Description of Java Conceptual Diagram"></p><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>一些术语：</p><blockquote><ul><li><a href="https://www.jcp.org/en/home/index" target="_blank" rel="noopener">JCP</a> 是 Java Community Process（Java社区进程）的简称，社会各界组成的 Java 社区，规划和领导 Java 的发展。</li><li><a href="https://www.jcp.org/en/jsr/all" target="_blank" rel="noopener">JSR</a> 是 Java Specification Requests（Java 规范请求）的简称，是  JCP 成员向委员会提交的 Java 发展议案，经过一系列流程后，如果通过会成为 JEP，最终会体现在未来的 Java 中。</li><li><a href="http://openjdk.java.net/jeps/0" target="_blank" rel="noopener">JEP</a> 是 JDK Enhancement Proposals （Java 增强提案）的简称，为了保证日后 JDK 研发能够更加顺利地进行，从 JDK 8 开始，Oracle 启用 JEP 来定义和管理纳入新版 JDK 发布范围的功能特性。JDK 的版本变化将从这些提案中选取。例如：<ul><li><a href="http://openjdk.java.net/projects/coin" target="_blank" rel="noopener">Project Coin</a>：目标是确定应向 JDK 7 中添加哪些小的语言特性。</li><li><a href="http://openjdk.java.net/projects/amber" target="_blank" rel="noopener">Project Amber</a>：目标是探索和孵化较小的、面向生产力的 Java 语言特性。</li><li><a href="http://openjdk.java.net/projects/loom" target="_blank" rel="noopener">Project Loom</a>：</li><li><a href="http://openjdk.java.net/projects/valhalla" target="_blank" rel="noopener">Project Valhalla</a>：</li><li><a href="http://openjdk.java.net/projects/panama" target="_blank" rel="noopener">Project Panama</a>：</li><li>……</li></ul></li></ul></blockquote><p>一点历史：</p><blockquote><p>JDK 从 1.5 版本开始，在官方的正式文档与宣传资料中已经不再使用类似“JDK 1.5”的名称，只有程序员内部使用的开发版本号（Developer Version，例如 java -version 的输出）才继续沿用 1.5、1.6 和 1.7 的版本号（JDK 10 之后又改为了采用年份加月份作为开发版本号，例如 18.3），而公开版本号（Product Version）则改为 JDK 5、JDK 6 和 JDK 7 的命名方式。</p><p>从 JDK 10 开始，每年的 3 月和 9 月各发布一个大版本，目的就是避免众多功能特性被集中捆绑到一个 JDK 版本上而引发交付风险。同时为了降低维护成本，每六个 JDK 大版本中才会被划出一个长期支持（Long Term Suppot，LTS）版本，只有 LTS 版的 JDK 能够获得为期三年的支持和更新，普通版的 JDK 就只有短短六个月的生命周期。</p><p>JDK 8 和 JDK 11 是 LTS 版本，再下一个就到 2021 年发布的 JDK 17。</p></blockquote><p>常见 JDK 版本：</p><ul><li><p>OracleJDK 商业版</p><blockquote><p>OTN 协议下发行的传统的 OracleJDK，个人可以免费使用，但若在生产环境中商用就必须付费，可以有三年时间的更新支持。</p></blockquote></li><li><p><a href="http://openjdk.java.net/" target="_blank" rel="noopener">OpenJDK</a> 开源版</p><blockquote><p>GPLv2+CE 协议下由 Oracle 发行的 OpenJDK，可以免费在开发、测试、生产环境中使用，但是只有半年时间的更新支持。</p><p>由于 Oracle 不愿意在旧版本的 OpenJDK 上继续耗费资源，而 RedHat (IBM) 又乐意扩大自己在 Java 社区的影响力，因此 RedHat 代替 Oracle 成为了 OpenJDK 历史版本的维护者，接过了 OpenJDK 6、7、8、11 的管理权力和维护职责。</p></blockquote></li><li><p>OpenJDK 的变种版本：</p><ul><li><p><a href="https://adoptopenjdk.net/" target="_blank" rel="noopener">AdoptOpenJDK builds</a></p></li><li><p>AdoptOpenJDK OpenJ9 builds</p><blockquote><p>除了标准的 OpenJDK 构建外，AdoptOpenJDK 还提供了使用 OpenJ9 而非 HotSpot 的版本。OpenJ9 最初是由 IBM 实现的 JVM，现在已开源并交由 Eclipse 运作。</p></blockquote></li><li><p><a href="https://developers.redhat.com/products/openjdk/overview" target="_blank" rel="noopener">Red Hat build of OpenJDK</a></p></li><li><p><a href="https://www.aliyun.com/product/dragonwell" target="_blank" rel="noopener">Alibaba Dragonwell</a></p></li><li><p><a href="https://www.azul.com/" target="_blank" rel="noopener">Azul Zulu</a></p></li><li><p><a href="https://github.com/Tencent/TencentKona-8" target="_blank" rel="noopener">Tencent Kona 8</a>、<a href="https://github.com/Tencent/TencentKona-11" target="_blank" rel="noopener">Tencent Kona 11</a></p></li><li><p>…</p></li></ul></li></ul><p>参考《<a href="https://github.com/JavaMilk/JDKHistory" target="_blank" rel="noopener">JDK 历代版本变化</a>》</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>除了官方 HotSpotVM、GraalVM 实现，其它厂商实现如下：</p><p><img src="/img/java/jvm/jvm_impl.png" alt=""></p><h1 id="Enterprise-Edition"><a href="#Enterprise-Edition" class="headerlink" title="Enterprise Edition"></a>Enterprise Edition</h1><h2 id="Roadmap-1"><a href="#Roadmap-1" class="headerlink" title="Roadmap"></a>Roadmap</h2><p>作为分水岭，2017 年 11 月，Oracle 将 Java EE 移交给 Eclipse 基金会。 2018 年 3 月 5 日，Eclipse 基金会宣布 Java EE (Enterprise Edition) 被更名为 Jakarta EE。</p><p>参考：《<a href="https://www.infoq.cn/article/62TVY0c7ANAm*rjdzKfj" target="_blank" rel="noopener">Java EE 规范重命名为 Jakarta EE</a>》</p><ul><li>Jakarta 9（2019 及以后）使用 jakarta 命名空间。</li><li>Java EE 5（2005）到 Java EE 8（2017）使用 javax 命名空间。</li><li>Java EE 4 使用 javax 命名空间。</li></ul><table><thead><tr><th>规范</th><th>创建组织</th></tr></thead><tbody><tr><td>Java EE 1.3 (JSR-058)</td><td>Java Community Process</td></tr><tr><td>Java EE 1.4 (JSR-151)</td><td>Java Community Process</td></tr><tr><td><a href="https://docs.oracle.com/javaee/5/" target="_blank" rel="noopener">Java EE 5 (JSR-244)</a></td><td>Java Community Process</td></tr><tr><td><a href="https://docs.oracle.com/javaee/6/" target="_blank" rel="noopener">Java EE 6 (JSR-316)</a></td><td>Java Community Process</td></tr><tr><td><a href="https://docs.oracle.com/javaee/7/index.html" target="_blank" rel="noopener">Java EE 7 (JSR-342)</a></td><td>Java Community Process</td></tr><tr><td>Java EE 8 (JSR-366)</td><td>Java Community Process</td></tr><tr><td><a href="https://jakarta.ee/release/8/" target="_blank" rel="noopener">Jakarta EE 8</a></td><td>Jakarta EE Platform Specification Project with guidance provided by the <a href="https://jakarta.ee/" target="_blank" rel="noopener">Jakarta EE Working Group</a></td></tr><tr><td><a href="https://jakarta.ee/release/9/" target="_blank" rel="noopener">Jakarta EE 9</a></td><td>Jakarta EE Platform Specification Project with guidance provided by the <a href="https://jakarta.ee/" target="_blank" rel="noopener">Jakarta EE Working Group</a></td></tr></tbody></table><h2 id="Java-EE"><a href="#Java-EE" class="headerlink" title="Java EE"></a>Java EE</h2><p>Java Platform, Enterprise Edition</p><h2 id="Jakarta-EE"><a href="#Jakarta-EE" class="headerlink" title="Jakarta EE"></a>Jakarta EE</h2><p><a href="https://projects.eclipse.org/list-of-projects" target="_blank" rel="noopener">Eclipse Foundation Projects</a></p><ul><li><a href="https://projects.eclipse.org/projects/ee4j" target="_blank" rel="noopener">Eclipse EE4J</a></li><li><a href="https://jakarta.ee/specifications/" target="_blank" rel="noopener">https://jakarta.ee/specifications/</a></li></ul><h3 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h3><p>Jakarta EE 平台的架构关系如下图所示。（请注意，此图显示了元素间的逻辑关系；它并不意味着将元素间物理关系为单独的机器、进程、地址空间或虚拟机。）</p><p>下面分别描述每个矩形及其之间的关系：</p><ul><li>容器（如 Web Container）作为 Jakarta EE 运行时环境，为 Application Components（如 Server Pages、Servlet）提供所需服务；</li><li>而所提供的服务，由矩形下半部分的方框表示。例如， Web Container 为 Servlet 提供了 Bean Validation API。详见 <a href="https://jakarta.ee/specifications/platform/9/jakarta-platform-spec-9.html#a84" target="_blank" rel="noopener">Jakarta EE 标准服务</a>。</li><li>Java SE 的 API 受 Java SE 运行时环境（JRE）的支持，适用于每种类型的 Application Components。</li><li>箭头表示需要访问 Jakarta EE 平台的其它部分。例如，Web Container 通过 JDBC™ API 为 Server Pages、Servlet 提供数据库访问能力。</li></ul><p><img src="/img/java/basics/Jakarta_EE_Architecture_Diagram.svg" alt="Jakarta EE Architecture Diagram"></p><h3 id="Application-Components"><a href="#Application-Components" class="headerlink" title="Application Components"></a>Application Components</h3><p>Jakarta EE 运行时环境定义了 Jakarta EE 产品必须支持的四种 Application Components 类型：</p><table><thead><tr><th>Application Components</th><th>描述</th></tr></thead><tbody><tr><td>Application clients</td><td>通常是在台式计算机上执行的 GUI 程序。提供类似于本机应用程序的用户体验，并且可以访问 Jakarta EE 中间层的所有设施。</td></tr><tr><td>Applets</td><td>通常是在 Web 浏览器中执行的 GUI 组件，但也可以在支持 Applet 编程模型的各种其它应用程序或设备中执行。</td></tr><tr><td>Web Components (<a href="https://jakarta.ee/specifications/servlet/" target="_blank" rel="noopener">Servlets</a>, <a href="https://jakarta.ee/specifications/pages/" target="_blank" rel="noopener">Server Pages</a>, <a href="https://jakarta.ee/specifications/faces/" target="_blank" rel="noopener">Server Faces</a> Applications, Filters, and Web Event Listeners)</td><td>通常在 Web 容器中执行，并可能响应来自 Web 客户端的 HTTP 请求。</td></tr><tr><td><a href="https://jakarta.ee/specifications/enterprise-beans/" target="_blank" rel="noopener">Enterprise Beans</a></td><td>在支持事务的托管环境中执行。可以使用 SOAP/HTTP 协议直接提供 Web 服务。</td></tr></tbody></table><h3 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h3><p>容器为 Jakarta EE Application Components 提供运行时支持。</p><p>容器为 Application Components 提供了一套底层 Jakarta EE API 的联合视图。Jakarta EE Application Components 从不直接与其它  Jakarta EE  Application Components 交互。它们使用容器的协议和方法来相互交互以及与平台服务交互。在 Application Components 和  Jakarta EE 服务之间插入一个容器，可以使该容器透明地注入该组件所需的服务，例如声明式事务管理，安全检查，资源池和状态管理。</p><blockquote><p>This specification requires that containers provide a Java Compatible™ runtime environment, as defined by the Java Platform, Standard Edition, v8 specification (Java SE).</p></blockquote><h3 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h3><blockquote><p>The Jakarta EE platform requires a database, accessible through the JDBC API, for the storage of business data. The database is accessible from:</p><ul><li>Web Components</li><li>Enterprise Beans</li><li>Application clients</li></ul></blockquote><h3 id="Jakarta-EE-Standard-Services"><a href="#Jakarta-EE-Standard-Services" class="headerlink" title="Jakarta EE Standard Services"></a>Jakarta EE Standard Services</h3><p><a href="https://jakarta.ee/specifications/platform/9/jakarta-platform-spec-9.html#a84" target="_blank" rel="noopener">https://jakarta.ee/specifications/platform/9/jakarta-platform-spec-9.html#a84</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>教程：</p><ul><li><p><a href="https://www.tutorialspoint.com/java8/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/java8/index.htm</a></p></li><li><p><a href="https://www.tutorialspoint.com/java9/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/java9/index.htm</a></p></li><li><p><a href="https://www.tutorialspoint.com/java/lang/java_lang_interfaces.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/java/lang/java_lang_interfaces.htm</a></p></li><li><p><a href="https://www.tutorialspoint.com/java/util/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/java/util/index.htm</a></p></li><li><p><a href="https://www.tutorialspoint.com/java_generics/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/java_generics/index.htm</a></p></li><li><p><a href="https://www.tutorialspoint.com/java_concurrency/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/java_concurrency/index.htm</a></p></li></ul><p>《<a href="https://www.infoq.cn/article/is-java-out-of-date/" target="_blank" rel="noopener">Java 老矣，尚能饭否？——2017 Java 9 语言的发展现状以及未来</a>》</p><p>《<a href="https://www.infoq.cn/article/WomHORGulYaYEDYwoiP8" target="_blank" rel="noopener">2019 中国 Java 发展趋势报告</a>》</p><blockquote><p>Java 作为使用最为广泛的语言，最近几年还是有比较大进步的，无论从语法的易用性上还是性能上都有很大程度的提升。吸收了函数式编程的思想，lambda 表达式、Parallem stream、Var 变量等提升了开发人员的效率与代码的简洁性。ZGC 无疑是一项重大的改进，在一定程度上解决了 Java 天生的 GC 延迟问题。</p><p>Java 的编程复杂度并没有明显的降低，比如 I/O 处理、并发 / 并⾏计算，以及类加载等等。再者是 Java 与操作系统之间的交互仍不够充分，尽管 Java 9 开始提供了不少的 API，然⽽了解和使用的群体不⾜。Java 在这方面明显不及 GO 语言。</p><p>从语⾔层⾯来看，Java 正在向主流非 Java 语⾔融合，解决其中鸿沟的关键是<strong>语法的变化</strong>，比如 Java 8 的 Lambda 表达式 和 Java 10 的局部变量类型（ <code>var</code> ）等。个人认为这是一件好事，未来前后端不分家，相互渗透，对于彼此语言都是良性。</p></blockquote><p>《<a href="https://segmentfault.com/a/1190000021906788" target="_blank" rel="noopener">2020年 JVM 生态报告解读</a>》</p><p>《<a href="https://www.infoq.cn/article/YgPRotsrI1qSr8cxRGlq" target="_blank" rel="noopener">Java 的新未来：逐渐“Kotlin 化”</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式编程系列（三）Reactor Operator API 总结</title>
      <link href="2020/08/25/java-reactor-api/"/>
      <url>2020/08/25/java-reactor-api/</url>
      
        <content type="html"><![CDATA[<p>Reactive Streams 规范并未提供任何运算符（Operators），而 Reactor 框架的核心价值之一就是提供了丰富的运算符。从简单的转换、过滤到复杂的编排和错误处理，涉及方方面面。</p><p>推荐通过参考文档而不是 JavaDoc 来学习 Mono/Flux API 和 Operator 操作符。参考：<a href="https://projectreactor.io/docs/core/release/reference/docs/index.html#which-operator" target="_blank" rel="noopener">“which operator do I need?” appendix</a></p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>使用 Reactor API 时，有以下几个注意点：</p><p>一、每个 Operator API 都会返回新实例</p><blockquote><p>在 Reactor 中，操作符（Operators）好比流水线中的工作站。 每个操作符都会向 <code>Publisher</code> 添加行为，并将上一步的 <code>Publisher</code>  包装成<strong>新实例</strong>。因而，整个链就被串起来，数据从第一个  <code>Publisher</code>   开始，沿着链向下移动，通过每个链接进行转换。最终，<code>Subscriber</code> 结束该流程。 注意，直到 <code>Subscriber</code> 订阅 <code>Publisher</code> 为止，什么都不会发生。</p><p>理解操作符会创建新实例这一行为，有助于避免一些常见错误，详见：<a href="https://projectreactor.io/docs/core/release/reference/#faq.chain" target="_blank" rel="noopener">I Used an Operator on my Flux but it Doesn’t Seem to Apply. What Gives?</a></p></blockquote><p>二、Nothing Happens Until You <code>subscribe()</code></p><blockquote><p>Reactor 中，当您编写 <code>Publisher</code> 链时，仅用于描述异步处理的抽象过程，默认情况下数据不会开始处理。只有通过订阅，将 <code>Publisher</code> 与 <code>Subscriber</code> 绑定在一起时，才能触发整个链中的数据流处理。这是由其内部实现方式决定的：<code>Subscriber</code> 发出<strong>请求信号</strong>并向上传播，直到源 <code>Publisher</code>。</p></blockquote><p><img src="/img/java/reactive-stream/reactive-stream/org.reactivestream_api.png" alt="org.reactivestream_api"></p><p>详见：<a href="https://projectreactor.io/docs/core/release/reference/index.html#faq.chain" target="_blank" rel="noopener">C.2. I Used an Operator on my <code>Flux</code> but it Doesn’t Seem to Apply. What Gives?</a></p><p>三、使用背压（Backpressure）进行流量控制</p><blockquote><p>Propagating signals upstream is also used to implement <strong>backpressure</strong>, which we described in the assembly line analogy as a feedback signal sent up the line when a workstation processes more slowly than an upstream workstation.</p><p>The real mechanism defined by the Reactive Streams specification is pretty close to the analogy: A subscriber can work in <em>unbounded</em> mode and let the source push all the data at its fastest achievable rate or it can use the <code>request</code> mechanism to signal the source that it is ready to process at most <code>n</code> elements.</p><p>Intermediate operators can also change the request in-transit. Imagine a <code>buffer</code> operator that groups elements in batches of ten. If the subscriber requests one buffer, it is acceptable for the source to produce ten elements. Some operators also implement <strong>prefetching</strong> strategies, which avoid <code>request(1)</code> round-trips and is beneficial if producing the elements before they are requested is not too costly.</p><p>This transforms the push model into a <strong>push-pull hybrid</strong>, where the downstream can pull n elements from upstream if they are readily available. But if the elements are not ready, they get pushed by the upstream whenever they are produced.</p></blockquote><h1 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h1><p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html</a></p><blockquote><p>for [0|1] elements</p></blockquote><p><img src="/img/java/reactive-stream/reactor/mono/mono.svg" alt="mono"></p><h2 id="创建-Mono-流"><a href="#创建-Mono-流" class="headerlink" title="创建 Mono 流"></a>创建 Mono 流</h2><p><img src="/img/java/reactive-stream/reactor/mono/mono_create.png" alt="mono_create"></p><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><blockquote><p>Each operator adds behavior to a <code>Publisher</code> and wraps the previous step’s <code>Publisher</code> into a new instance. The whole chain is thus linked, such that data originates from the first <code>Publisher</code> and moves down the chain, transformed by each link. Eventually, a <code>Subscriber</code> finishes the process. Remember that nothing happens until a <code>Subscriber</code> subscribes to a <code>Publisher</code>.</p><p>While the Reactive Streams specification does not specify operators at all, one of the best added values of reactive libraries, such as Reactor, <strong>is the rich vocabulary of operators</strong> that they provide. These cover a lot of ground, from simple transformation and filtering to complex orchestration and error handling.</p></blockquote><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>常用的如下：</p><ul><li><p>I want to transform existing data:</p><ul><li><p>on a 1-to-1 basis (eg. strings to their length): <code>map</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#map-java.util.function.Function-" target="_blank" rel="noopener">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#map-java.util.function.Function-" target="_blank" rel="noopener">Mono</a>)</p><ul><li>…by just casting it: <code>cast</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cast-java.lang.Class-" target="_blank" rel="noopener">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#cast-java.lang.Class-" target="_blank" rel="noopener">Mono</a>)</li><li>…in order to materialize each source value’s index: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#index--" target="_blank" rel="noopener">Flux#index</a></li></ul></li><li><p>on a 1-to-n basis (eg. strings to their characters): <code>flatMap</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-" target="_blank" rel="noopener">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMap-java.util.function.Function-" target="_blank" rel="noopener">Mono</a>) + use a factory method</p></li><li><p>running an asynchronous task for each source item (eg. urls to http request): <code>flatMap</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-" target="_blank" rel="noopener">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMap-java.util.function.Function-" target="_blank" rel="noopener">Mono</a>) + an async <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true" target="_blank" rel="noopener">Publisher</a>-returning method</p><ul><li><p>…ignoring some data: conditionally return a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#empty--" target="_blank" rel="noopener">Mono.empty()</a> in the flatMap lambda</p></li><li><p>…retaining the original sequence order: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-" target="_blank" rel="noopener">Flux#flatMapSequential</a> (this triggers the async processes immediately but reorders the results)</p></li><li><p>…where the async task can return multiple values, from a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html" target="_blank" rel="noopener">Mono</a> source: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMapMany-java.util.function.Function-" target="_blank" rel="noopener">Mono#flatMapMany</a></p><ul><li><pre><code class="java"><span class="comment">// Mono 转 Flux</span><span class="comment">// Create a Flux that emits the items contained in the provided Iterable. A new iterator will be created for each subscriber.</span>Mono#flatMapMany(Flux::fromIterable)</code></pre></li></ul></li></ul></li></ul></li><li><p>I want to add pre-set elements to an existing sequence:</p><ul><li>at the start: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#startWith-T...-" target="_blank" rel="noopener">Flux#startWith(T…)</a></li><li>at the end: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatWithValues-T...-" target="_blank" rel="noopener">Flux#concatWithValues(T…)</a></li></ul></li><li><p>I want to aggregate a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html" target="_blank" rel="noopener">Flux</a>: (the <code>Flux#</code> prefix is assumed below)</p><ul><li><p>into a List: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectList--" target="_blank" rel="noopener">collectList</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectSortedList--" target="_blank" rel="noopener">collectSortedList</a></p></li><li><p>into a Map: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectMap-java.util.function.Function-" target="_blank" rel="noopener">collectMap</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectMultimap-java.util.function.Function-" target="_blank" rel="noopener">collectMultiMap</a></p></li><li><p>into an arbitrary container: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collect-java.util.stream.Collector-" target="_blank" rel="noopener">collect</a></p></li><li><p>into the size of the sequence: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#count--" target="_blank" rel="noopener">count</a></p></li><li><p>by applying a function between each element (eg. running sum): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#reduce-A-java.util.function.BiFunction-" target="_blank" rel="noopener">reduce</a></p><ul><li><pre><code class="java">Flux.range(<span class="number">0</span>, <span class="number">5</span>)  .reduce(Integer::sum)  <span class="comment">// 两两相加</span>  .map(Objects::toString)  .subscribe(log::info);</code></pre></li><li><p>…but emitting each intermediary value: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#scan-A-java.util.function.BiFunction-" target="_blank" rel="noopener">scan</a></p></li></ul></li><li><p>into a boolean value from a predicate:</p><ul><li>applied to all values (AND): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#all-java.util.function.Predicate-" target="_blank" rel="noopener">all</a></li><li>applied to at least one value (OR): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#any-java.util.function.Predicate-" target="_blank" rel="noopener">any</a></li><li>testing the presence of any value: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#hasElements--" target="_blank" rel="noopener">hasElements</a> <em>(there is a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html" target="_blank" rel="noopener">Mono</a> equivalent in <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#hasElement--" target="_blank" rel="noopener">hasElement</a>)</em></li><li>testing the presence of a specific value: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#hasElement-T-" target="_blank" rel="noopener">hasElement(T)</a></li></ul></li></ul></li><li><p>I want to combine publishers…</p><ul><li>…</li></ul></li><li><p>I want to repeat an existing sequence: <code>repeat</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#repeat--" target="_blank" rel="noopener">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#repeat--" target="_blank" rel="noopener">Mono</a>)</p><ul><li>…</li></ul></li><li><p>I have an empty sequence but…</p><ul><li><p>I want a value instead: <code>defaultIfEmpty</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defaultIfEmpty-T-" target="_blank" rel="noopener">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defaultIfEmpty-T-" target="_blank" rel="noopener">Mono</a>)</p></li><li><p>I want another sequence instead: <code>switchIfEmpty</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchIfEmpty-org.reactivestreams.Publisher-" target="_blank" rel="noopener">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#switchIfEmpty-reactor.core.publisher.Mono-" target="_blank" rel="noopener">Mono</a>)</p><ul><li><pre><code class="java">Flux.just(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  .filter(i -&gt; i &lt; <span class="number">0</span>)  .next()  .doOnNext(i -&gt; log.info(<span class="string">"Exist a item: {}"</span>, i))  .switchIfEmpty(Mono.just(-<span class="number">1</span>))  .map(Objects::toString)  .subscribe(log::info);</code></pre></li></ul></li></ul></li></ul><ul><li><p>I have a sequence but I am not interested in values: <code>ignoreElements</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ignoreElements--" target="_blank" rel="noopener">Flux.ignoreElements()</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ignoreElement--" target="_blank" rel="noopener">Mono.ignoreElement()</a>)</p><ul><li>…and I want the completion represented as a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html" target="_blank" rel="noopener">Mono</a>: <code>then</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#then--" target="_blank" rel="noopener">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#then--" target="_blank" rel="noopener">Mono</a>)</li><li>…and I want to wait for another task to complete at the end: <code>thenEmpty</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#thenEmpty-org.reactivestreams.Publisher-" target="_blank" rel="noopener">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenEmpty-org.reactivestreams.Publisher-" target="_blank" rel="noopener">Mono</a>)</li><li>…and I want to switch to another <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html" target="_blank" rel="noopener">Mono</a> at the end: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#then-reactor.core.publisher.Mono-" target="_blank" rel="noopener">Mono#then(mono)</a></li><li>…and I want to emit a single value at the end: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenReturn-V-" target="_blank" rel="noopener">Mono#thenReturn(T)</a></li><li>…and I want to switch to a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html" target="_blank" rel="noopener">Flux</a> at the end: <code>thenMany</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#thenMany-org.reactivestreams.Publisher-" target="_blank" rel="noopener">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenMany-org.reactivestreams.Publisher-" target="_blank" rel="noopener">Mono</a>)</li></ul></li><li><p>…</p></li></ul><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><ul><li>I want to filter a sequence:<ul><li>based on an arbitrary criteria: <code>filter</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filter-java.util.function.Predicate-" target="_blank" rel="noopener">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#filter-java.util.function.Predicate-" target="_blank" rel="noopener">Mono</a>)<ul><li>…that is asynchronously computed: <code>filterWhen</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filterWhen-java.util.function.Function-" target="_blank" rel="noopener">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#filterWhen-java.util.function.Function-" target="_blank" rel="noopener">Mono</a>)</li></ul></li><li>restricting on the type of the emitted objects: <code>ofType</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ofType-java.lang.Class-" target="_blank" rel="noopener">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ofType-java.lang.Class-" target="_blank" rel="noopener">Mono</a>)</li><li>by ignoring the values altogether: <code>ignoreElements</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ignoreElements--" target="_blank" rel="noopener">Flux.ignoreElements()</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ignoreElement--" target="_blank" rel="noopener">Mono.ignoreElement()</a>)</li><li>by ignoring duplicates:<ul><li>in the whole sequence (logical set): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#distinct--" target="_blank" rel="noopener">Flux#distinct</a></li><li>between subsequently emitted items (deduplication): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#distinctUntilChanged--" target="_blank" rel="noopener">Flux#distinctUntilChanged</a></li></ul></li></ul></li><li>I want to keep only a subset of the sequence:<ul><li>by taking N elements:<ul><li>at the beginning of the sequence: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-long-boolean-" target="_blank" rel="noopener">Flux#take(long, true)</a><ul><li>…requesting an unbounded amount from upstream: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-long-boolean-" target="_blank" rel="noopener">Flux#take(long, false)</a></li><li>…based on a duration: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-java.time.Duration-" target="_blank" rel="noopener">Flux#take(Duration)</a></li><li>…only the first element, as a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html" target="_blank" rel="noopener">Mono</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#next--" target="_blank" rel="noopener">Flux#next()</a></li><li>…using <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscription.html#request(long)" target="_blank" rel="noopener">request(N)</a> rather than cancellation: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#limitRequest-long-" target="_blank" rel="noopener">Flux#limitRequest(long)</a></li></ul></li><li>at the end of the sequence: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeLast-int-" target="_blank" rel="noopener">Flux#takeLast</a></li><li>until a criteria is met (inclusive): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeUntil-java.util.function.Predicate-" target="_blank" rel="noopener">Flux#takeUntil</a> (predicate-based), <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeUntilOther-org.reactivestreams.Publisher-" target="_blank" rel="noopener">Flux#takeUntilOther</a> (companion publisher-based)</li><li>while a criteria is met (exclusive): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeWhile-java.util.function.Predicate-" target="_blank" rel="noopener">Flux#takeWhile</a></li></ul></li><li>by taking at most 1 element:<ul><li>at a specific position: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#elementAt-int-" target="_blank" rel="noopener">Flux#elementAt</a></li><li>at the end: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeLast-int-" target="_blank" rel="noopener">.takeLast(1)</a><ul><li>…and emit an error if empty: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#last--" target="_blank" rel="noopener">Flux#last()</a></li><li>…and emit a default value if empty: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#last-T-" target="_blank" rel="noopener">Flux#last(T)</a></li></ul></li></ul></li><li>by skipping elements:<ul><li>at the beginning of the sequence: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skip-long-" target="_blank" rel="noopener">Flux#skip(long)</a><ul><li>…based on a duration: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skip-java.time.Duration-" target="_blank" rel="noopener">Flux#skip(Duration)</a></li></ul></li><li>at the end of the sequence: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipLast-int-" target="_blank" rel="noopener">Flux#skipLast</a></li><li>until a criteria is met (inclusive): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipUntil-java.util.function.Predicate-" target="_blank" rel="noopener">Flux#skipUntil</a> (predicate-based), <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipUntilOther-org.reactivestreams.Publisher-" target="_blank" rel="noopener">Flux#skipUntilOther</a> (companion publisher-based)</li><li>while a criteria is met (exclusive): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipWhile-java.util.function.Predicate-" target="_blank" rel="noopener">Flux#skipWhile</a></li></ul></li><li>by sampling items:<ul><li>by duration: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sample-java.time.Duration-" target="_blank" rel="noopener">Flux#sample(Duration)</a><ul><li>but keeping the first element in the sampling window instead of the last: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sampleFirst-java.time.Duration-" target="_blank" rel="noopener">sampleFirst</a></li></ul></li><li>by a publisher-based window: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sample-org.reactivestreams.Publisher-" target="_blank" rel="noopener">Flux#sample(Publisher)</a></li><li>based on a publisher “timing out”: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sampleTimeout-java.util.function.Function-" target="_blank" rel="noopener">Flux#sampleTimeout</a> (each element triggers a publisher, and is emitted if that publisher does not overlap with the next)</li></ul></li></ul></li><li>I expect at most 1 element (error if more than one)…<ul><li>and I want an error if the sequence is empty: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#single--" target="_blank" rel="noopener">Flux#single()</a></li><li>and I want a default value if the sequence is empty: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#single-T-" target="_blank" rel="noopener">Flux#single(T)</a></li><li>and I accept an empty sequence as well: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#singleOrEmpty--" target="_blank" rel="noopener">Flux#singleOrEmpty</a></li></ul></li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><table><thead><tr><th>方法</th><th>注释</th></tr></thead><tbody><tr><td><code>doOnNext</code></td><td>Add behavior triggered when the <code>Mono</code> emits a data successfully.</td></tr><tr><td><code>doOnSuccess</code></td><td>Add behavior triggered when the <code>Mono</code> completes successfully.<br/>* <code>null</code> : completed without data<br/>* <code>T</code>: completed with data</td></tr><tr><td><code>doOnError</code></td><td>Add behavior triggered when the <code>Mono</code> completes with an error.</td></tr><tr><td><code>doAfterSuccessOrError</code></td><td>Add behavior triggered after the <code>Mono</code> terminates, either by completing downstream successfully or with an error. The arguments will be null depending on success, success with data and error:<br/>* <code>null</code>, <code>null</code> : completed without data<br/>* <code>T</code>, <code>null</code> : completed with data<br/>* <code>null</code>, <code>Throwable</code> : failed with/without data</td></tr><tr><td><code>doOnSubscribe</code></td><td>Add behavior triggered when the <code>Mono</code> is subscribed.</td></tr><tr><td><code>doOnCancel</code></td><td>Add behavior triggered when the <code>Mono</code> is cancelled.</td></tr><tr><td><code>doOnRequest</code></td><td>Add behavior triggering a <code>LongConsumer</code> when the Mono receives any request.</td></tr></tbody></table><table><thead><tr><th>方法</th><th>注释</th></tr></thead><tbody><tr><td><code>log</code></td><td>Observe all Reactive Streams signals and trace them using <code>Logger</code> support. Default will use <code>Level.INFO</code> and java.util.logging. If <strong>SLF4J</strong> is available, it will be used instead.</td></tr><tr><td><code>timestamp</code></td><td>If this <code>Mono</code> is valued, emit a <code>Tuple2</code> pair of T1 the current clock time in millis (as a <code>Long</code> measured by the parallel Scheduler) and T2 the emitted data (as a T).</td></tr><tr><td><code>elapsed</code></td><td></td></tr></tbody></table><p><img src="/img/java/reactive-stream/reactor/mono/mono_do.png" alt="mono_od"></p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>Two ways to recover from errors:</p><ul><li>by falling back</li><li>by retrying</li></ul><table><thead><tr><th>方法</th><th>注释</th><th>描述</th></tr></thead><tbody><tr><td><code>error</code></td><td>Create a <code>Mono</code> that terminates with the specified error immediately after being subscribed to.</td><td>创建异常流。</td></tr><tr><td><code>onErrorReturn</code></td><td>Simply emit a captured fallback value when <u>any error</u> is observed on this <code>Mono</code>.<br/>Simply emit a captured fallback value when <u>an error of the specified type</u> is observed on this <code>Mono</code>.<br/>Simply emit a captured fallback value when <u>an error matching the given predicate</u> is observed on this <code>Mono</code>.</td><td>catching an exception and falling back to a default value</td></tr><tr><td><code>onErrorResume</code></td><td>Subscribe to a fallback publisher when <u>any error</u> occurs, using a function to choose the fallback depending on the error.<br/>Subscribe to a fallback publisher when <u>an error matching the given type</u> occurs.<br/>Subscribe to a fallback publisher when <u>an error matching a given predicate</u> occurs.</td><td>catching an exception and falling back to another <code>Mono</code></td></tr><tr><td><code>onErrorContinue</code></td><td></td><td></td></tr><tr><td><code>onErrorMap</code></td><td>Transform any error emitted by this <code>Mono</code> by synchronously applying a function to it.<br/>Transform an error emitted by this <code>Mono</code> by synchronously applying a function to it <u>if the error matches the given type.</u> Otherwise let the error pass through.<br/>Transform an error emitted by this <code>Mono</code> by synchronously applying a function to it <u>if the error matches the given predicate.</u> Otherwise let the error pass through.</td><td>catching an exception and wrapping and re-throwing</td></tr><tr><td><code>retry()</code><br/><code>retry(long)</code></td><td>Re-subscribes to this <code>Mono</code> sequence if it signals any error, indefinitely.<br/>Re-subscribes to this <code>Mono</code> sequence if it signals any error, for a fixed number of times.</td><td>retrying with a simple policy (max number of attempts)</td></tr><tr><td><code>retryWhen</code></td><td></td><td></td></tr></tbody></table><p><img src="/img/java/reactive-stream/reactor/mono/mono_error.png" alt="mono_error"></p><h2 id="终结操作"><a href="#终结操作" class="headerlink" title="终结操作"></a>终结操作</h2><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><h3 id="阻塞返回结果"><a href="#阻塞返回结果" class="headerlink" title="阻塞返回结果"></a>阻塞返回结果</h3><p><img src="/img/java/reactive-stream/reactor/mono/mono_block.png" alt="mono_block"></p><h1 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h1><p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html</a></p><blockquote><p>for [N] elements</p></blockquote><p><img src="/img/java/reactive-stream/reactor/flux/flux.svg" alt="flux"></p><h2 id="创建-Flux-流"><a href="#创建-Flux-流" class="headerlink" title="创建 Flux 流"></a>创建 Flux 流</h2><p>普通创建：</p><p><img src="/img/java/reactive-stream/reactor/flux/flux_create.png" alt="flux_create"></p><p>遍历创建：</p><p>定时创建：</p><p><img src="/img/java/reactive-stream/reactor/flux/flux_create_interval.png" alt="flux_create_interval"></p><p>合并创建：</p><p><img src="/img/java/reactive-stream/reactor/flux/flux_create_combine.png" alt="flux_create_combine"></p><p>编程式创建：</p><p><img src="/img/java/reactive-stream/reactor/flux/flux_create_2.png" alt="flux_create_2"></p><p>其它：</p><p><img src="/img/java/reactive-stream/reactor/flux/flux_create_switchOnNext.png" alt="flux_create_switchOnNext"></p><h2 id="中间操作-1"><a href="#中间操作-1" class="headerlink" title="中间操作"></a>中间操作</h2><h3 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h3><p>Flux 转 Mono：</p><p><img src="/img/java/reactive-stream/reactor/flux/flux_to_mono.png" alt="flux_to_mono"></p><p><code>map</code>、<code>flatMap</code>：</p><p><img src="/img/java/reactive-stream/reactor/flux/flux_map.png" alt="flux_map"></p><p>转成并行流：</p><p><img src="/img/java/reactive-stream/reactor/flux/flux_parallel.png" alt="flux_parallel"></p><h3 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h3><p><img src="/img/java/reactive-stream/reactor/flux/flux_ifempty.png" alt="flux_ifempty"></p><h3 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h3><p><code>count</code></p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><img src="/img/java/reactive-stream/reactor/flux/flux_sort.png" alt="flux_sort"></p><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p><img src="/img/java/reactive-stream/reactor/flux/flux_distinct.png" alt="flux_distinct"></p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p><img src="/img/java/reactive-stream/reactor/flux/flux_window.png" alt="flux_window"></p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><p><img src="/img/java/reactive-stream/reactor/flux/flux_concat.png" alt="flux_concat"></p><p><img src="/img/java/reactive-stream/reactor/flux/flux_merge.png" alt="flux_merge"></p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><img src="/img/java/reactive-stream/reactor/flux/flux_zip.png" alt="flux_zip"></p><h3 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h3><table><thead><tr><th>方法</th><th>注释</th></tr></thead><tbody><tr><td><code>take(long n)</code></td><td>Take only the first N values from this <code>Flux</code>, if available.</td></tr><tr><td><code>takeLast(long n)</code></td><td>Emit the last N values this <code>Flux</code> emitted before its completion.</td></tr><tr><td><code>last()</code></td><td>Emit the last element observed before complete signal as a <code>Mono</code>, or emit <code>NoSuchElementException</code> error if the source was empty.</td></tr><tr><td><code>last(T defaultValue)</code></td><td>Emit the last element observed before complete signal as a <code>Mono</code>, or emit the <strong>defaultValue</strong> if the source was empty.</td></tr></tbody></table><p><img src="/img/java/reactive-stream/reactor/flux/flux_take.png" alt="flux_take"></p><h3 id="延迟处理"><a href="#延迟处理" class="headerlink" title="延迟处理"></a>延迟处理</h3><p><img src="/img/java/reactive-stream/reactor/flux/flux_delay.png" alt="flux_delay"></p><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><p><img src="/img/java/reactive-stream/reactor/flux/flux_buffer.png" alt="flux_buffer"></p><h3 id="执行操作"><a href="#执行操作" class="headerlink" title="执行操作"></a>执行操作</h3><p><img src="/img/java/reactive-stream/reactor/flux/flux_do.png" alt="flux_do"></p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><img src="/img/java/reactive-stream/reactor/flux/flux_error.png" alt="flux_error"></p><h2 id="终结操作-1"><a href="#终结操作-1" class="headerlink" title="终结操作"></a>终结操作</h2><h3 id="订阅-1"><a href="#订阅-1" class="headerlink" title="订阅"></a>订阅</h3><p>订阅后可以使用 <code>Disposable</code> API 停止 FLux 流。</p><p><img src="/img/java/reactive-stream/reactor/flux/flux_subscribe.png" alt="flux_subscribe"></p><h3 id="阻塞返回结果-1"><a href="#阻塞返回结果-1" class="headerlink" title="阻塞返回结果"></a>阻塞返回结果</h3><p><img src="/img/java/reactive-stream/reactor/flux/flux_block.png" alt="flux_block"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://projectreactor.io/" target="_blank" rel="noopener">Reactor 框架</a>，实现 Reactive Streams 规范，并扩展大量特性</p><p><a href="https://projectreactor.io/docs/core/release/reference/docs/index.html#which-operator" target="_blank" rel="noopener">Appendix A: Which operator do I need?</a></p><p><a href="https://zhuanlan.zhihu.com/p/35964846" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35964846</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 响应式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式编程系列（二）Reactor 入门总结</title>
      <link href="2020/08/08/java-reactor-startup/"/>
      <url>2020/08/08/java-reactor-startup/</url>
      
        <content type="html"><![CDATA[<p>Reactor 是一款基于 JVM 的<strong>完全非阻塞</strong>的响应式编程框架。它实现了 Reactive Streams 规范，具有高效的流量控制（以管理背压的形式），并扩展了大量特性，例如提供了丰富的 Operators 运算符。</p><h1 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h1><p>Reactor Core 需要在 <code>Java 8</code> 及以上版本运行。因为 Reactor 直接集成了 Java 8 的函数式 API，特别是：</p><ul><li><code>java.util.CompletableFuture</code></li><li><code>java.util.stream.Stream</code></li><li><code>java.time.Duration</code></li></ul><h1 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h1><p>自 Reactor 3 开始（since <code>reactor-core 3.0.4</code>, with the <code>Aluminium</code> release train），Reactor 使用 BOM (Bill of Materials) 模型来管理依赖。BOM 将一组相关的、可以良好协作的构建（Maven Artifact）组合在一起，提供版本管理。避免构件间潜在的版本不兼容风险。</p><p>为项目引入该 BOM：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;reactor.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后就可以为项目添加相关依赖。注意忽略版本号，以便由 BOM 统一管理版本号（除非你想覆盖 BOM 管理的版本号）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Reactor --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里 Reactor Core 传递依赖于 Reactive Stream 规范，如下：</p><p><img src="/img/java/reactive-stream/reactor/reactor_dependencies.png" alt="reactor_dependencies"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.reactivestreams<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactive-streams<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h1><p>Reactor Core 提供了两个<strong>可组合式</strong>的<strong>异步串行 API</strong>：</p><ul><li><code>reactor.core.publisher.Mono</code> (for [0|1] elements)</li><li><code>reactor.core.publisher.Flux</code> (for [N] elements)</li></ul><p>这两个类都是 <code>org.reactivestreams.Publisher</code> 接口的实现类：</p><p><img src="/img/java/reactive-stream/reactor/Publisher.png" alt="Publisher"></p><p>Reactor Core 还提供了 <code>org.reactivestreams.Subscriber</code> 接口的实现类，如下（还有其它子类，此处不一一例举）：</p><p><img src="/img/java/reactive-stream/reactor/Subscriber.png" alt="Subscriber"></p><p>不过一般不会直接使用该实现类，而是使用 <code>Mono</code>、<code>Flux</code> 提供的 <code>subscribe</code> 方法（如下图），并传入 Lambda 表达式语句（代码即参数），由方法的实现负责将参数封装为 <code>Subscriber</code> 接口的实现类，供消费使用：</p><p><img src="/img/java/reactive-stream/reactor/reactor_subscribe.png" alt="reactor_subscribe"></p><p>响应式编程，如 Reactor 旨在解决 JVM 上传统异步编程带来的缺点、以及编程范式上从命令式过渡到响应式编程：</p><h2 id="阻塞带来的性能浪费"><a href="#阻塞带来的性能浪费" class="headerlink" title="阻塞带来的性能浪费"></a>阻塞带来的性能浪费</h2><p>现代的应用程序通常有大量并发请求。即使现代的硬件性能不断提高，软件性能仍然是关键瓶颈。</p><p>广义上讲，有两种方法可以提高程序的性能：</p><ul><li>利用并行（parallel）使用更多 CPU 线程和更多硬件资源。</li><li>提升现有资源的利用率。</li></ul><p>通常，Java 开发者使用阻塞方式来编写程序。除非达到性能瓶颈，否则这种做法可行。之后，通过增加线程数，运行类似的阻塞代码。 但这种方式很快就会导致<strong>资源争用和并发问题</strong>。</p><p>更糟糕的是，阻塞会浪费资源。试想一下，程序一旦遇到一些延迟（特别是 I/O 操作，例如数据库请求或网络请求），就会挂起线程，从而导致资源浪费，因为大量线程处于空闲状态，等待数据，甚至导致资源耗尽。尽管使用池化技术可以提升资源利用率、避免资源耗尽，但只能缓解而不能解决根本问题，而且池内资源同样有耗尽的问题。</p><p>因此，并行技术并非银弹。</p><h2 id="传统异步编程带来的缺点"><a href="#传统异步编程带来的缺点" class="headerlink" title="传统异步编程带来的缺点"></a>传统异步编程带来的缺点</h2><p>Java 提供了两种异步编程模型：</p><ul><li>Callbacks: 异步方法<strong>没有返回值</strong>，但是带有一个额外的 <code>callback</code> 回调参数（值为 Lambda 表达式或匿名类），回调参数在结果可用时被调用。</li><li>Futures: 异步方法调用后立即返回一个 <code>Future&lt;T&gt;</code> 对象。异步方法负责计算出结果值 <code>T</code>，由 <code>Future</code> 对象包装起来。该结果值并非立即可用，可以轮询该 <code>Future</code> 对象，直到结果值可用为止。这种方式顺序执行代码，将异步编程模型转为同步编程模型。<code>ExecutorService</code> 提供了方法 <code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>。</li></ul><p>两种模型都有一个共同的缺点：难以组合代码，从而导致代码可读性差、难以维护。例如，当业务逻辑复杂，步骤存在依赖关系时，会导致回调<strong>嵌套过深</strong>，从而导致著名的 Callback Hell 问题。</p><p>详见代码例子。</p><h2 id="从命令式过渡到响应式编程"><a href="#从命令式过渡到响应式编程" class="headerlink" title="从命令式过渡到响应式编程"></a>从命令式过渡到响应式编程</h2><p><img src="/img/java/reactive-stream/reactor/from_imperative_to_reactive_programming.png" alt="from_imperative_to_reactive_programming"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://projectreactor.io/" target="_blank" rel="noopener">Reactor 框架</a>，实现 Reactive Streams 规范，并扩展大量特性</p><ul><li><p><a href="https://projectreactor.io/docs/core/release/reference/index.html#getting-started" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/index.html#getting-started</a></p></li><li><p><a href="https://projectreactor.io/docs/core/release/reference/index.html#intro-reactive" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/index.html#intro-reactive</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 响应式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式编程系列（一）Java 响应式编程总结</title>
      <link href="2020/08/01/java-reactive-programming/"/>
      <url>2020/08/01/java-reactive-programming/</url>
      
        <content type="html"><![CDATA[<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>响应式编程（Reactive Programming）概念最早于上世纪九十年代被提出，微软为 .NET 生态开发了 Reactive Extensions (Rx) 库用于支持响应式编程，后来 Netflix 开发了 RxJava，为 JVM 生态实现了响应式编程。随着时间的推移，2015 年 <a href="https://www.reactive-streams.org/" target="_blank" rel="noopener">Reactive Stream</a>（响应式流）规范诞生，为 JVM 上的响应式编程定义了一组接口和交互规则。<a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="noopener">RxJava</a> 从 RxJava 2 开始实现 Reactive Stream 规范。同时 MongoDB、<a href="https://projectreactor.io/" target="_blank" rel="noopener">Reactor</a>、Slick 等也相继实现了 Reactive Stream 规范。</p><p>Spring Framework 5 推出了<a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html" target="_blank" rel="noopener">响应式 Web 框架</a>。</p><p>Java 9 引入了<a href="http://openjdk.java.net/jeps/266" target="_blank" rel="noopener">响应式编程的 API</a>，将 Reactive Stream 规范定义的四个接口集成到了 <a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/Flow.html" target="_blank" rel="noopener"><code>java.util.concurrent.Flow</code></a> 类中。Java 9 提供了 <code>SubmissionPublisher</code> 和 <code>ConsumerSubscriber</code> 两个默认实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------+     +-------------+     +------------------+     +-------------------------------+</span><br><span class="line">| Reactive Extensions (Rx) |     | RxJava 1.x  |     | Reactive Streams |     | RxJava 2                      |</span><br><span class="line">| by Microsoft             +-----&gt; by Netflix  +-----&gt; Specification    +-----&gt; (Supporting Reactive Streams) |</span><br><span class="line">| for .NET                 |     | for Java 6+ |     | for JVM          |     | for Java 6+                   |</span><br><span class="line">+--------------------------+     +-------------+     +------------------+     +-------------------------------+</span><br><span class="line">                                                                                              |</span><br><span class="line">                                                                                              |</span><br><span class="line">                                                                                              |</span><br><span class="line">                     +-----------------------+     +--------------------+     +---------------v---------------+</span><br><span class="line">                     | Java 9 Standard       |     | Spring Framework 5 |     | Project Reactor              |</span><br><span class="line">                     | (JEP-266 by Doug Lea) &lt;-----+ Reactive Stack     &lt;-----+ (Supporting Reactive Streams) |</span><br><span class="line">                     |                       |     |                    |     | for Java 8+                   |</span><br><span class="line">                     +-----------------------+     +--------------------+     +-------------------------------+</span><br></pre></td></tr></table></figure><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>响应式编程（Reactive Programing）是一种基于数据流（data stream）和变化传递（propagation of change）的声明式（declarative）的编程范式。</p><h1 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h1><p>响应式编程范式通常在面向对象语言中作为<strong>观察者模式</strong>的扩展出现。可以将其与大家熟知的<strong>迭代器模式</strong>作对比，主要区别在于：</p><table><thead><tr><th></th><th>迭代器（Iterator）</th><th>响应式流（Reactive Stream）</th></tr></thead><tbody><tr><td>设计模式</td><td>迭代器模式</td><td>观察者模式</td></tr><tr><td>数据方向</td><td>拉模式（PULL）</td><td>推模式（PUSH）</td></tr><tr><td>获取数据</td><td><code>T next()</code></td><td><code>onNext(T)</code></td></tr><tr><td>处理完成</td><td><code>hasNext()</code></td><td><code>onCompleted()</code></td></tr><tr><td>异常处理</td><td><code>throws Exception</code></td><td><code>onError(Exception)</code></td></tr></tbody></table><p>Java 8 引入了 Stream 用于流的操作，Java 9 引入的 Flow 也是数据流的操作。相比之下：</p><ul><li>Stream 更侧重于流的过滤、映射、整合、收集，使用的是 <strong>PULL</strong> 模式。</li><li>而 Flow/RxJava/Reactor 更侧重于流的产生与消费，使用的是 <strong>PUSH</strong> 模式 。</li></ul><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>参考《<a href="/2018/05/01/java-collections-iterator/">Iterator API 总结</a>》</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote><p>观察者模式是一种行为型设计模式，允许你定义一种订阅机制，可在对象事件发生时<strong>主动通知</strong>多个 “观察” 该对象的其它对象。</p></blockquote><p><img src="/img/java/design-pattern/Observer.png" alt="Observer"></p><p>在响应式流中，上述操作由 <code>Publisher-Subscriber</code> 负责。由 <code>Publisher</code> 生产新值并推送给 <code>Subscriber</code>，这个“推送”就是响应式的关键，亦即“<strong>变化传递（propagation of change）</strong>”。另外，应用于被推送值的操作（Operator）是“<strong>声明式</strong>”而不是“命令式”的：开发者表达的是计算逻辑，而不是描述其具体的控制流程。</p><p>流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onNext x 0..N [onError | onComplete]</span><br></pre></td></tr></table></figure><h1 id="Reactive-Streams-规范"><a href="#Reactive-Streams-规范" class="headerlink" title="Reactive Streams 规范"></a>Reactive Streams 规范</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>Reactive Stream（响应式流）规范的 Maven 依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.reactivestreams/reactive-streams --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.reactivestreams<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactive-streams<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h2><p>整个依赖包中，仅仅定义了四个核心接口：</p><ul><li><code>org.reactivestreams.Subscription</code> 接口定义了连接发布者和订阅者的方法；</li><li><code>org.reactivestreams.Publisher&lt;T&gt;</code> 接口定义了发布者的方法；</li><li><code>org.reactivestreams.Subscriber&lt;T&gt;</code> 接口定义了订阅者的方法；</li><li><code>org.reactivestreams.Processor&lt;T,R&gt;</code> 接口定义了处理器；</li></ul><p><img src="/img/java/reactive-stream/reactive-stream/org.reactivestreams.png" alt="org.reactivestreams"></p><h2 id="接口交互流程"><a href="#接口交互流程" class="headerlink" title="接口交互流程"></a>接口交互流程</h2><p>简要交互如下：</p><p><img src="/img/java/reactive-stream/reactive-stream/process_of_reactive_stream.jpg" alt="process_ofreactive_stream"></p><p>API 交互如下：</p><p><img src="/img/java/reactive-stream/reactive-stream/process_of_reactive_stream_2.png" alt="process_of_reactive_stream_2"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Reactive Java Programming》</p><p>Reactive Streams 规范</p><ul><li><a href="https://www.reactive-streams.org/" target="_blank" rel="noopener">https://www.reactive-streams.org/</a></li><li><a href="https://en.wikipedia.org/wiki/Reactive_Streams" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Reactive_Streams</a></li><li><a href="https://zhuanlan.zhihu.com/p/41342507" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/41342507</a></li></ul><p><a href="http://openjdk.java.net/jeps/266" target="_blank" rel="noopener">http://openjdk.java.net/jeps/266</a></p><p><a href="http://reactivex.io/" target="_blank" rel="noopener">http://reactivex.io/</a></p><ul><li>《Reactive Programming with RxJava》</li></ul><p><a href="https://projectreactor.io/" target="_blank" rel="noopener">Reactor 框架</a></p><ul><li>实现 Reactive Streams 规范，并扩展大量特性</li></ul><p><a href="https://spring.io/reactive" target="_blank" rel="noopener">https://spring.io/reactive</a></p><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html" target="_blank" rel="noopener">Web on Reactive Stack - Spring</a></p><ul><li>基于 Reactor 框架实现</li><li>默认基于 Netty 作为应用服务器</li><li>好处：能够以固定的线程来处理高并发（充分发挥机器的性能）</li><li>提供 API：<ul><li>Spring WebFlux</li><li>WebClient</li><li>WebSockets</li><li>Testing</li><li>RSocket</li><li>Reactive Libraries</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 响应式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程系列（三）Java 线程池总结</title>
      <link href="2020/05/03/java-concurrency-threadpool/"/>
      <url>2020/05/03/java-concurrency-threadpool/</url>
      
        <content type="html"><![CDATA[<p>为什么要用线程池？</p><blockquote><p>线程的创建和销毁是有代价的。</p><p>如果请求的到达率非常高且请求的处理过程是轻量级的，那么为每个请求创建一个新线程将消耗大量的计算资源。</p><p>活跃的线程会消耗系统资源，尤其是内存。大量空闲线程会占用许多内存，给垃圾回收器带来压力，而且大量线程竞争 CPU 资源还会产生其它的性能开销。</p><p>可创建线程的数量上存在限制，如果创建太多线程，会使系统饱和甚至抛出 <code>OutOfMemoryException</code> 。</p></blockquote><p>问题如下：</p><p><img src="/img/java/concurrent/no_thread_pool_design.png" alt="no_thread_pool_design"></p><p>为了解决以上问题，从 Java 5 开始 JDK 并发 API 提供了 Executor Framework，用于<strong>将任务的创建与执行分离</strong>，避免使用者直接与 <code>Thread</code> 对象打交道，通过池化设计与阻塞队列保护系统资源：</p><p><img src="/img/java/concurrent/thread_pool_design.png" alt="thread_pool_design"></p><p>使用 Executor Framework 的第一步就是创建一个 <code>ThreadPoolExecutor</code> 类的对象。你可以使用这个类提供的 <strong>四个构造方法</strong>或 <code>Executors</code> <strong>工厂类</strong>来创建 <code>ThreadPoolExecutor</code> 。一旦有了执行者，你就可以提交 <code>Runnable</code> 或 <code>Callable</code> 对象给执行者来执行。</p><h1 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h1><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p><code>Executor</code> 接口的实现类如下：</p><p><img src="/img/java/concurrent/subtypes_of_Executor.png" alt="subtypes_of_Executor"></p><p>其中，<code>ThreadPoolExecutor</code> 类实现了两个核心接口 <code>Executor</code> 和 <code>ExecutorService</code>，方法如下：</p><p><img src="/img/java/concurrent/Executor.png" alt="ThreadPoolExecutor"></p><p><code>ThreadPoolExecutor</code> 类的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 线程池使用一个int变量存储线程池状态和工作线程数</span></span><br><span class="line"><span class="comment">  * int4个字节，32位，用高三位存储线程池状态，低29位存储工作线程数</span></span><br><span class="line"><span class="comment">  * 为什么使用一个变量来同时表示线程状态和线程数？就是节省空间。咨询了一下写c的朋友，他们经常这么写</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//COUNT_BITS=29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//理论上线程池最大线程数量CAPACITY=(2^29)-1，即 536,870,911</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线程池状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">//获取工作线程数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">//初始化ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 线程池状态转换</span></span><br><span class="line"><span class="comment">  * RUNNING -&gt; SHUTDOWN</span></span><br><span class="line"><span class="comment">  * RUNNING or SHUTDOWN -&gt; STOP</span></span><br><span class="line"><span class="comment">  * SHUTDOWN or STOP -&gt; TIDYING</span></span><br><span class="line"><span class="comment">  * TIDYING -&gt; TERMINATED  terminated()执行完后变为该TERMINATED</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//接受新任务，可以处理阻塞队列里的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//不接受新任务，可以处理阻塞队列里的任务。执行shutdown()会变为SHUTDOWN</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//不接受新的任务，不处理阻塞队列里的任务，中断正在处理的任务。执行shutdownNow()会变为STOP</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//临时过渡状态，所有的任务都执行完了，当前线程池有效的线程数量为0，这个时候线程池的状态是TIDYING，执行terminated()变为TERMINATED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//终止状态，terminated()调用完成后的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重入锁，更新线程池核心大小、线程池最大大小等都有用到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//用于存储woker</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">//用于终止线程池</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"><span class="comment">//记录线程池中曾经出现过的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">//完成任务数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心线程数</span></span><br><span class="line"><span class="comment"> * 核心线程会一直存活，即使没有任务需要处理，当线程数小于核心线程数时。</span></span><br><span class="line"><span class="comment"> * 即使现有的线程空闲，线程池也会优先创建新线程来处理任务，而不是直接交给现有的线程处理。</span></span><br><span class="line"><span class="comment"> * 核心线程数在初始化时不会创建，只有提交任务的时候才会创建。核心线程在allowCoreThreadTimeout为true的时候超时会退出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"> <span class="comment">/** 最大线程数</span></span><br><span class="line"><span class="comment">   * 当线程数大于或者等于核心线程，且任务队列已满时，线程池会创建新的线程，直到线程数量达到maxPoolSize。</span></span><br><span class="line"><span class="comment">   * 如果线程数已等于maxPoolSize，且任务队列已满，则已超出线程池的处理能力，线程池会采取拒绝操作。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 线程空闲时间</span></span><br><span class="line"><span class="comment">  * 当线程空闲时间达到keepAliveTime，该线程会退出，直到线程数量等于corePoolSize。</span></span><br><span class="line"><span class="comment">  * 如果allowCoreThreadTimeout设置为true，则所有线程均会退出。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">//是否允许核心线程空闲超时退出，默认值为false。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"><span class="comment">//线程工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"><span class="comment">//用于保存等待执行的任务的阻塞队列。比如LinkedBlockQueue，SynchronousQueue等</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  rejectedExecutionHandler：任务拒绝策略</span></span><br><span class="line"><span class="comment"> *  DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务</span></span><br><span class="line"><span class="comment"> *  AbortPolicy：抛出异常。这也是默认的策略</span></span><br><span class="line"><span class="comment"> *  CallerRunsPolicy：用调用者所在线程来运行任务</span></span><br><span class="line"><span class="comment"> *  DiscardPolicy：不处理，丢弃掉</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">//默认的拒绝策略：抛出异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler =</span><br><span class="line">    <span class="keyword">new</span> AbortPolicy();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission shutdownPerm =</span><br><span class="line">    <span class="keyword">new</span> RuntimePermission(<span class="string">"modifyThread"</span>);</span><br></pre></td></tr></table></figure><p><code>ThreadPoolExecutor</code> 提供了四个构造方法，以参数最多的为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> || maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分别介绍源码中涉及的重要属性。</p><h2 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h2><p>作为一个线程池，有两个关键属性：</p><ul><li>线程池状态 <code>runState</code></li><li>工作线程数 <code>workerCnt</code></li></ul><p>这两个关键属性保存在名为 <code>ctl</code> 的 <code>AtomicInteger</code> 类型属性之中，高 3 位表示 <code>runState</code>，低 29 位表示 <code>workerCnt</code>，如下：</p><p><img src="/img/java/concurrent/ctl.png" alt="ctl"></p><p>为什么要用 3 位来表示线程池的状态呢，原因是线程池一共有 5 种状态，而 2 位只能表示出 4 种情况，所以至少需要 3 位才能表示得了 5 种状态，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">runState workerCnt                       runState workerCnt</span><br><span class="line">     000 00000000000000000000000000000   SHUTDOWN empty</span><br><span class="line">‭‭     001 00000000000000000000000000000       STOP empty</span><br><span class="line">     010 00000000000000000000000000000    TIDYING empty</span><br><span class="line">     ‭011 00000000000000000000000000000‬ TERMINATED empty</span><br><span class="line">     111 00000000000000000000000000000    RUNNING empty</span><br><span class="line">‭     111 11111111111111111111111111111    RUNNING full</span><br></pre></td></tr></table></figure><p>通过 <code>ctlOf</code> 方法初始化 <code>ctl</code> 属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或运算符(|)规则：1|1=1</span></span><br><span class="line"><span class="comment">//                 1|0=1</span></span><br><span class="line"><span class="comment">//                 0|1=1</span></span><br><span class="line"><span class="comment">//                 0|0=0</span></span><br><span class="line"><span class="comment">// 以初始化参数 ctlOf(RUNNING, 0) 为例：</span></span><br><span class="line">  <span class="number">11100000000000000000000000000000</span></span><br><span class="line">| <span class="number">00000000000000000000000000000000</span></span><br><span class="line">= <span class="number">11100000000000000000000000000000</span></span><br></pre></td></tr></table></figure><p>通过 <code>runStateOf</code> 方法获取线程池状态 <code>runState</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取线程池状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取反运算符(~)规则：~1=0</span></span><br><span class="line"><span class="comment">//                   ~0=1</span></span><br><span class="line"><span class="comment">// 以 c = 111 11111111111111111111111111111（RUNNING full）为例：</span></span><br><span class="line">     ~<span class="number">11111111111111111111111111111</span></span><br><span class="line">=     <span class="number">00000000000000000000000000000</span></span><br><span class="line">&amp; <span class="number">111</span> <span class="number">11111111111111111111111111111</span></span><br><span class="line">= <span class="number">111</span></span><br></pre></td></tr></table></figure><p>通过 <code>workerCountOf</code> 方法获取工作线程数 <code>workerCnt</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取工作线程数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与运算符(&amp;)规则：1&amp;1=1</span></span><br><span class="line"><span class="comment">//                 1&amp;0=0</span></span><br><span class="line"><span class="comment">//                 0&amp;1=0</span></span><br><span class="line"><span class="comment">//                 0&amp;0=0</span></span><br><span class="line"><span class="comment">// 以 c = 111 11111111111111111111111111111（RUNNING full）为例：</span></span><br><span class="line">  <span class="number">111</span> <span class="number">11111111111111111111111111111</span></span><br><span class="line">&amp;     <span class="number">11111111111111111111111111111</span></span><br><span class="line">=     <span class="number">11111111111111111111111111111</span></span><br></pre></td></tr></table></figure><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>线程池状态用于标识线程池内部的一些运行情况，线程池的开启到关闭的过程就是线程池状态的一个流转的过程。</p><p>线程池共有五种状态：</p><p><img src="/img/java/concurrent/run_state.png" alt="run_state"></p><table><thead><tr><th align="left">状态</th><th><code>runState</code></th><th align="left">含义</th></tr></thead><tbody><tr><td align="left"><code>RUNNING</code></td><td>111</td><td align="left">运行状态，该状态下线程池可以接受新的任务，也可以处理阻塞队列中的任务。<br/>执行 <code>shutdown</code> 方法可进入 <code>SHUTDOWN</code> 状态。<br/>执行 <code>shutdownNow</code> 方法可进入 <code>STOP</code> 状态。</td></tr><tr><td align="left"><code>SHUTDOWN</code></td><td>000</td><td align="left">待关闭状态，不再接受新的任务，继续处理阻塞队列中的任务。<br/>当阻塞队列中的任务为空，并且工作线程数为 0 时，进入 <code>TIDYING</code> 状态。</td></tr><tr><td align="left"><code>STOP</code></td><td>001</td><td align="left">停止状态，不接收新任务，也不处理阻塞队列中的任务，并且会尝试结束执行中的任务。<br/>当工作线程数为 0 时，进入 <code>TIDYING</code> 状态。</td></tr><tr><td align="left"><code>TIDYING</code></td><td>010</td><td align="left">整理状态，此时任务都已经执行完毕，并且也没有工作线程 执行 <code>terminated</code> 方法后进入 <code>TERMINATED</code> 状态。</td></tr><tr><td align="left"><code>TERMINATED</code></td><td>011</td><td align="left">终止状态，此时线程池完全终止了，并完成了所有资源的释放。</td></tr></tbody></table><h3 id="工作线程数"><a href="#工作线程数" class="headerlink" title="工作线程数"></a>工作线程数</h3><p>尽管理论上线程池最大线程数量可达 <code>CAPACITY</code> 数，但是实际上都会通过 <code>maximumPoolSize</code> 限制最大线程数。因此工作线程数 <code>workerCnt</code> 的个数可能在 0 至 <code>maximumPoolSize</code> 之间变化。</p><p>当工作线程的空闲时间达到 <code>keepAliveTime</code>，该工作线程会退出，直到工作线程数 <code>workerCnt</code> 等于 <code>corePoolSize</code>。如果 <code>allowCoreThreadTimeout</code> 设置为 <code>true</code>，则所有工作线程均会退出。</p><p><img src="/img/java/concurrent/worker_count.png" alt="worker_count"></p><p>注意：</p><ul><li>整个线程池的基本执行过程：创建核心线程（Core Thread） &gt; 任务排队 &gt; 创建临时线程（Temp Thread）。</li><li>如果将 <code>maximumPoolSize</code> 设置为基本的无界值（如 Integer.MAX_VALUE），可能会创建大量的线程，从而导致 OOM。因此要限定 <code>maximumPoolSize</code> 的大小。</li><li>如果将 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 设置为相同值，则创建了 Fixed 固定大小的线程池。</li></ul><h3 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h3><p>通过提供不同的 <code>ThreadFactory</code> 接口实现，可以改变被创建线程 <code>Thread</code> 的名称、线程组、优先级、守护进程状态，等等。</p><p>参考《<a href="/2018/07/10/java-concurrent-package/#ThreadFactory">Java 并发编程系列（一）常用包总结</a>》</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列的使用详见另一篇《<a href="/2018/04/21/java-collections-framework-concurrent-impl/">Java 集合框架系列（三）并发实现总结</a>》。</p><p><img src="/img/java/concurrent/work_queue.png" alt="work_queue"></p><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>拒绝策略，默认有四种实现：</p><ul><li><code>AbortPolicy</code>：抛出异常，默认的策略。</li><li><code>DiscardPolicy</code>：不处理，丢弃掉。</li><li><code>DiscardOldestPolicy</code>：丢弃队列中最近的一个任务，并执行该任务。</li><li><code>CallerRunsPolicy</code>：用调用者所在线程来执行该任务。</li></ul><p><img src="/img/java/concurrent/RejectedExecutionHandler.png" alt="RejectedExecutionHandler"></p><p>通过 <code>RejectedExecutionHandler</code> 接口可以实现更多策略，例如记录日志或持久化不能处理的任务，或者发出告警。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><code>execute</code> 方法的整体执行流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * Proceed in 3 steps:</span><br><span class="line"> *</span><br><span class="line"> * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line"> * start a new thread with the given command as its first</span><br><span class="line"> * task.  The call to addWorker atomically checks runState and</span><br><span class="line"> * workerCount, and so prevents false alarms that would add</span><br><span class="line"> * threads when it shouldn&#39;t, by returning false.</span><br><span class="line"> *</span><br><span class="line"> * 2. If a task can be successfully queued, then we still need</span><br><span class="line"> * to double-check whether we should have added a thread</span><br><span class="line"> * (because existing ones died since last checking) or that</span><br><span class="line"> * the pool shut down since entry into this method. So we</span><br><span class="line"> * recheck state and if necessary roll back the enqueuing if</span><br><span class="line"> * stopped, or start a new thread if there are none.</span><br><span class="line"> *</span><br><span class="line"> * 3. If we cannot queue task, then we try to add a new</span><br><span class="line"> * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line"> * and so reject the task.</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><p><img src="/img/java/concurrent/work_flow_of_execute_method.png" alt="work_flow_of_execute_method"></p><h1 id="使用工厂类创建线程池"><a href="#使用工厂类创建线程池" class="headerlink" title="使用工厂类创建线程池"></a>使用工厂类创建线程池</h1><p><code>java.util.concurrent.ThreadPoolExecutor</code> 提供了四个不同的构造方法，但由于它们的复杂性（参数较多），Java 并发 API 提供了 <code>java.util.concurrent.Executors</code> 工厂类来简化线程池的构造，常用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(...)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO, LIFO, 优先级）执行。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(...)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(...)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 创建一个定长线程池，支持定时及周期性任务执行。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(...)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>但是这种方式并不推荐使用，参考《阿里巴巴 Java 开发手册》：    </p><p><img src="/img/java/concurrent/principal_of_executors.png" alt="principal of executors"></p><p><code>java.util.concurrent.Executors</code> 源码分析如下，首先是 <code>newFixedThreadPool(...)</code> 和 <code>newSingleThreadExecutor(...)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fixed 限定 corePoolSize 和 maximumPoolSize 为相同大小，即线程池大小固定（意味着无法扩展）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Single 其实就是 Fixed 为 1 的变种</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法中，关键在于对 <code>java.util.concurrent.LinkedBlockingQueue</code> 的构造，使用了默认的无参构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许的请求队列长度（capacity）为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是 <code>newCachedThreadPool(...)</code> 和 <code>newScheduledThreadPool(...)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 允许的创建线程数量（maximumPoolSize）为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问题在于 ScheduledThreadPoolExecutor 构造方法的默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下 <code>java.util.concurrent.ScheduledThreadPoolExecutor</code> 的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ScheduledThreadPoolExecutor 构造方法中，允许的创建线程数量（maximumPoolSize）为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程系列（二）Java 并发包总结</title>
      <link href="2020/05/01/java-concurrency-package/"/>
      <url>2020/05/01/java-concurrency-package/</url>
      
        <content type="html"><![CDATA[<p>工作中常用到一些并发编程类，这里做一些总结。</p><p>JDK 中涉及到线程的包如下：</p><h1 id="java-lang"><a href="#java-lang" class="headerlink" title="java.lang"></a>java.lang</h1><blockquote><p>内含基础并发类。</p></blockquote><h2 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h2><p>无返回结果的异步任务。</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>程序中的执行线程。</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><code>Thread</code> 对象中保存了一些<strong>属性</strong>能够帮助我们来辨别每一个线程，知道它的状态，调整控制其优先级等：</p><p><code>ID</code></p><blockquote><p>每个线程的独特标识。</p></blockquote><p><code>Name</code></p><blockquote><p>线程的名称。</p></blockquote><p><code>Priority</code></p><blockquote><p>线程对象的优先级。优先级别在 1-10 之间，1 是最低级，10 是最高级。不建议改变它们的优先级。</p></blockquote><p><code>Daemon</code></p><blockquote><p>是否为守护线程。</p><p>Java 有一种特别的线程叫做守护线程。这种线程的<strong>优先级非常低</strong>，通常在程序里没有其他线程运行时才会执行它。当守护线程是程序里唯一在运行的线程时，JVM 会结束守护线程并终止程序。</p><p>根据这些特点，守护线程通常用于在同一程序里给普通线程（也叫使用者线程）提供服务。它们通常无限循环的等待服务请求或执行线程任务。它们不能做重要的任务，因为我们不知道什么时候会被分配到 CPU 时间片，并且只要没有其他线程在运行，它们可能随时被终止。<strong>JAVA中最典型的这种类型代表就是垃圾回收器 GC</strong>。</p><p>只能在 start() 方法之前可以调用 setDaemon() 方法。一旦线程运行了，就不能修改守护状态。</p><p>可以使用 isDaemon() 方法来检查线程是否是守护线程。</p></blockquote><p><code>Thread.UncaughtExceptionHandler</code></p><blockquote><p>用于捕获和处理线程对象抛出的 Unchecked Exception 来避免程序终结。</p></blockquote><p><code>Thread.State</code></p><blockquote><p>线程的状态，共六种：<br>NEW<br>RUNNABLE<br>BLOCKED<br>WAITING<br>TIME_WAITING<br>TERMINATED</p></blockquote><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><code>Thread</code> 类提供了以下几类<strong>方法</strong>：</p><ul><li>线程睡眠 <code>Thread.sleep(...)</code></li><li>线程中断 <code>Thread.interrupt()</code></li><li>线程让步 <code>Thread.yield()</code></li><li>线程合并 <code>Thread.join(...)</code></li><li>……</li></ul><p><code>Object</code> 提供了一组线程协作方法：</p><ul><li>线程协作 <code>Object.wait/notify</code></li></ul><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal<T></h2><p><code>ThreadLocal</code> 存放的值是线程内共享的，线程间互斥的，主要用于在线程内共享一些数据。</p><p>可以通过实现 <code>AutoCloseable</code> 以使用 try-with-resources 语法简化 <code>ThreadLocal</code> 资源清理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (ChannelContext ctx = <span class="keyword">new</span> ChannelContext(channel)) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelContext</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Channel&gt; CTX = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelContext</span><span class="params">(FundChannelDTO dto)</span> </span>&#123;</span><br><span class="line">        Channel channel = Channel.builder()</span><br><span class="line">                .appId(dto.getAppId().toString())</span><br><span class="line">                .build();</span><br><span class="line">        CTX.set(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChannelContext</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        CTX.set(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CTX.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CTX.remove();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="meta">@Builder</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String appId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadGroup"><a href="#ThreadGroup" class="headerlink" title="ThreadGroup"></a>ThreadGroup</h2><h1 id="java-util"><a href="#java-util" class="headerlink" title="java.util"></a>java.util</h1><h2 id="TimerTask"><a href="#TimerTask" class="headerlink" title="TimerTask"></a>TimerTask</h2><p><code>Timer</code> 是 JDK 中提供的一个定时器工具类，使用的时候会在主线程之外起一个单独的线程执行指定的定时任务 <code>TimerTask</code>，可以指定执行一次或者反复执行多次。</p><p><code>TimerTask</code> 是一个实现了 <code>Runnable</code> 接口的抽象类，代表一个可以被 <code>Timer</code> 执行的任务。</p><p><img src="/img/java/concurrent/TimerTask.png" alt="TimerTask"></p><h1 id="java-util-concurrent"><a href="#java-util-concurrent" class="headerlink" title="java.util.concurrent"></a>java.util.concurrent</h1><blockquote><p>JDK 5 引入的 Executor Framework ，用于取代传统的并发编程。</p></blockquote><p><img src="/img/java/concurrent/package_concurrent.png" alt="Package concurrent"></p><h2 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h2><p>通过提供不同的 <code>ThreadFactory</code> 接口实现，可以改变被创建线程 <code>Thread</code> 的<strong>属性</strong>。<code>ThreadFactory</code> 有几种创建方式：</p><p>1、完全自定义方式。缺点是需要在 <code>newThread</code> 方法中实现的代码较多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory threadFactory = runnable -&gt; &#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">    thread.setName(<span class="string">"..."</span>);</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、使用 <code>Executors</code> 工具类，这也是 <code>Executors</code> 工具类中提供的几种默认线程池所使用的方式。</p><p>缺点是只能使用默认属性，无法修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory threadFactory = Executors.defaultThreadFactory();</span><br></pre></td></tr></table></figure><p>优点是实现了基本的线程名称自增，该实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default thread factory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     <span class="string">"-thread-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、通过 Guava 提供的 <code>ThreadFactoryBuilder</code>。优点是可以轻易自定义任何属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadFactory threadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"wechat-notify-%d"</span>).build()</span><br></pre></td></tr></table></figure><p>该实现如下，如果未提供自定义的 <code>ThreadFactory</code>，将使用 <code>Executors</code> 工具类提供的默认 <code>ThreadFactory</code> 并进行二次修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory <span class="title">build</span><span class="params">(ThreadFactoryBuilder builder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String nameFormat = builder.nameFormat;</span><br><span class="line">  <span class="keyword">final</span> Boolean daemon = builder.daemon;</span><br><span class="line">  <span class="keyword">final</span> Integer priority = builder.priority;</span><br><span class="line">  <span class="keyword">final</span> UncaughtExceptionHandler uncaughtExceptionHandler = builder.uncaughtExceptionHandler;</span><br><span class="line">  <span class="keyword">final</span> ThreadFactory backingThreadFactory = (builder.backingThreadFactory != <span class="keyword">null</span>)</span><br><span class="line">          ? builder.backingThreadFactory</span><br><span class="line">          : Executors.defaultThreadFactory();</span><br><span class="line">  <span class="keyword">final</span> AtomicLong count = (nameFormat != <span class="keyword">null</span>) ? <span class="keyword">new</span> AtomicLong(<span class="number">0</span>) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">      Thread thread = backingThreadFactory.newThread(runnable);</span><br><span class="line">      <span class="keyword">if</span> (nameFormat != <span class="keyword">null</span>) &#123;</span><br><span class="line">        thread.setName(format(nameFormat, count.getAndIncrement()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (daemon != <span class="keyword">null</span>) &#123;</span><br><span class="line">        thread.setDaemon(daemon);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (priority != <span class="keyword">null</span>) &#123;</span><br><span class="line">        thread.setPriority(priority);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (uncaughtExceptionHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">        thread.setUncaughtExceptionHandler(uncaughtExceptionHandler);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h2><p>有返回结果的异步任务。Executor Framework 的一个重要优点是提供了 <code>java.util.concurrent.Callable&lt;V&gt;</code> 接口用于返回异步任务的结果。它的用法跟 <code>Runnable</code> 接口很相似，但它提供了两种改进：</p><ul><li>这个接口中主要的方法叫 <code>call()</code> ，可以返回结果。</li><li>当你提交 <code>Callable</code> 对象到 <code>Executor</code> 执行者，你可以获取一个实现 <code>Future</code> 接口的对象，你可以用这个对象来控制和获取 <code>Callable</code> 对象的状态和结果。</li></ul><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><p><code>CountDownLatch</code></p><p><code>CyclicBarrier</code></p><p><code>Phaser</code></p><p><code>CompletableFuture</code></p><p><code>Semaphore</code></p><p><code>Exchanger</code></p><p><code>Executors</code></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>参考另一篇《Java 并发编程系列（二）线程池总结》。</p><h2 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h2><p>详见另一个篇《Java 集合框架系列（三）并发实现总结》。</p><h2 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h2><p>java.util.concurrent.locks</p><blockquote><p>用于实现线程安全与通信。</p></blockquote><p><img src="/img/java/concurrent/package_locks.png" alt="Package locks"></p><h2 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h2><p>java.util.concurrent.atomic</p><blockquote><p>使用这些数据结构可以避免在并发程序中使用同步代码块（synchronized 或 Lock）。</p></blockquote><p><img src="/img/java/concurrent/package_atomic.png" alt="Package atomic"></p><p>JDK 5 新增的原子类，底层基于魔术类 <code>Unsafe</code> 进行 CAS 无锁操作。实现类按功能分组如下：</p><table><thead><tr><th></th><th>Integer</th><th>Long</th><th>Boolean</th><th>引用类型</th></tr></thead><tbody><tr><td>基本类</td><td><code>AtomicInteger</code></td><td><code>AtomicLong</code></td><td><code>AtomicBoolean</code></td><td></td></tr><tr><td>引用类型</td><td></td><td></td><td></td><td><code>AtomicReference</code><br/><code>AtomicStampedReference</code><br/><code>AtomicMarkableReference</code></td></tr><tr><td>数组类型</td><td><code>AtomicIntegerArray</code></td><td><code>AtomicLongArray</code></td><td></td><td><code>AtomicReferenceArray</code></td></tr><tr><td>属性原子修改器</td><td><code>AtomicIntegerFieldUpdater</code></td><td><code>AtomicLongFieldUpdater</code></td><td></td><td><code>AtomicReferenceFieldUpdater</code></td></tr></tbody></table><p>JDK 8 新增 <code>Striped64</code> 累加计数器这个并发组件，64 指的是计数 64 bit 的数，即 <code>Long</code> 和 <code>Double</code> 类型。其实现类如下：</p><table><thead><tr><th>Long</th><th>Double</th></tr></thead><tbody><tr><td><code>LongAdder</code></td><td><code>DoubleAdder</code></td></tr><tr><td><code>LongAccumulator</code></td><td><code>DoubleAccumulator</code></td></tr></tbody></table><p>性能对比参考：<a href="http://www.manongjc.com/article/105666.html" target="_blank" rel="noopener">http://www.manongjc.com/article/105666.html</a></p><h1 id="Spring-包简介"><a href="#Spring-包简介" class="headerlink" title="Spring 包简介"></a>Spring 包简介</h1><h2 id="org-springframework-scheduling"><a href="#org-springframework-scheduling" class="headerlink" title="org.springframework.scheduling"></a>org.springframework.scheduling</h2><p>Spring Framework 中并发编程相关的类主要位于 <code>spring-context</code> 下的 <code>org.springframework.scheduling</code>，例如其子包 <code>concurrent</code>：</p><p><img src="/img/java/concurrent/package_spring_concurrent.png" alt="org.springframework.scheduling.concurrent"></p><p>其中，顶层的 <code>org.springframework.scheduling.concurrent.CustomizableThreadFactory</code> 结构如下：</p><p><img src="/img/java/concurrent/CustomizableThreadFactory.png" alt="org.springframework.util.CustomizableThreadFactory"></p><ul><li><p><code>CustomizableThreadFactory</code> 实现了 <code>java.util.concurrent.ThreadFactory</code> 线程工厂接口，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Executors.defaultThreadFactory 方法提供了一个实用的简单实现，为新线程设置了上下文，详见源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Thread <span class="title">newThread</span><span class="params">(Runnable r)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>CustomizableThreadFactory</code> 继承了 <code>org.springframework.util.CustomizableThreadCreator</code> 类，用于创建新线程，并提供各种线程属性自定义配置（如线程名前缀、线程优先级等）。</p></li></ul><p>然后重点看下最常用的 <code>org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor</code> 类，提供的方法列表如下：</p><p><img src="/img/java/concurrent/ThreadPoolTaskExecutor.png" alt="ThreadPoolTaskExecutor 方法列表"></p><p>当我们在实例化 <code>ThreadPoolTaskExecutor</code> 类的时候，其调用堆栈如下：</p><p><img src="/img/java/concurrent/ThreadPoolTaskExecutor_threads.png" alt=""></p><p>可见，实际上是先调用了抽象父类 <code>ExecutorConfigurationSupport</code> 的 <code>afterPropertiesSet()</code> 和 <code>initialize()</code> 方法，最后再调用 <code>ThreadPoolTaskExecutor#initializeExecutor(...)</code>，该方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ExecutorService <span class="title">initializeExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BlockingQueue&lt;Runnable&gt; queue = createQueue(<span class="keyword">this</span>.queueCapacity);</span><br><span class="line"></span><br><span class="line">    ThreadPoolExecutor executor;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.taskDecorator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="keyword">this</span>.corePoolSize, <span class="keyword">this</span>.maxPoolSize, <span class="keyword">this</span>.keepAliveSeconds, TimeUnit.SECONDS,</span><br><span class="line">                queue, threadFactory, rejectedExecutionHandler) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.execute(taskDecorator.decorate(command));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="keyword">this</span>.corePoolSize, <span class="keyword">this</span>.maxPoolSize, <span class="keyword">this</span>.keepAliveSeconds, TimeUnit.SECONDS,</span><br><span class="line">                queue, threadFactory, rejectedExecutionHandler);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.allowCoreThreadTimeOut) &#123;</span><br><span class="line">        executor.allowCoreThreadTimeOut(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.threadPoolExecutor = executor;</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是通过构造方法实例化 <code>java.util.concurrent.ThreadPoolExecutor</code> 对象，并设置相应参数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系数据模型总结</title>
      <link href="2020/04/25/relational-data-model/"/>
      <url>2020/04/25/relational-data-model/</url>
      
        <content type="html"><![CDATA[<h1 id="数据特征"><a href="#数据特征" class="headerlink" title="数据特征"></a>数据特征</h1><p>数据具有两种特征：</p><blockquote><p>静态特征，指的是数据结构、数据间的联系、对数据取值范围的约束。</p><p>动态特征，指的是对数据可以进行符合一定规则的操作</p></blockquote><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><h2 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h2><p><img src="/img/db/data-model/composition_of_data_model.png" alt="composition_of_data_model"></p><h2 id="模型分类"><a href="#模型分类" class="headerlink" title="模型分类"></a>模型分类</h2><p><img src="/img/db/data-model/classification_of_data_model.png" alt="classification_of_data_model"></p><h1 id="关系数据模型"><a href="#关系数据模型" class="headerlink" title="关系数据模型"></a>关系数据模型</h1><h2 id="关系数据结构"><a href="#关系数据结构" class="headerlink" title="关系数据结构"></a>关系数据结构</h2><p><img src="/img/db/data-model/data_structure_of_relational_data_model.png" alt="data_structure_of_relational_data_model"></p><h2 id="关系的完整性约束"><a href="#关系的完整性约束" class="headerlink" title="关系的完整性约束"></a>关系的完整性约束</h2><p><img src="/img/db/data-model/data_check_of_relational_data_model.png" alt="data_check_of_relational_data_model"></p><h2 id="关系数据语言"><a href="#关系数据语言" class="headerlink" title="关系数据语言"></a>关系数据语言</h2><p>关系语言是一种声明式的查询语言，基于声明式编程范式（Declarative），有别于命令式编程范式（Imperative），特点（优点）是：<strong>高度非过程化</strong>！</p><p><img src="/img/db/data-model/relational_language_of_relational_data_model.png" alt="relational_language_of_relational_data_model"></p><h1 id="关系数据库的规范化理论"><a href="#关系数据库的规范化理论" class="headerlink" title="关系数据库的规范化理论"></a>关系数据库的规范化理论</h1><p><img src="/img/db/data-model/normalized_form.png" alt="normalized_form"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8" target="_blank" rel="noopener">数学符号表（维基百科）</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0_(%E6%95%B0%E6%8D%AE%E5%BA%93)" target="_blank" rel="noopener">关系代数（维基百科）</a></p><p><a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0" target="_blank" rel="noopener">关系代数（百度百度）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式 ID 之雪花算法实现</title>
      <link href="2020/03/24/distributed-id-generator/"/>
      <url>2020/03/24/distributed-id-generator/</url>
      
        <content type="html"><![CDATA[<h1 id="雪花算法介绍"><a href="#雪花算法介绍" class="headerlink" title="雪花算法介绍"></a>雪花算法介绍</h1><p>雪花算法（Snowflake）是 Twitter 提出来的一个算法，其目的是生成一个 64 bit 的整数：</p><p><img src="/img/distribute/Snowflake.png" alt="Snowflake"></p><p>转换为十进制和十六进制如下。其中十进制的最大长度为 19 位：</p><p><img src="/img/distribute/max_id.png" alt=""></p><p>其中：</p><ul><li><p>42 bit：用来记录时间戳，表示自 1970-01-01T00:00:00Z 之后经过的毫秒数，其中 1 bit 是符号位。由于精确到毫秒，相比有符号 32 bit 整型所存储的时间戳需要多 10 bit 来记录毫秒数（0-999）。42 bit 可以记录 69 年，如果设置好起始时间比如今年是2018年，那么可以用到2089年。42 bit 时间戳范围如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="keyword">long</span> a = <span class="number">0b00_00000000_00000000_00000000_00000000_00000000L</span>;</span><br><span class="line"><span class="comment">// 999</span></span><br><span class="line"><span class="keyword">long</span> b = <span class="number">0b00_00000000_00000000_00000000_00000011_11100111L</span>;</span><br><span class="line"><span class="comment">// 2^41-1, 2199023255551</span></span><br><span class="line"><span class="keyword">long</span> c = <span class="number">0b01_11111111_11111111_11111111_11111111_11111111L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1970-01-01T00:00:00.000Z</span></span><br><span class="line">Instant.ofEpochMilli(a).atZone(ZoneOffset.of(<span class="string">"-00:00"</span>)).toLocalDateTime();</span><br><span class="line"><span class="comment">// 1970-01-01T00:00:00.999Z</span></span><br><span class="line">Instant.ofEpochMilli(b).atZone(ZoneOffset.of(<span class="string">"-00:00"</span>)).toLocalDateTime();</span><br><span class="line"><span class="comment">// 2039-09-07T15:47:35.551Z</span></span><br><span class="line">Instant.ofEpochMilli(c).atZone(ZoneOffset.of(<span class="string">"-00:00"</span>)).toLocalDateTime();</span><br></pre></td></tr></table></figure></li><li><p>10 bit：用来记录机器 ID，总共可以记录 1024 台机器，一般用前 5 位代表数据中心，后面 5 位是某个数据中心的机器 ID</p></li><li><p>12 bit：循环位，用来对同一个毫秒之内产生不同的 ID，12 位可以最多记录 4095 个，也就是在同一个机器同一毫秒最多记录 4095 个，多余的需要进行等待下个毫秒。</p></li></ul><p>上面只是一个将 64 bit 划分的标准，当然也不一定这么做，可以根据不同业务的具体场景来划分，比如下面给出一个业务场景：</p><ul><li>服务目前 QPS10 万，预计几年之内会发展到百万。</li><li>当前机器三地部署，上海，北京，深圳都有。</li><li>当前机器 10 台左右，预计未来会增加至百台。</li></ul><p>这个时候我们根据上面的场景可以再次合理的划分 64 bit，QPS几年之内会发展到百万，那么每毫秒就是千级的请求，目前10台机器那么每台机器承担百级的请求（100 W / 1000 ms / 10 台）。为了保证扩展，后面的循环位可以限制到 1024，也就是 2^10，那么循环位 10 位就足够了。</p><p>机器三地部署我们可以用 3 bit 总共 8 来表示机房位置；当前机器 10 台，为了保证能够扩展到百台那么可以用 7 bit 总共 128 来表示；时间位依然是 42 bit。那么还剩下 64-10-3-7-42 = 2 bit，剩下 2 bit 可以用来进行扩展。</p><h1 id="雪花算法实现"><a href="#雪花算法实现" class="headerlink" title="雪花算法实现"></a>雪花算法实现</h1><p>下面是我的对雪花算法的实现，涉及几点思考：</p><ol><li>为了节省空间、提升运算性能，主要使用到位运算，而不是字符串操作。</li><li>为了提高可配置性，将每一部分的位数抽取成了常量，以便自定义。</li><li>解决时间回拨问题。如果回拨时长较短（可配置，代码中配了 5 ms），线程等待；如果较长，则利用扩展位避免生成重复 ID（扩展位可配，代码中配置了 3 位，即最多支持 3 次回拨，超出则抛异常）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGeneratorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> initialCapacity = <span class="number">1000</span>;</span><br><span class="line">        Set&lt;Long&gt; ids = <span class="keyword">new</span> HashSet&lt;&gt;(initialCapacity);</span><br><span class="line">        IdGenerator idGenerator = <span class="keyword">new</span> IdGenerator(<span class="number">3</span>, <span class="number">31</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; initialCapacity; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> id = idGenerator.nextId();</span><br><span class="line">            ids.add(id);</span><br><span class="line"></span><br><span class="line">            IdGenerator.log(id);</span><br><span class="line">        &#125;</span><br><span class="line">        assertEquals(ids.size(), initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timestamp;</span><br><span class="line">    <span class="comment">// 数据中心</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> dataCenterNo;</span><br><span class="line">    <span class="comment">// 机器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerNo;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> seqNo;</span><br><span class="line">    <span class="comment">// 扩展位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据中心 取值范围（十进制）：0~3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA_CENTER_NO_BITS = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 机器 取值范围（十进制）：0~31</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_NO_BITS = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 序列号 取值范围（十进制）：0~4095</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEQ_NO_BITS = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">// 扩展位 取值范围（十进制）：0~7</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXT_BITS = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据中心 最大值（十进制）：3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DATA_CENTER_NO = (<span class="number">1</span> &lt;&lt; DATA_CENTER_NO_BITS) - <span class="number">0B1</span>;</span><br><span class="line">    <span class="comment">// 机器 最大值（十进制）：31</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_WORKER_NO = (<span class="number">1</span> &lt;&lt; WORKER_NO_BITS) - <span class="number">0B1</span>;</span><br><span class="line">    <span class="comment">// 序列号 最大值（十进制）：4095</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SEQ_NO = (<span class="number">1</span> &lt;&lt; SEQ_NO_BITS) - <span class="number">0B1</span>;</span><br><span class="line">    <span class="comment">// 扩展位 最大值（十进制）：7</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_EXT = (<span class="number">1</span> &lt;&lt; EXT_BITS) - <span class="number">0B1</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 时间戳 左移 22 位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIMESTAMP_SHIFT = DATA_CENTER_NO_BITS + WORKER_NO_BITS + SEQ_NO_BITS + EXT_BITS;</span><br><span class="line">    <span class="comment">// 数据中心 左移 20 位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA_CENTER_NO_SHIFT = WORKER_NO_BITS + SEQ_NO_BITS + EXT_BITS;</span><br><span class="line">    <span class="comment">// 机器 左移 15 位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORKER_NO_SHIFT = SEQ_NO_BITS + EXT_BITS;</span><br><span class="line">    <span class="comment">// 序列号 左移 3 位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SEQ_NO_SHIFT = EXT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大回拨毫秒数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_BACKWARD_MILLIS = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataCenterNo 数据中心编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerNo 机器编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IdGenerator</span><span class="params">(<span class="keyword">int</span> dataCenterNo, <span class="keyword">int</span> workerNo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Integer.toBinaryString(dataCenterNo).length() &gt; DATA_CENTER_NO_BITS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"当前数据中心编号 %s 超限，最大支持 %s"</span>, dataCenterNo, MAX_DATA_CENTER_NO));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.toBinaryString(workerNo).length() &gt; WORKER_NO_BITS) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"当前机器编号 %s 超限，最大支持 %s"</span>, workerNo, MAX_WORKER_NO));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.dataCenterNo = dataCenterNo;</span><br><span class="line">        <span class="keyword">this</span>.workerNo = workerNo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成分布式 ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分布式 ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// init or reset</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp == <span class="number">0</span> || timestamp &lt; now) &#123;</span><br><span class="line">            timestamp = now;</span><br><span class="line">            seqNo = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// seqNo increment</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timestamp == now) &#123;</span><br><span class="line">            <span class="keyword">if</span> (seqNo &lt; MAX_SEQ_NO) &#123;</span><br><span class="line">                seqNo++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">"序列号已耗尽，等待重新生成。seqNo = &#123;&#125;, MAX_SEQ_NO = &#123;&#125;"</span>, seqNo, MAX_SEQ_NO);</span><br><span class="line">                <span class="keyword">return</span> sleepAndNextId(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// clock backward</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nextIdForBackward(now);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; TIMESTAMP_SHIFT</span><br><span class="line">                | dataCenterNo &lt;&lt; DATA_CENTER_NO_SHIFT</span><br><span class="line">                | workerNo &lt;&lt; WORKER_NO_SHIFT</span><br><span class="line">                | seqNo &lt;&lt; SEQ_NO_SHIFT</span><br><span class="line">                | ext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">nextIdForBackward</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        log.warn(<span class="string">"发生时间回拨，timestamp = &#123;&#125;, now = &#123;&#125;"</span>, timestamp, now);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> duration = timestamp - now;</span><br><span class="line">        <span class="comment">// 回拨不多，直接等待并重试</span></span><br><span class="line">        <span class="keyword">if</span> (duration &lt;= MAX_BACKWARD_MILLIS) &#123;</span><br><span class="line">            <span class="keyword">return</span> sleepAndNextId(duration);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回拨过多，则使用扩展位</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ext &lt; MAX_EXT) &#123;</span><br><span class="line">                <span class="comment">// 将时间戳修正为回拨时间，为防止重复生成 ID，扩展位加一，并重试</span></span><br><span class="line">                ext++;</span><br><span class="line">                timestamp = now;</span><br><span class="line">                <span class="keyword">return</span> nextId();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(<span class="string">"扩展位已耗尽。ext = %s, MAX_EXT = %s"</span>, ext, MAX_EXT));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">sleepAndNextId</span><span class="params">(<span class="keyword">long</span> millis)</span> </span>&#123;</span><br><span class="line">        Thread.sleep(millis);</span><br><span class="line">        <span class="keyword">return</span> nextId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> timestamp = id &gt;&gt; TIMESTAMP_SHIFT;</span><br><span class="line">        <span class="keyword">long</span> dataCenterNo = id &gt;&gt; DATA_CENTER_NO_SHIFT &amp; MAX_DATA_CENTER_NO;</span><br><span class="line">        <span class="keyword">long</span> workerNo = id &gt;&gt; WORKER_NO_SHIFT &amp; MAX_WORKER_NO;</span><br><span class="line">        <span class="keyword">long</span> seqNo = id &gt;&gt; SEQ_NO_SHIFT &amp; MAX_SEQ_NO;</span><br><span class="line">        <span class="keyword">long</span> ext = id &amp; MAX_EXT;</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"Binary is &#123;&#125;, id is &#123;&#125;"</span>, Long.toBinaryString(id), id);</span><br><span class="line">        log.info(<span class="string">"Binary is &#123;&#125;, time is &#123;&#125;"</span>, Long.toBinaryString(timestamp), getLocalDateTime(timestamp));</span><br><span class="line">        log.info(<span class="string">"Binary is &#123;&#125;, dataCenterNo is &#123;&#125;"</span>, Long.toBinaryString(dataCenterNo), dataCenterNo);</span><br><span class="line">        log.info(<span class="string">"Binary is &#123;&#125;, workerNo is &#123;&#125;"</span>, Long.toBinaryString(workerNo), workerNo);</span><br><span class="line">        log.info(<span class="string">"Binary is &#123;&#125;, seqNo is &#123;&#125;"</span>, Long.toBinaryString(seqNo), seqNo);</span><br><span class="line">        log.info(<span class="string">"Binary is &#123;&#125;, ext is &#123;&#125;"</span>, Long.toBinaryString(ext), ext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> LocalDateTime <span class="title">getLocalDateTime</span><span class="params">(<span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Instant.ofEpochMilli(timestamp).atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Binary is 101111000100100011111011111000111010101011111111000000000000000, id is 6783685416349302784</span><br><span class="line">&#x2F;&#x2F; Binary is 10111100010010001111101111100011101010101, time is 2021-04-02T17:43:58.037</span><br><span class="line">&#x2F;&#x2F; Binary is 11, dataCenterNo is 3</span><br><span class="line">&#x2F;&#x2F; Binary is 11111, workerNo is 31</span><br><span class="line">&#x2F;&#x2F; Binary is 0, seqNo is 0</span><br><span class="line">&#x2F;&#x2F; Binary is 0, ext is 0</span><br></pre></td></tr></table></figure><p>二进制分段如下：<code>10111100010010001111101111100011101010101_11_11111_000000000000_000</code></p><h1 id="延伸阅读：位运算"><a href="#延伸阅读：位运算" class="headerlink" title="延伸阅读：位运算"></a>延伸阅读：位运算</h1><p>位运算符如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;：按位与。</span><br><span class="line">|：按位或。</span><br><span class="line">~：按位非。</span><br><span class="line">^：按位异或。</span><br><span class="line">&lt;&lt;：左位移运算符（M &lt;&lt; n &#x3D; M * 2^n）。</span><br><span class="line">&gt;&gt;：右位移运算符（M &gt;&gt; n &#x3D; M &#x2F; 2*n）。</span><br><span class="line">&gt;&gt;&gt;：无符号右移运算符。</span><br></pre></td></tr></table></figure><p>例如，Java 中求 key 应当放到散列表的哪个位置（offset）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getOffset</span><span class="params">(Object key, <span class="keyword">int</span> length)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> hashcode</span>;</span><br><span class="line">    <span class="keyword">int</span> hash = (hashcode = key.hashCode()) ^ (hashcode &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">int</span> offset = hash &amp; (length - <span class="number">1</span>);</span><br><span class="line">    log.info(<span class="string">"key: &#123;&#125;, hashcode: &#123;&#125;, hash: &#123;&#125;, offset: &#123;&#125;"</span>, key, Integer.toBinaryString(hashcode), Integer.toBinaryString(hash), offset);</span><br><span class="line">    <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://www.cnblogs.com/SunArmy/p/9837348.html" target="_blank" rel="noopener">《Java 位运算符 &amp;、|、^、~、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;》</a></li><li><a href="https://blog.csdn.net/qq_39705793/article/details/81237005" target="_blank" rel="noopener">《异或的用途》</a></li></ul><h1 id="UNIX-时间戳"><a href="#UNIX-时间戳" class="headerlink" title="UNIX 时间戳"></a>UNIX 时间戳</h1><p>参考：<a href="/2020/02/28/unix-timestamp/">UNIX 时间戳总结</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNIX 时间戳总结</title>
      <link href="2020/02/28/unix-timestamp/"/>
      <url>2020/02/28/unix-timestamp/</url>
      
        <content type="html"><![CDATA[<h1 id="UNIX-时间戳"><a href="#UNIX-时间戳" class="headerlink" title="UNIX 时间戳"></a>UNIX 时间戳</h1><p><img src="/img/gnu-linux/unix_timestamp.png" alt="unix_timestamp"></p><h1 id="延伸阅读：Y2K38-错误"><a href="#延伸阅读：Y2K38-错误" class="headerlink" title="延伸阅读：Y2K38 错误"></a>延伸阅读：Y2K38 错误</h1><p>2038年问题又叫Unix千年臭虫或Y2K38错误。在时间值以带符号的32位整数来存储或计算的数据存储情况下，这个错误就有可能引发问题。</p><p>可以用Unix带符号的32位整数时间格式来表示的最大时间是 2038年1月19日03:14:07UTC（2038-01-19T03:14:07Z），这是自 1970-01-01T00:00:00Z 之后过了 2147483647 秒，值的边界如下：</p><table><thead><tr><th>时间</th><th>时间戳</th><th>二进制字面量</th></tr></thead><tbody><tr><td>1970-01-01T00:00:00Z</td><td>0</td><td>00000000 00000000 00000000 00000000</td></tr><tr><td>2038-01-19T03:14:07Z</td><td>2^31-1, 2147483647</td><td>01111111 11111111 11111111 11111111</td></tr></tbody></table><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="keyword">long</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 2^31-1, 2147483647</span></span><br><span class="line"><span class="keyword">long</span> b = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1970-01-01T00:00:00.000Z</span></span><br><span class="line">Instant.ofEpochSecond(a).atZone(ZoneOffset.of(<span class="string">"-00:00"</span>)).toLocalDateTime()</span><br><span class="line"><span class="comment">// 2038-01-19T03:14:07.000Z</span></span><br><span class="line">Instant.ofEpochSecond(b).atZone(ZoneOffset.of(<span class="string">"-00:00"</span>)).toLocalDateTime()</span><br></pre></td></tr></table></figure><p>过了最大时间后，由于整数溢出，时间值将作为负数来存储，系统会将日期读为1901年12月13日，而不是2038年1月19日。</p><p>用简单的语言来说，Unix机器最终将会耗尽存储空间来列举秒数。所以，到那一天，使用标准时间库的C程序会开始出现日期问题。你可以在维基百科上详细阅读更多的相关内容（<a href="https://en.wikipedia.org/wiki/Year_2038_problem）。" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Year_2038_problem）。</a></p><p>下面这个动画显示了2038年错误将如何重置日期：</p><p><img src="/img/distribute/Y2K38.GIF" alt="Y2K38"></p><p>资料来源：维基百科</p><p>目前，2038年错误没有什么通行的解决方案。如果对用于存储时间值的time_t数据类型的定义进行更改，依赖带符号的32位time_t整数性质的应用程序就会出现一些代码兼容性问题。假设time_t的类型被更改为不带符号的32位整数，那将加大最新的时间限制。但是，这会对由负整数表示的1970年之前的日期造成混乱。</p><p>使用64位架构的操作系统和程序使用64位time_t整数。使用带符号的64位值可以将日期延长至今后的2920亿年。</p><p>已有人提出了许多建议，包括以带符号的64位整数来存储自某个时间点（1970年1月1日或2000年1月1日）以来的毫秒/微秒，以获得至少30万年的时间范围。其他建议包括用新的库重新编译程序，等等。这方面的工作正在开展之中；据专家们声称，2038年问题解决起来应该不难。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zh.wikipedia.org/zh/UNIX%E6%97%B6%E9%97%B4" target="_blank" rel="noopener">UNIX时间 - 维基百科</a></p><p><a href="https://time.is/UTC" target="_blank" rel="noopener">https://time.is/UTC</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL InnoDB 特性总结</title>
      <link href="2020/01/15/mysql-innodb-features/"/>
      <url>2020/01/15/mysql-innodb-features/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/mysql/InnoDB_features.png" alt="InnoDB_features"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-introduction.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-introduction.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 主键与外键总结</title>
      <link href="2020/01/03/mysql-primary-key-and-foreign-key/"/>
      <url>2020/01/03/mysql-primary-key-and-foreign-key/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>MySQL 原生支持外键（即允许跨表交叉引用相关数据）和外键约束（用于保持<strong>数据一致性</strong>！）。</p><p>外键关系涉及包含初值的父表，以及引用父表值的子表。而外键约束就定义在子表之上。</p><blockquote><p>A foreign key relationship involves a <strong>parent table</strong> that holds the initial column values, and a <strong>child table</strong> with column values that reference the parent column values. A foreign key constraint is defined on the child table.</p></blockquote><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>在 <code>CREATE TABLE</code> 或 <code>ALTER TABLE</code> 语句中定义外键约束的基本语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[CONSTRAINT [fk_symbol]] FOREIGN KEY</span><br><span class="line">    [index_name] (col_name, ...)</span><br><span class="line">    REFERENCES tbl_name (col_name,...)</span><br><span class="line">    [ON <span class="keyword">DELETE</span> reference_option]</span><br><span class="line">    [<span class="keyword">ON</span> <span class="keyword">UPDATE</span> reference_option]</span><br><span class="line"></span><br><span class="line">reference_option:</span><br><span class="line">    RESTRICT | <span class="keyword">CASCADE</span> | <span class="keyword">SET</span> <span class="literal">NULL</span> | <span class="keyword">NO</span> <span class="keyword">ACTION</span> | <span class="keyword">SET</span> <span class="keyword">DEFAULT</span></span><br></pre></td></tr></table></figure><p>删除外键约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> fk_symbol;</span><br></pre></td></tr></table></figure><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建父表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_parent`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_unicode_ci <span class="keyword">COMMENT</span>=<span class="string">'父表'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建子表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_child`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`parent_id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`fk_parent_id`</span> (<span class="string">`parent_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`fk_parent_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`parent_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`t_parent`</span> (<span class="string">`id`</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_unicode_ci <span class="keyword">COMMENT</span>=<span class="string">'子表'</span>;</span><br></pre></td></tr></table></figure><p>可视化界面如下：</p><p><img src="/img/mysql/foreign_key_constraint.png" alt="foreign_key_constraint"></p><p>注意：</p><ul><li><p>创建外键约束时，如果主外键之间的数据类型不一致（例如长度、无符号），会报错：<code>1215 - Cannot add the foreign key constraint</code>。</p></li><li><p>创建外键约束后，MySQL 会为子表自动创建普通索引 <code>fk_parent_id</code>，以提升 <code>join</code> 查询性能。</p></li><li><p>创建外键不一定只能引用父表的主键，也能引用普通列。如果引用普通列，MySQL 则会在父表和子表同时为该列创建普通索引。如果删除该索引会报错：<code>1553 - Cannot drop index &#39;...&#39;: needed in a foreign key constraint</code>。</p></li><li><p><code>reference_option</code> 的几种情况总结如下：</p><ul><li><p>操作父表：</p><ul><li><code>RESTRICT</code> 在 <code>UPDATE</code> 或者 <code>DELETE</code> 父表记录时，对子表进行<strong>一致性检查</strong>。</li><li><code>CASCADE</code> 在 <code>UPDATE</code> 或者 <code>DELETE</code> 父表记录时，对子表进行<strong>级联操作</strong>。</li><li><code>SET NULL</code> 在 <code>UPDATE</code> 或者 <code>DELETE</code> 父表记录时，对子表进行 <strong>SET NULL 操作</strong>。</li></ul><table><thead><tr><th></th><th><code>RESTRICT</code> (<code>NO ACTION</code>)</th><th><code>CASCADE</code></th><th><code>SET NULL</code></th></tr></thead><tbody><tr><td><code>INSERT</code></td><td>正常插入</td><td>正常插入</td><td>正常插入</td></tr><tr><td><code>UPDATE</code></td><td>更新父表值，会报错 <code>1451 - Cannot delete or update a parent row: a foreign key constraint fails</code></td><td>更新父表值，子表值级联更新</td><td>更新父表值，子表值 SET NULL</td></tr><tr><td><code>DELETE</code></td><td>删除父表行，会报错 <code>1451 - Cannot delete or update a parent row: a foreign key constraint fails</code></td><td>删除父表行，子表行级联删除</td><td>删除父表行，子表值 SET NULL</td></tr></tbody></table></li><li><p>操作子表：</p><ul><li><code>INSERT</code>、<code>UPDATE</code> 触发一致性检查。</li></ul><table><thead><tr><th></th><th><code>RESTRICT</code> (<code>NO ACTION</code>)</th><th><code>CASCADE</code></th><th><code>SET NULL</code></th></tr></thead><tbody><tr><td><code>INSERT</code></td><td>无论哪个 option，插入子表行为父表不存在的值，都会报错 <code>1452 - Cannot add or update a child row: a foreign key constraint fails</code></td><td></td><td></td></tr><tr><td><code>UPDATE</code></td><td>同上</td><td></td><td></td></tr><tr><td><code>DELETE</code></td><td>无论哪个 option，删除子表行都 ok</td><td></td><td></td></tr></tbody></table></li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/img/mysql/primary_key_and_foreign_key.png" alt="primary_key_and_foreign_key"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/create-table-foreign-keys.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/create-table-foreign-keys.html</a></p><p><a href="https://mp.weixin.qq.com/s/jOF1rohb6OvA3Pb5rL6Ilg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/jOF1rohb6OvA3Pb5rL6Ilg</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OAuth 2.0 几种授权类型总结</title>
      <link href="2019/12/02/oauth2/"/>
      <url>2019/12/02/oauth2/</url>
      
        <content type="html"><![CDATA[<p>OAuth 协议解决了以下问题：</p><ul><li>密码泄露风险</li><li>无法控制授权范围、有效期</li></ul><p>OAuth 协议中，术语“授权类型（<a href="https://oauth.net/2/grant-types/" target="_blank" rel="noopener">Grant Types</a>）”是指应用获取“访问令牌（Access Token）”的方式。OAuth 2.0 定义了以下几种授权类型：</p><ul><li>用户类资源：需要用户先授权<ul><li>授权码模式（<a href="https://oauth.net/2/grant-types/authorization-code/" target="_blank" rel="noopener">Authorization Code</a>），需要用户授权</li><li>简化模式（<a href="https://oauth.net/2/grant-types/implicit/" target="_blank" rel="noopener">Implicit</a>），不建议使用</li><li>密码模式（<a href="https://oauth.net/2/grant-types/password/" target="_blank" rel="noopener">Password</a>）</li><li>设备码模式（<a href="https://oauth.net/2/grant-types/device-code/" target="_blank" rel="noopener">Device Code</a>）</li></ul></li><li>商户类资源，无需用户授权<ul><li>客户端模式（<a href="https://oauth.net/2/grant-types/client-credentials/" target="_blank" rel="noopener">Client Credentials</a>），也叫商户模式接入</li></ul></li><li>其它<ul><li>令牌刷新模式（<a href="https://oauth.net/2/grant-types/refresh-token/" target="_blank" rel="noopener">Refresh Token</a>）</li></ul></li></ul><p>几种授权类型都有其对应的使用场景，各有利弊，但目的都是为了获取访问令牌。访问令牌是一个用于访问已授权资源的临时凭据。</p><p>商户在接入认证服务器之前，需要先申请一套专用的 <code>client_id</code>、<code>client_secret</code>，据此再申请 <code>access_token</code>。下表总结了其中三种主流授权类型下，申请 <code>access_token</code> 令牌的前置条件：</p><table><thead><tr><th>授权方式</th><th>grant_type</th><th>授权的前置条件</th><th>描述</th></tr></thead><tbody><tr><td>授权码模式</td><td><code>authorization_code</code></td><td>授权码</td><td>这种模式是最常见、功能最完整、流程最严密的授权模式，第三方应用需要先获取授权码，才能申请到令牌。它的特点就是通过第三方应用的后台服务器，与“服务提供商”的认证服务器进行互动，<strong>通过授权码（<code>authorization_code</code>）交换访问令牌（<code>access_token</code>）</strong>，第三方应用不接触用户密码，安全性高。</td></tr><tr><td>密码模式</td><td><code>password</code></td><td>用户的账号、密码</td><td>这种模式通常用在用户对该应用高度信任的情况下，或者所有服务都由同一家公司提供。在这种模式下，用户必须把自己的<strong>用户名和密码</strong>发给应用。应用使用这些信息，再向“服务提供商”索要授权，其风险在于应用获知了密码。但应用无需存储密码，而是存储和使用令牌即可。<br/>密码模式还有一种主流的变种，即使用<strong>用户手机号和短信验证码</strong>申请令牌，相比密码模式会更安全些。为了区分，可以自定义一个 <code>grant_type</code> 为 <code>sms_verify_code</code>。</td></tr><tr><td>客户端模式</td><td><code>client_credentials</code></td><td>无</td><td>第三方应用以自己的名义，而不是以用户的名义，向“服务提供商”进行认证，并获取商户类资源，而不是用户类资源。</td></tr></tbody></table><h1 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h1><p>OAuth 旨在让用户能够对第三方应用授予有限的访问权限。第三方应用首先需要确定所需的权限，然后将用户导向浏览器以获得其授权。简单回顾下：</p><p><img src="/img/security/oauth2.webp" alt="OAuth2 Authorization Code Flow"></p><p>要开始授权流程，第三方应用需要先构建 URL。这里附一张流程图，详细总结下授权码模式的整个流程：</p><p><img src="/img/security/oauth2.png" alt="OAuth 2.0 授权码模式"></p><p>报文如下：</p><p><img src="/img/security/grant_type_of_authorization_code.png" alt="OAuth 2.0 授权码模式"></p><p>交互方式上特别注意浏览器会进行几次 302 重定向。流程总结如下：</p><ol><li>第三方应用首先向服务提供商申请 <code>client_id</code> 应用唯一标识、<code>client_secret</code> 密钥，用于后续获取令牌时提供身份校验；</li><li>获取授权码：此时要提供预分配好的 <code>client_id</code> 标识来源，提供 <code>scope</code> 标识要申请的权限，提供 <code>redirect_uri</code> 标识授权完毕后要回跳的第三方应用的链接。</li><li>第一次 302 重定向：认证服务器展示登录授权页。</li><li>第二次 302 重定向：在用户提交授权，认证服务器认证成功后，会分配授权码 <code>code</code>，并重定向回第三方应用的 <code>redirect_uri</code> 。</li><li>建议第三方应用要根据当前用户会话生成随机且唯一的 <code>state</code> 参数，并在接收到授权码时先进行校验，避免 CSRF 攻击。</li><li>最后，第三方应用会向认证服务器申请令牌 <code>access_token</code>，此时要提供预分配好的 <code>code</code>、<code>client_id</code>、<code>client_secret</code> 以便认证。这一步是在后端之间完成的，对用户不可见。</li><li><code>access_token</code> 是有有效期的，过期后需要刷新。</li><li>拿到令牌 <code>access_token</code> 后，第三方应用就可以访问资源方，获取所需资源。<code>access_token</code> 相当于用户的 session id。</li></ol><p>以微信公众平台为例，<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842" target="_blank" rel="noopener">微信网页授权</a> 就是使用了“授权码模式（<code>grant_type=authorization_code</code>）”。商户在完成接入并获取<strong>用户</strong>的 <code>access_token</code> 之后，可用于如下场景：</p><ul><li>获取用户 openid</li><li>获取用户信息（如昵称、头像、性别、所在地）</li><li>……</li></ul><h1 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h1><p>报文如下：</p><p><img src="/img/security/grant_type_of_password.png" alt="OAuth 2.0 密码模式"></p><h1 id="客户端模式"><a href="#客户端模式" class="headerlink" title="客户端模式"></a>客户端模式</h1><p>客户端授权模式用于请求商户资源，而不是用户资源，报文如下：</p><p><img src="/img/security/grant_type_of_client_credentials.png" alt="OAuth 2.0 客户端模式"></p><p>以微信公众平台为例，<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140183" target="_blank" rel="noopener">获取公众号的 access_token</a> 就是使用了“客户端模式（<code>grant_type=client_credential</code>）”。商户在完成接入并获取<strong>应用</strong>的 <code>access_token</code> 之后，可用于如下场景：</p><ul><li>自定义菜单的配置</li><li>消息推送</li><li>素材管理</li><li>用户管理</li><li>帐户管理</li><li>数据统计</li><li>…… 大量服务</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://oauth.net/2/" target="_blank" rel="noopener">https://oauth.net/2/</a></p><p><a href="https://developer.okta.com/blog/2017/06/21/what-the-heck-is-oauth" target="_blank" rel="noopener">What the Heck is OAuth?</a></p><p><a href="https://developer.linkedin.com/zh-cn/docs/oauth2" target="_blank" rel="noopener">https://developer.linkedin.com/zh-cn/docs/oauth2</a></p><p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></p><p><a href="https://www.jianshu.com/p/c7c8f51713b6" target="_blank" rel="noopener">移花接木：针对OAuth2的CSRF攻击</a></p><p><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421140842" target="_blank" rel="noopener">微信网页授权（授权码模式）</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 延迟关联优化超多分页场景</title>
      <link href="2019/11/26/mysql-deferred-join/"/>
      <url>2019/11/26/mysql-deferred-join/</url>
      
        <content type="html"><![CDATA[<h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>场景：</p><ul><li>订单表数据量：3000 万。</li><li>查询最近 7 天的订单，并做分页、分片。</li></ul><p>表结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_order`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`order_no`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  ...</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`uk_order_no`</span> (<span class="string">`order_no`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_create_time`</span> (<span class="string">`create_time`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8</span><br></pre></td></tr></table></figure><p>超多分页场景如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_order </span><br><span class="line"><span class="keyword">where</span> create_time <span class="keyword">between</span> <span class="string">'2019-10-17'</span> <span class="keyword">and</span> <span class="string">'2019-10-25'</span> </span><br><span class="line"><span class="keyword">limit</span> <span class="number">1000000</span>, <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+---------+-------+-----------------+-----------------+---------+------+---------+-----------------------+</span></span><br><span class="line">| id | select_type | table   | type  | possible_keys   | key             | key_len | ref  | rows    | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+---------+-------+-----------------+-----------------+---------+------+---------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t_order | range | idx_create_time | idx_create_time | 5       | NULL | 3775048 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+---------+-------+-----------------+-----------------+---------+------+---------+-----------------------+</span></span><br></pre></td></tr></table></figure><p>虽然走了 <code>idx_create_time</code> 索引，但仍然是个慢查询，扫描行数过多。</p><h1 id="超多分页的问题是什么？"><a href="#超多分页的问题是什么？" class="headerlink" title="超多分页的问题是什么？"></a>超多分页的问题是什么？</h1><blockquote><p>随着偏移量 <code>offset</code> 的增加，MySQL 需要花费大量的时间来扫描需要丢弃的数据。本质上就是 <code>offset</code> 过大导致的大量回表 I/O 查询。</p></blockquote><p>如果能减少这种大量的回表查询，就能提升查询性能。</p><h1 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h1><h2 id="什么是延迟关联优化？"><a href="#什么是延迟关联优化？" class="headerlink" title="什么是延迟关联优化？"></a>什么是延迟关联优化？</h2><p>什么是“延迟关联”？</p><blockquote><p> 通过使用覆盖索引查询返回需要的主键，再根据主键关联原表获得需要的数据。 </p></blockquote><p>参考两个材料：</p><p>《高性能 MySQL》P194：</p><p><img src="/img/mysql/deferred_join_1.png" alt="deferred_join_1"></p><p>《阿里巴巴 Java 开发手册》：</p><p><img src="/img/mysql/deferred_join_2.png" alt="deferred_join_2"></p><h2 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h2><p>查询的列被所建的辅助索引所覆盖，无需回表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t_order </span><br><span class="line"><span class="keyword">where</span> create_time <span class="keyword">between</span> <span class="string">'2019-10-17'</span> <span class="keyword">and</span> <span class="string">'2019-10-25'</span> </span><br><span class="line"><span class="keyword">limit</span> <span class="number">1000000</span>, <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+---------+-------+-----------------+-----------------+---------+------+---------+--------------------------+</span></span><br><span class="line">| id | select_type | table   | type  | possible_keys   | key             | key_len | ref  | rows    | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+---------+-------+-----------------+-----------------+---------+------+---------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t_order | range | idx_create_time | idx_create_time | 5       | NULL | 3775048 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+---------+-------+-----------------+-----------------+---------+------+---------+--------------------------+</span></span><br></pre></td></tr></table></figure><p>上述查询字段改为 <code>id</code> 后，执行计划中新增： <code>Extra=Using index</code>，表示走覆盖索引，无需回表，查询速度快了 N 倍。</p><h1 id="延迟关联优化"><a href="#延迟关联优化" class="headerlink" title="延迟关联优化"></a>延迟关联优化</h1><p>延迟关联优化涉及到了 SQL 优化的两个重要概念：覆盖索引和回表。</p><ul><li>通过覆盖索引在辅助索引上完成所有扫描、过滤、排序（利用索引有序）和分页；</li><li>最后通过主键回表查询，最大限度减少回表查询的 I/O 次数。</li></ul><p>SQL 改造如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_order t </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t_order </span><br><span class="line">    <span class="keyword">where</span> create_time <span class="keyword">between</span> <span class="string">'2019-10-17'</span> <span class="keyword">and</span> <span class="string">'2019-10-25'</span> </span><br><span class="line">    <span class="keyword">limit</span> <span class="number">1000000</span>, <span class="number">10</span></span><br><span class="line">) e </span><br><span class="line"><span class="keyword">on</span> t.id = e.id;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+---------------+--------+-----------------+-----------------+---------+------+---------+--------------------------+</span></span><br><span class="line">| id | select_type | table         | type   | possible_keys   | key             | key_len | ref  | rows    | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+---------------+--------+-----------------+-----------------+---------+------+---------+--------------------------+</span></span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt;    | ALL    | NULL            | NULL            | NULL    | NULL | 1000010 | NULL                     |</span><br><span class="line">|  1 | PRIMARY     | t             | eq_ref | PRIMARY         | PRIMARY         | 8       | e.id |       1 | NULL                     |</span><br><span class="line">|  2 | DERIVED     | t_order       | range  | idx_create_time | idx_create_time | 5       | NULL | 3775048 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+---------------+--------+-----------------+-----------------+---------+------+---------+--------------------------+</span></span><br></pre></td></tr></table></figure><p>优化前：</p><ol><li>辅助索引查询，得到 id</li><li>id 逐一回表查询<strong>（1000000  + 10 次回表）</strong></li><li>查询结果放弃前 offset 行，返回 limit 行</li></ol><p>优化后：</p><ol><li>辅助查询覆盖查询，得到 id</li><li>查询结果放弃前 offset 行，返回 limit 行</li><li><strong>只需 limit 条 id 回表查询</strong>，大大减少回表查询的 I/O 次数</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/derived-tables.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/derived-tables.html</a></p><p><a href="http://mysql.taobao.org/monthly/2017/03/05/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2017/03/05/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL JOIN 表连接总结</title>
      <link href="2019/11/09/mysql-join/"/>
      <url>2019/11/09/mysql-join/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/mysql/join.png" alt="join"></p><h1 id="连接语法"><a href="#连接语法" class="headerlink" title="连接语法"></a>连接语法</h1><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单的等值语法创建内联结</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Vendors, Products</span><br><span class="line"><span class="keyword">WHERE</span> Vendors.vend_id = Products.vend_id;</span><br><span class="line"></span><br><span class="line"><span class="comment"># ANSI SQL 规范首选 INNER JOIN 语法创建内联结</span></span><br><span class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</span><br><span class="line"><span class="keyword">FROM</span> Vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Products</span><br><span class="line"><span class="keyword">ON</span> Vendors.vend_id = Products.vend_id;</span><br></pre></td></tr></table></figure><p>在内连接两个表时，实际要做的是将第一个表中的每一行与第二个表中的每一行配对，<code>WHERE</code> 或 <code>ON</code> 子句作为过滤条件，<strong>只包含那些匹配连接条件的行</strong>。</p><p>由没有连接条件的表关系返回的结果为<strong>笛卡儿积（cartesian product）</strong>。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。因此应当总是提供连接条件。</p><h2 id="外连接（左、右）"><a href="#外连接（左、右）" class="headerlink" title="外连接（左、右）"></a>外连接（左、右）</h2><p>许多连接将一个表中的行与另一个表中的行相关联，但有时候需要<strong>包含没有关联行</strong>的那些行，例如：</p><ul><li><p>对每个顾客下的订单进行计数，包括那些至今尚未下订单的顾客；</p></li><li><p>列出所有产品以及订购数量，包括没有人订购的产品；</p></li><li><p>计算平均销售规模，包括那些至今尚未下订单的顾客。</p></li></ul><p>在上述例子中，连接包含了那些在相关表中没有关联行的行。这种连接称为外连接。</p><p>例如，要检索出所有顾客+订单，包括那些还未下单的顾客：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Orders.order_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">cust_id    order_num</span><br><span class="line"><span class="comment">---------- ---------</span></span><br><span class="line">1000000001 20005</span><br><span class="line">1000000001 20009</span><br><span class="line">1000000002 NULL</span><br><span class="line">1000000003 20006</span><br><span class="line">1000000004 20007</span><br><span class="line">1000000005 20008</span><br></pre></td></tr></table></figure><p>上例如果使用内连接，将不包含 <em>1000000002</em> 顾客，因为他还未下单（即连接条件不匹配）。</p><p>作为对比，下例使用内连接 <code>INNER JOIN</code> 和聚集函数 <code>COUNT()</code> 统计出所有顾客的订单数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, <span class="keyword">COUNT</span>(Orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Customers.cust_id;</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">cust_id    num_ord</span><br><span class="line"><span class="comment">---------- --------</span></span><br><span class="line">1000000001 2</span><br><span class="line">1000000003 1</span><br><span class="line">1000000004 1</span><br><span class="line">1000000005 1</span><br></pre></td></tr></table></figure><p>但如果使用左外连接 <code>LEFT OUTER JOIN</code> 和聚集函数 <code>COUNT()</code> 进行相同统计，将会包括那些还未下单的顾客，例如顾客 <em>1000000002</em>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, <span class="keyword">COUNT</span>(Orders.order_num) <span class="keyword">AS</span> num_ord</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Customers.cust_id;</span><br><span class="line"></span><br><span class="line">-&gt;</span><br><span class="line">cust_id    num_ord</span><br><span class="line"><span class="comment">---------- -------</span></span><br><span class="line">1000000001 2</span><br><span class="line">1000000002 0</span><br><span class="line">1000000003 1</span><br><span class="line">1000000004 1</span><br><span class="line">1000000005 1</span><br></pre></td></tr></table></figure><p>由于 <code>COUNT(column)</code> 计数会忽略 <code>NULL</code> 值，因此顾客 <em>1000000002</em> 的统计结果为 0。</p><p>注意，左、右外连接之间的唯一差别是所关联的表的顺序。换句话说，调整 <code>FROM</code> 或 <code>WHERE</code> 子句中表的顺序，左外连接可以转换为右外连接。因此，这两种外连接可以互换使用，哪个方便就用哪个。</p><h1 id="连接算法"><a href="#连接算法" class="headerlink" title="连接算法"></a>连接算法</h1><p>MySQL 使用下面两种算法执行表连接：</p><ul><li>嵌套循环连接算法（Nested-Loop Join（NLJ）），在被驱动表 <code>join</code> 字段有索引时使用。</li><li>基于块的嵌套循环连接算法（Block Nested-Loop Join（BNL）），在被驱动表 <code>join</code> 字段无索引时使用，以减少被驱动表的全表扫描次数。</li></ul><h2 id="NLJ"><a href="#NLJ" class="headerlink" title="NLJ"></a>NLJ</h2><p>Nested-Loop Join (NLJ) :</p><blockquote><p>A simple nested-loop join (NLJ) algorithm reads rows from the first table in a loop one at a time, passing each row to a nested loop that processes the next table in the join. This process is repeated as many times as there remain tables to be joined.</p></blockquote><p>例如，使用以下 <code>join type</code> 执行 <code>t1</code>、<code>t2</code> 和  <code>t3</code> 三个表之间的表连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Table   Join Type</span><br><span class="line">t1      range</span><br><span class="line">t2      ref</span><br><span class="line">t3      ALL</span><br></pre></td></tr></table></figure><p>使用 NLJ 算法，则按以下方式处理连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each row <span class="keyword">in</span> t1 matching range &#123;</span><br><span class="line">  <span class="keyword">for</span> each row <span class="keyword">in</span> t2 matching reference key &#123;</span><br><span class="line">    <span class="keyword">for</span> each row <span class="keyword">in</span> t3 &#123;</span><br><span class="line">      <span class="keyword">if</span> row satisfies join conditions, send to client</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BNL"><a href="#BNL" class="headerlink" title="BNL"></a>BNL</h2><p>BNL 算法将外层循环的检索行缓存到 <code>join_buffer</code>（无序数组）中，以减少内层循环的全表扫描次数。例如，如果外层循环先将 10 行数据读入缓冲区，并将其传递给下一个内层循环，内层循环只需全表扫描一次，即可将读取到的每一行与缓冲区中的所有 10 行在内存中进行比较。这将使得内层循环表的全表扫描次数减少一个数量级。</p><p>MySQL <code>join buffer</code> 具有以下特征：</p><ul><li>当 <code>join type</code> 为 <code>ALL</code>、<code>index</code>、<code>range</code> 使用 <code>join buffer</code>。</li><li><code>join buffer</code> 同样适用于外连接，详见：<a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html" target="_blank" rel="noopener">Section 8.2.1.11, “Block Nested-Loop and Batched Key Access Joins”</a></li><li>系统变量 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_join_buffer_size" target="_blank" rel="noopener"><code>join_buffer_size</code></a> 用于配置每次查询每个 BNL 连接的缓冲区大小，因此一个查询可能用到多个 <code>join buffer</code>。</li><li>在执行连接之前分配 <code>join buffer</code>，并在查询完成后释放。</li></ul><p>使用 BNL 算法，伪代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> each row <span class="keyword">in</span> t1 matching range &#123;</span><br><span class="line">  <span class="keyword">for</span> each row <span class="keyword">in</span> t2 matching reference key &#123;</span><br><span class="line">    store used columns <span class="keyword">from</span> t1, t2 <span class="keyword">in</span> join buffer</span><br><span class="line">    <span class="keyword">if</span> buffer is full &#123;</span><br><span class="line">      <span class="keyword">for</span> each row <span class="keyword">in</span> t3 &#123;</span><br><span class="line">        <span class="keyword">for</span> each t1, t2 combination <span class="keyword">in</span> join buffer &#123;</span><br><span class="line">          <span class="keyword">if</span> row satisfies join conditions, send to client</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      empty join buffer</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> buffer is not empty &#123;</span><br><span class="line">  <span class="keyword">for</span> each row <span class="keyword">in</span> t3 &#123;</span><br><span class="line">    <span class="keyword">for</span> each t1, t2 combination <span class="keyword">in</span> join buffer &#123;</span><br><span class="line">      <span class="keyword">if</span> row satisfies join conditions, send to client</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设 <code>S</code> 为每行 <code>used columns from t1, t2</code> 的大小， <code>C</code> 为其行数，则 <code>t3</code> 全表扫描的次数为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t3_scanned_count &#x3D; </span><br><span class="line">  (S * C) % join_buffer_size &#x3D;&#x3D; 0 ? </span><br><span class="line">    (S * C) &#x2F; join_buffer_size : </span><br><span class="line">    (S * C) &#x2F; join_buffer_size + 1</span><br></pre></td></tr></table></figure><p>因此，随着 <code>join_buffer_size</code> 增加，<code>t3</code> 全表扫描的次数反比减少，直到 <code>join_buffer_size=(S * C)</code> 时则无法再优化。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/join.html" target="_blank" rel="noopener">JOIN Syntax</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/select-optimization.html" target="_blank" rel="noopener">Optimizing SELECT Statements</a></p><ul><li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/nested-loop-joins.html" target="_blank" rel="noopener">Nested-Loop Join Algorithms</a></p></li><li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/nested-join-optimization.html" target="_blank" rel="noopener">Nested Join Optimization</a></p></li><li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/outer-join-optimization.html" target="_blank" rel="noopener">Outer Join Optimization</a></p></li><li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/outer-join-simplification.html" target="_blank" rel="noopener">Outer Join Simplification</a></p></li><li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/mrr-optimization.html" target="_blank" rel="noopener">Multi-Range Read Optimization</a></p></li><li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/bnl-bka-optimization.html" target="_blank" rel="noopener">Block Nested-Loop and Batched Key Access Joins</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 几种排序机制分析及优化</title>
      <link href="2019/10/25/mysql-order-by/"/>
      <url>2019/10/25/mysql-order-by/</url>
      
        <content type="html"><![CDATA[<h1 id="排序流程"><a href="#排序流程" class="headerlink" title="排序流程"></a>排序流程</h1><p>四种排序情况的流程（参考《极客时间》专栏）：</p><p><img src="/img/mysql/order_by_process.png" alt="order_by_process"></p><p><img src="/img/mysql/order_by_process_2.png" alt="order_by_process"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>排序总结：</p><p><img src="/img/mysql/order_by.png" alt="order_by"></p><p>外部排序总结：</p><ul><li>MySQL 会给每个线程分配一块内存用于排序，称为 <code>sort_buffer</code>。对 <code>sort_buffer</code> 中的数据按照排序字段做<strong>快速排序</strong>；</li><li>排序可能在内存中完成，也可能需要使用磁盘排序，取决于排序所需的内存和参数 <code>sort_buffer_size</code>。</li><li>内存放不下时，使用外部磁盘排序，外部磁盘排序一般使用<strong>归并排序</strong>算法。可以简单理解，MySQL 将需要排序的数据分成 N 份，每一份单独排序后存在这些临时文件中。然后把这 N 个有序文件再合并成一个有序的大文件。</li></ul><p>优化方式：</p><ul><li>将 <code>WHERE</code> 和 <code>ORDER BY</code> 子句用到的字段，添加联合索引（注意字段顺序）；</li><li>如果 <code>GROUP BY</code> 结果无需排序，可以加上 <code>ORDER BY NULL</code>。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 索引优化总结</title>
      <link href="2019/10/20/mysql-index/"/>
      <url>2019/10/20/mysql-index/</url>
      
        <content type="html"><![CDATA[<p>索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高几个数量级，“最优”的索引有时比一个“好的”索引性能要好两个数量级。</p><p>索引是存储引擎用于快速找到记录的一种数据结构。在 MySQL 中，索引是在存储引擎层而不是服务器层实现的（如下图）。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p><p><img src="/img/mysql/mysql_architecture.png" alt="MySQL Architecture"></p><h1 id="常见索引类型"><a href="#常见索引类型" class="headerlink" title="常见索引类型"></a>常见索引类型</h1><p>MySQL 支持的常见索引类型：</p><ul><li>B+Tree 索引</li><li>Hash index（哈希索引）</li><li>R-Tree index（空间数据索引）</li><li>Full-text index（全文索引）</li><li>……</li></ul><p>本文只探讨最常用的 B-Tree 索引。</p><h1 id="B-Tree-数据结构"><a href="#B-Tree-数据结构" class="headerlink" title="B+Tree 数据结构"></a>B+Tree 数据结构</h1><h1 id="B-Tree-索引特性"><a href="#B-Tree-索引特性" class="headerlink" title="B+Tree 索引特性"></a>B+Tree 索引特性</h1><p>当我们谈论索引的时候，如果没有特别指明类型，那多半说的是 B+Tree 索引。InnoDB 存储引擎默认使用的也是 B+Tree 数据结构来存储数据。<br>索引可以包含一个或多个列的值。如果包含多个列（称为“联合索引”），那么列的顺序至关重要，因为 MySQL 只能高效地使用索引的 <strong>最左前缀列</strong>。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的，下面看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE People (</span><br><span class="line">   last_name  varchar(50)    not null,</span><br><span class="line">   first_name varchar(50)    not null,</span><br><span class="line">   dob        date           not null,</span><br><span class="line">   gender     enum(&#39;m&#39;, &#39;f&#39;) not null,</span><br><span class="line">   key(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>可以使用该 B-Tree 索引的查询类型：</p><h2 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h2><p>全值匹配（Match the full value）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM people</span><br><span class="line">WHERE last_name &#x3D; &#39;Wu&#39; AND first_name &#x3D; &#39;Qida&#39; AND dob &#x3D; &#39;2018-01-01&#39;;</span><br></pre></td></tr></table></figure><h2 id="匹配最左前缀"><a href="#匹配最左前缀" class="headerlink" title="匹配最左前缀"></a>匹配最左前缀</h2><p>匹配最左前缀（Match a leftmost prefix）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM people</span><br><span class="line">WHERE last_name &#x3D; &#39;Wu&#39;;</span><br><span class="line"></span><br><span class="line">SELECT * </span><br><span class="line">FROM people</span><br><span class="line">WHERE last_name &#x3D; &#39;Wu&#39; AND first_name &#x3D; &#39;Qida&#39;;</span><br></pre></td></tr></table></figure><h2 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h2><p>匹配列前缀（Match a column prefix）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM people</span><br><span class="line">WHERE last_name LIKE &#39;W%&#39;;</span><br></pre></td></tr></table></figure><p>注意 MySQL <code>LIKE</code> 的限制：</p><blockquote><p>MySQL can’t perform the LIKE operation in the index. This is a limitation of the low-level storage engine API, which in MySQL 5.5 and earlier allows only simple comparisons (such as equality, inequality, and greater-than) in index operations. </p><p>MySQL can perform <strong>prefix-match LIKE patterns</strong> in the index because it can convert them to simple comparisons, but the leading wildcard in the query makes it impossible for the storage engine to evaluate the match. Thus, the MySQL server itself will have to fetch and match on the row’s values, not the index’s values.</p></blockquote><h2 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h2><p>匹配范围值（Match a range of values）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM people</span><br><span class="line">WHERE last_name BETWEEN &#39;Wu&#39; AND &#39;Li&#39;;</span><br></pre></td></tr></table></figure><h2 id="精确匹配某一列，并范围匹配另外一列"><a href="#精确匹配某一列，并范围匹配另外一列" class="headerlink" title="精确匹配某一列，并范围匹配另外一列"></a>精确匹配某一列，并范围匹配另外一列</h2><p>精确匹配某一列，并范围匹配另外一列（Match one part exactly and match a range on another part）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * </span><br><span class="line">FROM people</span><br><span class="line">WHERE last_name &#x3D; &#39;Wu&#39; And first_name LIKE &#39;Q%&#39;;</span><br></pre></td></tr></table></figure><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>只访问索引列的查询（Index-only queries）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name, first_name, dob</span><br><span class="line">FROM people</span><br><span class="line">WHERE last_name &#x3D; &#39;Wu&#39; AND first_name &#x3D; &#39;Qida&#39; AND dob &#x3D; &#39;2018-01-01&#39;;</span><br></pre></td></tr></table></figure><h1 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h1><h2 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h2><p>索引列按区分度从高到低排列。</p><h2 id="使用独立的列"><a href="#使用独立的列" class="headerlink" title="使用独立的列"></a>使用独立的列</h2><p>“独立的列”是指不在索引列上做任何操作，包括：</p><ul><li>计算（不能是表达式的一部分）</li><li>作为函数的参数。</li><li>隐式或显式的类型转换</li><li>隐式字符编码转换</li></ul><p>例如，下面这个查询无法使用 actor_id 列的索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 错误示范</span><br><span class="line">SELECT * </span><br><span class="line">FROM people</span><br><span class="line">WHERE id + 1 &#x3D; 5;</span><br><span class="line"></span><br><span class="line">-- 正确示范</span><br><span class="line">SELECT * </span><br><span class="line">FROM people</span><br><span class="line">WHERE id &#x3D; 4;</span><br></pre></td></tr></table></figure><p>凭肉眼很容易看出 <code>WHERE</code> 中的表达式其实等价于 <code>id = 4</code> ，但是 MySQL 无法自动解析这个方程式。这完全是用户行为。我们应该养成简化 <code>WHERE</code> 条件的习惯，始终将索引列单独放在比较符号的一侧。</p><p>下面是另一个常见的错误，将索引列作为函数的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 错误示范</span><br><span class="line">SELECT ...</span><br><span class="line">WHERE DATE(create_time) &#x3D; &#39;2000-01-01&#39;;</span><br><span class="line"></span><br><span class="line">-- 正确示范</span><br><span class="line">SELECT ...</span><br><span class="line">WHERE create_time BETWEEN &#39;2000-01-01 00:00:00&#39; AND &#39;2000-01-01 23:59:59&#39;;</span><br></pre></td></tr></table></figure><p>另一个常见错误，merchant_no 为 <code>VARCHAR</code> 类型且加了索引，但由于隐式类型转换为数字类型，导致全表扫描：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误示范</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> t_order</span><br><span class="line"><span class="keyword">WHERE</span> merchant_no = <span class="number">2016</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 正确示范</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> t_order</span><br><span class="line"><span class="keyword">WHERE</span> merchant_no = <span class="string">'2016'</span>;</span><br></pre></td></tr></table></figure><h2 id="字符串索引优化"><a href="#字符串索引优化" class="headerlink" title="字符串索引优化"></a>字符串索引优化</h2><h3 id="常规方式"><a href="#常规方式" class="headerlink" title="常规方式"></a>常规方式</h3><ul><li>直接创建完整索引<ul><li>优点：可以使用覆盖索引</li><li>缺点：比较占用空间</li></ul></li><li>创建前缀索引<ul><li>优点：节省空间</li><li>缺点：<ul><li>需要计算好区分度，以定义合适的索引长度，否则会增加回表次数</li><li>无法使用覆盖索引</li></ul></li></ul></li></ul><p>区分度计算方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">4</span>)) / <span class="keyword">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L4, </span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">5</span>)) / <span class="keyword">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L5, </span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">6</span>)) / <span class="keyword">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L6, </span><br><span class="line">  <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(email,<span class="number">7</span>)) / <span class="keyword">count</span>(<span class="keyword">distinct</span> email) <span class="keyword">as</span> L7,</span><br><span class="line"><span class="keyword">from</span> t1;</span><br></pre></td></tr></table></figure><h3 id="其它方式一"><a href="#其它方式一" class="headerlink" title="其它方式一"></a>其它方式一</h3><ul><li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题。查询时使用 <code>reverse</code> 函数。</li><li>创建额外的 hash 字段并创建索引，查询性能稳定（散列冲突的概率更小），有额外的存储和计算消耗，查询时使用 <code>crc32</code> 函数并二次比较。</li></ul><p>这两种方式都不支持范围扫描，只支持等值查询。</p><h3 id="其它方式二"><a href="#其它方式二" class="headerlink" title="其它方式二"></a>其它方式二</h3><p>改为使用更合适的数据类型，例如：</p><ul><li>使用日期与时间类型，而不是字符串来存储日期和时间。</li><li>使用整型，而不是字符串来存储 IP 地址。</li><li>使用定长二进制类型（如 <code>binary</code>），而不是字符串来存储散列值。</li></ul><h1 id="索引选择性"><a href="#索引选择性" class="headerlink" title="索引选择性"></a>索引选择性</h1><p>了解两个概念：</p><ul><li><strong>基数</strong>（Cardinality）也称为区分度，是指数据列所包含的不同值的数量。例如，某个数据列包含值：1、2、3、4、5、1，则基数为 5。可以通过 <code>show index</code> 查看。</li><li><strong>索引选择性</strong>（Index Selectivity）是指基数（Cardinality）和数据表的记录总数（#T）的比值，范围从 <code>1/#T</code> 到 <code>1</code> 之间。</li></ul><p>索引的选择性越高则查询效率越高，因为选择性高的索引可以让 MySQL 在查找时过滤掉更多的行。唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。</p><p>下面显示如何计算某列的<strong>平均选择性</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(DISTINCT last_name) &#x2F; COUNT(*) AS Selectivity</span><br><span class="line">FROM people;</span><br><span class="line"></span><br><span class="line">Selectivity: 0.0312</span><br></pre></td></tr></table></figure><p>只看平均选择性有时是不够的，需考虑最坏或特殊情况下的选择性（即值的分布，是否有某些值占比过多？）。</p><p>如果索引的选择性低（基数/总数的比值），可能会导致优化器生成执行计划时，不走这个索引。</p><p>有时 MySQL 会选错索引，解决方案如下：</p><ul><li>通过 <code>show index</code> 语句查看索引的“基数”。对于由于索引统计信息不准确导致的问题，可以用 <code>analyze table</code> 来重新统计索引信息。</li><li><code>force index</code> 强行选择一个索引。</li><li>修改语句，引导 MySQL 使用我们期望的索引。</li><li>新建一个更合适的索引，来提供给优化器做选择，或删掉误用的索引。</li></ul><h1 id="三星索引评价系统"><a href="#三星索引评价系统" class="headerlink" title="三星索引评价系统"></a>三星索引评价系统</h1><p>评估某个索引是否适合某个查询的“三星评价系统”（three-star system）：</p><blockquote><p>Lahdenmaki and Leach’s book also introduces a three-star system for grading how suitable an index is for a query:</p><ul><li>The index earns one star if it places relevant rows adjacent to each other, </li><li>a second star if its rows are sorted in the order the query needs,</li><li>and a final star if it contains all the columns needed for the query.</li></ul></blockquote><ul><li>一星：索引列满足查询所需的条件。如果是多个查询条件，则利用联合索引及其最左前缀匹配特性。</li><li>二星：索引行排序符合查询所需的排序，没有额外的 <code>ORDER BY</code>（避免 <code>filesort</code>）。</li><li>三星：索引列满足查询所需的全部列，不再需要回表查询（即利用覆盖索引 <code>covering index</code>）。</li></ul><h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><p>下面介绍一些查看索引的常用命令：</p><h2 id="DESC"><a href="#DESC" class="headerlink" title="DESC"></a>DESC</h2><p><code>DESC</code> 命令查看表结构时，可以看到索引列 <code>Key</code> ，共有三种类型：</p><ul><li><code>PRI</code> 表示主键索引（PRIMARY KEY）。</li><li><code>UNI</code> 表示唯一索引（UNIQUE KEY），值不能重复。</li><li><code>MUL</code> 表示普通索引（MULTIPLE KEY） ，值可重复。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ DESC table_name;</span><br><span class="line"></span><br><span class="line">+---------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field   | Type         | Null | Key | Default | Extra |</span><br><span class="line">+---------+--------------+------+-----+---------+-------+</span><br><span class="line">| FID     | int(11)      | NO   | PRI | NULL    |       |</span><br><span class="line">| FKEY    | varchar(50)  | NO   | UNI | NULL    |       |</span><br><span class="line">| FVALUE  | varchar(500) | YES  | MUL | NULL    |       |</span><br><span class="line">| FDESC   | varchar(50)  | YES  | MUL | NULL    |       |</span><br><span class="line">| FCACHED | int(1)       | NO   |     | 1       |       |</span><br><span class="line">+---------+--------------+------+-----+---------+-------+</span><br></pre></td></tr></table></figure><h2 id="SHOW-INDEX"><a href="#SHOW-INDEX" class="headerlink" title="SHOW INDEX"></a>SHOW INDEX</h2><p><code>SHOW INDEX</code> 可以以列为单位，查看该表索引的具体信息，例如：</p><ul><li>表名 <code>Table</code></li><li>索引唯一性 <code>Non_unique</code></li><li>索引名 <code>Key_name</code></li><li>联合索引中的顺序 <code>Seq_in_index</code></li><li>列名 <code>Column_name</code></li><li>基数 <code>Cardinality</code></li><li>索引类型 <code>Index_type</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ SHOW INDEX FROM table_name;</span><br><span class="line"></span><br><span class="line">+------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">|   Table    | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |</span><br><span class="line">+------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">| table_name |          0 |  PRIMARY |            1 | FID         | A         |         105 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| table_name |          0 |  UK_FKEY |            1 | FKEY        | A         |         105 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| table_name |          1 |  IDX_V_D |            1 | FVALUE      | A         |         105 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">| table_name |          1 |  IDX_V_D |            2 | FDESC       | A         |         105 |     NULL | NULL   |      | BTREE      |         |               |</span><br><span class="line">+------------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br></pre></td></tr></table></figure><h2 id="SHOW-CREATE-TABLE"><a href="#SHOW-CREATE-TABLE" class="headerlink" title="SHOW CREATE TABLE"></a>SHOW CREATE TABLE</h2><p><code>SHOW CREATE TABLE</code> 可以查看该表的建表语句，留意最后几行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE table_name;</span><br><span class="line"></span><br><span class="line">CREATE TABLE &#96;table_name&#96; (</span><br><span class="line">  &#96;FID&#96; int(11) NOT NULL,</span><br><span class="line">  &#96;FKEY&#96; varchar(50) NOT NULL,</span><br><span class="line">  &#96;FVALUE&#96; varchar(200) NOT NULL,</span><br><span class="line">  &#96;FDESC&#96; varchar(50) DEFAULT NULL,</span><br><span class="line">  &#96;FCACHED&#96; int(1) NOT NULL DEFAULT &#39;1&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;FID&#96;),</span><br><span class="line">  UNIQUE KEY &#96;UK_FKEY&#96; (&#96;FKEY&#96;),</span><br><span class="line">  KEY &#96;IDX_V_D&#96; (&#96;FVALUE&#96;, &#96;FDESC&#96;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高性能 MySQL》</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-indexes.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-indexes.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/optimization-indexes.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/optimization-indexes.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/show-columns.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/show-columns.html</a></p><p>《<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 执行计划总结</title>
      <link href="2019/10/01/mysql-explain/"/>
      <url>2019/10/01/mysql-explain/</url>
      
        <content type="html"><![CDATA[<p><code>EXPLAIN</code> 语句提供有关 MySQL 优化器如何执行语句的信息。能够用于 <code>SELECT</code>、<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code>、<code>UPDATE</code> 语句。</p><p><code>EXPLAIN</code> 为 <code>SELECT</code> 语句中使用到的每张表输出一行信息 。它按照 MySQL 在处理 <code>SELECT</code> 语句时的读取顺序来列出各张表。</p><p>MySQL 使用嵌套循环连接算法（NLJ）来解析所有的表连接（MySQL resolves all joins using a nested-loop join method）。详见另一篇。</p><p><code>EXPLAIN</code> 输出列如下：</p><table><thead><tr><th>Column</th><th>JSON Name</th><th>Meaning</th></tr></thead><tbody><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_id" target="_blank" rel="noopener"><code>id</code></a></td><td><code>SELECT</code> 标识符</td><td>The <code>SELECT</code> identifier</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_select_type" target="_blank" rel="noopener"><code>select_type</code></a></td><td><code>SELECT</code> 类型</td><td>The <code>SELECT</code> type</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_table" target="_blank" rel="noopener"><code>table</code></a></td><td>引用的表名</td><td>The table for the output row</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_partitions" target="_blank" rel="noopener"><code>partitions</code></a></td><td>匹配的分区</td><td>The matching partitions</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_type" target="_blank" rel="noopener"><code>type</code></a></td><td>连接类型</td><td>The join type</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_possible_keys" target="_blank" rel="noopener"><code>possible_keys</code></a></td><td>可选的索引</td><td>The possible indexes to choose</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key" target="_blank" rel="noopener"><code>key</code></a></td><td>实际选择的索引</td><td>The index actually chosen</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_key_len" target="_blank" rel="noopener"><code>key_len</code></a></td><td>实际所选 key 的长度</td><td>The length of the chosen key</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_ref" target="_blank" rel="noopener"><code>ref</code></a></td><td>与索引比较的列</td><td>The columns compared to the index</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_rows" target="_blank" rel="noopener"><code>rows</code></a></td><td>扫描行数</td><td>Estimate of rows to be examined</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_filtered" target="_blank" rel="noopener"><code>filtered</code></a></td><td>按表条件过滤的行百分比</td><td>Percentage of rows filtered by table condition</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain_extra" target="_blank" rel="noopener"><code>Extra</code></a></td><td>附加信息</td><td>Additional information</td></tr></tbody></table><h1 id="id"><a href="#id" class="headerlink" title="id"></a>id</h1><p><code>id</code> 列的编号是 <code>SELECT</code> 的序列号，有几个 <code>SELECT</code> 就有几个 <code>id</code>。<code>id</code> 值越大执行优先级越高，<code>id</code> 值相同则从上往下执行，<code>id</code> 值为 <code>NULL</code> 则最后执行。</p><h1 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h1><p>表示查询类型是简单查询还是复杂查询。常见 <code>SELECT</code> 类型如下：</p><table><thead><tr><th><code>select_type</code> Value</th><th>Meaning</th></tr></thead><tbody><tr><td><code>SIMPLE</code></td><td>Simple <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> (not using <a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a> or subqueries)</td></tr><tr><td><code>PRIMARY</code></td><td>Outermost <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a></td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a></td><td>Second or later <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> statement in a <a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a></td></tr><tr><td><code>UNION RESULT</code></td><td>Result of a <a href="https://dev.mysql.com/doc/refman/5.7/en/union.html" target="_blank" rel="noopener"><code>UNION</code></a></td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/optimizer-hints.html#optimizer-hints-subquery" target="_blank" rel="noopener"><code>SUBQUERY</code></a></td><td>First <a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> in subquery</td></tr><tr><td><code>DERIVED</code></td><td>Derived table</td></tr><tr><td><code>MATERIALIZED</code></td><td>Materialized subquery</td></tr></tbody></table><h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>表示输出行所引用的表名，特殊情况如下：</p><ul><li>&lt;union<em>M</em>,<em>N</em>&gt;：该行指的是 <code>id</code> 值为 <em>M</em> 和 <em>N</em> 的并集。当有 <code>UNION</code> 时，<code>UNION RESULT</code> 的 <code>table</code> 列的值为 &lt;union<em>M</em>,<em>N</em>&gt;，表示参与并集的 <code>id</code> 查询编号为 <em>M</em> 和 <em>N</em>。</li><li>&lt;derived<em>N</em>&gt;：当 <code>FROM</code> 子句中有子查询时， <code>table</code> 列为 &lt;derived<em>N</em>&gt;，表示当前查询依赖于 id=N 的查询结果，于是先执行 id=N 的查询。</li><li>&lt;subquery<em>N</em>&gt;</li></ul><h1 id="type"><a href="#type" class="headerlink" title="type"></a>type</h1><p>单表查询的性能对比：<code>const</code> &gt; <code>ref</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code>。一般来说，得保证查询达到 <code>range</code> 级别，最好达到 <code>ref</code> 级别。</p><h2 id="system"><a href="#system" class="headerlink" title="system"></a>system</h2><p>该表只有一行。是 <code>const</code> 连接类型的特例。</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>该表最多只有一个匹配行，该行在查询开始时读取。因为只有一行，所以优化器的其余部分可以将这一行中列的值视为常量。<code>const</code> 表非常快，因为它们只能读取一次。</p><p>当主键索引（<code>PRIMARY KEY</code> ）或唯一索引（<code>UNIQUE KEY</code>）与常量值比较时使用 <code>const</code> 类型。如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> primary_key = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> primary_key_part1 = <span class="number">1</span> <span class="keyword">AND</span> primary_key_part2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> unique_key = <span class="string">'001'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> unique_key_part1 = <span class="string">'001'</span> <span class="keyword">AND</span> unique_key_part2 = <span class="string">'002'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.unique_key_column = other_table.unique_key_column</span><br><span class="line">  <span class="keyword">AND</span> other_table.unique_key_column = <span class="string">'001'</span>;</span><br></pre></td></tr></table></figure><h2 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h2><p>对于 <code>other_table</code> 中的每行，仅从 <code>ref_table</code> 中读取唯一一行。<code>eq_ref</code> 类型用于主键索引（<code>PRIMARY KEY</code> ）或 <code>NOT NULL</code> 的唯一索引（<code>UNIQUE KEY</code>），且索引被表连接所使用时。除了 <code>system</code> 和 <code>const</code> 类型之外，这是最好的连接类型。<code>select_type=SIMPLE</code> 简单查询类型不会出现这种类型。</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.unique_key_column = other_table.column;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.unique_key_column_part1 = other_table.column</span><br><span class="line">  <span class="keyword">AND</span> ref_table.unique_key_column_part2 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>对于 <code>other_table</code> 中的每行，从 <code>ref_table</code> 中读取所有匹配行。<code>ref</code> 类型用于普通索引或联合索引的最左前缀列（<code>leftmost prefix of the key</code>），即无法根据键值查询到唯一一行。如果使用的索引仅匹配几行结果，则也是一种很好的连接类型。</p><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table <span class="keyword">WHERE</span> key_column = expr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table <span class="keyword">WHERE</span> key_column_part1 = expr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column = other_table.column;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column_part1 = other_table.column</span><br><span class="line">  <span class="keyword">AND</span> ref_table.key_column_part2 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p>使用索引进行范围查询时，例如：<code>=</code>, <code>&lt;&gt;</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>,  <code>&lt;=&gt;</code>, <code>IS NULL</code>, <code>BETWEEN</code>, <code>LIKE</code>, <code>IN()</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1 = <span class="number">10</span> <span class="keyword">AND</span> key_part2 <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>索引扫描，类似于 <code>ALL</code> 全表扫描。以下情况发生：</p><ul><li><p>覆盖索引（<code>covering index</code>）。此时 <code>Extra</code> 列显示 <code>Using index</code>。覆盖索引扫描通常比全表扫描速度更快，因为其存储空间更小。例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> primary_key <span class="keyword">FROM</span> tbl_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> unique_key <span class="keyword">FROM</span> tbl_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(primary_key) <span class="keyword">FROM</span> tbl_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(unique_key) <span class="keyword">FROM</span> tbl_name;</span><br></pre></td></tr></table></figure></li></ul><h2 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_full_table_scan" target="_blank" rel="noopener">全表扫描</a>。此时必须增加索引优化查询。</p><p>全表扫描发生的情况如下：</p><ul><li>小表，此时全表扫描比二级索引扫描再回表的速度要快；</li><li><code>ON</code> 或 <code>WHERE</code> 子句没有可用的索引；</li><li>查询的字段虽然使用了索引，但查询条件覆盖的范围太大以至于还不如全表扫描。优化方式详见：<a href="https://dev.mysql.com/doc/refman/5.7/en/where-optimization.html" target="_blank" rel="noopener">Section 8.2.1.1, “WHERE Clause Optimization”</a></li><li>使用了区分度（cardinality）低的索引，索引扫描范围太大以至于还不如全表扫描。如果是统计不准，可以用 <code>ANALYZE TABLE</code> 语句优化：<a href="https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html" target="_blank" rel="noopener">Section 13.7.2.1, “ANALYZE TABLE Syntax”</a></li></ul><h1 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h1><p>表示 MySQL 可选的索引。</p><p>如果此列为 <code>NULL</code>，表示 MySQL 没有可选的索引。此时，可以检查 <code>WHERE</code> 子句是否引用了某些适合建立索引的列，建立索引以提升查询性能。</p><h1 id="key"><a href="#key" class="headerlink" title="key"></a>key</h1><p>表示 MySQL 实际选择的索引。</p><ul><li>如果此列为 <code>NULL</code>，表示 MySQL 没有找到可用于提高查询性能的索引。</li><li>如果 <code>possible_keys NOT NULL</code>，但 <code>key NULL</code>，可能是因为表中数据不多，MySQL 认为索引对此查询帮助不大，选择了全表扫描。</li></ul><p>如需强制 MySQL 使用或忽略 <code>possible_keys</code> 中列出的索引，可以在查询中使用 <code>FORCE INDEX</code>、<code>USE INDEX</code> 或 <code>IGNORE INDEX</code>。详见：<a href="https://dev.mysql.com/doc/refman/5.7/en/index-hints.html" target="_blank" rel="noopener">索引提示</a>。</p><h1 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h1><p>表示 MySQL 实际选择的索引长度。如果该索引为联合索引，可用于判断 MySQL 实际使用了联合索引中的多少个字段。如果 <code>key</code> 列为 <code>NULL</code>，<code>key_len</code> 列也为 <code>NULL</code>。</p><p><code>key_len</code> 计算规则如下：</p><ul><li><p>使用 <code>NULL</code> 需要额外增加 1 Byte 记录是否为 <code>NULL</code>。并且进行比较和计算时要对 <code>NULL</code> 值做特别的处理，因此尽可能把所有列定义为 <code>NOT NULL</code>。</p></li><li><p>各个类型：</p><ul><li>整数类型<ul><li><code>TINYINT</code> 1 Byte</li><li><code>SMALLINT</code> 2 Bytes</li><li><code>MEDIUMINT</code> 3 Bytes</li><li><code>INT</code> 4 Bytes</li><li><code>BIGINT</code> 8 Bytes</li></ul></li><li>日期与时间类型<ul><li><code>DATE</code> 3 Bytes</li><li><code>TIMESTAMP</code> 4 Bytes</li><li><code>DATETIME</code> 8 Bytes</li></ul></li><li>字符串类型<ul><li><code>char(n)</code>：如果字符集为 <code>utf8</code>，则长度为 3n Bytes</li><li><code>varchar(n)</code>：如果字符集为 <code>utf8</code>，则长度为 3n + 2 Bytes。额外 2 Bytes 用于存储长度。</li></ul></li></ul></li><li><p>各个字符集：</p><ul><li><code>latin1</code> 编码一个字符 1 Byte</li><li><code>gbk</code> 编码一个字符 2 Bytes</li><li><code>utf8</code> 编码一个字符 3 Bytes</li><li><code>utf8mb4</code> 编码一个字符 4 Bytes</li></ul></li><li><p>创建索引的时候可以指定索引的长度，例如：<code>alter table test add index idx_username (username(30));</code>。长度 30 指的是字符的个数。</p></li><li><p><code>InnoDB</code> 索引最大长度为 767 Bytes，引自<a href="https://dev.mysql.com/doc/refman/5.7/en/create-table.html" target="_blank" rel="noopener">官方文档</a>：</p><blockquote><p><em>key_part</em>:<br><em>col_name</em> [(<em>length</em>)] [ASC | DESC]</p><p><em>index_type</em>:<br>USING {BTREE | HASH}</p><blockquote><p>Prefixes, defined by the <em>length</em> attribute, can be up to 767 bytes long for <code>InnoDB</code> tables or 3072 bytes if the <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_large_prefix" target="_blank" rel="noopener"><code>innodb_large_prefix</code></a> option is enabled. For <code>MyISAM</code> tables, the prefix length limit is 1000 bytes.</p></blockquote></blockquote></li></ul><p>举个例子，在字符集为 <code>utf8</code> 的情况下，<code>n</code> 最大只能为 <code>(767 - 2 (存储长度)) / 3 = 765 / 3 = 255 个字符</code>。因此当字符串过长时，MySQL 最多会将开头 255 个字符串截取出来作为索引。一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_username`</span> (<span class="string">`username`</span>(<span class="number">255</span>)) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_password`</span> (<span class="string">`password`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- key_len: 255 * 3 + 2 + 1 = 768 Bytes (额外增加 1 Byte 记录是否为 NULL)</span></span><br><span class="line">mysql&gt; explain select username from student where username = 'pete';</span><br><span class="line">+<span class="comment">----+-------------+---------+------+---------------+--------------+---------+-------+------+-------------+</span></span><br><span class="line">| id | select_type | table   | type | possible_keys | key          | key_len | ref   | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+---------+------+---------------+--------------+---------+-------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | student | ref  | idx_username  | idx_username | 768     | const |    1 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+---------+------+---------------+--------------+---------+-------+------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- key_len: 1 * 3 + 2 + 1 = 6 Bytes</span></span><br><span class="line">mysql&gt; explain select password from student where password = 'pete';</span><br><span class="line">+<span class="comment">----+-------------+---------+------+---------------+--------------+---------+-------+------+--------------------------+</span></span><br><span class="line">| id | select_type | table   | type | possible_keys | key          | key_len | ref   | rows | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+---------+------+---------------+--------------+---------+-------+------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | student | ref  | idx_password  | idx_password | 6       | const |    1 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+---------+------+---------------+--------------+---------+-------+------+--------------------------+</span></span><br></pre></td></tr></table></figure><p>如果使用过长的索引，例如修改了字符串编码类型、增加联合索引列，则报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Err] 1071 - Specified key was too long; max key length is 767 bytes</span><br></pre></td></tr></table></figure><h1 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h1><p><code>ref</code> 显示与 <code>key</code> 列（实际选择的索引）比较的内容，可选值：</p><ul><li>列名</li><li><code>const</code>：常量值</li><li><code>func</code>：值为某些函数的结果</li><li><code>NULL</code>：范围查询（<code>type=range</code>）</li></ul><p>例如联合索引如下，使用三个索引列查询时，执行计划如下（注意 <code>key_len</code> 和 <code>ref</code>）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">`channel_task_no` varchar(60) NOT NULL,</span><br><span class="line">`reconciliation_code` tinyint(4) unsigned NOT NULL DEFAULT '0',</span><br><span class="line">`reconciliation_status` tinyint(4) unsigned NOT NULL DEFAULT '0',</span><br><span class="line">KEY `idx_taskno_rcode_rstatus` (`channel_task_no`,`reconciliation_code`,`reconciliation_status`) USING BTREE</span><br><span class="line"></span><br><span class="line">+<span class="comment">----+-------------+-------+------+--------------------------+--------------------------+---------+-------------------+------+-----------------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys            | key                      | key_len | ref               | rows | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+--------------------------+--------------------------+---------+-------------------+------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t_xxx | ref  | idx_taskno_rcode_rstatus | idx_taskno_rcode_rstatus | 184     | const,const,const |    1 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+--------------------------+--------------------------+---------+-------------------+------+-----------------------+</span></span><br></pre></td></tr></table></figure><h1 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h1><p>表示 MySQL 认为执行查询必须扫描的行数。</p><p>对于 InnoDB 表，此数字是估计值，可能并不总是准确。</p><p>当 <code>prossible_keys</code> 存在多个可选索引时，优化器会选择一个认为最优的执行方案，以最小的代价去执行语句。其中，这个扫描行数就是影响执行代价的因素之一。扫描的行数越少，意味着访问磁盘数据的 IO 次数越少，消耗的 CPU 资源也越少。</p><p>当然，扫描行数并不是唯一的判断标准，优化器还会结合是否使用临时表、是否排序等因素进行综合判断。</p><p>所以在实践中，如果你发现 explain 的结果预估的 <code>rows</code> 值跟实际情况差距比较大，可以采用执行 <code>analyze table</code> 重新统计信息。</p><blockquote><p>在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在<strong>执行器每次调用引擎获取数据行</strong>的时候累加的。</p><p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。</p></blockquote><h1 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h1><p>这一列显示的是额外信息。如果想要查询越快越好，需要特别留意 <code>Extra</code> 列是否出现以下情况：</p><table><thead><tr><th>Extra</th><th>缓冲区</th><th>大小配置</th><th>数据结构</th><th>备注</th></tr></thead><tbody><tr><td><code>Using filesort</code></td><td><code>sort_buffer</code></td><td><code>sort_buffer_size</code></td><td>有序数组</td><td>使用了“外部排序”（全字段排序或 rowid 排序）</td></tr><tr><td><code>Using join buffer (Block Nested Loop)</code></td><td><code>join_buffer</code></td><td><code>join_buffer_size</code></td><td>无序数组</td><td>使用了“基于块的嵌套循环连接”算法（Block Nested-Loop Join（BNL））</td></tr><tr><td><code>Using temporary</code></td><td>临时表</td><td>小于 <code>tmp_table_size</code> 为内存临时表，否则为磁盘临时表（可以使用 <code>SQL_BIG_RESULT</code> 直接指定）</td><td>二维表结构（类似于 Map，Key-Value）</td><td>如果执行逻辑需要用到二维表特性，就会优先考虑使用临时表。例如：<code>DISTINCT</code>、<code>GROUP BY</code>、<code>UNION</code></td></tr></tbody></table><p>这三个数据结构都是用来存放 <code>SELECT</code> 语句执行过程中的中间数据，以辅助 SQL 语句的执行的。这些情况通常都能通过索引优化。</p><p>各种常见的重要值如下：</p><h2 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h2><p>使用了覆盖索引。</p><h2 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h2><p>使用 <code>WHERE</code> 条件过滤结果，但查询的列未被索引覆盖。</p><h2 id="Using-index-condition"><a href="#Using-index-condition" class="headerlink" title="Using index condition"></a>Using index condition</h2><p>查询的列不完全被索引覆盖。</p><p>例如：<a href="https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">索引下推优化（ICP）</a></p><h2 id="Using-temporary"><a href="#Using-temporary" class="headerlink" title="Using temporary"></a>Using temporary</h2><p>MySQL 需要创建一张临时表来处理查询。通常发生于查询包含 <code>DISTINCT</code>、<code>GROUP BY</code> 或 <code>ORDER BY</code> 子句等需要数据去重的场景。出现这种情况一般是要进行优化的，首先想到的是用索引进行优化。</p><h2 id="Using-join-buffer"><a href="#Using-join-buffer" class="headerlink" title="Using join buffer"></a>Using join buffer</h2><p>使用 BNL 算法进行表连接。这种情况下一般考虑使用索引对被驱动表的表连接字段进行优化，以使用更高效的 NLJ 算法。</p><h2 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a>Using filesort</h2><p>将用外部排序而不是索引排序，数据较少时从内存排序，否则需要在磁盘完成排序。这种情况下一般考虑使用索引进行优化。</p><p>优化参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/order-by-optimization.html" target="_blank" rel="noopener">Section 8.2.1.14, “ORDER BY Optimization”</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/execution-plan-information.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/execution-plan-information.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/analyze-table.html</a></p><p><em>MySQL Workbench</em> has a Visual Explain capability that provides a visual representation of <a href="https://dev.mysql.com/doc/refman/5.7/en/explain.html" target="_blank" rel="noopener">EXPLAIN</a> output. See <a href="https://dev.mysql.com/doc/workbench/en/wb-tutorial-visual-explain-dbt3.html" target="_blank" rel="noopener">Tutorial: Using Explain to Improve Query Performance</a>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 虚拟机系列（四）性能监控、故障处理工具总结</title>
      <link href="2019/09/16/jvm-tools/"/>
      <url>2019/09/16/jvm-tools/</url>
      
        <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><table><thead><tr><th>命令</th><th>全称</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td><code>jps</code></td><td>虚拟机进程状况工具（JVM Process Status Tool），</td><td>显示正在运行的所有 HotSpot VM 进程。</td><td></td></tr><tr><td><code>jstat</code></td><td>虚拟机统计信息监控工具（JVM Statistics Monitoring Tool）</td><td>用于监视本地或远程 HotSpot VM 各方面的运行数据，例如类加载/卸载、运行时数据区、GC、JIT。</td><td></td></tr><tr><td><code>jinfo</code></td><td>Java 配置信息工具（Configuration Info for Java）</td><td>实时显示或修改虚拟机配置信息。例如 <code>jinfo -flag MetaspaceSize VMID</code></td><td>在 JDK 9 中已集成到 <code>JHSDB</code></td></tr><tr><td><code>jmap</code></td><td>Memory Map for Java</td><td>用于实时生成虚拟机的堆内存转储快照（heap dump/hprof 文件），或查看堆内存信息。其它转储方法：<br/><code>-XX:+HeapDumpOnOutOfMemoryError</code><br/><code>-XX:+HeapDumpOnCtrlBreak</code></td><td>在 JDK 9 中已集成到 <code>JHSDB</code></td></tr><tr><td><code>jhat</code></td><td>JVM Heap Dump Browser</td><td>用于分析 heap dump 文件，它会建立一个 HTTP/HTML 服务器，让用户可以在浏览器上查看分析结果。分析结果默认以包为单位进行分组显示，分析内存泄漏问题主要会使用到其中的 Heap Histogram（与 <code>jmap -histo</code> 功能一样）与 OQL 页签功能，前者可以找到内存中总容量最大的对象，后者是标准的对象查询语言，使用类似 SQL 的语法堆内存中的对象进行查询统计。</td><td>在 JDK 9 中已被  <code>JHSDB</code> 替代</td></tr><tr><td><code>jstack</code></td><td>Stack Trace for Java</td><td>显示虚拟机当前时刻的线程快照（thread dump/javacore 文件）。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成堆栈快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等，都是导致线程长时间停顿的常见原因。</td><td>在 JDK 9 中已集成到 <code>JHSDB</code></td></tr></tbody></table><h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><table><thead><tr><th>命令</th><th>名称</th><th>基于</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td><code>jconsole</code></td><td>Java Console</td><td>JMX</td><td>一款基于 JMX (Java Management Extensions) 的可视化监视、管理工具。它的主要功能是通过 JMX  的 MBean (Managed Bean) 对系统进行信息收集和参数动态调整。</td><td>JDK 5 起免费提供</td></tr><tr><td><code>jvisualvm</code></td><td>Java VisualVM</td><td>无需特殊 Agent</td><td>拥有丰富的插件扩展。目前已经从 Oracle JDK 中分离出来，成为一个独立发展的开源项目：<a href="https://visualvm.github.io/" target="_blank" rel="noopener">https://visualvm.github.io/</a></td><td>JDK 6 起免费提供</td></tr><tr><td><code>jmc</code></td><td>Java Mission Control</td><td>Java Flight Recorder, JFR</td><td>曾经是 BEA 公司的图形化诊断工具，随着 BEA 公司被 Oracle 收购而融合进 Oracle JDK。从 JDK 11 开始已被移除出 JDK。2018 年开源并交付给 Open JDK 组织管理。需要与 HotSpot 内部的 JFR 配合才能工作。</td><td>JDK 7 起付费提供</td></tr><tr><td><code>jhsdb</code></td><td>Java HotSpot Debugger</td><td>Serviceability Agent</td><td>一个基于 Serviceability Agent 的 HotSpot 进程调试器。</td><td>JDK 9 起免费提供</td></tr></tbody></table><h2 id="反汇编工具"><a href="#反汇编工具" class="headerlink" title="反汇编工具"></a>反汇编工具</h2><blockquote><p>大多数情况下，通过诸如javap等反编译工具来查看源码的字节码已经能够满足我们的日常需求，但是不排除在有些特定场景下，我们需要通过反汇编来查看相应的汇编指令。本文我们就来介绍两个很好用的工具——HSDIS、JITWatch</p></blockquote><table><thead><tr><th>工具</th><th>描述</th></tr></thead><tbody><tr><td>HSDIS (HotSpot disassembler)</td><td>一款 HotSpot 虚拟机 JIT 编译代码的反汇编插件。</td></tr><tr><td>JITWatch</td><td>用于可视化分析。</td></tr></tbody></table><p><a href="https://zhuanlan.zhihu.com/p/158168592?from_voters_page=true" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/158168592?from_voters_page=true</a></p><h1 id="命令行工具-1"><a href="#命令行工具-1" class="headerlink" title="命令行工具"></a>命令行工具</h1><h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><p><code>jps</code> 命令的功能与 <code>ps</code> 类似，用于列出正在运行的 JVM 进程状态。</p><p>常用参数：</p><ul><li><code>-q</code> 只输出 LVMID，省略主类的名称。</li><li><code>-l</code> 输出主类的全名，如果进程执行的是 JAR 包，则输出 JAR 路径。</li><li><code>-m</code> 输出虚拟机进程启动时传递给主类 <code>main()</code> 函数的参数。</li><li><code>-v</code> 输出虚拟机进程启动时的 JVM 参数。</li></ul><h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p><code>jstat</code> 命令用于监视当前 JVM 的各种运行状态信息。在用户体验上也许不如 JMC、VisualVM 等可视化监控工具以图表形式展示那样直观，但在实际生产环境中不一定可以使用 GUI 图形界面，因此在没有 GUI、只提供命令行界面的服务器上，仍是<strong>运行期</strong>定位虚拟机性能问题的常用工具。</p><p>命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat options vmid [interval[s|ms] [count]]</span><br></pre></td></tr></table></figure><p>常用参数：</p><ul><li>options，要查询的虚拟机信息，主要分为三类：<ul><li>类加载<ul><li><code>-class</code> 监视类加载、卸载数量、总空间以及类加载所耗费的时间</li></ul></li><li>运行时数据区、GC<ul><li><code>-gccapacity</code> 查看 GC 情况和 JVM 各区的<strong>容量</strong>（字节）</li><li><code>-gc</code> 查看 GC 情况和 JVM 各区的<strong>容量</strong>和<strong>使用量</strong>（字节）</li><li><code>-gcutil</code> 查看 GC 情况和 JVM 各区的<strong>使用率</strong>（%）</li><li>…</li></ul></li><li>JIT<ul><li><code>-compiler</code> 输出即时编译器编译过的方法、耗时等信息</li><li><code>-printcompilation</code> 输出已经被即时编译的方法</li></ul></li></ul></li><li>vmid，如果是本地虚拟机进程，VMID 与 LVMID 一致；如果是远程虚拟机进程，则 VMID 的格式为：<code>[protocol:][//]lvmid[@hostname[:port]/servername]</code></li><li>interval，间隔时间，单位为秒或者毫秒</li><li>count，打印次数，如果缺省则打印无数次</li></ul><p>示例展示：</p><p>此示例连接到 lvmid 21891，并以 250 毫秒的间隔获取 7 个样本，每 6 行显示一次标题（<code>[-h&lt;lines&gt;]</code>），并显示由 <code>-gcutil</code> 选项指定的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcutil -h6 21891 250 7</span><br><span class="line"></span><br><span class="line">  S0     S1     E      O      P     YGC    YGCT    FGC    FGCT     GCT</span><br><span class="line"></span><br><span class="line"> 12.44   0.00  27.20   9.49  96.70    78    0.176     5    0.495    0.672</span><br><span class="line"></span><br><span class="line"> 12.44   0.00  62.16   9.49  96.70    78    0.176     5    0.495    0.672</span><br><span class="line"></span><br><span class="line"> 12.44   0.00  83.97   9.49  96.70    78    0.176     5    0.495    0.672</span><br><span class="line"></span><br><span class="line">  0.00   7.74   0.00   9.51  96.70    79    0.177     5    0.495    0.673</span><br><span class="line"></span><br><span class="line">  0.00   7.74  23.37   9.51  96.70    79    0.177     5    0.495    0.673</span><br><span class="line"></span><br><span class="line">  0.00   7.74  43.82   9.51  96.70    79    0.177     5    0.495    0.673</span><br><span class="line"></span><br><span class="line">  S0     S1     E      O      P     YGC    YGCT    FGC    FGCT     GCT</span><br><span class="line"></span><br><span class="line">  0.00   7.74  58.11   9.51  96.71    79    0.177     5    0.495    0.673</span><br></pre></td></tr></table></figure><p>该示例结果显示，对象首先都在 Eden 区中创建，在第 3 和第 4 个样本之间由于 Eden 区装满，发生了 Young GC， gc 耗时 0.001 秒，并将对象从 Eden 区（E）提升到 Old 区（O），导致 Old 区的使用率从 9.49％ 增加到 9.51％。</p><p> <code>-gcutil</code> 选项每列说明：</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>S0</td><td>Heap 上的 Survivor space 0 区（单位<strong>%</strong>）</td></tr><tr><td>S1</td><td>Heap 上的 Survivor space 1 区（单位<strong>%</strong>）</td></tr><tr><td>E</td><td>Heap 上的 Eden space 区（单位<strong>%</strong>）</td></tr><tr><td>O</td><td>Heap 上的 Old space 区（单位<strong>%</strong>）</td></tr><tr><td>P</td><td>Perm space 区（单位<strong>%</strong>）</td></tr></tbody></table><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>YGC</td><td>从应用程序启动到采样时发生 Young GC 的次数，<strong>E 区满后触发</strong></td></tr><tr><td>YGCT</td><td>从应用程序启动到采样时 Young GC 所用的时间（单位秒）</td></tr><tr><td>FGC</td><td>从应用程序启动到采样时发生 Full GC 的次数， <strong>O 区满后触发</strong></td></tr><tr><td>FGCT</td><td>从应用程序启动到采样时 Full GC 所用的时间（单位秒）</td></tr><tr><td>GCT</td><td>从应用程序启动到采样时用于垃圾回收的<strong>总时间</strong>（单位秒）</td></tr></tbody></table><h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p><code>jmap</code> 命令用于生成虚拟机的内存转储快照（heap dump 文件），或查看堆内存信息。</p><p>常用参数：</p><ul><li><code>-dump</code> 生成 Java 堆转储快照。格式为 <code>-dump:[live,]format=b,file=&lt;filename&gt;</code>，其中 <code>live</code> 子参数表示是否只 dump 出存活的对象。</li><li><code>-histo</code> 显示堆中对象统计信息，包括类、实例数量、合计容量。</li><li><code>-heap</code> 查看当前堆内存的详细信息，如配置信息 <code>Heap Configuration</code>、使用情况 <code>Heap Usage</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap 21090</span><br><span class="line">Attaching to process ID 21090, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 24.79-b02</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio &#x3D; 0</span><br><span class="line">   MaxHeapFreeRatio &#x3D; 100</span><br><span class="line">   MaxHeapSize      &#x3D; 3145728000 (3000.0MB)</span><br><span class="line">   NewSize          &#x3D; 2097152000 (2000.0MB)</span><br><span class="line">   MaxNewSize       &#x3D; 2097152000 (2000.0MB)</span><br><span class="line">   OldSize          &#x3D; 5439488 (5.1875MB)</span><br><span class="line">   NewRatio         &#x3D; 2</span><br><span class="line">   SurvivorRatio    &#x3D; 8</span><br><span class="line">   PermSize         &#x3D; 268435456 (256.0MB)  &#x2F;&#x2F; JDK8+ MetaspaceSize</span><br><span class="line">   MaxPermSize      &#x3D; 268435456 (256.0MB)  &#x2F;&#x2F; JDK8+ MaxMetaspaceSize</span><br><span class="line">   G1HeapRegionSize &#x3D; 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity &#x3D; 1762656256 (1681.0MB)</span><br><span class="line">   used     &#x3D; 1420607552 (1354.7969360351562MB)</span><br><span class="line">   free     &#x3D; 342048704 (326.20306396484375MB)</span><br><span class="line">   80.59470172725499% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity &#x3D; 138412032 (132.0MB)</span><br><span class="line">   used     &#x3D; 0 (0.0MB)</span><br><span class="line">   free     &#x3D; 138412032 (132.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity &#x3D; 138412032 (132.0MB)</span><br><span class="line">   used     &#x3D; 0 (0.0MB)</span><br><span class="line">   free     &#x3D; 138412032 (132.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity &#x3D; 1048576000 (1000.0MB)</span><br><span class="line">   used     &#x3D; 1048403072 (999.8350830078125MB)</span><br><span class="line">   free     &#x3D; 172928 (0.1649169921875MB)</span><br><span class="line">   99.98350830078125% used</span><br><span class="line">PS Perm Generation  &#x2F;&#x2F; JDK8+ 没有该区域</span><br><span class="line">   capacity &#x3D; 268435456 (256.0MB)</span><br><span class="line">   used     &#x3D; 67917928 (64.7715835571289MB)</span><br><span class="line">   free     &#x3D; 200517528 (191.2284164428711MB)</span><br><span class="line">   25.30139982700348% used</span><br></pre></td></tr></table></figure><p>注意，由于此例中使用的 JDK 7 版本，因此 Heap 中包含 Perm Generation。如果使用的 JDK 8 以上版本，则 Heap 不再包含此区域，取而代之的是在 Heap 之外有一块 Metaspace。</p><p>例如上述例子通过 <code>jmap -heap pid</code> 命令发现了某个服务 O 区内存被占满的问题：<code>Old Generation</code> 达到 99.98350830078125% used，O 区内存被占满，可以通过 <code>jstack</code> 继续排查 JVM 内存的<strong>动态使用情况</strong>。</p><h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><p><code>jstack</code> 命令用于 dump 出当前线程堆栈快照，根据堆栈信息我们可以定位到具体代码，所以它在 JVM 性能调优中使用得非常多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ jstack 21090 &gt; &#x2F;tmp&#x2F;threaddump</span><br><span class="line">$ less &#x2F;tmp&#x2F;localfile</span><br><span class="line"></span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.79-b02 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; daemon prio&#x3D;10 tid&#x3D;0x00007f67e03b4800 nid&#x3D;0x7bb9 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">&quot;catalina-exec-8000&quot; daemon prio&#x3D;10 tid&#x3D;0x00007f67ba4a0000 nid&#x3D;0x795a waiting on condition [0x00007f6558c0a000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">- parking to wait for  &lt;0x00000007886ab360&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)</span><br><span class="line">at org.apache.http.pool.PoolEntryFuture.await(PoolEntryFuture.java:139)</span><br><span class="line">at org.apache.http.pool.AbstractConnPool.getPoolEntryBlocking(AbstractConnPool.java:307)</span><br><span class="line">at org.apache.http.pool.AbstractConnPool.access$000(AbstractConnPool.java:65)</span><br><span class="line">at org.apache.http.pool.AbstractConnPool$2.getPoolEntry(AbstractConnPool.java:193)</span><br><span class="line">at org.apache.http.pool.AbstractConnPool$2.getPoolEntry(AbstractConnPool.java:186)</span><br><span class="line">at org.apache.http.pool.PoolEntryFuture.get(PoolEntryFuture.java:108)</span><br><span class="line">at org.apache.http.impl.conn.PoolingClientConnectionManager.leaseConnection(PoolingClientConnectionManager.java:212)</span><br><span class="line">at org.apache.http.impl.conn.PoolingClientConnectionManager$1.getConnection(PoolingClientConnectionManager.java:199)</span><br><span class="line">at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:424)</span><br><span class="line">at org.apache.http.impl.client.AbstractHttpClient.doExecute(AbstractHttpClient.java:884)</span><br><span class="line">at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:82)</span><br><span class="line">at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:107)</span><br><span class="line">at com.xxx.xxx.xxx.HttpClientService.doPost(HttpClientService.java:103)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>由于导出的 <code>threaddump</code> 文件非常大，可以先统计下所有线程、或关注的线程分别处于什么状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ grep /tmp/threaddump | awk <span class="string">'&#123;print $2$3$4$5&#125;'</span> | sort | uniq -c | sort</span><br><span class="line"></span><br><span class="line">39  RUNNABLE</span><br><span class="line">21  TIMED_WAITING (onobjectmonitor)</span><br><span class="line">6   TIMED_WAITING (parking)</span><br><span class="line">51  TIMED_WAITING (sleeping)</span><br><span class="line">3   WAITING (onobjectmonitor)</span><br><span class="line">305 WAITING (parking)</span><br></pre></td></tr></table></figure><p>发现有大量 <code>WAITING (parking)</code> 状态的线程。重新打开 <code>threaddump</code> 文件排查，根据堆栈可以定位到具体的问题代码，可以初步判断是 HTTP 连接耗尽资源导致的问题。</p><h1 id="可视化工具-1"><a href="#可视化工具-1" class="headerlink" title="可视化工具"></a>可视化工具</h1><h2 id="VisualVM"><a href="#VisualVM" class="headerlink" title="VisualVM"></a>VisualVM</h2><p>VisualVM 拥有丰富的<a href="https://visualvm.github.io/plugins.html" target="_blank" rel="noopener">插件</a>扩展。目前已经从 Oracle JDK 中分离出来，成为一个独立发展的开源项目：<a href="https://visualvm.github.io/" target="_blank" rel="noopener">https://visualvm.github.io/</a></p><p>例如：</p><ul><li><em>TDA</em> Plugin: Thread Dump Analyzer is a GUI for analyzing thread dumps generated by the Java VM.</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解 Java 虚拟机》</p><p>《<a href="https://blog.csdn.net/u013970991/article/details/52036253" target="_blank" rel="noopener">使用 VisualVM 进行性能分析及调优</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 虚拟机系列（三）垃圾收集器总结</title>
      <link href="2019/09/10/jvm-gc/"/>
      <url>2019/09/10/jvm-gc/</url>
      
        <content type="html"><![CDATA[<p>本文总结下垃圾收集涉及的一些重点：</p><p><img src="/img/java/jvm/gc_summary.png" alt="gc_summary"></p><p>基于分代收集算法的垃圾收集器组合，总结如下图，常用于 JDK 8 及之前的版本：</p><p><img src="/img/java/jvm/gc_combination.png" alt="generational_collection"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《深入理解 Java 虚拟机》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 虚拟机系列（二）运行时数据区总结</title>
      <link href="2019/09/01/jvm-runtime-data-areas/"/>
      <url>2019/09/01/jvm-runtime-data-areas/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近为了做春节大型活动，研究了下性能压测和 JVM 调优，先来看一张 JVM 监控图（硬件：4 核 8G）。</p><p><img src="/img/java/jvm/jvm_monitor.png" alt="JVM 监控"></p><p>6 小时的吞吐量为：(21600s - Young GC 35s + Old GC 0s) / 21600s = 99.8%，总吞吐量还是不错的（吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即 <code>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + GC 时间)</code>。如果虚拟机总共运行了 100 分钟，其中 GC 总耗时 1 分钟，那么吞吐量就是 99%。）。同时单次 Young GC 的平均耗时仅为 35s / 639 = 55 ms，停顿时间较短。</p><p>如果还需要进一步优化，思路如下：</p><ul><li>合理调整 Old Gen 与 Young Gen 大小比例，以减少 Young GC 次数，但单次 GC 耗时可能会相应延长，具体需测试。</li><li>更换垃圾收集器，并对垃圾收集器参数进行调优。</li></ul><p>下面介绍一些基础知识。</p><h1 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h1><p>手绘的运行时数据区如下：</p><p><img src="/img/java/jvm/runtime_data_areas.jpg" alt="jvm"></p><p>JVM 定义了在程序执行期间使用的各种运行时数据区：</p><ul><li>其中一些数据区是在 JVM 启动时创建、仅在 JVM 退出时才被销毁。</li><li>另外一些数据区是随每个线程创建及销毁。</li></ul><h2 id="PC-Register"><a href="#PC-Register" class="headerlink" title="PC Register"></a>PC Register</h2><p>JVM 可以一次支持多个线程执行。每个 JVM 线程都有专属的 <code>pc</code>（程序计数器 program counter）寄存器。在任何时候，每个 JVM 线程都在执行某个方法的代码，即该线程的当前方法（参考 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6" target="_blank" rel="noopener">栈帧（Frames）</a>一节）。</p><p><code>pc</code> 寄存器的值可以为两种：</p><ul><li>如果当前执行的是非 <code>native</code> 方法，值为当前正在执行的 JVM 指令的地址（<code>returnAddress</code>）。</li><li>如果是 <code>native</code> 方法，值为 undefined。</li></ul><p>JVM 的 <code>pc</code> 寄存器长度足以保存 <code>returnAddress</code> 或特定平台的本地指针。</p><p>The <code>returnAddress</code> Type and Values :</p><blockquote><p>The <code>returnAddress</code> type is used by the Java Virtual Machine’s <em>jsr</em>, <em>ret</em>, and <em>jsr_w</em> instructions (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.jsr" target="_blank" rel="noopener">§<em>jsr</em></a>, <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.ret" target="_blank" rel="noopener">§<em>ret</em></a>, <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.jsr_w" target="_blank" rel="noopener">§<em>jsr_w</em></a>). The values of the <code>returnAddress</code> type are pointers to the opcodes of Java Virtual Machine instructions. Unlike the numeric primitive types, the <code>returnAddress</code> type does not correspond to any Java programming language type and cannot be modified by the running program.</p></blockquote><h2 id="JVM-Stacks"><a href="#JVM-Stacks" class="headerlink" title="JVM Stacks"></a>JVM Stacks</h2><p>每个 JVM 线程都有一个私有的 <em>JVM Stack</em> 栈区，与该线程同时创建。JVM Stack 存储栈帧（参考 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.6" target="_blank" rel="noopener">栈帧（Frames）</a>一节）。JVM Stack 类似于常规编程语言（例如 C 语言）：它保存局部变量和部分结果，并在方法调用和返回中起作用。由于 JVM Stack 的操作只有出栈和入栈，因此栈帧可能堆积。JVM Stack 的内存空间不必连续。</p><p>规范允许 JVM Stack 要么是固定大小（通过 <code>-Xss</code> 指定大小）、要么是根据计算的需要进行动态扩容和缩容。如果 JVM Stack 的大小固定，则在创建每个 JVM Stack 时可以独立选择其大小。</p><p>以下异常情况与 JVM Stack 相关：</p><ul><li>如果线程所需空间大于分配的 JVM Stack 空间，则 JVM 抛出 <code>StackOverflowError</code>。</li><li>如果 JVM Stack 能够动态扩展，并尝试扩展，但是内存不足，则 JVM 抛出  <code>OutOfMemoryError</code>。</li></ul><h3 id="Frames"><a href="#Frames" class="headerlink" title="Frames"></a>Frames</h3><p>栈帧用于：</p><ul><li>存储数据和部分结果</li><li>作为方法的返回值</li><li>调度异常</li><li>执行动态链接</li></ul><p>每次调用方法时都会创建一个栈帧。当方法调用完毕，无论是正常还是异常结束（例如抛出了未捕获的异常），栈帧都会销毁。栈帧由 JVM 栈区创建。每个栈帧都有它自己的局部变量数组（Local Variables Array）、操作数栈（Operand Stacks）、以及对当前类当前方法的运行时常量池的引用。</p><p>局部变量数组和操作数栈的大小在编译时确定，并与栈帧关联的方法代码（参考 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3" target="_blank" rel="noopener">The <code>Code</code> Attribute</a>）一起提供。因此，栈帧数据结构的大小仅取决于 JVM 的实现，并且可以在方法调用时分配用于这些结构的内存。</p><p>在给定线程的任何时候，只有一个在执行方法中的栈帧处于活动状态。该活动栈帧称为<em>当前帧（current frame）</em>，该方法称为<em>当前方法（current method）</em>，定义当前方法的类称为<em>当前类（current class）</em>。局部变量和操作数栈上的操作引用<em>当前帧</em>。</p><p>如果当前方法调用了另一个方法或者该方法执行完毕，则该方法所处的帧不再是<em>当前帧</em>。调用方法时，将创建新的栈帧，并在控制权转移到新方法时变为<em>当前帧</em>。当方法返回时，<em>当前帧</em>将其方法调用的结果（如有）传递回前一帧并被丢弃，然后前一帧变回<em>当前帧</em>。</p><p>注意，由线程创建的栈帧仅线程自身可见，无法被其它线程所引用。</p><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><p>JVM 具有一个在所有 JVM 线程之间共享的堆区（<em>Heap</em>），用于分配所有类实例和数组所需的内存。</p><p>堆区在虚拟机启动时创建。堆中的对象由垃圾收集器（<em>garbage collector</em>）进行回收。对象永远不会显式释放。JVM 不假定任何类型的垃圾收集器，而由实现者根据系统要求自行选择实现。</p><p>堆的大小可以是固定的，也可以根据计算的需要进行扩容，如果不需要更大空间的堆，可以进行缩容。堆区的内存空间不必连续。</p><p>JVM 实现可以为用户提供堆的初始值配置。并且，如果堆可以动态扩容和缩容，还需提供堆的最大、最小值配置。</p><p>以下异常情况与堆相关：</p><ul><li>如果所需的堆空间大于能够分配的堆空间，则 JVM 抛出  <code>OutOfMemoryError</code>。</li></ul><h2 id="Method-Area"><a href="#Method-Area" class="headerlink" title="Method Area"></a>Method Area</h2><p>JVM 具有一个在所有 JVM 线程之间共享的方法区（<em>Method Area</em>）。方法区类似于常规编程语言的编译代码的存储区域。它存储每个类的结构，例如运行时常量池、字段（field）及方法（method）的数据、以及方法（methods）和构造方法（constructors）的代码，包括用于类及其实例初始化和接口初始化的特殊方法（参考 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9" target="_blank" rel="noopener">Special Methods</a>）。 </p><p>方法区在虚拟机启动时创建。尽管方法区在逻辑上是堆区的一部分，但是 JVM 实现可以选择不进行垃圾回收或压缩。JVM 规范没有规定方法区的位置或用于管理已编译代码的策略。</p><p>方法区可以是固定大小的，或者根据计算的需要进行扩容，如果无需更大空间的方法区，可以进行缩容。方法区的内存空间不必连续。</p><p>JVM 实现可以为用户提供方法区的初始值配置。在方法区大小可变的情况下，可以提供最大、最小值配置。</p><p>以下异常情况与方法区相关：</p><ul><li>如果方法区的内存空间无法满足分配请求，则 JVM 抛出  <code>OutOfMemoryError</code>。</li></ul><h2 id="Run-Time-Constant-Pool"><a href="#Run-Time-Constant-Pool" class="headerlink" title="Run-Time Constant Pool"></a>Run-Time Constant Pool</h2><p>运行时常量池是每个类或每个接口的 <code>class</code> 文件中 <code>constant_pool</code> 表（参考 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4" target="_blank" rel="noopener">The Constant Pool</a>）的运行时表示。它包含多种常量，范围从编译时已知的数值型的字面值（<em>numeric literals</em>）到必须在运行时解析的方法和字段引用。运行时常量池的功能类似于常规编程语言的符号表，尽管它包含的数据范围比典型的符号表要大。</p><p>每个运行时常量池都由方法区分配。当 JVM 创建类或接口时（参考 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3" target="_blank" rel="noopener">Creation and Loading Class</a>），将构造该类或接口的运行时常量池。</p><p>以下异常情况与方法区相关：</p><ul><li>创建类或接口时，如果运行时常量池的构造所需的内存超过 JVM 的方法区中可用的内存，则 JVM 抛出  <code>OutOfMemoryError</code>。</li></ul><h2 id="Native-Method-Stacks"><a href="#Native-Method-Stacks" class="headerlink" title="Native Method Stacks"></a>Native Method Stacks</h2><h1 id="java-命令"><a href="#java-命令" class="headerlink" title="java 命令"></a>java 命令</h1><p><strong>java</strong> [<em>options*] *classname</em> [<em>args</em>]</p><p><strong>java</strong> [<em>options<em>] *</em>-jar** *filename</em> [<em>args</em>]</p><ul><li><em>options</em>: Command-line options separated by spaces.</li><li><em>classname</em>: The name of the class to be launched.</li><li><em>filename</em>: The name of the Java Archive (JAR) file to be called. Used only with the <code>-jar</code> option.</li><li><em>args</em>: The arguments passed to the <code>main()</code> method separated by spaces.</li></ul><p><code>java</code> 命令用于启动 Java 应用程序。它通过启动 JRE，加载指定类并调用其 <code>main()</code> 方法来实现启动。<code>main()</code> 方法声明如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br></pre></td></tr></table></figure><p><code>java</code> 命令支持以下几类选项：</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BABDJJFI" target="_blank" rel="noopener">标准选项</a>，JVM 的所有实现所支持的最常用选项。</li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BABHDABI" target="_blank" rel="noopener">非标准选项</a>，特定于 Java HotSpot VM 的通用选项。</li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BABCBGHF" target="_blank" rel="noopener">高级运行时选项</a>，用于控制 Java HotSpot VM 的运行时行为。</li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BABDDFII" target="_blank" rel="noopener">高级 JIT 编译器选项</a>，用于控制 Java HotSpot VM 执行动态实时（JIT）编译。</li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BABFJDIC" target="_blank" rel="noopener">高级可维修性选项</a>，提供了收集系统信息和执行调试的能力。</li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BABFAFAE" target="_blank" rel="noopener">高级垃圾收集选项</a>，用于控制 Java HotSpot VM 如何执行垃圾回收（GC）。</li></ul><p>所有 JVM 实现都需要保证支持<em>标准选项</em>。标准选项用于执行常见操作，例如检查 JRE 版本、设置类路径、启用详细输出等。</p><p><em>非标准选项</em>是针对 Java HotSpot VM 的通用选项，因此不能保证所有 JVM 实现都能支持，并且随时可能改变。非标组选项以 <code>-X</code> 开头。</p><p><em>高级选项</em>不建议随意使用。这些是开发人员用于调整 Java HotSpot VM 特定区域的选项。这些区域通常具有特定的系统要求，并且可能需要对系统配置参数的访问权限。这些选项也不能保证所有 JVM 实现都能支持，并且随时可能改变。高级选项以 <code>-XX</code> 开头。</p><p>此处参考<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BABDCEGG" target="_blank" rel="noopener">已废弃与已移除的选项</a>（JDK 8）。</p><p>布尔类型的选项用于启用默认情况下禁用的功能，或者禁用默认情况下启用的功能。此类选项无需参数，格式如下：</p><ul><li><code>-XX:+</code><em>OptionName</em> 用于启用；</li><li><code>-XX:-</code><em>OptionName</em> 用于禁用。</li></ul><p>对于需要参数的选项，每个选项的确切语法有所差异：参数可以用空格、冒号（<code>:</code>）或等号（<code>=</code>）与选项名分开，或者参数可以直接跟在选项后面，具体参考文档。</p><p>如果需要指定字节大小，可以使用以下几种格式：</p><ul><li>no suffix</li><li><code>k</code> or <code>K</code> for kilobytes (KB)</li><li><code>m</code> or <code>M</code> for megabytes (MB)</li><li><code>g</code> or <code>G</code> for gigabytes (GB)</li></ul><p>例如，大小为 8 GB，参数可以设为 <code>8g</code>, <code>8192m</code>, <code>8388608k</code>, <code>8589934592</code>。如果需要指定百分比，使用 0 到 1 之间的数字（例如， <code>0.25</code> for 25%）。</p><h2 id="JVM-Stack"><a href="#JVM-Stack" class="headerlink" title="JVM Stack"></a>JVM Stack</h2><p><code>-Xss</code><em>size</em></p><p>Sets the thread stack size (in bytes). Append the letter <code>k</code> or <code>K</code> to indicate KB, <code>m</code> or <code>M</code> to indicate MB, <code>g</code> or <code>G</code> to indicate GB. The default value depends on the platform:</p><ul><li>Linux/ARM (32-bit): 320 KB</li><li>Linux/i386 (32-bit): 320 KB</li><li>Linux/x64 (64-bit): 1024 KB</li><li>OS X (64-bit): 1024 KB</li><li>Oracle Solaris/i386 (32-bit): 320 KB</li><li>Oracle Solaris/x64 (64-bit): 1024 KB</li></ul><p>The following examples set the thread stack size to 1024 KB in different units:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xss1m</span><br><span class="line">-Xss1024k</span><br><span class="line">-Xss1048576</span><br></pre></td></tr></table></figure><p>This option is equivalent to <code>-XX:ThreadStackSize</code>.</p><h2 id="Heap-1"><a href="#Heap-1" class="headerlink" title="Heap"></a>Heap</h2><p><code>-Xms</code><em>size</em></p><p>Sets the initial size (in bytes) of the heap. This value must be a multiple of 1024 and greater than 1 MB. Append the letter <code>k</code> or <code>K</code> to indicate kilobytes, <code>m</code> or <code>M</code> to indicate megabytes, <code>g</code> or <code>G</code> to indicate gigabytes.</p><p>The following examples show how to set the size of allocated memory to 6 MB using various units:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xms6291456</span><br><span class="line">-Xms6144k</span><br><span class="line">-Xms6m</span><br></pre></td></tr></table></figure><p>If you do not set this option, then the initial size will be set as the sum of the sizes allocated for the old generation and the young generation.</p><p>The <code>-Xms</code> option is equivalent to <code>-XX:InitialHeapSize</code>.</p><p><code>-Xmx</code><em>size</em></p><p>Specifies the maximum size (in bytes) of the memory allocation pool in bytes. This value must be a multiple of 1024 and greater than 2 MB. Append the letter <code>k</code> or <code>K</code> to indicate kilobytes, <code>m</code> or <code>M</code> to indicate megabytes, <code>g</code> or <code>G</code> to indicate gigabytes. The default value is chosen at runtime based on system configuration. For server deployments, <code>-Xms</code> and <code>-Xmx</code> are often set to the same value. See the section “Ergonomics” in <em>Java SE HotSpot Virtual Machine Garbage Collection Tuning Guide</em> at <a href="http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html</a>.</p><p>The following examples show how to set the maximum allowed size of allocated memory to 80 MB using various units:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xmx83886080</span><br><span class="line">-Xmx81920k</span><br><span class="line">-Xmx80m</span><br></pre></td></tr></table></figure><p>The <code>-Xmx</code> option is equivalent to <code>-XX:MaxHeapSize</code>.</p><p><code>-Xmn</code><em>size</em></p><p>Sets the initial and maximum size (in bytes) of the heap for the young generation (nursery). Append the letter <code>k</code> or <code>K</code> to indicate kilobytes, <code>m</code> or <code>M</code> to indicate megabytes, <code>g</code> or <code>G</code> to indicate gigabytes.</p><p>The young generation region of the heap is used for new objects. GC is performed in this region more often than in other regions. If the size for the young generation is too small, then a lot of minor garbage collections will be performed. If the size is too large, then only full garbage collections will be performed, which can take a long time to complete. Oracle recommends that you keep the size for the young generation between a half and a quarter of the overall heap size.</p><p>The following examples show how to set the initial and maximum size of young generation to 256 MB using various units:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xmn256m</span><br><span class="line">-Xmn262144k</span><br><span class="line">-Xmn268435456</span><br></pre></td></tr></table></figure><p>Instead of the <code>-Xmn</code> option to set both the initial and maximum size of the heap for the young generation, you can use <code>-XX:NewSize</code> to set the initial size and <code>-XX:MaxNewSize</code> to set the maximum size.</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-Xms</code>、<code>-XX:InitialHeapSize</code><br/><code>-Xmx</code>、<code>-XX:MaxHeapSize</code></td><td>设置 Heap 堆区的初始值和最大值，Server 端 JVM 建议将 <code>-Xms</code> 和 <code>-Xmx</code> 设为相同值。</td></tr></tbody></table><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-Xmn</code><br/><code>-XX:NewSize</code><br/><code>-XX:MaxNewSize</code></td><td>设置 Heap 堆内 Young Generation，而 Old Generation 等于：堆区减去 <code>-Xmn</code>。<br/>设置 <code>-Xmn</code> 等同于设置了相同的初始值 <code>-XX:NewSize</code> 和最大值 <code>-XX:MaxNewSize</code>。</td></tr></tbody></table><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-XX:NewRatio</code></td><td>设置 Young Generation 和 Old Generation 的比值，例如该值为 3，则表示 Young Generation 和 Old Generation 比值为1:3。</td></tr><tr><td><code>-XX:SurvivorRatio</code></td><td>设置 Young Generation 中 E 区和 S 区的比例， 即 -XX:SurvivorRatio=eden/s0=eden/s1。</td></tr></tbody></table><h2 id="Method-Area-1"><a href="#Method-Area-1" class="headerlink" title="Method Area"></a>Method Area</h2><h3 id="PermGen"><a href="#PermGen" class="headerlink" title="PermGen"></a>PermGen</h3><p>JDK 7 以前：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-XX:PermSize</code></td><td>Perm 的初始值</td></tr><tr><td><code>-XX:MaxPermSize</code></td><td>Perm 的最大值</td></tr></tbody></table><p>JVM 的永久代(PermGen)主要用于存放 Class 的 meta-data，Class 在被 Loader 加载时就会被放到 PermGen space，GC 在主程序运行期间不会对该区进行清理，默认是 64M 大小，当程序需要加载的对象比较多时，超过 64M 就会报这部分内存溢出了，需要加大内存分配。 </p><h3 id="Metaspace"><a href="#Metaspace" class="headerlink" title="Metaspace"></a>Metaspace</h3><p>JDK 8 及以后，永久代(PermGen)的概念被废弃掉了，参考 <a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">JEP 122: Remove the Permanent Generation</a>：</p><blockquote><p>The proposed implementation will <strong>allocate class meta-data in native memory</strong> and <strong>move interned Strings and class static variables to the Java heap</strong>. </p><p>Hotspot will explicitly allocate and free the native memory for the class meta-data. Allocation of new class meta-data would be <strong>limited by the amount of available native memory</strong> rather than fixed by the value of <code>-XX:MaxPermSize</code>, whether the default or specified on the command line.</p></blockquote><p>取而代之的是一个称为 Metaspace 的存储空间。Metaspace 使用的是本地内存，而不是堆内存，也就是说在默认情况下 Metaspace 的大小只与本地内存大小有关。可以通过以下的几个参数对 Metaspace 进行控制： </p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>-XX:MetaspaceSize</code></td><td>Metaspace 的初始值</td></tr><tr><td><code>-XX:MaxMetaspaceSize</code></td><td>Metaspace 的最大值</td></tr></tbody></table><h2 id="Direct-Memory"><a href="#Direct-Memory" class="headerlink" title="Direct Memory"></a>Direct Memory</h2><p><code>-XX:MaxDirectMemorySize</code>=<em>size</em></p><p>Sets the maximum total size (in bytes) of the New I/O (the <code>java.nio</code> package) direct-buffer allocations. Append the letter <code>k</code> or <code>K</code> to indicate kilobytes, <code>m</code> or <code>M</code> to indicate megabytes, <code>g</code> or <code>G</code> to indicate gigabytes. By default, the size is set to 0, meaning that the JVM chooses the size for NIO direct-buffer allocations automatically.</p><p>The following examples illustrate how to set the NIO size to 1024 KB in different units:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxDirectMemorySize&#x3D;1m</span><br><span class="line">-XX:MaxDirectMemorySize&#x3D;1024k</span><br><span class="line">-XX:MaxDirectMemorySize&#x3D;1048576</span><br></pre></td></tr></table></figure><h1 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h1><h2 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h2><p><code>java.lang.OutOfMemoryError: Java heap space</code>：这种是堆内存不够，一个原因是真不够，另一个原因是程序中有死循环，例如：</p><p><img src="/img/java/jvm/OOM.png" alt="OutOfMemory"></p><p>如果是堆内存不足，可调整 <code>-Xms</code>、<code>-Xmx</code>，或者新老生代的比例。</p><h2 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h2><p><code>java.lang.OutOfMemoryError: PermGen space</code>：这种是P区内存不够，可调整：<code>-XX:PermSize</code>、<code>-XX:MaxPermSize</code>。</p><h2 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h2><p><code>java.lang.StackOverflowError</code>：线程栈溢出，要么是方法调用层次过多（比如存在无限递归调用）：</p><p><img src="/img/java/jvm/SOF.png" alt="StackOverflow"></p><p>要么是线程栈太小，可调整 <code>-Xss</code> 参数增加线程栈大小。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://item.jd.com/11703581.html" target="_blank" rel="noopener">Java 虚拟机规范（Java SE 8 版 - 中文版）</a>》</p><p>《<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener">Java 虚拟机规范（Java SE 8 版 - 英文版）</a>》</p><p>《<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">JEP 122: Remove the Permanent Generation - Release on JDK 8</a>》</p><p>《<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">Command Line Options - JDK 8 HotSpot VM</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 虚拟机系列（一）厂商实现总结</title>
      <link href="2019/08/29/jvm-impl/"/>
      <url>2019/08/29/jvm-impl/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/java/jvm/jvm_impl.png" alt="jvm_impl"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Comparison_of_Java_virtual_machines</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 不用图床解决图片资源问题</title>
      <link href="2019/07/06/hexo-with-img/"/>
      <url>2019/07/06/hexo-with-img/</url>
      
        <content type="html"><![CDATA[<p>写博客难免会引用图片资源，这里提供一种不用图床解决图片资源上传的思路：将图片资源作为源文件一并上传仓库。</p><h1 id="新建-img-目录"><a href="#新建-img-目录" class="headerlink" title="新建 img 目录"></a>新建 img 目录</h1><p>首先，在 hexo 博客 source 目录下新建 img 目录，即：<code>hexo/source/img</code></p><p>然后，在文章的图片引用处使用该路径即可，例如：<code>![mono_create](/img/java/reactive/reactor/mono/mono_create.png)</code></p><p>最后，<code>hexo g</code> 构建出 <code>./public</code> 目录，发现 <code>img</code> 在该目录之中。<code>hexo s</code> 启动服务后，确认能够成功引用图片。</p><h1 id="解决-Typora-实时预览"><a href="#解决-Typora-实时预览" class="headerlink" title="解决 Typora 实时预览"></a>解决 Typora 实时预览</h1><p>通过上述方法能够解决部署后图片引用问题，但带来一个新的问题就是 Typora 无法实时预览。解决办法：在文章顶部加上 <code>typora-root-url: ..</code></p><p><img src="/img/hexo/hexo_with_img.png" alt="hexo_with_img"></p><p>可以将该路径加入到 hexo 模板之中，这样每次 <code>hexo n</code> 新建文稿都会带上该配置：</p><p><img src="/img/hexo/hexo_with_img_2.png" alt="hexo_with_img_2"></p><p>配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">updated: &#123;&#123; updated &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">typora-root-url: ..</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 实战系列（一）常用数据结构及使用场景总结</title>
      <link href="2019/06/05/redis-cmd/"/>
      <url>2019/06/05/redis-cmd/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><table><thead><tr><th></th><th>单个</th><th>批量</th></tr></thead><tbody><tr><td>获取</td><td><code>GET</code> key<br/><code>STRLEN</code> key<br/><code>GETRANGE</code> key start end</td><td><code>MGET</code> key [key …]</td></tr><tr><td>设值</td><td><code>SET</code> key value [EX seconds&#124;PX milliseconds] [NX&#124;XX] [KEEPTTL]<br/><code>SETNX</code> key value<br/><code>SETEX</code> key seconds value<br/><code>PSETEX</code> key milliseconds value<br/><code>GETSET</code> key value<br/><code>SETRANGE</code> key offset value</td><td><code>MSET</code> key value [key value …]<br/><code>MSETNX</code> key value [key value …]</td></tr><tr><td>原子递增、递减</td><td><code>INCR</code> key<br/><code>INCRBY</code> key increment<br/><code>INCRBYFLOAT</code> key increment<br/><code>DECR</code> key<br/><code>DECRBY</code> key decrement</td><td></td></tr><tr><td>追加</td><td><code>APPEND</code></td><td></td></tr><tr><td>位操作</td><td><code>SETBIT</code> key offset value<br/><code>GETBIT</code> key offset<br/><code>BITCOUNT</code> key [start end]<br/><code>BITOP</code> operation destkey key [key …]<br/><code>BITFIELD</code> …<br/><code>BITPOS</code> key bit [start] [end]</td><td></td></tr></tbody></table><p>使用场景：</p><ul><li><p>WEB 集群下的 Session 共享：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br></pre></td></tr></table></figure></li><li><p>分布式锁：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 返回 1 表示加锁成功，0 表示加锁失败</span><br><span class="line">SETNX key value</span><br><span class="line">SET key value NX</span><br><span class="line"></span><br><span class="line">-- 解锁</span><br><span class="line">DEL key</span><br></pre></td></tr></table></figure></li><li><p>全局计数器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br><span class="line">DECR key</span><br></pre></td></tr></table></figure></li><li><p>分布式流水号：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br><span class="line">INCRBY key</span><br></pre></td></tr></table></figure></li></ul><p>分布式流水号 Java 伪代码如下，单机一次性取 1000 个 ID，以降低网络开销和 Redis 负载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxId;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> INCR_BY = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (id == <span class="number">0</span> || id == maxId) &#123;</span><br><span class="line">    maxId = eval(incrby id INCR_BY);</span><br><span class="line">    id = maxId - INCR_BY + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> id++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Hashes"><a href="#Hashes" class="headerlink" title="Hashes"></a>Hashes</h2><p>散列表，一种通过<strong>散列函数</strong>计算对应数组下标，并通过下标随机访问数据时，时间复杂度为 <code>O(1)</code> 的特性快速定位数据的数据结构。Redis 散列表使用这种数据结构来快速获取指定 field。</p><table><thead><tr><th></th><th>单个</th><th>批量</th></tr></thead><tbody><tr><td>获取</td><td><code>HGET</code> key field<br/><code>HSCAN</code> key cursor [MATCH pattern] [COUNT count]<br/><code>HSTRLEN</code> key field</td><td><code>HMGET</code> key field [field …]</td></tr><tr><td>获取所有 fields</td><td><code>HKEYS</code> key</td><td></td></tr><tr><td>获取所有 values</td><td><code>HVALS</code> key</td><td></td></tr><tr><td>获取所有 fields 和 values</td><td><code>HGETALL</code> key</td><td></td></tr><tr><td>判断 field 是否存在</td><td><code>HEXISTS</code> key field</td><td></td></tr><tr><td>获取 field 个数</td><td><code>HLEN</code> key</td><td></td></tr><tr><td>设值</td><td><code>HSET</code> key field value [field value …]<br/><code>HSETNX</code> key field value</td><td><del><code>HMSET</code> key field value [field value …]</del></td></tr><tr><td>原子递增、递减</td><td><code>HINCRBY</code> key field increment<br/><code>HINCRBYFLOAT</code> key field increment</td><td></td></tr><tr><td>删除 fields</td><td><code>HDEL</code> key field [field …]</td><td></td></tr></tbody></table><h2 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h2><p>双端队列。</p><p><img src="/img/redis/redis_lists.png" alt="redis_lists"></p><table><thead><tr><th></th><th>左</th><th>右</th></tr></thead><tbody><tr><td>入队</td><td><code>LPUSH</code> key element [element …]<br/><code>LPUSHX</code> key element [element …]</td><td><code>RPUSH</code> key element [element …]<br/><code>RPUSHX</code> key element [element …]</td></tr><tr><td>出队</td><td><code>LPOP</code> key</td><td><code>RPOP</code> key</td></tr><tr><td>阻塞出队</td><td><code>BLPOP</code> key [key …] timeout</td><td><code>BRPOP</code> key [key …] timeout</td></tr><tr><td>插队</td><td><code>LINSERT</code> key BEFORE&#124;AFTER pivot element</td><td></td></tr><tr><td>获取指定索引的元素</td><td><code>LINDEX</code> key index</td><td></td></tr><tr><td>获取指定范围的元素</td><td><code>LRANGE</code> key start stop</td><td></td></tr><tr><td>获取列表长度</td><td><code>LLEN</code> key</td><td></td></tr><tr><td>覆盖元素</td><td><code>LSET</code> key index element</td><td></td></tr><tr><td>移除元素</td><td><code>LREM</code> key count element</td><td></td></tr><tr><td>移除指定范围的元素</td><td><code>LTRIM</code> key start stop</td><td></td></tr></tbody></table><table><thead><tr><th></th><th>非阻塞</th><th>阻塞</th></tr></thead><tbody><tr><td>出队并重新入队另一个队列</td><td><code>RPOPLPUSH</code> source destination</td><td><code>BRPOPLPUSH</code> source destination timeout</td></tr></tbody></table><p>使用场景：</p><ul><li>Stack (FILO): <code>LPUSH</code> + <code>LPOP</code></li><li>Queue (FIFO): <code>LPUSH</code> + <code>RPOP</code>，实现消息流</li><li>Blocking Queue (FIFO): <code>LPUSH</code> + <code>BRPOP</code></li></ul><h2 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h2><p>无序集合。</p><p>集合操作：</p><table><thead><tr><th></th><th>命令</th></tr></thead><tbody><tr><td>添加元素</td><td><code>SADD</code> key member [member …]</td></tr><tr><td>移除元素</td><td><code>SREM</code> key member [member …]</td></tr><tr><td>判断指定元素是否存在</td><td><code>SISMEMBER</code> key member</td></tr><tr><td>获取所有元素</td><td><code>SMEMBERS</code> key</td></tr><tr><td>获取元素个数</td><td><code>SCARD</code> key</td></tr><tr><td>增量式遍历集合元素</td><td><code>SSCAN</code> key cursor [MATCH pattern] [COUNT count]</td></tr><tr><td>获取指定个数的<strong>随机元素</strong></td><td><code>SRANDMEMBER</code> key [count]</td></tr><tr><td>移除指定个数的<strong>随机元素</strong>，并返回</td><td><code>SPOP</code> key [count]</td></tr></tbody></table><p>集合运算：</p><table><thead><tr><th></th><th>命令</th></tr></thead><tbody><tr><td>移动指定元素到另一个集合</td><td><code>SMOVE</code> source destination member</td></tr><tr><td>求交集</td><td><code>SINTER</code> key [key …]</td></tr><tr><td>求交集，并保存结果</td><td><code>SINTERSTORE</code> destination key [key …]</td></tr><tr><td>求并集</td><td><code>SUNION</code> key [key …]</td></tr><tr><td>求并集，并保存结果</td><td><code>SUNIONSTORE</code> destination key [key …]</td></tr><tr><td>求差集</td><td><code>SDIFF</code> key [key …]</td></tr><tr><td>求差集，并保存结果</td><td><code>SDIFFSTORE</code> destination key [key …]</td></tr></tbody></table><p>使用场景：</p><ul><li><p>抽奖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 随机抽奖</span><br><span class="line">SRANDMEMBER key [count]</span><br><span class="line"></span><br><span class="line">-- 随机抽取一二三等奖</span><br><span class="line">SPOP key [count]</span><br></pre></td></tr></table></figure></li><li><p>社交应用的关注模型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-- 我关注的人</span><br><span class="line">SMEMBERS key</span><br><span class="line"></span><br><span class="line">-- 求共同关注</span><br><span class="line">SINTER key [key ...]</span><br><span class="line"></span><br><span class="line">-- 我关注的人也关注 ta</span><br><span class="line">foreach(member <span class="keyword">in</span> 我关注的人) &#123;</span><br><span class="line">  -- 我每个关注的人，他们关注的人中，是否有 ta</span><br><span class="line">  SISMEMBER ((SMEMBERS key) of member) ta</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-- 我可能认识的人</span><br><span class="line">foreach(member <span class="keyword">in</span> 我关注的人) &#123;</span><br><span class="line">  -- 我每个关注的人，他们关注的人中，有我可能认识的人</span><br><span class="line">  SDIFF ((SMEMBERS key) of member) 我关注的人</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>商品筛选</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 1、分类筛选维度，每个维度的每个值都为一个集合</span><br><span class="line">-- 2、将商品按维度按值加入对应集合</span><br><span class="line">-- 3、多选筛选条件，求交集</span><br><span class="line">SINTER key [key ...]</span><br><span class="line"></span><br><span class="line">-- 4、根据交集 member，获取商品详情（O(1) 时间复杂度）</span><br><span class="line">foreach member &#123;</span><br><span class="line">  -- 每个 field 为商品属性</span><br><span class="line">  HGETALL member</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Sorted-Sets"><a href="#Sorted-Sets" class="headerlink" title="Sorted Sets"></a>Sorted Sets</h2><p>有序集合。</p><h1 id="其它命令"><a href="#其它命令" class="headerlink" title="其它命令"></a>其它命令</h1><table><thead><tr><th></th><th>命令</th></tr></thead><tbody><tr><td>删除 key</td><td><code>DEL</code></td></tr><tr><td>设值 key 的过期时间（秒）</td><td><code>EXPIRE</code></td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://redis.io/commands" target="_blank" rel="noopener">https://redis.io/commands</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构系列（一）脑图总结</title>
      <link href="2019/06/02/data-structure/"/>
      <url>2019/06/02/data-structure/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p><img src="/img/data-structure/problem_solution_steps.png" alt="计算机解决问题的步骤"></p><h1 id="基本概念和术语"><a href="#基本概念和术语" class="headerlink" title="基本概念和术语"></a>基本概念和术语</h1><p><img src="/img/data-structure/data_structure_terms.png" alt="data_structure"></p><ul><li>数据</li><li>数据对象：是<strong>性质相同</strong>的数据元素的集合，是数据的子集。</li><li>数据元素：数据的<strong>基本单位</strong>，也是运算的基本单位。例如在数据库中，又称为记录（Record）/元组（Tuple）。</li><li>数据项：数据不可分割的<strong>最小单位</strong>。例如在数据库中，又称为字段（Field）/域（Domain）。</li><li>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。它包括：<ul><li>数据的逻辑结构</li><li>数据的存储结构</li><li>数据的基本运算</li></ul></li></ul><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><table><thead><tr><th></th><th>线性结构</th><th>树形结构</th><th>图结构</th></tr></thead><tbody><tr><td>顺序存储方式</td><td>数组</td><td>数组<br/>* 完全二叉树<br/>* 满二叉树</td><td>-</td></tr><tr><td>链式存储方式</td><td>链表<br/>* 单向链表<br/>* 双向链表<br/>* 单向循环链表<br/>* 双向循环链表</td><td>链表</td><td>链表</td></tr></tbody></table><h3 id="离散集合"><a href="#离散集合" class="headerlink" title="离散集合"></a>离散集合</h3><h3 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h3><h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><h3 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h3><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>数据的逻辑结构在计算机中的实现，成为数据的存储结构（或物理结构）。</p><p>一般情况下，一个存储结构包括以下两个部分：</p><ul><li>存储数据元素本身</li><li>数据元素之间的关联方式</li></ul><h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3><h3 id="链式存储方式"><a href="#链式存储方式" class="headerlink" title="链式存储方式"></a>链式存储方式</h3><h3 id="索引存储方式"><a href="#索引存储方式" class="headerlink" title="索引存储方式"></a>索引存储方式</h3><h3 id="散列存储方式"><a href="#散列存储方式" class="headerlink" title="散列存储方式"></a>散列存储方式</h3><h1 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h1><p><img src="/img/data-structure/data_structure.png" alt="data_structure"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html</a></p><p><a href="https://www.bigocheatsheet.com" target="_blank" rel="noopener">https://www.bigocheatsheet.com</a></p><p><a href="https://baozoulin.gitbook.io/-data-structure/chapter1/12-luo-ji-jie-gou-yu-wu-li-jie-gou" target="_blank" rel="noopener">逻辑结构与物理结构</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo &amp; Travis CI 搭建博客</title>
      <link href="2019/05/26/hexo-with-travis-ci/"/>
      <url>2019/05/26/hexo-with-travis-ci/</url>
      
        <content type="html"><![CDATA[<p>Hexo 博客使用好多年了，总结下日常使用的一些内容。</p><h1 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h1><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -g 参数全局安装 Hexo 命令行工具，安装后才可以使用下述 hexo 命令</span></span><br><span class="line">$ npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化本地仓库及 hexo 文件，适用于第一次使用</span></span><br><span class="line">$ hexo init</span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo 基础配置、主题、插件配置等等，详细配置参考官网</span></span><br><span class="line">$ vim _config.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 package.json 的声明（hexo 版本及 dependencies 版本）安装所需依赖到当前目录 node_modules</span></span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>依赖安装完毕，开始使用 hexo，常用命令如下：</p><p><img src="/img/hexo/hexo_cmd.png" alt="Hexo 常用命令"></p><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><p>为了方便随时随地可以编写博客，搭建好的本地仓库及其源文件一般会推送到 GitHub 远程仓库中保管，而构建出来的 <code>./public</code> 目录会部署到 GitHub Pages 服务。因此需要在 GitHub 中新建两个仓库：</p><ul><li>仓库一：存放源文件，名字随意</li><li>仓库二：存放构建文件（<code>./public</code>），GitHub Pages 服务要求名字为 <code>yourname.github.io</code></li></ul><h1 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h1><p>完成上面两步就可以开始创作了。但毕竟命令还是有些繁琐，因此可以利用持续集成服务代替人工来做重复的事情。引入 Travis CI 后，整体流程如下：</p><p><img src="/img/hexo/github-pages-ci.png" alt="GitHub Pages with CI"></p><p>从上述流程来看，作者只需要完成创作并推送即可，其它构建、部署的事则由 Travis CI 来完成，非常简单。</p><p>下面来看下如何配置：</p><h2 id="GitHub-创建-access-token"><a href="#GitHub-创建-access-token" class="headerlink" title="GitHub 创建 access token"></a>GitHub 创建 access token</h2><p>登录 GitHub - Settings - Developer Settings 选项，找到 Personal access tokens 页面，创建个人 access token，创建时权限 <code>repo</code> 权限和 <code>user:email</code> 权限。</p><h2 id="Travis-CI-仓库配置"><a href="#Travis-CI-仓库配置" class="headerlink" title="Travis CI 仓库配置"></a>Travis CI 仓库配置</h2><ol><li>使用 GitHub 账户登录 <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> 官网并进行 OAuth 授权</li><li>同步仓库一，过程中会在 GitHub 账户下安装 Travis CI 的 GitHub App，用于触发持续集成</li><li>为仓库一设置环境变量：<ul><li><code>GH_TOKEN</code> 值为 GitHub access token</li><li><code>GH_REF</code> 值为 GitHub 仓库二地址</li></ul></li></ol><h2 id="创建-travis-yml-配置"><a href="#创建-travis-yml-配置" class="headerlink" title="创建 .travis.yml 配置"></a>创建 .travis.yml 配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置语言</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="comment"># 设置相应的版本，可以指定版本 10，或者使用稳定版 stable</span></span><br><span class="line"><span class="attr">node_js:</span> <span class="string">stable</span></span><br><span class="line"><span class="comment"># 设置只监听哪个分支</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="comment"># 缓存 node_modules 目录，可以节省持续集成的时间</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="attr">after_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">./public</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">init</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.name</span> <span class="string">"yourname"</span> <span class="comment"># 修改name</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">user.email</span> <span class="string">"youremail"</span> <span class="comment"># 修改email</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">"Travis CI Auto Builder"</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">push</span> <span class="string">--force</span> <span class="string">--quiet</span> <span class="string">"https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;"</span> <span class="string">master:master</span></span><br></pre></td></tr></table></figure><h2 id="自动构建"><a href="#自动构建" class="headerlink" title="自动构建"></a>自动构建</h2><p>创作并推送到仓库一即可，其它构建、部署的事都由 Travis CI 来完成，过程如下：</p><p><img src="/img/hexo/travis_ci.png" alt="Travis CI"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程系列（三）Java 8 Stream API 总结</title>
      <link href="2019/05/21/java8-stream-api/"/>
      <url>2019/05/21/java8-stream-api/</url>
      
        <content type="html"><![CDATA[<p>本文总结下 Stream API：</p><p><img src="/img/java/lambda/java.util.stream.png" alt="java.util.stream"></p><h1 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h1><p>流是从支持数据处理操作的源生成的元素序列，源可以是数组、集合、文件、函数。流不是集合元素，它不是数据结构并不保存数据，它的主要目的在于计算。</p><h1 id="如何生产流"><a href="#如何生产流" class="headerlink" title="如何生产流"></a>如何生产流</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>通过 <code>Arrays.stream</code> 方法生成流，并且该方法生成的流是数值流（即 <code>IntStream</code> 而不是 <code>Stream&lt;Integer&gt;</code>）。使用数值流可以避免计算过程中的拆箱装箱，提高性能。Stream API 提供了 <code>mapToInt</code>、<code>mapToDouble</code>、<code>mapToLong</code> 三种方式将对象流（<code>Stream&lt;T&gt;</code>）转换成对应的数值流，同时提供了 <code>boxed</code> 方法将数值流转换为对象流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] intArr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">IntStream intStream = Arrays.stream(intArr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span>[] longArr = <span class="keyword">new</span> <span class="keyword">long</span>[]&#123;<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">3L</span>, <span class="number">4L</span>, <span class="number">5L</span>&#125;;</span><br><span class="line">LongStream longStream = Arrays.stream(longArr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>[] doubleArr = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>&#125;;</span><br><span class="line">DoubleStream doubleStream = Arrays.stream(doubleArr);</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>通过集合生成，最常用的一种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integerList = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = integerList.stream();</span><br></pre></td></tr></table></figure><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>通过文件生成，得到的每个流是给定文件中的每一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">Stream&lt;String&gt; stream1 = Files.lines(Paths.get(<span class="string">"E:\\data.txt"</span>), Charset.defaultCharset());</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"E:\\data.txt"</span>));</span><br><span class="line">Stream&lt;String&gt; stream2 = reader.lines();</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// []</span></span><br><span class="line">Stream&lt;Integer&gt; stream3 = Stream.empty();</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">Stream&lt;Integer&gt; stream4 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate 方法接受两个参数，第一个为初始化值，第二个为进行的函数操作，因为 iterate 生成的流为无限流，因此通过 limit 方法对流进行了截断，只生成 5 个偶数</span></span><br><span class="line"><span class="comment">// [0, 2, 4, 6, 8]</span></span><br><span class="line">Stream&lt;Integer&gt; stream5 = Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>).limit(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// generate 方法接受一个参数，方法参数类型为 Supplier&lt;T&gt; ，由它为流提供值。generate 生成的流也是无限流，因此通过 limit 对流进行了截断</span></span><br><span class="line"><span class="comment">// [0.0819448251044178, 0.9273399484995596, 0.3050941986467305, 0.824966110053092, 0.6101914799225238]</span></span><br><span class="line">Stream&lt;Double&gt; stream6 = Stream.generate(Math::random).limit(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 builder 模式创建流</span></span><br><span class="line"><span class="comment">// [1, 2]</span></span><br><span class="line">Stream&lt;Integer&gt; stream8 = Stream.&lt;Integer&gt;builder().add(<span class="number">1</span>).add(<span class="number">2</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 concat 方法拼接两个流</span></span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line">Stream&lt;Integer&gt; stream7 = Stream.concat(Stream.of(<span class="number">1</span>, <span class="number">2</span>), Stream.of(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure><h1 id="流的操作类型"><a href="#流的操作类型" class="headerlink" title="流的操作类型"></a>流的操作类型</h1><h2 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h2><p>一个流可以后面跟随零个或多个中间操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的，仅仅调用到这类方法，并没有真正开始流的遍历，真正的遍历需等到终结操作。</p><h2 id="终结操作"><a href="#终结操作" class="headerlink" title="终结操作"></a>终结操作</h2><p>一个流有且只能有一个终结操作，当这个操作执行后，流就被关闭，无法再被操作了。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="分组统计"><a href="#分组统计" class="headerlink" title="分组统计"></a>分组统计</h2><p>测试数据如下，需要按 key 分组统计总个数、总和、平均数、最大值、最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Pair&lt;String, Integer&gt;&gt; peoples = Arrays.asList(Pair.of(<span class="string">"Lucy"</span>, <span class="number">10</span>),</span><br><span class="line">                                                    Pair.of(<span class="string">"Lucy"</span>, <span class="number">30</span>),</span><br><span class="line">                                                    Pair.of(<span class="string">"Peter"</span>, <span class="number">18</span>));</span><br></pre></td></tr></table></figure><p>方式一，各项单独统计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;Lucy=2, Peter=1&#125;</span></span><br><span class="line">Map&lt;String, Long&gt; counting = peoples.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(Pair::getKey, Collectors.counting()));</span><br><span class="line"><span class="comment">// &#123;Lucy=40, Peter=18&#125;</span></span><br><span class="line">Map&lt;String, Integer&gt; summing = peoples.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(Pair::getKey, Collectors.summingInt(Pair::getValue)));</span><br><span class="line"><span class="comment">// &#123;Lucy=20.0, Peter=18.0&#125;</span></span><br><span class="line">Map&lt;String, Double&gt; averaging = peoples.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(Pair::getKey, Collectors.averagingDouble(Pair::getValue)));</span><br><span class="line"><span class="comment">// &#123;Lucy=Optional[(Lucy,30)], Peter=Optional[(Peter,18)]&#125;</span></span><br><span class="line">Map&lt;String, Optional&lt;Pair&lt;String, Integer&gt;&gt;&gt; max = peoples.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(Pair::getKey, Collectors.maxBy(Comparator.comparing(Pair::getValue))));</span><br><span class="line"><span class="comment">// &#123;Lucy=Optional[(Lucy,10)], Peter=Optional[(Peter,18)]&#125;</span></span><br><span class="line">Map&lt;String, Optional&lt;Pair&lt;String, Integer&gt;&gt;&gt; min = peoples.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(Pair::getKey, Collectors.minBy(Comparator.comparing(Pair::getValue))));</span><br></pre></td></tr></table></figure><p>方式二，汇总统计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   Lucy=IntSummaryStatistics&#123;count=2, sum=40, min=10, average=20.000000, max=30&#125;, </span></span><br><span class="line"><span class="comment">//   Peter=IntSummaryStatistics&#123;count=1, sum=18, min=18, average=18.000000, max=18&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">Map&lt;String, IntSummaryStatistics&gt; summary = peoples.stream()</span><br><span class="line">    .collect(Collectors.groupingBy(Pair::getKey, Collectors.summarizingInt(Pair::getValue)));</span><br></pre></td></tr></table></figure><h2 id="获取列表索引"><a href="#获取列表索引" class="headerlink" title="获取列表索引"></a>获取列表索引</h2><p><code>forEach</code> 方法入参缺少列表索引，无法实现某些场景下的特殊需求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elements.forEach(element -&gt; downloadFile(element));</span><br></pre></td></tr></table></figure><p>解决方案一，通过 <code>IntStream</code> 获取索引 index：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">0</span>, elements.size())</span><br><span class="line">        .forEach(index -&gt; downloadFile(elements.get(index), index));</span><br></pre></td></tr></table></figure><p>解决方案二，自定义工具类通过 <code>BiConsumer</code> 传参，获取索引 index 和元素 element：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IterateUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Iterable&lt;? extends E&gt; elements, BiConsumer&lt;Integer, ? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(elements);</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : elements) &#123;</span><br><span class="line">            action.accept(index++, element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line">IterateUtil.forEach(</span><br><span class="line">    elements, </span><br><span class="line">    (index, element) -&gt; downloadFile(element, index)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).toArray();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] objects = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).toArray();</span><br><span class="line">Integer[] integers = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>).toArray(Integer[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>《<a href="https://www.baeldung.com/java-lambda-exceptions" target="_blank" rel="noopener">Exceptions in Java 8 Lambda Expressions</a>》</p><p>《<a href="https://www.jianshu.com/p/597a7ccfec25" target="_blank" rel="noopener">Stream 中异常处理的四种方式</a>》</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html</a></p><p><a href="https://docs.oracle.com/javase/tutorial/collections/streams/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/collections/streams/index.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程系列（二）Java 8 Optional API 总结</title>
      <link href="2019/05/14/java8-optional/"/>
      <url>2019/05/14/java8-optional/</url>
      
        <content type="html"><![CDATA[<p>Java 8 引入了 <code>Optional</code> 类用于解决臭名昭著的空指针异常。它本质上是一个可以为 <code>null</code> 的容器对象，并提供了很多有用的方法，以函数式编程的风格简化 <code>null</code> 处理。</p><p><code>Optional</code> 示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String nullStr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 Optional</span></span><br><span class="line">Optional&lt;String&gt; a = Optional.of(<span class="string">"a"</span>);</span><br><span class="line">Optional&lt;String&gt; b = Optional.empty();</span><br><span class="line">Optional&lt;String&gt; c = Optional.ofNullable(nullStr);</span><br><span class="line"></span><br><span class="line">String s0 = a.get();  <span class="comment">// a</span></span><br><span class="line">String s1 = b.orElse(<span class="string">"other"</span>);  <span class="comment">// other</span></span><br><span class="line">String s2 = b.orElseGet(<span class="keyword">this</span>::someExpensiveOperation);  <span class="comment">// 方法引用的返回值</span></span><br><span class="line">String s3 = b.orElseGet(() -&gt; someExpensiveOperation());  <span class="comment">// lambda 表达式的返回值</span></span><br><span class="line">String s4 = b.orElseThrow(IllegalArgumentException::<span class="keyword">new</span>);  <span class="comment">// 抛异常</span></span><br><span class="line">String s5 = b.orElseThrow(() -&gt; <span class="keyword">new</span> IllegalArgumentException(<span class="string">"非法参数"</span>));  <span class="comment">// 抛异常</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isPresent = a.isPresent();  <span class="comment">// true</span></span><br><span class="line">a.ifPresent(System.out::println);  <span class="comment">// a</span></span><br><span class="line">a.filter(String::isEmpty).ifPresent(System.out::println);  <span class="comment">// 条件不匹配，无打印</span></span><br><span class="line">a.map(String::toUpperCase).ifPresent(System.out::println);  <span class="comment">// 映射为大写字母 A 并打印</span></span><br></pre></td></tr></table></figure><p>上述示例中，<code>Optional</code> 几个关键方法主要使用到这几个函数式接口：</p><ul><li><code>orElseGet</code> 使用到： <code>java.util.function.Supplier</code></li><li><code>orElseThrow</code> 使用到： <code>java.util.function.Supplier</code></li><li><code>ifPresent</code> 使用到：<code>java.util.function.Consumer</code></li><li><code>filter</code> 使用到：<code>java.util.function.Predicate</code></li><li><code>map</code> 使用到：<code>java.util.function.Function</code></li></ul><p><code>Optional</code> 几个关键方法的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the value if present, otherwise invoke &#123;<span class="doctag">@code</span> other&#125; and return</span></span><br><span class="line"><span class="comment">     * the result of that invocation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">orElseGet</span><span class="params">(Supplier&lt;? extends T&gt; other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value != <span class="keyword">null</span> ? value : other.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return the contained value, if present, otherwise throw an exception</span></span><br><span class="line"><span class="comment">     * to be created by the provided supplier.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;X extends Throwable&gt; <span class="function">T <span class="title">orElseThrow</span><span class="params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="keyword">throws</span> X </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> exceptionSupplier.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If a value is present, invoke the specified consumer with the value,</span></span><br><span class="line"><span class="comment">     * otherwise do nothing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifPresent</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">            consumer.accept(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If a value is present, and the value matches the given predicate,</span></span><br><span class="line"><span class="comment">     * return an &#123;<span class="doctag">@code</span> Optional&#125; describing the value, otherwise return an</span></span><br><span class="line"><span class="comment">     * empty &#123;<span class="doctag">@code</span> Optional&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(predicate);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> predicate.test(value) ? <span class="keyword">this</span> : empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If a value is present, apply the provided mapping function to it,</span></span><br><span class="line"><span class="comment">     * and if the result is non-null, return an &#123;<span class="doctag">@code</span> Optional&#125; describing the</span></span><br><span class="line"><span class="comment">     * result.  Otherwise return an empty &#123;<span class="doctag">@code</span> Optional&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(mapper);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> empty();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.ofNullable(mapper.apply(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程系列（一）Java 8 Lambda 表达式总结</title>
      <link href="2019/05/07/java8-lambda/"/>
      <url>2019/05/07/java8-lambda/</url>
      
        <content type="html"><![CDATA[<h1 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h1><p>Lambda 表达式总结：</p><p><img src="/img/java/lambda/lambda.png" alt="lambda"></p><p>Java 8 为函数式编程新增的重点 API：</p><p><img src="/img/java/lambda/api.png" alt="api"></p><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>函数式接口是只有一个抽象方法的接口，作为 Lambda 表达式和方法引用的<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html#target-typing" target="_blank" rel="noopener">目标类型</a>。</p><p>JDK 8 新增了 9 组共 43 个通用型函数式接口，位于 <code>java.util.function</code> 包下，用来支持 Java 的函数式编程。接口如此之多的原因有二：</p><ul><li><p>为了支持不同的参数个数。如 <code>UnaryOperator&lt;T&gt;</code> 仅支持一个参数，而 <code>BinaryOperator&lt;T&gt;</code> 支持两个参数。这一点从接口命名及函数签名也能看出：</p><ul><li><code>Unary</code> 一元</li><li><code>Binary</code> 二元</li><li><code>Ternary</code> 三元</li><li><code>Quaternary</code> 四元</li><li>……</li></ul></li><li><p>泛型不支持原始数据类型。而在面对大数据量的流式 API 运算时，为了解决包装类在自动拆装箱的性能消耗，引入了 <code>int</code>、<code>long</code>、<code>Double</code> 原始数据类型的函数式接口。</p><blockquote><p>千万不要用带包装类型的基础函数接口来代替基本类型的函数接口。虽然可行，但它破坏了第 61 条的规则“基本类型优于装箱基本类型”。使用装箱基本类型进行批量操作处理，最终会导致致命的性能问题。——《Effective Java》</p></blockquote></li></ul><p>这些接口统计如下：</p><table><thead><tr><th>接口</th><th>函数签名</th><th>范例</th><th>范例</th><th>基本类型特化</th></tr></thead><tbody><tr><td><code>Predicate&lt;T&gt;</code></td><td><code>boolean test(T t)</code></td><td><code>String::isEmpty</code></td><td>符合某个条件吗？</td><td><code>IntPredicate</code><br/><code>LongPredicate</code><br/><code>DoublePredicate</code></td></tr><tr><td><code>BiPredicate&lt;T, U&gt;</code></td><td><code>boolean test(T t, U u)</code></td><td></td><td></td><td></td></tr><tr><td><code>Supplier&lt;T&gt;</code></td><td><code>T get()</code></td><td><code>Instant::now</code></td><td>无参的工厂方法</td><td><code>BooleanSupplier</code><br/><code>IntSupplier</code><br/><code>LongSupplier</code><br/><code>DoubleSupplier</code></td></tr><tr><td><code>Consumer&lt;T&gt;</code></td><td><code>void accept(T t)</code></td><td><code>System.out::println</code></td><td>输出一个值</td><td><code>IntConsumer</code><br/><code>LongConsumer</code><br/><code>DoubleConsumer</code></td></tr><tr><td><code>BiConsumer&lt;T, U&gt;</code></td><td><code>void accept(T t, U u)</code></td><td></td><td></td><td><code>ObjIntConsumer&lt;T&gt;</code><br/><code>ObjLongConsumer&lt;T&gt;</code><br/><code>ObjDoubleConsumer&lt;T&gt;</code></td></tr><tr><td><code>Function&lt;T, R&gt;</code></td><td><code>R apply(T t)</code></td><td><code>Arrays::asList</code></td><td>类型转换</td><td><code>IntFunction&lt;R&gt;</code><br/><code>IntToLongFunction</code><br/><code>IntToDoubleFunction</code><br/><code>LongFunction&lt;R&gt;</code><br/><code>LongToIntFunction</code><br/><code>LongToDoubleFunction</code><br/><code>DoubleFunction&lt;R&gt;</code><br/><code>DoubleToIntFunction</code><br/><code>DoubleToLongFunction</code><br/><code>ToIntFunction&lt;T&gt;</code><br/><code>ToLongFunction&lt;T&gt;</code><br/><code>ToDoubleFunction&lt;T&gt;</code></td></tr><tr><td><code>BiFunction&lt;T, U, R&gt;</code></td><td><code>R apply(T t, U u)</code></td><td></td><td></td><td><code>ToIntBiFunction&lt;T, U&gt;</code><br/><code>ToLongBiFunction&lt;T, U&gt;</code><br/><code>ToDoubleBiFunction&lt;T, U&gt;</code></td></tr><tr><td><code>UnaryOperator&lt;T&gt;</code></td><td><code>T apply(T t)</code></td><td><code>String::toUpperCase</code></td><td>格式转换</td><td><code>IntUnaryOperator</code><br/><code>LongUnaryOperator</code><br/><code>DoubleUnaryOperator</code></td></tr><tr><td><code>BinaryOperator&lt;T&gt;</code></td><td><code>T apply(T t1, T t2)</code></td><td><code>BigInteger::add</code></td><td>求两个数的加减乘除</td><td><code>IntBinaryOperator</code><br/><code>LongBinaryOperator</code><br/><code>DoubleBinaryOperator</code></td></tr></tbody></table><p>以上接口都标注了 <code>@FunctionalInterface</code>。这是 Java 8 为函数式接口引入的一个新注解，有两个目的：</p><ul><li>告诉这个接口及其文档的读者，这个接口是针对 Lambda 设计的；</li><li>用于编译级错误检查。加上该注解，当你写的接口不符合函数式接口定义的时候，编译器会报错。该注解会强制 <code>javac</code> 检查一个接口是否符合函数式接口的标准。如果该注释添加给一个枚举类型、类或另一个注解，<strong>或者接口包含不止一个抽象方法</strong>，<code>javac</code> 就会报错。重构代码时，使用它能很容易发现问题，因此建议必须始终用 <code>@FunctionalInterface</code> 注解对自己编写的函数式接口进行标注。</li></ul><p>此外，函数式接口允许：</p><ul><li>函数式接口里允许定义默认方法，因为默认方法不是抽象方法，其有一个默认实现，所以是符合函数式接口的定义的。</li><li>函数式接口里允许定义静态方法，因为静态方法不能是抽象方法，是一个已经实现了的方法，所以是符合函数式接口的定义的。</li><li>函数式接口里允许定义 <code>java.lang.Object</code> 里的 <code>public</code> 方法。</li></ul><h1 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h1><p>方法引用通过方法的名字来指向一个方法，可以使语言的构造更紧凑简洁，进一步减少冗余代码，尤其是 Lambda 表达式。</p><p>方法引用使用一对冒号 <code>::</code>。</p><p>下面对比下方法引用简化 Lambda 表达式的例子：</p><table><thead><tr><th>方法引用类型</th><th>方法引用范例</th><th>Lambda 表达式</th></tr></thead><tbody><tr><td>静态</td><td><code>Integer::parseInt</code></td><td><code>str -&gt; Integer.parseInt(str)</code></td></tr><tr><td>有限制</td><td><code>Instant.now()::isAfter</code></td><td><code>Instant then = Instant.now();</code><br/><code>t -&gt; then.isAfter(t)</code></td></tr><tr><td>无限制</td><td><code>String::toLowerCase</code></td><td><code>str -&gt; str.toLowerCase()</code></td></tr><tr><td>类构造器</td><td><code>TreeMap&lt;K, V&gt;::new</code></td><td><code>() -&gt; new TreeMap&lt;K, V&gt;</code></td></tr><tr><td>数组构造器</td><td><code>int[]::new</code></td><td><code>len -&gt; new int[len]</code></td></tr></tbody></table><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>这里对比 JavaScript 和 Java 两门语言的例子，方便对比学习。</p><h2 id="JavaScript-箭头函数"><a href="#JavaScript-箭头函数" class="headerlink" title="JavaScript 箭头函数"></a>JavaScript 箭头函数</h2><p>在 JavaScript 语言中，<strong>函数是一等公民</strong>（参考<a href="[https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html#%E4%B8%BA%E4%BD%95%E9%92%9F%E7%88%B1%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch2.html#为何钟爱一等公民)">为何钟爱一等公民</a>、<a href="https://www.zhihu.com/question/67652709" target="_blank" rel="noopener">知乎</a>）。ES6 新特性允许使用“箭头”（<code>=&gt;</code>）定义函数，语法简洁，使用如下：</p><p>没有参数，需要空括号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="keyword">var</span> result = f();</span><br></pre></td></tr></table></figure><p>一个参数，无需括号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> v; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="keyword">var</span> result = f(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>多个参数，需要括号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123; <span class="keyword">return</span> num1 + num2; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"><span class="keyword">var</span> result = sum(<span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>箭头函数的一个用处是<strong>简化回调函数</strong>：</p><p>例子 1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法，结果 1 2 3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure><p>例子 2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法，结果 [1, 4, 9]</span></span><br><span class="line"><span class="keyword">var</span> result = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure><p>例子 3：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法，结果 [1, 2, 3]</span></span><br><span class="line"><span class="keyword">var</span> result = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure><p>例子 4：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &gt; <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法，结果 [2, 3]</span></span><br><span class="line"><span class="keyword">var</span> result = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="Java-Lambda-表达式"><a href="#Java-Lambda-表达式" class="headerlink" title="Java Lambda 表达式"></a>Java Lambda 表达式</h2><p>然而在 Java 语言中，函数并非一等公民。但可以利用 Lambda 表达式 + 函数式接口来模拟 JavaScript 类似的语法，对比如下：</p><p>没有参数，需要空括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IntSupplier f = () -&gt; <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="keyword">int</span> result = f.getAsInt();</span><br></pre></td></tr></table></figure><p>一个参数，无需括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ToIntFunction&lt;Integer&gt; f = i -&gt; i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="keyword">int</span> result = f.applyAsInt(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>多个参数，需要括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IntBinaryOperator sum = (num1, num2) -&gt; num1 + num2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法引用进一步简化语法</span></span><br><span class="line"><span class="comment">// IntBinaryOperator sum = Integer::sum;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 20</span></span><br><span class="line"><span class="keyword">int</span> result = sum.applyAsInt(<span class="number">10</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>Lambda 表达式同样可以<strong>简化回调函数</strong>：</p><p>例子 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line">IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).forEach(x -&gt; System.out.println(x));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法引用进一步简化语法</span></span><br><span class="line"><span class="comment">// IntStream.of(1, 2, 3).forEach(System.out::println);</span></span><br></pre></td></tr></table></figure><p>例子 2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [1, 4, 9]</span></span><br><span class="line"><span class="keyword">int</span>[] result = IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).map(x -&gt; x * x).toArray();</span><br></pre></td></tr></table></figure><p>例子 3：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="keyword">int</span>[] result = Stream.of(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line">    .sorted((a, b) -&gt; a - b)</span><br><span class="line">    .mapToInt(Integer::intValue)</span><br><span class="line">    .toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法引用进一步简化语法</span></span><br><span class="line"><span class="comment">// int[] result = Stream.of(2, 3, 1)</span></span><br><span class="line"><span class="comment">//     .sorted(Comparator.naturalOrder())</span></span><br><span class="line"><span class="comment">//     .mapToInt(Integer::intValue)</span></span><br><span class="line"><span class="comment">//     .toArray();</span></span><br></pre></td></tr></table></figure><p>例子 4：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [2, 3]</span></span><br><span class="line"><span class="keyword">int</span>[] result = IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).filter(x -&gt; x &gt; <span class="number">1</span>).toArray();</span><br></pre></td></tr></table></figure><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ul><li>Java 8 引入了 <code>Optional</code> 类用于解决臭名昭著的空指针异常。它本质上是一个可以为 <code>null</code> 的容器对象，并提供了很多有用的方法，以函数式编程的风格简化 <code>null</code> 处理。</li><li>Stream API 是一种基于函数式编程的模型，用于增强集合处理。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html</a></p><p><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html</a></p><p><a href="https://docs.oracle.com/javase/tutorial/collections/streams/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/collections/streams/index.html</a></p><p>《Effective Java 第三版》：</p><ul><li>第 42 条：Lambda 优先于匿名类</li><li>第 43 条：方法引用优先于 Lambda</li><li>第 44 条：坚持使用标准的函数式接口（包括基本数据类型的函数式接口）</li><li>第 45 条：谨慎使用 Stream（必要时也需要使用 <code>Iterator</code> 外部迭代器）</li><li>第 46 条：优先选择 Stream 中无副作用的函数（使用收集器 <code>Collectors</code> 而不是 <code>forEach</code>）</li><li>第 47 条：Stream 要优先用 Collection 作为返回类型</li><li>第 48 条：谨慎使用 Stream 并行</li></ul><p>《Java 8 函数式编程》</p><p>《Java 8 实战》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 事务自动提交机制总结</title>
      <link href="2019/03/27/mysql-transaction-autocommit/"/>
      <url>2019/03/27/mysql-transaction-autocommit/</url>
      
        <content type="html"><![CDATA[<h1 id="事务的自动提交机制"><a href="#事务的自动提交机制" class="headerlink" title="事务的自动提交机制"></a>事务的自动提交机制</h1><p>在 <code>InnoDB</code>，所有用户活动都发生在事务中。</p><p><code>InnoDB</code> 默认采用事务<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_autocommit" target="_blank" rel="noopener">自动提交</a>（<code>autocommit</code>）机制。也就是说，如果不是显式开启一个事务，则每条 SQL 语句都<strong>形成独立事务</strong>。如果该语句执行后没有返回错误，MySQL 会自动执行 <code>COMMIT</code>。但如果该语句返回错误，则根据<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-error-handling.html" target="_blank" rel="noopener">错误情况</a>执行 <code>COMMIT</code> 或 <code>ROLLBACK</code>。</p><p>如何修改当前会话的提交模式？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'AUTOCOMMIT'</span>;</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--1 或者 ON 表示启用， 0 或者 OFF 表示禁用</span></span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>关闭后，会话将始终开启一个事务。直到你显式提交或回滚该事务后，一个新事务又被开启。</li><li>如果一个关闭了 <code>autocommit</code> 的会话没有显式提交事务，然后会话被关闭，MySQL 将回滚该事务。</li><li>有一些命令，在执行之后会强制执行 <code>COMMIT</code> 提交当前的活动事务。例如：<ul><li><code>ALTER TABLE</code></li><li><code>LOCK TABLES</code></li></ul></li></ul><h1 id="提交多语句事务"><a href="#提交多语句事务" class="headerlink" title="提交多语句事务"></a>提交多语句事务</h1><p>如何在一个事务中组合多条 SQL 语句（multiple-statement transaction）？有两种方式：</p><ol><li><p>方式一：显式关闭当前会话的 <code>autocommit</code>，然后提交或回滚事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">parent</span> <span class="keyword">VALUES</span> (<span class="number">10</span>, <span class="string">'Heikki'</span>);</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></li><li><p>方式二：如果不想关闭 <code>autocommit</code>，可以通过 <a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener"><code>START TRANSACTION</code></a> 或 <a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener"><code>BEGIN</code></a> 语句显式开启事务，然后通过 <a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener"><code>COMMIT</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener"><code>ROLLBACK</code></a> 语句显式结束事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">parent</span> <span class="keyword">VALUES</span> (<span class="number">15</span>, <span class="string">'John'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">parent</span> <span class="keyword">VALUES</span> (<span class="number">20</span>, <span class="string">'Paul'</span>);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">parent</span> <span class="keyword">WHERE</span> b = <span class="string">'Heikki'</span>;</span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure></li></ol><p>最终结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">parent</span>;</span><br><span class="line">+<span class="comment">------+--------+</span></span><br><span class="line">|  id  | name   |</span><br><span class="line">+<span class="comment">------+--------+</span></span><br><span class="line">|  10  | Heikki |</span><br><span class="line">+<span class="comment">------+--------+</span></span><br></pre></td></tr></table></figure><h1 id="在事务中混合使用存储引擎问题"><a href="#在事务中混合使用存储引擎问题" class="headerlink" title="在事务中混合使用存储引擎问题"></a>在事务中混合使用存储引擎问题</h1><p>MySQL 服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。</p><p>如果在事务中混合使用了事务型和非事务型的表（例如 <code>InnoDB</code> 和 <code>MyISAM</code> 表），可能会有意想不到的情况发生。请看下例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--引入一张 MyISAM 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`people`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`last_name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`first_name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM;</span><br></pre></td></tr></table></figure><p>示例一，在事务中混合使用存储引擎，出现报错：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">--执行成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">parent</span>(<span class="keyword">name</span>) <span class="keyword">VALUES</span>(<span class="string">'Heikki'</span>);</span><br><span class="line"><span class="comment">--执行失败</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> people(last_name, first_name) <span class="keyword">VALUES</span>(<span class="string">'pete'</span>, <span class="string">'Lee'</span>);</span><br><span class="line">1785 - When @@GLOBAL.ENFORCE_GTID_CONSISTENCY = 1, updates to non-transactional tables can only be done in either autocommitted statements or single-statement transactions, and never in the same statement as updates to transactional tables.</span><br></pre></td></tr></table></figure><p>示例二，当事务回滚，非事务型的表上的变更无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> people(last_name, first_name) <span class="keyword">VALUES</span>(<span class="string">'pete'</span>, <span class="string">'Lee'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">parent</span>(<span class="keyword">name</span>) <span class="keyword">VALUES</span>(<span class="string">'Heikki'</span>);</span><br><span class="line"><span class="comment">--parent表（InnoDB）回滚成功，people表（MyISAM）回滚失败</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p>所以，为每张表选择合适的存储引擎非常重要。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高性能 MySQL》</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/sql-syntax-transactions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/sql-syntax-transactions.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 事务实操总结</title>
      <link href="2019/03/26/mysql-transaction-characteristics/"/>
      <url>2019/03/26/mysql-transaction-characteristics/</url>
      
        <content type="html"><![CDATA[<p>前文总结了 MySQL 事务的一些概念，下面总结下如何进行实操。</p><h1 id="开启事务、提交与回滚"><a href="#开启事务、提交与回滚" class="headerlink" title="开启事务、提交与回滚"></a>开启事务、提交与回滚</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span></span><br><span class="line">    [transaction_characteristic [, transaction_characteristic] ...]</span><br><span class="line"></span><br><span class="line">transaction_characteristic: &#123;</span><br><span class="line">    <span class="keyword">WITH</span> <span class="keyword">CONSISTENT</span> <span class="keyword">SNAPSHOT</span></span><br><span class="line">  | <span class="keyword">READ</span> WRITE</span><br><span class="line">  | <span class="keyword">READ</span> <span class="keyword">ONLY</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">COMMIT</span></span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br><span class="line"><span class="keyword">SET</span> autocommit = &#123;<span class="number">0</span> | <span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>主要语法作用如下：</p><ul><li><code>START TRANSACTION</code> 或 <code>BEGIN</code> 开启新的事务。</li><li><code>COMMIT</code> 提交当前事务，使其更改持久化。</li><li><code>ROLLBACK</code> 回滚当前事务，取消其更改。</li><li><code>SET autocommit</code> 禁用或启用当前会话的默认自动提交模式。</li></ul><p><code>START TRANSACTION</code> 是标准的 SQL 语法，推荐使用。它支持以下 <code>BEGIN</code> 语法所不支持的修饰符：</p><ul><li><code>WITH CONSISTENT SNAPSHOT</code> 在事务开启同时创建快照（一致性视图），主要用于可重复读（RR）。</li><li><code>READ WRITE</code> 读写模式，默认值。</li><li><code>READ ONLY</code> 只读模式，有助于提升存储引擎的性能表现。</li></ul><h1 id="SET-TRANSACTION-语法"><a href="#SET-TRANSACTION-语法" class="headerlink" title="SET TRANSACTION 语法"></a>SET TRANSACTION 语法</h1><p>可以通过 <a href="https://dev.mysql.com/doc/refman/5.7/en/set-transaction.html" target="_blank" rel="noopener">SET TRANSACTION</a> 语句设置事务的特性，包括隔离级别和读写模式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span> | <span class="keyword">SESSION</span>] <span class="keyword">TRANSACTION</span></span><br><span class="line">    transaction_characteristic [, transaction_characteristic] ...</span><br><span class="line"></span><br><span class="line">transaction_characteristic: &#123;</span><br><span class="line">    <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">level</span></span><br><span class="line">  | access_mode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">level</span>: &#123;</span><br><span class="line">     REPEATABLE <span class="keyword">READ</span></span><br><span class="line">   | <span class="keyword">READ</span> COMMITTED</span><br><span class="line">   | <span class="keyword">READ</span> UNCOMMITTED</span><br><span class="line">   | <span class="keyword">SERIALIZABLE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">access_mode: &#123;</span><br><span class="line">     <span class="keyword">READ</span> WRITE</span><br><span class="line">   | <span class="keyword">READ</span> <span class="keyword">ONLY</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事务特性范围（作用域）"><a href="#事务特性范围（作用域）" class="headerlink" title="事务特性范围（作用域）"></a>事务特性范围（作用域）</h2><p>您可以设置事务特性的作用域为全局、当前会话或仅针对下一个事务，其优先级为事务 &gt; 会话 &gt; 全局：</p><ul><li><p>使用 <code>GLOBAL</code> 关键字：</p><ul><li>全局应用于所有后续会话。</li><li>现有会话不受影响。</li><li>全局设置要求 <a href="https://dev.mysql.com/doc/refman/5.7/en/privileges-provided.html#priv_super" target="_blank" rel="noopener">SUPER</a> 权限。</li></ul></li><li><p>使用 <code>SESSION</code> 关键字：</p><ul><li>应用于当前会话中执行的所有后续事务。</li><li>不影响正在进行的事务。</li></ul></li><li><p>没有 <code>SESSION</code> 或  <code>GLOBAL</code> 关键字：</p><ul><li><p>仅应用于当前会话中执行的下一个事务。</p></li><li><p>后续事务将恢复为当前会话的默认值。</p></li><li><p>事务中不允许使用该语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">SERIALIZABLE</span>;</span><br><span class="line">ERROR 1568 (25001): Transaction characteristics can't be changed while a transaction is in progress</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>语法总结如下：</p><table><thead><tr><th>语法</th><th>作用域</th></tr></thead><tbody><tr><td>SET GLOBAL TRANSACTION <em>transaction_characteristic</em></td><td>Global</td></tr><tr><td>SET SESSION TRANSACTION <em>transaction_characteristic</em></td><td>Session</td></tr><tr><td>SET TRANSACTION <em>transaction_characteristic</em></td><td>Next transaction only</td></tr></tbody></table><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>MySQL 能够识别所有的四个事务隔离级别，<code>InnoDB</code> 引擎也支持所有的隔离级别。可以使用 <code>ISOLATION LEVEL level</code> 子句进行设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> UNCOMMITTED; <span class="comment">--读未提交</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">READ</span> COMMITTED; <span class="comment">--读已提交</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> REPEATABLE <span class="keyword">READ</span>; <span class="comment">--可重复读</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">SERIALIZABLE</span>; <span class="comment">--串行化</span></span><br></pre></td></tr></table></figure><h2 id="事务读写模式"><a href="#事务读写模式" class="headerlink" title="事务读写模式"></a>事务读写模式</h2><p>MySQL 支持两种事务读写模式，其设置方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">READ</span> WRITE; <span class="comment">--读写模式，默认值</span></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">READ</span> <span class="keyword">ONLY</span>; <span class="comment">--只读模式，有助于提升存储引擎的性能表现</span></span><br></pre></td></tr></table></figure><p>如果要单独为某个事务指定读写模式，搭配 <code>START TRANSACTION</code> 使用。</p><h1 id="SET-语法"><a href="#SET-语法" class="headerlink" title="SET 语法"></a>SET 语法</h1><p>也可以通过 <a href="https://dev.mysql.com/doc/refman/5.7/en/set-variable.html" target="_blank" rel="noopener"><code>SET</code></a> 语句直接进行各种变量赋值，语法总结如下：</p><table><thead><tr><th>语法</th><th>作用域</th></tr></thead><tbody><tr><td>SET GLOBAL <em>var_name</em> = <em>value</em></td><td>Global</td></tr><tr><td>SET @@GLOBAL.<em>var_name</em> = <em>value</em></td><td>Global</td></tr><tr><td>SET SESSION <em>var_name</em> = <em>value</em></td><td>Session</td></tr><tr><td>SET @@SESSION.<em>var_name</em> = <em>value</em></td><td>Session</td></tr><tr><td>SET <em>var_name</em> = <em>value</em></td><td>Session</td></tr><tr><td>SET @@<em>var_name</em> = <em>value</em></td><td>Next transaction only</td></tr></tbody></table><p>变量的查询语法如下，例如 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_transaction_isolation" target="_blank" rel="noopener"><code>transaction_isolation</code></a> 和 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_transaction_read_only" target="_blank" rel="noopener"><code>transaction_read_only</code></a> ：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @@GLOBAL.transaction_isolation, @@GLOBAL.transaction_read_only;</span><br><span class="line"><span class="keyword">SELECT</span> @@SESSION.transaction_isolation, @@SESSION.transaction_read_only;</span><br></pre></td></tr></table></figure><h1 id="启动时设置"><a href="#启动时设置" class="headerlink" title="启动时设置"></a>启动时设置</h1><p>上面介绍的两种语法都是用于运行时设置，下面介绍两种方式用于在服务启动时设置：</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--transaction-isolation&#x3D;REPEATABLE-READ</span><br><span class="line">--transaction-read-only&#x3D;OFF</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">transaction-isolation &#x3D; REPEATABLE-READ</span><br><span class="line">transaction-read-only &#x3D; OFF</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/commit.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/set-transaction.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/set-transaction.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/set-variable.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/set-variable.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-ro-txn.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-ro-txn.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 多版本并发控制（MVCC）总结</title>
      <link href="2019/03/23/mysql-consistent-nonlocking-reads-with-mvcc/"/>
      <url>2019/03/23/mysql-consistent-nonlocking-reads-with-mvcc/</url>
      
        <content type="html"><![CDATA[<h1 id="本文大纲"><a href="#本文大纲" class="headerlink" title="本文大纲"></a>本文大纲</h1><p><img src="/img/mysql/tx_isolation.png" alt="Transaction Isolation"></p><h1 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h1><p>上文提到，数据库的事务隔离性，主要解决以下问题：</p><ul><li>防止多个事务并发执行时由于交叉执行而导致的数据不一致问题。</li><li>解决同一事务内的多次相同查询，数据不一致问题。</li></ul><p>有哪些数据不一致的情况？</p><ul><li>脏读</li><li>不可重复读</li><li>幻读</li></ul><p>为了数据不一致问题，引入了四个隔离级别，随着隔离级别的提升，可以解决上述更多情况。它们所使用的 <code>SELECT</code> 模式分别如下：</p><table><thead><tr><th>隔离级别</th><th>SELECT 默认模式</th><th>备注</th></tr></thead><tbody><tr><td>读未提交<br/><code>READ UNCOMMITTED</code></td><td>/</td><td></td></tr><tr><td>读已提交<br/><code>READ COMMITTED</code></td><td>使用一致性非加锁读（Consistent Non-locking Reads）<br/>总是使用<strong>最新快照</strong></td><td></td></tr><tr><td>可重复读<br/><code>REPEATABLE READ</code></td><td>使用一致性非加锁读（Consistent Non-locking Reads）<br/>同一事务内总是使用<strong>首次快照</strong>，确保可重复读。</td><td>一致性读取不会在它访问的数据上加任何锁，因此其它事务可以自由地同时修改那些数据，同一份数据在 undo log 会存在<strong>多份历史版本</strong>。（即通过多版本并发控制（MVCC）实现可重复读）</td></tr><tr><td>串行化<br/><code>SERIALIZABLE</code></td><td>加共享锁读<br/>（S-Locking reads）</td><td>加锁读会给数据加共享锁，其它事务读取时可以继续加共享锁，但修改会阻塞等待以获取排它锁，保证读写的串行化，因此同一份数据只存在<strong>一份当前版本</strong>。（即通过读写锁实现可重复读）</td></tr></tbody></table><h1 id="InnoDB-可重复读实现"><a href="#InnoDB-可重复读实现" class="headerlink" title="InnoDB 可重复读实现"></a>InnoDB 可重复读实现</h1><p>下面重点看下 MySQL InnoDB 如何实现可重复读这个隔离级别。它使用了一致性非加锁读（Consistent Non-locking Reads）实现多版本并发控制（MVCC），这种方法不会在它访问的数据上设置任何锁，因此其它事务可以自由地同时修改那些表，并发性能高。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>下图展示了两个事务并发执行时，最终会出现的五种情况：</p><p><img src="/img/mysql/consistent-read-examples.png" alt="consistent read examples"></p><p>即：</p><blockquote><p>事务的可重复读的能力是怎么实现的？</p><p>可重复读的核心就是一致性读（consistent read）；而事务更新数据的时候，只能用当前读（current read）。如果当前的记录的行锁被其他事务占用的话，就需要进入锁等待。</p></blockquote><h2 id="Current-Read"><a href="#Current-Read" class="headerlink" title="Current Read"></a>Current Read</h2><p>数据库快照适用于同一事务内的 <code>SELECT</code> 语句，而不一定适用于 DML 语句。不同事务间的增删改操作还是会相互影响的，因为 DML 与 SELECT 语句不同，使用的是 <em>current read</em>。例如：</p><ul><li><p>尽管事务 A 创建一致性视图时查不到 <code>xyz</code> 记录，但如果此后其它事务插入了 <code>xyz</code> 记录并提交事务，事务 A 仍然可以将它们删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(c1) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 = <span class="string">'xyz'</span>;</span><br><span class="line"><span class="comment">-- Returns 0: no rows match.</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c1 = <span class="string">'xyz'</span>;</span><br><span class="line"><span class="comment">-- Deletes several rows recently committed by other transaction.</span></span><br></pre></td></tr></table></figure></li><li><p>尽管事务 A 创建一致性视图时查不到 <code>abc</code> 记录，但如果此后其它事务插入了 <code>abc</code> 记录并提交事务，事务 A 仍然可以修改这些记录，并看到本事务内的修改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 = <span class="string">'abc'</span>;</span><br><span class="line"><span class="comment">-- Returns 0: no rows match.</span></span><br><span class="line"><span class="keyword">UPDATE</span> t1 <span class="keyword">SET</span> c2 = <span class="string">'cba'</span> <span class="keyword">WHERE</span> c2 = <span class="string">'abc'</span>;</span><br><span class="line"><span class="comment">-- Affects 10 rows: another txn just committed 10 rows with 'abc' values.</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(c2) <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> c2 = <span class="string">'cba'</span>;</span><br><span class="line"><span class="comment">-- Returns 10: this txn can now see the rows it just updated.</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Consistent-Read-实现原理"><a href="#Consistent-Read-实现原理" class="headerlink" title="Consistent Read 实现原理"></a>Consistent Read 实现原理</h2><p>Consistent Read 实现依赖于 Undo Log 和 Consistent Read-View。</p><h3 id="Undo-Log-是什么？"><a href="#Undo-Log-是什么？" class="headerlink" title="Undo Log 是什么？"></a>Undo Log 是什么？</h3><blockquote><p>A storage area that holds copies of data modified by active <strong>transactions</strong>. If another transaction needs to see the original data (as part of a <strong>consistent read</strong> operation), the unmodified data is retrieved from this storage area.</p><p>In MySQL 5.6 and MySQL 5.7, you can use the <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_undo_tablespaces" target="_blank" rel="noopener"><code>innodb_undo_tablespaces</code></a> variable have undo logs reside in <strong>undo tablespaces</strong>, which can be placed on another storage device such as an <strong>SSD</strong>. In MySQL 8.0, undo logs reside in two default undo tablespaces that are created when MySQL is initialized, and additional undo tablespaces can be created using <a href="https://dev.mysql.com/doc/refman/5.7/en/create-tablespace.html" target="_blank" rel="noopener"><code>CREATE UNDO TABLESPACE</code></a> syntax.</p><p>The undo log is split into separate portions, the <strong>insert undo buffer</strong> and the <strong>update undo buffer</strong>.</p></blockquote><h3 id="Consistent-Read-View-是什么？"><a href="#Consistent-Read-View-是什么？" class="headerlink" title="Consistent Read-View 是什么？"></a>Consistent Read-View 是什么？</h3><blockquote><p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。</p><p>数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</p><p>这个视图数组和高水位，就组成了当前事务的一致性视图（consistent read-view）。</p><p>这个视图数组把所有的 row trx_id 分成了几种不同的情况。如下图：</p></blockquote><p><img src="/img/mysql/consistent-read-view.png" alt="consistent-read-view"></p><p>以下表事务为例，对于当前事务 105 来说，一致性视图为：<code>[100,103,104,105],106</code>，其中低水位为 <code>100</code>，高水位为 <code>106</code>。这些事务分布如上图。</p><table><thead><tr><th>row trx_id</th><th>committed?</th><th>remark</th></tr></thead><tbody><tr><td>100</td><td>N</td><td></td></tr><tr><td>101</td><td>Y</td><td></td></tr><tr><td>102</td><td>Y</td><td></td></tr><tr><td>103</td><td>N</td><td></td></tr><tr><td>104</td><td>N</td><td></td></tr><tr><td>105</td><td>N</td><td>current trx</td></tr></tbody></table><p>对于当前事务 ID <code>105</code>，根据以下流程图，就只能看到已提交事务 <code>1-99</code>, <code>101</code>, <code>102</code></p><p><img src="/img/mysql/consistent-read-process.png" alt="consistent read process"></p><p><strong>数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</strong>假如事务 ID <code>100-104</code> 依次修改了同一份数据（如上图右），虽然数据当前版本为 <code>104</code>，但对于当前事务 ID <code>105</code> 来说，也只能看到版本链上事务 ID <code>102</code> 提交的数据版本。</p><h2 id="如何查看最新快照"><a href="#如何查看最新快照" class="headerlink" title="如何查看最新快照"></a>如何查看最新快照</h2><p>如果要查看最新快照，可以通过以下三个方法：</p><ul><li>使用 <code>READ COMMITTED</code> 隔离级别</li><li>提交当前事务并发起新查询，刷新时间点</li><li>使用加锁读（读锁或写锁）</li></ul><p>下例展示了第二种方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">             Session A              Session B</span><br><span class="line"></span><br><span class="line">           START TRANSACTION;     START TRANSACTION;</span><br><span class="line">time</span><br><span class="line">|          SELECT * FROM t;</span><br><span class="line">|          empty set</span><br><span class="line">|                                 INSERT INTO t VALUES (1, 2);</span><br><span class="line">|</span><br><span class="line">v          SELECT * FROM t;</span><br><span class="line">           empty set</span><br><span class="line">                                  COMMIT;</span><br><span class="line"></span><br><span class="line">           SELECT * FROM t;</span><br><span class="line">           empty set</span><br><span class="line"></span><br><span class="line">           COMMIT;</span><br><span class="line"></span><br><span class="line">           SELECT * FROM t;</span><br><span class="line">           ---------------------</span><br><span class="line">           |    1    |    2    |</span><br><span class="line">           ---------------------</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高性能 MySQL》</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html</a></p><p><a href="https://time.geekbang.org/column/article/70562" target="_blank" rel="noopener">https://time.geekbang.org/column/article/70562</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL ACID 事务模型与隔离级别总结</title>
      <link href="2019/03/20/mysql-transaction-model/"/>
      <url>2019/03/20/mysql-transaction-model/</url>
      
        <content type="html"><![CDATA[<h1 id="ACID-模型"><a href="#ACID-模型" class="headerlink" title="ACID 模型"></a>ACID 模型</h1><p>维基百科关于 ACID 的定义：</p><blockquote><p>ACID 是<a href="https://en.wikipedia.org/wiki/Database_transaction" target="_blank" rel="noopener">数据库事务</a>的一组属性，旨在即使在发生错误、电源故障等情况下也能保证<strong>数据有效性</strong>。在数据库环境中，一系列满足 ACID 属性的数据库操作（可以视作对数据的单个逻辑操作）称为事务。例如，将资金从某个银行账户转账到另一个银行账户。</p></blockquote><p>下面重点讨论 MySQL <code>InnoDB</code> 存储引擎如何与 ACID 模型进行交互：</p><h2 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h2><blockquote><p>一个<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_transaction" target="_blank" rel="noopener">事务</a>必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部成功<strong>提交</strong>，要么全部失败<strong>回滚</strong>，对于一个事务来说，不可能只执行其中的一部分操作。</p></blockquote><p>相关的 MySQL 功能包括：</p><ul><li>事务的自动提交（<code>autocommit</code>）设置。</li><li><code>START TRANSACTION</code>、<code>COMMIT</code>、<code>ROLLBACK</code> 语句。</li></ul><h2 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h2><blockquote><p>数据库总是从一个一致性的状态转换到另外一个一致性的状态，即使出现系统崩溃等异常情况。</p></blockquote><p>相关的 MySQL 功能包括：</p><ul><li><code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_doublewrite_buffer" target="_blank" rel="noopener">双写缓冲区</a>。</li><li><code>InnoDB</code> <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_crash_recovery" target="_blank" rel="noopener">崩溃恢复</a>。</li></ul><h2 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h2><blockquote><p>隔离性可以防止多个事务并发执行时由于交叉执行而导致的数据不一致问题。事务隔离分为不同级别，详见下述<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_isolation_level" target="_blank" rel="noopener">隔离级别</a>。</p></blockquote><p>相关的 MySQL 功能包括：</p><ul><li>事务的自动提交（<code>autocommit</code>）设置。</li><li><code>SET TRANSACTION ISOLATION LEVEL</code> 语句。</li></ul><h2 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h2><blockquote><p>一旦事务提交，则其所做的修改会永久保存到数据库中。此时即使系统崩溃、修改的数据也不会丢失。</p></blockquote><p>持久性是个有点模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且不可能有能做到 100% 的持久性保证的策略，否则为何还要做数据库备份？</p><p>与持久性相关的 MySQL 功能比较多，这里不做讨论。</p><h1 id="读现象问题"><a href="#读现象问题" class="headerlink" title="读现象问题"></a>读现象问题</h1><p>我们重点来关注下隔离性。隔离性可以防止多个事务并发执行时由于<strong>交叉执行而导致的数据不一致问题</strong>。因此如果不考虑隔离性，会引发如下问题：</p><h2 id="脏读（Dirty-reads）"><a href="#脏读（Dirty-reads）" class="headerlink" title="脏读（Dirty reads）"></a>脏读（Dirty reads）</h2><p>一个事务能够看到其它事务尚未提交的修改。例如：</p><p><img src="/img/mysql/dirty_read.png" alt="脏读"></p><h2 id="不可重复读（Non-repeatable-reads）"><a href="#不可重复读（Non-repeatable-reads）" class="headerlink" title="不可重复读（Non-repeatable reads）"></a>不可重复读（Non-repeatable reads）</h2><p>一个事务的两次查询返回不同的结果。例如：</p><p><img src="/img/mysql/non_repeatable_read.png" alt="不可重复读"></p><p>有两种策略可以避免不可重复读：</p><ul><li>采用共享锁（s-lock）或排它锁（x-lock），进行加锁读（Locking reads）。</li><li>采用多版本并发控制（MVCC），进行一致性非加锁读（Consistent Non-locking Reads）。</li></ul><h2 id="幻读（Phantom-reads）"><a href="#幻读（Phantom-reads）" class="headerlink" title="幻读（Phantom reads）"></a>幻读（Phantom reads）</h2><p>一个事务的两次查询返回不同的结果集。例如：</p><p><img src="/img/mysql/phantom_read.png" alt="幻读"></p><h1 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h1><p>通过提升事务的隔离级别（Isolation Level），可以逐一解决上述问题。所谓隔离级别，就是在数据库事务中，为保证多个事务<strong>并发读写数据</strong>的正确性而提出的定义，它并不是 MySQL 专有的概念，而是源于 <a href="https://en.wikipedia.org/wiki/American_National_Standards_Institute" target="_blank" rel="noopener">ANSI</a>/<a href="https://en.wikipedia.org/wiki/International_Organization_for_Standardization" target="_blank" rel="noopener">ISO</a> 制定的 <a href="https://en.wikipedia.org/wiki/SQL-92" target="_blank" rel="noopener">SQL-92</a> 标准。</p><p>每种关系型数据库都提供了各自特色的隔离级别实现，虽然在通常的隔离级别定义中是以锁为实现单元，但实际的实现千差万别。以最常见的 MySQL <code>InnoDB</code> 存储引擎为例，它是基于 <a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-multi-versioning.html" target="_blank" rel="noopener">MVCC</a>（Multi-Versioning Concurrency Control）和锁的复合实现，性能较高。MySQL <code>InnoDB</code> 存储引擎的事务隔离级别及其解决问题如下：</p><table><thead><tr><th>隔离级别</th><th>脏读<br/>（Dirty reads）</th><th>不可重复读<br/>（Non-repeatable reads）</th><th>幻读<br/>（Phantom reads）</th><th>SELECT 默认模式</th></tr></thead><tbody><tr><td>读未提交<br/>（<code>READ UNCOMMITTED</code>）</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>读已提交<br/>（<code>READ COMMITTED</code>）</td><td>×</td><td>√</td><td>√</td><td>使用一致性非加锁读（Consistent Non-locking Reads (MVCC)）<br/>总是使用<strong>最新快照</strong></td></tr><tr><td>可重复读<br/>（<code>REPEATABLE READ</code>）</td><td>×</td><td>×</td><td>×（<code>InnoDB</code> 特有）<br/>使用 gap lock 或 next-key lock</td><td>使用一致性非加锁读（Consistent Non-locking Reads (MVCC)）<br/>同一事务内总是使用<strong>首次快照</strong>，确保可重复读。</td></tr><tr><td>串行化<br/>（<code>SERIALIZABLE</code>）</td><td>×</td><td>×</td><td>×<br/>使用 gap lock 或 next-key lock</td><td>加共享锁读<br/>（S-Locking reads）</td></tr></tbody></table><h2 id="读未提交（READ-UNCOMMITTED）"><a href="#读未提交（READ-UNCOMMITTED）" class="headerlink" title="读未提交（READ UNCOMMITTED）"></a>读未提交（READ UNCOMMITTED）</h2><p>一个事务能够看到其它事务尚未提交的修改，这是最低的隔离水平，允许<strong>脏读</strong>出现。</p><p>这个级别会导致很多问题，从性能上来说，也不会比其它级别好太多，但却缺乏其它级别的很多好处，实际应用中很少使用。</p><h2 id="读已提交（READ-COMMITTED）"><a href="#读已提交（READ-COMMITTED）" class="headerlink" title="读已提交（READ COMMITTED）"></a>读已提交（READ COMMITTED）</h2><p>事务能够看到的数据都是其它事务已经提交的修改，也就是保证不会看到任何中间性状态，因此不会出现脏读问题。但读已提交仍然是比较低的隔离级别，并不保证再次读取时能够获取同样的数据，也就是允许其它事务并发修改数据，允许不可重复读和幻读出现。</p><blockquote><p>Tips: 事务隔离级别越高，就越能保证数据的<strong>完整性</strong>和<strong>一致性</strong>，但同时对并发性能的影响也越大。通常，对于绝大多数的应用程序来说，在非 MySQL 数据库的情况下，可以优先考虑将数据库系统的隔离级别设置为<strong>读已提交</strong>，这能够在避免起码的脏读的同时，保证较好的并发性能。尽管这种事务隔离级别会导致不可重复读、幻读，但较为科学的做法是在可能出现这类问题的个别场合中，由应用程序<strong>主动采取读锁或写锁</strong>来进行事务控制。</p></blockquote><p>MySQL 读已提交的默认行为如下：</p><ul><li><p>同一事务中的<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_consistent_read" target="_blank" rel="noopener">一致性读取（Consistent read）</a>总是会设置和读取自己的最新<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_snapshot" target="_blank" rel="noopener">快照（snapshot）</a>，因此会产生不可重复读问题，因为其它事务可能会并发修改数据。</p></li><li><p>对于加锁读、<code>UPDATE</code>、<code>DELETE</code> 语句，<code>InnoDB</code> 仅锁定匹配的索引记录。由于禁用了 gap lock，因此会产生幻读问题，因为其它事务可以在<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_gap" target="_blank" rel="noopener">间隙（gap）</a>中插入新行。</p><blockquote><p>gap:</p><p>A place in an <code>InnoDB</code> <strong>index</strong> data structure where new values could be inserted. When you lock a set of rows with a statement such as <code>SELECT ... FOR UPDATE</code>, <code>InnoDB</code> can create locks that apply to the gaps as well as the actual values in the index.</p></blockquote><blockquote><p>gap lock:</p><p>A <strong>lock</strong> on a <strong>gap</strong> between index records, or a lock on the gap before the first or after the last index record.</p></blockquote></li></ul><h2 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h2><p>这是 MySQL <code>InnoDB</code> 存储引擎<strong>默认的隔离级别</strong>。</p><ul><li><p>同一事务中的<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_consistent_read" target="_blank" rel="noopener">一致性读取（Consistent read）</a>总是会读取第一次读取时首次建立的<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_snapshot" target="_blank" rel="noopener">快照（snapshot）</a>。这意味着如果你在同一事务中发起多个普通（非加锁） <code>SELECT</code> 语句，其查询结果是相互一致的。一致性读取机制保证了同一事务中<strong>可重复读</strong>，避免了不可重复读问题，不管其它事务是否提交了 <code>INSERT</code>、<code>DELETE</code>、<code>UPDATE</code> 操作。如果想每次 <code>SELECT</code> 都返回最新快照，要么隔离级别降为 READ COMMITTED，要么使用加锁读。</p></li><li><p>对于加锁读、<code>UPDATE</code>、<code>DELETE</code> 语句，加锁行为取决于语句是使用具有唯一搜索条件的唯一索引还是范围搜索条件：</p><ul><li><p>对于具有唯一搜索条件的唯一索引， <code>InnoDB</code> 仅锁定匹配的索引记录。例如：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 T1 的 x-lock 会阻止其它事务加锁读或修改 id = 10 的记录</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">parent</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 事务 T2 无法修改 id = 10 的记录，直到事务 T1 结束</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">parent</span> <span class="keyword">SET</span> <span class="keyword">name</span> = <span class="string">'Pete'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>对于范围搜索条件，<code>InnoDB</code> 使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_gap_lock" target="_blank" rel="noopener">gap lock</a> 或 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_next_key_lock" target="_blank" rel="noopener">next-key lock</a> 锁定扫描到的索引范围， 以阻止其它会话插入被范围所覆盖的<a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_gap" target="_blank" rel="noopener">间隙</a>。这是 <code>InnoDB</code> 和其它一些数据库实现的不同，解决了可重复读级别下的幻读问题。例如：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务 T1 的 gap lock 会阻止其它事务插入 id &gt; 10 的记录</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">parent</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> &gt; <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="comment">-- 事务 T2 无法插入 id &gt; 10 的新记录，直到事务 T1 结束</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">parent</span>(<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">VALUES</span>(<span class="number">11</span>, <span class="string">'Pete'</span>);</span><br><span class="line"><span class="comment">-- 事务 T2 可以插入 id &lt;= 9 的新记录，无需等待事务 T1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">parent</span>(<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">VALUES</span>(<span class="number">9</span>, <span class="string">'Pete'</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="串行化（SERIALIZABLE）"><a href="#串行化（SERIALIZABLE）" class="headerlink" title="串行化（SERIALIZABLE）"></a>串行化（SERIALIZABLE）</h2><p>并发事务之间的读写操作是串行化的，通常意味着读取需要获取共享锁（读锁），更新需要获取排他锁（写锁），如果 SQL 使用 <code>WHERE</code> 语句，还会获取 gap lock 和 next-key lock，可能导致大量的超时和锁争用的问题。</p><p>这是最高的隔离级别，实际应用中很少使用，只有在非常需要确保数据一致性而且可以接受没有并发的情况下，才会考虑。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高性能 MySQL》</p><p><a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels</a></p><p><a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Dirty_reads" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Isolation_(database_systems)#Dirty_reads</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_read" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_dirty_read</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_non_repeatable_read" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_non_repeatable_read</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_phantom" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_phantom</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-acid.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/mysql-acid.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-transaction-model.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 死锁问题分析总结</title>
      <link href="2019/02/25/mysql-deadlock/"/>
      <url>2019/02/25/mysql-deadlock/</url>
      
        <content type="html"><![CDATA[<p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</p><p>为了解决这种问题，数据库系统实现了各种<strong>死锁检测</strong>和<strong>死锁超时</strong>机制。越复杂的系统，比如 <code>InnoDB</code> 存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有效，否则死锁会导致出现非常慢的查询。还有一种解决方式，就是当查询的时间达到锁等待超时的设定后放弃锁请求，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1205 - <span class="keyword">Lock</span> <span class="keyword">wait</span> <span class="keyword">timeout</span> exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><p><code>InnoDB</code> 目前处理死锁的方法是，<strong>将持有最少行级排它锁的事务进行回滚</strong>，这是相对比较简单的死锁回滚算法。</p><p>锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁的产生有双重原因：</p><ol><li>有些是因为真正的数据冲突，这种情况通常很难避免。</li><li>有些则完全是由于存储引擎的实现方式导致的。</li></ol><p><strong>死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。</strong>对于事务型的系统，这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。</p><p>同时，为了避免产生死锁问题，根源在于程序设计时要注意不同事务间 SQL 语句的执行顺序，避免互相锁住对方的资源。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-deadlocks.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 锁粒度与索引总结</title>
      <link href="2019/02/22/mysql-locking-and-index/"/>
      <url>2019/02/22/mysql-locking-and-index/</url>
      
        <content type="html"><![CDATA[<h1 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h1><p>所谓的锁粒度，就是在<strong>锁的开销</strong>和<strong>数据的安全性</strong>之间寻求平衡，这种平衡当然也会影响到性能：</p><blockquote><p>一种提高共享资源并发性的方式就是让锁定对象更有<strong>选择性</strong>。尽量只锁定需要修改的部分数据，而不是所有资源。更理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。</p><p>问题是加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。如果系统花费大量的时间来管理锁，而不是存取数据，那么系统的性能可能会因此受到影响。</p></blockquote><p><code>InnoDB</code> 存储引擎目前有以下两种锁粒度：</p><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>表锁（Table Lock）是 MySQL 中最基本的锁粒度，并且是开销最小的粒度。<code>MyISAM</code> 存储引擎仅支持表锁。</p><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>行锁（Row Lock）可以最大程度的支持并发处理，同时也带来了最大的锁开销。行锁只在存储引擎层实现，而不在 MySQL 服务器层。<code>InnoDB</code> 存储引擎支持行锁级别。</p><h1 id="锁粒度与索引的关系"><a href="#锁粒度与索引的关系" class="headerlink" title="锁粒度与索引的关系"></a>锁粒度与索引的关系</h1><p>以一个例子总结锁粒度与索引的关系：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`child`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`parent_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_parent_id`</span> (<span class="string">`parent_id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>1、<code>InnoDB</code> 行锁是通过<strong>给索引上的索引项加锁</strong>来实现的，只有通过索引条件检索数据，<code>InnoDB</code> 才使用行锁，否则，<code>InnoDB</code> 将使用表锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--开启事务 T1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看执行计划，全表扫描（type=ALL）</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'D'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | child | ALL  | NULL          | NULL | NULL    | NULL |    5 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--执行查询，加表锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'D'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">+<span class="comment">----+-----------+------+</span></span><br><span class="line">| id | parent_id | name |</span><br><span class="line">+<span class="comment">----+-----------+------+</span></span><br><span class="line">|  4 |         3 | D    |</span><br><span class="line">+<span class="comment">----+-----------+------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--开启事务 T2</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看执行计划，命中索引 idx_parent_id</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> parent_id = <span class="number">4</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+---------------+---------+-------+------+-------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+---------------+---------+-------+------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | child | ref  | idx_parent_id | idx_parent_id | 8       | const |    1 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+---------------+---------+-------+------+-------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--执行查询，由于事务 T1 加了表锁，事务 T2 对 parent_id = 4 索引项的行锁被阻塞，一直等待</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> parent_id = <span class="number">4</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>2、由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是<strong>使用相同的索引键，是会出现锁冲突的</strong>。应用设计的时候要注意这一点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--开启事务 T1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看执行计划，命中索引 idx_parent_id</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> parent_id = <span class="number">2</span> <span class="keyword">AND</span> <span class="keyword">name</span> = <span class="string">'A'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | child | ref  | idx_parent_id | idx_parent_id | 8       | const |    2 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--执行查询</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> parent_id = <span class="number">2</span> <span class="keyword">AND</span> <span class="keyword">name</span> = <span class="string">'A'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">+<span class="comment">----+-----------+------+</span></span><br><span class="line">| id | parent_id | name |</span><br><span class="line">+<span class="comment">----+-----------+------+</span></span><br><span class="line">|  1 |         2 | A    |</span><br><span class="line">+<span class="comment">----+-----------+------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--开启事务 T2</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看执行计划，命中索引 idx_parent_id</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> parent_id = <span class="number">2</span> <span class="keyword">AND</span> <span class="keyword">name</span> = <span class="string">'C'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | child | ref  | idx_parent_id | idx_parent_id | 8       | const |    2 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行查询，虽然 T1、T2 访问不同行的记录，但由于使用了相同的索引键 parent_id = 2，出现锁冲突，从而阻塞，一直等待</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> parent_id = <span class="number">2</span> <span class="keyword">AND</span> <span class="keyword">name</span> = <span class="string">'C'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>3、当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，<code>InnoDB</code> 都会使用<strong>行锁</strong>来对数据加锁。</p><p>4、即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 <code>InnoDB</code> 将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查 SQL 的执行计划，以确认是否真正使用了索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--开启事务 T1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看执行计划，虽然使用了索引 idx_parent_id，但 MySQL 认为全表扫描效率更高，因此实际上没有使用索引</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> parent_id = <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | child | ALL  | idx_parent_id | NULL | NULL    | NULL |    5 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--虽然使用了索引 idx_parent_id，但由于进行了全表扫描，因此实际使用表锁</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> parent_id = <span class="number">2</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">+<span class="comment">----+-----------+------+</span></span><br><span class="line">| id | parent_id | name |</span><br><span class="line">+<span class="comment">----+-----------+------+</span></span><br><span class="line">|  1 |         2 | A    |</span><br><span class="line">|  2 |         2 | C    |</span><br><span class="line">|  3 |         2 | C    |</span><br><span class="line">+<span class="comment">----+-----------+------+</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--开启事务 T2</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--执行查询，由于事务 T1 加了表锁，事务 T2 对 parent_id = 4 索引项的行锁被阻塞，一直等待</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">child</span> <span class="keyword">WHERE</span> parent_id = <span class="number">4</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高性能 MySQL》</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 加锁读（Locking Reads）机制总结</title>
      <link href="2019/02/20/mysql-locking-read/"/>
      <url>2019/02/20/mysql-locking-read/</url>
      
        <content type="html"><![CDATA[<p>MySQL 支持两种读机制：</p><ul><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener">一致性非加锁读（Consistent Non-locking Reads）</a>，是 InnoDB 在 <code>RR</code> 隔离级别下处理 SELECT 查询语句的默认模式，用于实现多版本并发控制（MVCC）以解决不可重复读问题。由于无锁，并发性能高。</li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="noopener">加锁读（Locking Reads）</a>，是 InnoDB 在 <code>SERIALIZABLE</code>  隔离级别下处理 SELECT 查询语句的默认模式，查询默认加共享锁读（S-Locking reads）。由于有锁，并发性能低（因为获取写锁需阻塞等待读锁释放）。</li></ul><h1 id="加锁读机制"><a href="#加锁读机制" class="headerlink" title="加锁读机制"></a>加锁读机制</h1><p><code>InnoDB</code> 支持两种类型的 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking_read" target="_blank" rel="noopener">加锁读（Locking Reads）</a>，为事务操作提供额外的<strong>安全性</strong>：</p><ul><li><a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_shared_lock" target="_blank" rel="noopener">共享锁（Shared Lock, S-Lock）</a>，也叫读锁（Read Lock）<ul><li>语法：<code>SELECT ... LOCK IN SHARE MODE</code> or <code>SELECT ... FOR SHARE</code> in MySQL 8.0.1，在检索行上设置共享锁（s-lock）</li><li>其它事务允许读取检索行，但不允许更新或删除，更新或删除会一直阻塞等待，直到该事务结束。</li></ul></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_exclusive_lock" target="_blank" rel="noopener">排它锁（Exclusive Lock, X-Lock）</a>，也叫写锁（Write Lock）<ul><li>语法：<code>SELECT ... FOR UPDATE</code> 在检索行上设置排它锁（x-lock）</li><li>其它事务不允许更新或删除</li><li>不允许加共享锁读取 <code>SELECT ... LOCK IN SHARE MODE</code></li><li>如果事务隔离级别为 <code>SERIALIZABLE</code>，不允许读取（因为该级别的读取默认需要获得共享读锁）</li><li>上述操作将一直阻塞等待，直到该事务结束。</li></ul></li></ul><p>共享锁和排它锁之间存在冲突的四种情况总结如下：</p><table><thead><tr><th></th><th>T1 持有共享锁（S-Lock）</th><th>T1 持有排它锁（X-Lock）</th></tr></thead><tbody><tr><td><strong>T2 获取共享锁（S-Lock）</strong></td><td>兼容</td><td>冲突</td></tr><tr><td><strong>T2 获取排它锁（X-Lock）</strong></td><td>冲突</td><td>冲突</td></tr></tbody></table><p>下面进一步分析共享锁和排它锁：</p><h2 id="共享锁（读锁）"><a href="#共享锁（读锁）" class="headerlink" title="共享锁（读锁）"></a>共享锁（读锁）</h2><p>共享锁是共享性的，或者说是相互不阻塞的。持有该锁的多个事务允许同时读取同一个资源，而互不干扰。</p><p>举个例子，如果事务 <code>T1</code> 持有对行 <code>r</code> 的共享锁，那么来自另一个事务 <code>T2</code> 的锁请求，将按如下两种方式处理：</p><ul><li><code>T2</code> 的共享锁请求能够立即授予。其结果是，<code>T1</code> 和 <code>T2</code> 都持有对行 <code>r</code> 的共享锁。</li><li><code>T2</code> 的排它锁请求不被授予。</li></ul><h2 id="排它锁（写锁）"><a href="#排它锁（写锁）" class="headerlink" title="排它锁（写锁）"></a>排它锁（写锁）</h2><p>排它锁是排它性的，也就是说一个排它锁会阻塞其它的共享锁和排它锁，这是出于安全策略的考虑，只有这样，才能确保在给定的时间里，有且只有一个持有该锁的事务执行更新或删除操作，并防止其它事务读取正在操作的同一资源。</p><p>举个例子，如果事务 <code>T1</code> 持有对行 <code>r</code> 的排它锁，那么来自另一个事务 <code>T2</code> 的<strong>任一锁请求都不被授予</strong>。相反，事务 <code>T2</code> 必须等待事务 <code>T1</code> 直到其释放对行 <code>r</code> 的锁定。</p><h1 id="锁定方式"><a href="#锁定方式" class="headerlink" title="锁定方式"></a>锁定方式</h1><p>大多数时候，MySQL 锁的内部管理都是透明的，其表现如下：</p><ul><li><code>SELECT</code> 在 <code>InnoDB</code> 的读已提交（READ COMMITTED）、可重复读（REPEATABLE READ）这两种事务隔离级别下，默认采用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener">一致性非加锁读取</a>，因此<strong>无需加锁即可读取所需数据</strong>。</li><li>如果需要使用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="noopener">加锁读</a>提升数据安全性，实现悲观并发控制，可采用共享锁（<code>LOCK IN SHARE MODE</code>）或排它锁（<code>FOR UDPATE</code>）进行显式锁定。</li><li><code>UPDATE</code>、<code>DELETE</code> 默认采用排它锁，隐式锁定。</li></ul><p>总结如下：</p><table><thead><tr><th>语句</th><th>锁的类型</th><th>锁定方式</th></tr></thead><tbody><tr><td><code>SELECT ... FROM</code></td><td>如果事务隔离为 SERIALIZABLE，使用共享锁。否则无锁。</td><td>隐式锁定</td></tr><tr><td><code>SELECT ... LOCK IN SHARE MODE</code></td><td>共享锁（shared next-key lock）</td><td>显式锁定</td></tr><tr><td><code>SELECT ... FOR UDPATE</code></td><td>排它锁（exclusive next-key lock）</td><td>显式锁定</td></tr><tr><td><code>UPDATE ... WHERE ...</code></td><td>排它锁（exclusive next-key lock）</td><td>隐式锁定</td></tr><tr><td><code>DELETE FROM ... WHERE ...</code></td><td>排它锁（exclusive next-key lock）</td><td>隐式锁定</td></tr><tr><td><code>INSERT</code></td><td>排它锁（exclusive index-record lock）</td><td>隐式锁定</td></tr></tbody></table><h2 id="隐式锁定"><a href="#隐式锁定" class="headerlink" title="隐式锁定"></a>隐式锁定</h2><p><code>InnoDB</code> 采用的是两阶段锁定协议（Two-phase locking protocol）。在事务执行过程中，随时都可以执行锁定，锁只有在执行 <code>COMMIT</code> 或者 <code>ROLLBACK</code> 的时候才会释放，并且所有的锁是在同一时刻被释放。<code>InnoDB</code> 会根据隔离级别在需要的时候自动加锁，例如下列操作：</p><ul><li><code>UPDATE</code>、<code>DELETE</code> </li></ul><h2 id="显式锁定"><a href="#显式锁定" class="headerlink" title="显式锁定"></a>显式锁定</h2><p><code>InnoDB</code> 也支持通过特定语句进行显式锁定，这些语句不属于 SQL 规范：</p><ul><li><code>SELECT ... LOCK IN SHARE MODE</code>（共享锁）</li><li><code>SELECT ... FOR UDPATE</code>（排它锁）</li></ul><p>MySQL 也支持 <code>LOCK TABLES</code> 和 <code>UNLOCK TABLE</code> 语句，这是在服务器层实现的，和存储引擎无关。它们有自己的用途，但并不能替代事务。如果应用需要用到事务，还是应该选择事务型存储引擎。</p><p>经常可以发现，应用已经将表从 <code>MyISAM</code> 转换到 <code>InnoDB</code>，但还是显示地使用 <code>LOCK TABLE</code> 语句。这不但没有必要，还会严重影响性能，实际上 <code>InnoDB</code> 的行级锁工作得更好。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>这里举个例子，有一张 parent 和 child 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- parnet 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`parent`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- child 表，其中 parent_id 字段外键关联 parent 表的 id 主键</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`child`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`parent_id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`fk_parent_id`</span> (<span class="string">`parent_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`fk_parent_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`parent_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`parent`</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><p>如果在同一事务中先查询、后插入或更新相关数据，常规的 <code>SELECT</code> 语句无法得到足够保护。因为在此期间其它事务可能对同一资源进行更新或删除。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--开启事务 T1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">--为变量@id赋值</span></span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">id</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">id</span>:=<span class="keyword">id</span> <span class="keyword">FROM</span> <span class="keyword">parent</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Heikki'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--在此期间，某个事务 T2 成功删除了同一资源</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">parent</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Heikki'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--事务 T1 插入失败：外键关联错误</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">child</span>(parend_id, <span class="keyword">name</span>) <span class="keyword">VALUES</span>(@<span class="keyword">id</span>, <span class="string">'Baby'</span>);</span><br><span class="line">1452 - Cannot add or <span class="keyword">update</span> a <span class="keyword">child</span> <span class="keyword">row</span>: a <span class="keyword">foreign</span> <span class="keyword">key</span> <span class="keyword">constraint</span> fails (<span class="string">`test`</span>.<span class="string">`child`</span>, <span class="keyword">CONSTRAINT</span> <span class="string">`fk_parent_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`parent_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`parent`</span> (<span class="string">`id`</span>))</span><br></pre></td></tr></table></figure><p>下面分别看下如何用共享锁和排它锁解决这个问题：</p><h2 id="LOCK-IN-SHARE-MODE"><a href="#LOCK-IN-SHARE-MODE" class="headerlink" title="LOCK IN SHARE MODE"></a>LOCK IN SHARE MODE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--开启事务 T1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> parent_id = <span class="number">2</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | parent_id | name  |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 |         2 | Baby  |</span><br><span class="line">|  2 |         2 | Baby5 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--在此期间，某个事务 T2 能够成功删除同一资源</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line"></span><br><span class="line"><span class="comment">--事务 T1 如果继续使用一致性非加锁读，将会得到第一次读取时的快照，因为 InnoDB 当前隔离级别为 RR</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> parent_id = <span class="number">2</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | parent_id | name  |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  1 |         2 | Baby  |</span><br><span class="line">|  2 |         2 | Baby5 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--事务 T1 如果使用加锁读，将会得到最新快照。同时事务 T1 获取该行的共享锁，其它任何事务都只能读、不能写该行，直到事务 T1 结束，释放共享锁</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> parent_id = <span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">| id | parent_id | name  |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">|  2 |         2 | Baby5 |</span><br><span class="line">+<span class="comment">----+-----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--在此期间，事务 T3 可以删除未被锁定的行</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line">Query OK, 1 row affected</span><br><span class="line"></span><br><span class="line"><span class="comment">--在此期间，事务 T3 无法删除带锁的行。因为它无法获取该行的排它锁，因此会阻塞直到事务 T1 解锁该行。如果等待超时，则事务回滚</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span></span><br><span class="line"><span class="number">1205</span> - <span class="keyword">Lock</span> <span class="keyword">wait</span> <span class="keyword">timeout</span> exceeded; try restarting transaction</span><br><span class="line"></span><br><span class="line"><span class="comment">--事务 T1 提交，释放共享锁</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--事务 T3 如果没有超时，则操作成功</span></span><br><span class="line">Query OK, 1 row affected</span><br></pre></td></tr></table></figure><h2 id="FOR-UPDATE"><a href="#FOR-UPDATE" class="headerlink" title="FOR UPDATE"></a>FOR UPDATE</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--开启事务 T1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">--事务 T1 获取该行的排它锁</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> parent_id = <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--在此期间，事务 T2 可以非加锁读，因为无需先获取该行的锁</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> parent_id = <span class="number">2</span>;</span><br><span class="line"><span class="comment">--也可以加共享锁读非锁定行</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> parent_id = <span class="number">3</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="comment">--但无法加共享锁读锁定行</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">child</span> <span class="keyword">where</span> parent_id = <span class="number">2</span> <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="comment">--也无法获取排它锁进行修改</span></span><br><span class="line"><span class="keyword">update</span> <span class="keyword">child</span> <span class="keyword">set</span> <span class="keyword">name</span> = <span class="string">'Hello'</span> <span class="keyword">where</span> parent_id = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>————分割线————</p><p>可见，通过共享锁和排它锁都能解决这个问题。下例演示通过 <code>SELECT ... LOCK IN SHARE MODE</code> 设置共享锁解决开头那个问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--开启事务 T1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="comment">--为变量@id赋值</span></span><br><span class="line"><span class="keyword">set</span> @<span class="keyword">id</span>=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="keyword">id</span>:=<span class="keyword">id</span> <span class="keyword">FROM</span> <span class="keyword">parent</span> <span class="keyword">WHERE</span> <span class="keyword">NAME</span> = <span class="string">'Heikki'</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--在此期间，某个事务 T2 无法删除同一资源。因为 T2 会一直等待，直到 T1 事务完成，所有数据都处于一致状态，并释放共享锁之后，T2 才能获取排它锁，并对数据进行修改</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">parent</span> <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Heikki'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--事务 T1 插入成功</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">child</span>(parend_id, <span class="keyword">name</span>) <span class="keyword">VALUES</span>(@<span class="keyword">id</span>, <span class="string">'Baby'</span>);</span><br><span class="line"><span class="comment">--提交事务 T1，写库</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>在 <code>T1</code> 成功提交事务并释放共享锁之后，<code>T2</code> 获得排它锁。但由于 <code>T1</code> 在 <code>child</code> 表中写入了一条对 <code>parent</code> 表的外键关联记录，所以 <code>T2</code> 删除失败：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1451 - Cannot <span class="keyword">delete</span> <span class="keyword">or</span> <span class="keyword">update</span> a <span class="keyword">parent</span> <span class="keyword">row</span>: a <span class="keyword">foreign</span> <span class="keyword">key</span> <span class="keyword">constraint</span> fails (<span class="string">`test`</span>.<span class="string">`child`</span>, <span class="keyword">CONSTRAINT</span> <span class="string">`fk_parent_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`parent_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`parent`</span> (<span class="string">`id`</span>))</span><br></pre></td></tr></table></figure><p>最后，提几个注意点：</p><ul><li>只有在通过以下方式之一禁用<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-autocommit-commit-rollback.html" target="_blank" rel="noopener">自动提交（autocommit）</a>时，才能加锁读：<ul><li>通过 <a href="https://dev.mysql.com/doc/refman/5.7/en/commit.html" target="_blank" rel="noopener"><code>START TRANSACTION</code></a> 语句，显式开启事务；</li><li>通过设置 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_autocommit" target="_blank" rel="noopener"><code>autocommit</code></a>为 <code>0</code>，显式关闭自动提交。</li></ul></li><li>加锁读有可能产生<strong>死锁</strong>，具体取决于事务的隔离级别。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《高性能 MySQL》</p><p><a href="https://en.wikipedia.org/wiki/Two-phase_locking" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Two-phase_locking</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html</a></p><p><a href="https://blog.csdn.net/claram/article/details/54023216" target="_blank" rel="noopener">https://blog.csdn.net/claram/article/details/54023216</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程系列（一）两种并发控制机制的总结</title>
      <link href="2019/02/18/concurrency-control/"/>
      <url>2019/02/18/concurrency-control/</url>
      
        <content type="html"><![CDATA[<h1 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h1><p>计算机领域中，并发控制（Concurrency Control）是一种机制，它确保并发操作可以产生正确结果。</p><p>有两种常用的并发控制机制：</p><ul><li>乐观并发控制（Optimistic Concurrency Control, OCC），又称为乐观锁（Optimistic Lock），最早是由孔祥重（H.T.Kung）教授提出的。</li><li>悲观并发控制（Pessimistic Concurrency Control, PCC），又称为悲观锁（Pessimistic Lock）。</li></ul><p>这两种机制或者锁并不是 MySQL 或者数据库中独有的概念，而是并发编程的基本概念。</p><h2 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h2><ul><li><p>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，没有才能更新成功。</p></li><li><p>适用场景：</p><ul><li>它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理<strong>各自影响的那部分数据</strong>。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其它事务又修改了该数据。如果其它事务有更新的话，正在提交的事务会进行<strong>回滚</strong>。因此乐观并发控制多数用于数据争用不大、冲突较少的环境中。这种环境中，偶尔回滚事务的成本会低于读取数据时锁定数据的成本，因此可以获得比其它并发控制方法更高的吞吐量。</li></ul></li><li><p>实现方式：</p><ul><li><p>MVCC 多版本并发控制。</p></li><li><p>CAS（Compare And Set）：实现思路是在 <code>set</code> 的时候，加上初始状态的 <code>compare</code> 条件判断，只有初始状态不变时，才 <code>set</code> 成功。为了避免 ABA 问题（例如 CAS 过程中只简单进行“值”的校验，在有些情况下，“值”相同不会引入错误的业务逻辑（例如余额），但有些情况下，“值”虽然相同，却已经不是原来的数据了），CAS 不能只比对“值”，还<strong>必须确保数据是原来的数据</strong>，才能修改成功。实现方式是采用“数据版本”机制，例如通过版本号（version）、时间戳（update_time），来做乐观锁的判断条件，一个数据一个版本，版本变化，即使值相同，也不应该修改成功。</p><ul><li><p>例如，使用 Java 原子类 <code>AtomicStampedReference</code> 进行值与版本号的双重校验，而不是 <code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code>、<code>AtomicReference</code> 等等只基于值的校验。</p></li><li><p>例如，MySQL：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table_name WHERE condition&#x3D;#condition#;</span><br><span class="line">UPDATE table_name SET name&#x3D;#name#, version&#x3D;version+1 WHERE version&#x3D;#version#；</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="悲观并发控制"><a href="#悲观并发控制" class="headerlink" title="悲观并发控制"></a>悲观并发控制</h2><ul><li><p>顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，直到使用完毕才会解锁，这样别人想拿这个数据就会 block 住直到它拿到锁。</p></li><li><p>适用场景：</p><ul><li>悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。悲观锁大多数情况下依靠数据库的<strong>锁机制</strong>实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，由于会阻塞其它事务导致其一直等待，<strong>降低整体吞吐量</strong>，这样的开销往往无法承受。而乐观锁机制则避免了长事务中的数据库开销。</li></ul></li></ul><ul><li>使用场景：</li></ul><h3 id="原子性操作"><a href="#原子性操作" class="headerlink" title="原子性操作"></a>原子性操作</h3><p>集群部署环境下，面对并发请求，我们常常使用“一锁二判三更新”这套常规操作，其中第一步加锁是为了确保后两步操作的原子性，实现串行化访问临界资源，即同一时刻只能有一个线程独占性的访问临界资源（同步互斥访问），确保并发情况下临界资源的线程安全。</p><p>下面提供两种实现方案：</p><p>方案一 使用数据库行锁</p><ul><li>MySQL：在同一事务中先对资源加<strong>排它锁（写锁）</strong>，阻塞其它事务对同一资源的读写访问，然后在事务内进行代码判断以及资源更新提交，实现串行化访问资源：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 共享锁（读锁）</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;</span><br><span class="line"><span class="comment">-- 排它锁（写锁）</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure></li></ul><p>方案二 使用其它分布式锁，节约数据库资源（<strong>推荐方案</strong>）</p><ul><li><p>Redis：<code>SETNX</code> 互斥锁（mutex key）实现分布式锁，使用时注意设置锁的过期时间避免锁死，然后后台线程设置锁续命，解锁时只能由集群内同机器操作。</p></li><li><p>Zookeeper：使用命令 <code>create -e -s</code> 创建临时+序号（<code>EPHEMERAL_SEQUENTIAL</code>）节点。</p></li></ul><h1 id="MySQL-的并发控制"><a href="#MySQL-的并发控制" class="headerlink" title="MySQL 的并发控制"></a>MySQL 的并发控制</h1><p><img src="/img/mysql/concurrency_control.png" alt="并发控制总结"></p><p>MySQL <code>InnoDB</code> 存储引擎中，悲观<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html" target="_blank" rel="noopener">锁的类型</a>还有很多种：</p><ul><li>Shared and Exclusive Locks（共享锁和排它锁）</li><li>Intention Locks（意向锁）</li><li>Record Locks（记录锁）</li><li>Gap Locks（区间锁）</li><li>Next-Key Locks</li><li>Insert Intention Locks（插入意向锁）</li><li>AUTO-INC Locks（自增锁）</li><li>Predicate Locks for Spatial Indexes（空间索引谓词锁）</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>这里举一个抽奖活动的例子，分别展示乐观锁和悲观锁的两种实现流程：</p><p><img src="/img/mysql/example_of_concurrency_control.jpg" alt="抽奖活动例子"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Concurrency_control" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Concurrency_control</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html</a></p><p><a href="https://segmentfault.com/a/1190000011200547" target="_blank" rel="noopener">《支付宝防并发方案之”一锁二判三更新”》</a></p><p>《高性能 MySQL》</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 字符集与排序规则总结</title>
      <link href="2019/01/03/mysql-charset/"/>
      <url>2019/01/03/mysql-charset/</url>
      
        <content type="html"><![CDATA[<p>查看数据库支持的字符集：<code>SHOW CHARACTER SET</code></p><p>查看数据库支持的排序规则：<code>SHOW COLLATION</code></p><h1 id="字符集（Character-Sets）"><a href="#字符集（Character-Sets）" class="headerlink" title="字符集（Character Sets）"></a>字符集（Character Sets）</h1><p>下表是 MySQL 中八个可能影响到字符集的系统变量，其中有几个如果配置不当可能会乱码问题，需重点关注：</p><table><thead><tr><th>变量</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td><code>character_set_client</code></td><td><code>utf8</code></td><td>The character set for statements that arrive from the client.</td></tr><tr><td><code>character_set_connection</code></td><td><code>utf8</code></td><td>The character set used for literals specified without a character set introducer and for number-to-string conversion.</td></tr><tr><td><code>character_set_database</code></td><td><code>latin1</code></td><td>The character set used by the default database.</td></tr><tr><td><code>character_set_filesystem</code></td><td><code>binary</code></td><td>The file system character set.</td></tr><tr><td><code>character_set_results</code></td><td><code>utf8</code></td><td>The character set used for returning query results to the client. This includes result data such as column values, result metadata such as column names, and error messages.</td></tr><tr><td><code>character_set_server</code></td><td><code>latin1</code></td><td>The server’s default character set.</td></tr><tr><td><code>character_set_system</code></td><td><code>utf8</code></td><td>The character set used by the server for storing identifiers.</td></tr><tr><td><code>character_sets_dir</code></td><td></td><td>The directory where character sets are installed.</td></tr></tbody></table><p>可以通过下图来了解 MySQL 内部字符集转换过程：</p><p><img src="/img/mysql/mysql_character_set.jpg" alt="MySQL Character Set"></p><ol><li>MySQL 收到请求时将请求数据从 <code>character_set_client</code> 转换为 <code>character_set_connection</code></li><li>进行内部操作前将请求数据从 <code>character_set_connection</code> 转换为内部操作字符集，步骤如下：<ol><li>使用每个数据字段的 <code>CHARACTER SET</code> 设定值；</li><li>若上述值不存在，则使用对应数据表的字符集设定值；</li><li>若上述值不存在，则使用对应数据库的字符集设定值；</li><li>若上述值不存在，则使用 <code>character_set_server</code> 设定值。</li></ol></li><li>最后将操作结果从内部操作字符集转换为 <code>character_set_results</code></li></ol><p>而系统变量 <code>character_set_database</code> 主要用来设置默认创建数据库的编码格式，如果在创建数据库时没有设置编码格式，就按照这个格式设置，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`testdb`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET latin1 */</span></span><br></pre></td></tr></table></figure><p>从而影响到建表时默认的字符集：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test`</span> (</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=latin1;</span><br></pre></td></tr></table></figure><p>从而影响到中文字符的插入：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">test</span> <span class="keyword">values</span> (<span class="string">'你好'</span>);</span><br><span class="line"></span><br><span class="line">[Err] 1366 - Incorrect string value: '\xE4\xBD\xA0\xE5\xA5\xBD' for column 'name' at row 1</span><br></pre></td></tr></table></figure><h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># 影响系统变量 character_set_database 和 character_set_server</span><br><span class="line">character-set-server &#x3D; utf8</span><br><span class="line">collation-server &#x3D; utf8_unicode_ci</span><br><span class="line">init-connect &#x3D; &#39;SET NAMES utf8&#39;</span><br><span class="line"></span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine&#x3D;INNODB</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set &#x3D; utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set &#x3D; utf8</span><br></pre></td></tr></table></figure><p>配置后，需要重启服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql</span><br><span class="line">net start mysql</span><br></pre></td></tr></table></figure><p>之后，通过命令 <code>SHOW VARIABLES LIKE &#39;%character%&#39;</code> 查看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------+----------+</span><br><span class="line">| Variable_name            | Value    |</span><br><span class="line">+--------------------------+----------+</span><br><span class="line">| character_set_client     | utf8     |</span><br><span class="line">| character_set_connection | utf8     |</span><br><span class="line">| character_set_database   | utf8     |</span><br><span class="line">| character_set_filesystem | binary   |</span><br><span class="line">| character_set_results    | utf8     |</span><br><span class="line">| character_set_server     | utf8     |</span><br><span class="line">| character_set_system     | utf8     |</span><br><span class="line">| character_sets_dir       | ...      |</span><br><span class="line">+--------------------------+----------+</span><br></pre></td></tr></table></figure><p>如果在创建数据库之前，没有在配置文件中配置好默认字符集，可以通过 <code>SET</code> 命令进行修改。</p><p>配置好后，建库结果如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`testdb`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8 COLLATE utf8_unicode_ci */</span></span><br></pre></td></tr></table></figure><h1 id="排序规则（Collations）"><a href="#排序规则（Collations）" class="headerlink" title="排序规则（Collations）"></a>排序规则（Collations）</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/charset.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/charset.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html</a></p><p><img src="/img/mysql/charset.png" alt="charset"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射篇（四）动态代理之 JDK Proxy 总结</title>
      <link href="2018/12/01/java-jdk-proxy/"/>
      <url>2018/12/01/java-jdk-proxy/</url>
      
        <content type="html"><![CDATA[<p>什么是代理？</p><blockquote><p>代理对象 = 增强代码 + 目标对象</p></blockquote><p><img src="/img/java/proxy/Proxy.png" alt="proxy"></p><p>有哪些代理方式？</p><ul><li>静态代理</li><li>动态代理</li></ul><p>什么是动态代理？</p><blockquote><p>动态代理是一种在<strong>运行时</strong>动态生成代理的机制。这个概念是与静态代理相对的，静态代理需要为每一个目标类都手工编写或用工具生成一个对应的代理类，非常繁琐。</p></blockquote><p>动态代理的实现方式？</p><blockquote><p>动态代理的实现方式有很多种，比如：</p><ul><li><p>利用 JDK 自身提供的动态代理 API（<code>java.lang.reflect</code>）</p></li><li><p>或者利用性能更高的第三方字节码生成框架（例如 ASM、cglib（基于 ASM）、Javassist 等）</p></li></ul><p>最终目标都是生成一个代理类的字节码。</p></blockquote><p>哪些场景用到动态代理？</p><blockquote><p>比如：</p><p>包装 RPC 调用、…</p><p>面向切面的编程（AOP）</p><p><img src="/img/spring/aop/aop_lib.png" alt=""></p></blockquote><p>动态代理从代理对象创建到方法执行的整体流程如下：</p><p><img src="/img/java/proxy/jdk_proxy_process.png" alt="jdk_proxy_process"></p><p>下面来看下 JDK 自身提供的动态代理，底层是如何实现的。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>来个例子，实现如图效果：</p><p><img src="/img/java/proxy/jdk_proxy_example.png" alt="jdk_proxy_process2"></p><p>首先创建接口 <code>Flyable</code> 和目标类 <code>Bird</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标类和代理类共同实现的接口</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String param)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"Target bird fly, param = &#123;&#125;"</span>, param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是关键的一步，实现 <code>InvocationHandler</code> 接口，创建代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Flyable target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// proxy 参数表示动态生成的 Proxy 类 通过反射创建出来的对象</span></span><br><span class="line">    <span class="comment">// method 参数表示 proxy 对象本次执行的方法，可以判断该参数动态决定执行对应的业务逻辑</span></span><br><span class="line">    <span class="comment">// args 参数表示 proxy 对方本次执行的方法参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 在目标对象执行前执行代码</span></span><br><span class="line">        log.info(<span class="string">"Before target bird method: &#123;&#125;"</span>, method.getName());</span><br><span class="line">        <span class="comment">// 在目标对象上执行指定方法</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 在目标对象执行后执行代码</span></span><br><span class="line">        log.info(<span class="string">"After target bird method: &#123;&#125;"</span>, method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Flyable <span class="title">newProxy</span><span class="params">(Flyable target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方式一：显式使用反射创建代理对象（先获取 com.sun.proxy.$Proxy0 的 Class 对象）</span></span><br><span class="line">        <span class="comment">// Class&lt;?&gt; proxyClass = Proxy.getProxyClass(Flyable.class.getClassLoader(), target.getClass().getInterfaces());</span></span><br><span class="line">        <span class="comment">// Constructor&lt;?&gt; constructor = proxyClass.getConstructor(InvocationHandler.class);</span></span><br><span class="line">        <span class="comment">// return (Flyable) constructor.newInstance(new BirdProxy(target));</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式二：隐式使用反射创建代理对象，API 更简单</span></span><br><span class="line">        <span class="keyword">return</span> (Flyable) Proxy.newProxyInstance(Flyable<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(), <span class="title">target</span>.<span class="title">getClass</span>().<span class="title">getInterfaces</span>(), <span class="title">new</span> <span class="title">BirdProxy</span>(<span class="title">target</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建目标对象</span></span><br><span class="line">        Bird target = <span class="keyword">new</span> Bird();</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        Flyable proxy = BirdProxy.newProxy(target);</span><br><span class="line">        <span class="comment">// 调用任意方法，将执行代理逻辑</span></span><br><span class="line">        proxy.fly(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before target bird method: fly</span><br><span class="line">Target bird fly, param = hello world</span><br><span class="line">After target bird method: fly</span><br></pre></td></tr></table></figure><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>例子中涉及到两个 API，由 Java 1.3 引入：</p><p><code>java.lang.reflect.InvocationHandler</code>，代理对象内部的成员变量。作为代理对象和目标对象的<strong>桥梁</strong>，代理对象的每个方法调用，都会调用其 <code>invoke()</code> 方法，委托其去调用目标对象，可在此时机补充<strong>增强代码</strong>。</p><p><img src="/img/java/proxy/InvocationHandler_class.png" alt="InvocationHandler"></p><p><code>java.lang.reflect.Proxy</code>，用于创建代理类或代理对象，同时还是它们的父类。</p><p><img src="/img/java/proxy/Proxy_class.png" alt="Proxy"></p><p><code>Proxy</code> 的核心方法 <code>newProxyInstance</code> 用于运行时动态生成代理类并通过反射创建实例，其源码及关键注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 代理类构造方法的参数类型 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] constructorParams = &#123; InvocationHandler<span class="class">.<span class="keyword">class</span> &#125;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 查找或生成指定的代理类</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 反射调用代理类的构造方法（入参为指定的 invocation handler）创建实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反射获取构造方法</span></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 调用构造方法，创建代理对象</span></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Generate a proxy class.  Must call the checkProxyAccess method</span></span><br><span class="line"><span class="comment">     * to perform permission checks before calling this.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">        <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">        <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="获取动态代理生成的-Class-文件"><a href="#获取动态代理生成的-Class-文件" class="headerlink" title="获取动态代理生成的 Class 文件"></a>获取动态代理生成的 Class 文件</h1><p><code>java.lang.reflect.Proxy</code> 底层使用了 <code>sun.misc.ProxyGenerator</code> 工具类生成代理类。通过指定 <code>java</code> 命令参数 <code>-Dsun.misc.ProxyGenerator.saveGeneratedFiles=true</code> 可以让工具类将动态生成的字节码写到本地磁盘文件（$ProxyN.class）。本例生成的字节码文件反编译后源码如下，重点关注 <code>fly</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.proxy.Flyable;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 proxy 对象的 fly 方法，则委托 InvocationHandler 对象执行 invoke 方法</span></span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.github.proxy.Flyable"</span>).getMethod(<span class="string">"fly"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，动态生成的 <code>$Proxy0</code> 类同样实现了 <code>Flyable</code> 接口，与目标类 <code>Bird</code> 类形成一个三角结构：</p><p><img src="/img/java/proxy/jdk_proxy.png" alt="jdk_proxy"></p><p><code>fly</code> 方法的实现，仅仅只是调用了 <code>InvocationHandler</code> 对象的 <code>invoke</code> 方法，传入上下文参数。具体的业务逻辑还是在自己的 <code>InvocationHandler</code> 中根据参数判断并自行实现。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://en.wikipedia.org/wiki/Proxy_pattern" target="_blank" rel="noopener">Proxy pattern 设计模式</a>》</p><p>《<a href="https://refactoringguru.cn/design-patterns/proxy" target="_blank" rel="noopener">代理设计模式</a>》</p><p>《<a href="https://www.jianshu.com/p/fc285d669bc5" target="_blank" rel="noopener">10分钟看懂动态代理设计模式</a>》</p><p>《<a href="https://time.geekbang.org/column/article/7489" target="_blank" rel="noopener">动态代理是基于什么原理？</a>》</p><p>《<a href="https://www.zhihu.com/question/20794107/answer/658139129" target="_blank" rel="noopener">Java 动态代理作用是什么？ - 知乎用户的回答</a>》</p><p>《<a href="http://stackoverflow.com/questions/22930195/understanding-proxy-arguments-of-the-invoke-method-of-java-lang-reflect-invoca" target="_blank" rel="noopener">Understanding “proxy” arguments of the invoke method of java.lang.reflect.InvocationHandler</a>》</p><p>《<a href="https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html" target="_blank" rel="noopener">字节码增强技术探索</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射篇（三）泛型 API 总结</title>
      <link href="2018/11/21/java-reflection-generic-type/"/>
      <url>2018/11/21/java-reflection-generic-type/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型-API"><a href="#泛型-API" class="headerlink" title="泛型 API"></a>泛型 API</h1><p>JDK 1.5 引入了泛型特性，一同引入的还有 Java <code>Type</code> 类型体系。其中 <code>Type</code> 接口作为核心，是 Java 编程语言中所有类型的通用超级接口（common superinterface），这些类型包括：</p><ul><li>原始类型（raw types）</li><li>参数化类型（parameterized types）</li><li>数组类型（array types）</li><li>类型变量（type variables）</li><li>八大原始类型（primitive types）</li></ul><p>调整后新引入的五个接口如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Type</span><br><span class="line">  java.lang.reflect.ParameterizedType &#x2F;&#x2F; 最最常用</span><br><span class="line">  java.lang.reflect.TypeVariable</span><br><span class="line">  java.lang.reflect.WildcardType</span><br><span class="line">  java.lang.reflect.GenericArrayType</span><br></pre></td></tr></table></figure><p><img src="/img/java/reflection/Type.png" alt="Type"></p><p>它们的核心方法如下：</p><p><img src="/img/java/reflection/Type_methods.png" alt="Type_methods"></p><p>同时新增的接口还有 <code>GenericDeclaration</code>。从源码中看，只有三个类实现了该接口（见下图）。因此我们只能在<strong>类型</strong>（例如 <code>class</code>，<code>interface</code>）、<strong>方法</strong>（<code>Method</code>）和<strong>构造方法</strong>（<code>Constructor</code>）这三个地方声明泛型参数（type variables），而其它地方只能使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Method</span><br><span class="line">java.lang.reflect.Constructor</span><br><span class="line">java.lang.Class</span><br></pre></td></tr></table></figure><p><img src="/img/java/reflection/GenericDeclaration.png" alt="GenericDeclaration"></p><p><code>GenericDeclaration</code> 接口只定义了一个方法，用于获取 <code>TypeVariable</code>：</p><p><img src="/img/java/reflection/GenericDeclaration_method.png" alt="GenericDeclaration_method"></p><p>类、字段、方法、构造方法也相应增加了一组方法用于获取 <code>Type</code>、<code>TypeVariable</code>：</p><ul><li><p><code>Class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取普通 Class</span></span><br><span class="line">Class&lt;? <span class="keyword">super</span> T&gt; getSuperclass()</span><br><span class="line">Class&lt;?&gt;[] getInterfaces()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Type</span></span><br><span class="line"><span class="function">Type <span class="title">getGenericSuperclass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getGenericInterfaces</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取 TypeVariable</span></span></span><br><span class="line"><span class="function">TypeVariable&lt;?&gt;[] <span class="title">getTypeParameters</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>Field</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取普通 Class</span></span><br><span class="line">Class&lt;?&gt; getType()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Type</span></span><br><span class="line"><span class="function">Type <span class="title">getGenericType</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>Method</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取普通 Class</span></span><br><span class="line">Class&lt;?&gt; getReturnType()</span><br><span class="line">Class&lt;?&gt;[] getParameterTypes()</span><br><span class="line">Class&lt;?&gt;[] getExceptionTypes()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Type</span></span><br><span class="line"><span class="function">Type <span class="title">getGenericReturnType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getGenericParameterTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Type[] <span class="title">getGenericExceptionTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取 TypeVariable</span></span></span><br><span class="line"><span class="function">TypeVariable&lt;?&gt;[] <span class="title">getTypeParameters</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>Constructor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取普通 Class</span></span><br><span class="line">Class&lt;?&gt;[] getParameterTypes()</span><br><span class="line">Class&lt;?&gt;[] getExceptionTypes()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Type</span></span><br><span class="line">Type[] getGenericParameterTypes()</span><br><span class="line">Type[] getGenericExceptionTypes()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 TypeVariable</span></span><br><span class="line">TypeVariable&lt;?&gt;[] getTypeParameters()</span><br></pre></td></tr></table></figure></li></ul><h1 id="泛型术语"><a href="#泛型术语" class="headerlink" title="泛型术语"></a>泛型术语</h1><p>泛型涉及的术语比较多，其与反射接口的对应关系如下：</p><table><thead><tr><th>术语</th><th>中文含义</th><th>举例</th><th>反射接口</th><th>备注</th></tr></thead><tbody><tr><td>Generic type</td><td>泛型</td><td><code>List&lt;E&gt;</code></td><td><code>ParameterizedType</code></td><td></td></tr><tr><td>Parameterized type</td><td>参数化类型</td><td><code>List&lt;String&gt;</code></td><td><code>ParameterizedType</code></td><td></td></tr><tr><td>Raw type</td><td>原始类型</td><td><code>List</code></td><td><code>ParameterizedType#getRawType</code></td><td>该方法虽然返回  <code>Type</code> 类型，但实际类型是 <code>Class</code>，可以强转使用：<code>(Class&lt;?&gt;) type</code>。</td></tr><tr><td>Unbounded wildcard type</td><td>无限制通配符类型</td><td><code>List&lt;?&gt;</code></td><td><code>ParameterizedType</code></td><td></td></tr><tr><td>Bounded wildcard type</td><td>有限制通配符类型（上限）</td><td><code>List&lt;? extends Number&gt;</code></td><td><code>ParameterizedType</code></td><td></td></tr><tr><td>Bounded wildcard type</td><td>有限制通配符类型（下限）</td><td><code>List&lt;? super Number&gt;</code></td><td><code>ParameterizedType</code></td><td></td></tr><tr><td>wildcard type</td><td>通配符类型</td><td><code>?</code></td><td><code>WildcardType</code></td><td></td></tr><tr><td>Formal type parameter</td><td>形式类型参数</td><td><code>E</code></td><td><code>TypeVarialbe</code></td><td></td></tr><tr><td>Actual type parameter</td><td>实际类型参数</td><td><code>String</code></td><td><code>ParameterizedType#getActualTypeArguments</code></td><td>该方法虽然返回  <code>Type[]</code> 类型，但各元素实际类型是 <code>Class</code>，可以强转使用：<code>(Class&lt;?&gt;) type</code>。</td></tr><tr><td>Bounded type parameter</td><td>有限制类型参数</td><td><code>&lt;E extends Number&gt;</code></td><td></td><td></td></tr><tr><td>Recursive type bound</td><td>递归类型限制</td><td><code>&lt;T extends Comparable&lt;T&gt;&gt;</code></td><td></td><td></td></tr><tr><td>Generic method</td><td>泛型方法</td><td><code>static &lt;E&gt; List&lt;E&gt; asList(E[] a)</code></td><td></td><td></td></tr><tr><td>Type token</td><td>类型令牌</td><td><code>String.class</code></td><td></td><td></td></tr></tbody></table><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>下面是几个获取 <code>Type</code> 的例子，先创建三个类：<code>BaseMapper</code>、<code>PersonMapper</code>、<code>Person</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseMapper</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Serializable</span> &amp; <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;, <span class="title">K</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">getById</span><span class="params">(K id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonMapper</span> <span class="keyword">implements</span> <span class="title">BaseMapper</span>&lt;<span class="title">Person</span>, <span class="title">Long</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Number&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;T&gt; list1, List&lt;? extends Comparable&lt;T&gt;&gt; list2, T[] array, T item)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.personName.compareTo(o.getPersonName());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Method method = PersonMapper.class.getMethod("test", List.class, List.class, Number[].class, Number.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [0] ParameterizedType</span></span><br><span class="line">    <span class="comment">// [1] ParameterizedType</span></span><br><span class="line">    <span class="comment">// [2] GenericArrayType</span></span><br><span class="line">    <span class="comment">// [3] TypeVariable</span></span><br><span class="line">    Type[] genericParameterTypes = method.getGenericParameterTypes();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Class</span></span><br><span class="line">    Type genericReturnType = method.getGenericReturnType();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Class[0]</span></span><br><span class="line">    Type[] genericExceptionTypes = method.getGenericExceptionTypes();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个 <code>Type</code> 变量的内容如下：</p><p><img src="/img/java/reflection/generic_type_example.png" alt="generic_type_examples"></p><h2 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h2><p>接下来看下 <code>ParameterizedType</code> 的使用，可以用于获取泛型的原始类型（Raw type）、实际类型参数（Actual type parameter）列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// com.github.reflection.BaseMapper&lt;com.github.reflection.Person, java.lang.Long&gt;</span></span><br><span class="line">    Type genericInterface = PersonMapper.class.getGenericInterfaces()[0];</span><br><span class="line">    assertTrue(genericInterface <span class="keyword">instanceof</span> ParameterizedType);</span><br><span class="line">    ParameterizedType parameterizedType = (ParameterizedType) genericInterface;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取原始类型：BaseMapper.class</span></span><br><span class="line">    assertEquals(BaseMapper<span class="class">.<span class="keyword">class</span>, <span class="title">parameterizedType</span>.<span class="title">getRawType</span>())</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实际类型参数列表：Person.class、Long.class</span></span><br><span class="line">    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();</span><br><span class="line">    assertEquals(<span class="string">"There are two actual type arguments"</span>, <span class="number">2</span>, actualTypeArguments.length);</span><br><span class="line">    <span class="comment">// class com.github.reflection.Person</span></span><br><span class="line">    assertClass(<span class="string">"One is Person"</span>, actualTypeArguments[<span class="number">0</span>], Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// class java.lang.Long</span></span><br><span class="line">    assertClass(<span class="string">"Another is Long"</span>, actualTypeArguments[<span class="number">1</span>], Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">assertClass</span><span class="params">(Type type, Class expectedClass)</span> </span>&#123;</span><br><span class="line">    assertTrue(type <span class="keyword">instanceof</span> Class);</span><br><span class="line">    Class clazz = (Class) type;</span><br><span class="line">    assertEquals(expectedClass, clazz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>genericInterface</code> 变量的内容如下，接口返回类型虽然为 <code>Type</code>，实际类型为 <code>ParameterizedType</code>，因此可以强转。该泛型变量的原始类型、实际类型参数列表如下，实际都为 <code>Class</code> 类型，因此可以强转 <code>(Class&lt;?&gt;) type</code>：</p><p><img src="/img/java/reflection/ParameterizedType_example.png" alt="ParameterizedType_example"></p><h2 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h2><p><code>WildcardType</code> 的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// java.util.List&lt;?&gt;</span></span><br><span class="line">    Method method = PersonMapper.class.getMethod("log", List.class);</span><br><span class="line">    Type genericParameterType = method.getGenericParameterTypes()[<span class="number">0</span>];</span><br><span class="line">    assertTrue(<span class="string">"The first parameter type of log method is instance of ParameterizedType"</span>, </span><br><span class="line">               genericParameterType <span class="keyword">instanceof</span> ParameterizedType);</span><br><span class="line">    ParameterizedType parameterType = (ParameterizedType) genericParameterType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WildcardType</span></span><br><span class="line">    Type type = parameterType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    assertTrue(<span class="string">"The actual type argument of ParameterizedType is instance of WildcardType"</span>, </span><br><span class="line">               type <span class="keyword">instanceof</span> WildcardType);</span><br><span class="line">    WildcardType wildcardType = (WildcardType) type;</span><br><span class="line">    assertEquals(<span class="string">"No lower bounds exist"</span>, <span class="number">0</span>, wildcardType.getLowerBounds().length);</span><br><span class="line">    assertEquals(<span class="string">"Only one upper bound exist"</span>, <span class="number">1</span>, wildcardType.getUpperBounds().length);</span><br><span class="line">    <span class="comment">// 通配符默认上限类型为 Object</span></span><br><span class="line">    assertEquals("The upper bound is Object", Object.class, wildcardType.getUpperBounds()[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Type</code> 类型变量 <code>genericParameterType</code> 的内容如下，实际类型是 <code>ParameterizedType</code>，其 <code>?</code> 通配符是 <code>WildcardType</code>：</p><p><img src="/img/java/reflection/WildcardType_example.png" alt="WildcardType_example"></p><h2 id="例子四"><a href="#例子四" class="headerlink" title="例子四"></a>例子四</h2><p><code>TypeVariable</code> 的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Method method = BaseMapper.class.getMethod("getById", Serializable.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TypeVariable</span></span><br><span class="line">    Type genericReturnType = method.getGenericReturnType();</span><br><span class="line">    assertTrue(<span class="string">"Return type of method is instance of TypeVariable"</span>, genericReturnType <span class="keyword">instanceof</span> TypeVariable);</span><br><span class="line">    TypeVariable typeVariable = (TypeVariable) genericReturnType;</span><br><span class="line">    assertEquals("First upper bound is Serializable", Serializable.class, typeVariable.getBounds()[0]);</span><br><span class="line">    ParameterizedType parameterizedType = (ParameterizedType) typeVariable.getBounds()[<span class="number">1</span>];</span><br><span class="line">    assertEquals(<span class="string">"Second upper bound is Comparable"</span>, Comparable<span class="class">.<span class="keyword">class</span>, <span class="title">parameterizedType</span>.<span class="title">getRawType</span>())</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Type</code> 类型变量 <code>genericReturnType</code> 的内容如下，实际类型是 <code>TypeVariable</code>，</p><p><img src="/img/java/reflection/TypeVariable_example.png" alt="TypeVariable_example"></p><h2 id="例子五"><a href="#例子五" class="headerlink" title="例子五"></a>例子五</h2><p>定义一个泛型工具类，用于获取 <code>T.class</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射获得定义 Class 时声明的父类的泛型参数的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回第一个类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">getSuperClassGenricType</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSuperClassGenricType(clazz, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过反射获得定义 Class 时声明的父类的泛型参数的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 返回某个下标的类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Class <span class="title">getSuperClassGenricType</span><span class="params">(Class clazz, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IndexOutOfBoundsException </span>&#123;</span><br><span class="line">        Type genType = clazz.getGenericSuperclass();</span><br><span class="line">        <span class="keyword">if</span> (!(genType <span class="keyword">instanceof</span> ParameterizedType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Object<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Type[] params = ((ParameterizedType) genType).getActualTypeArguments();</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= params.length || index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Object<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(params[index] <span class="keyword">instanceof</span> Class)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Object<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (Class) params[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/faed45dbfa0c" target="_blank" rel="noopener">https://www.jianshu.com/p/faed45dbfa0c</a></p><p><a href="https://blog.csdn.net/ShuSheng0007/article/details/89520530" target="_blank" rel="noopener">https://blog.csdn.net/ShuSheng0007/article/details/89520530</a></p><p>API：</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Type.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Type.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/ParameterizedType.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/ParameterizedType.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/TypeVariable.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/TypeVariable.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/WildcardType.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/WildcardType.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/GenericArrayType.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/GenericArrayType.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射篇（二）注解 API 总结</title>
      <link href="2018/11/14/java-reflection-annotation/"/>
      <url>2018/11/14/java-reflection-annotation/</url>
      
        <content type="html"><![CDATA[<p>JDK 1.5 引入了注解，其主要用途如下：</p><ul><li>生成文档，通过代码里标识的元数据生成 javadoc 文档。</li><li>编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。</li><li>编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。</li><li>运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。</li></ul><h1 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h1><p>首先，注解也是一种 <code>class</code>，所有注解都默认继承自通用接口：<code>java.lang.annotation.Annotation</code>：</p><p><img src="/img/java/reflection/annotation.png" alt="annotation"></p><p>从上图可见，JDK 提供的元注解（meta annotation）如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Native</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable</span></span><br><span class="line"><span class="meta">@Target</span></span><br><span class="line"><span class="meta">@Retention</span></span><br></pre></td></tr></table></figure><p>其中，<code>@Native</code>、<code>@Documented</code>、<code>@Inherited</code> 是一个“标记注解”，没有成员。</p><p>常用元注解的作用如下：</p><h2 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h2><p><code>@Inherited</code> 用于定义<strong>子类是否可继承父类定义的注解</strong>。仅针对 <code>@Target(ElementType.TYPE)</code> 类型的注解有效，并且仅针对 <code>class</code> 的继承，对 <code>interface</code> 的继承无效。注意：</p><ul><li>因此 <code>interface</code> 上标注的注解，无法被 JDK Proxy 动态代理生成的类所继承。</li><li>也因此 Spring AOP 的切点表达式 <code>@annotation(...)</code> 无法切到基于 JDK Proxy 的动态代理类。</li></ul><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Inherited.html</a></p><blockquote><p>Indicates that an annotation type is automatically inherited. If an Inherited meta-annotation is present on an annotation type declaration, and the user queries the annotation type on a class declaration, and the class declaration has no annotation for this type, <strong>then the class’s superclass will automatically be queried for the annotation type.</strong> This process will be repeated until an annotation for this type is found, or the top of the class hierarchy (Object) is reached. If no superclass has an annotation for this type, then the query will indicate that the class in question has no such annotation.</p><p><strong>Note that this meta-annotation type has no effect if the annotated type is used to annotate anything other than a class. Note also that this meta-annotation only causes annotations to be inherited from superclasses; annotations on implemented interfaces have no effect.</strong></p></blockquote><h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p><code>@Target</code> 用于定义注解能够被标注于源码的哪些位置。可用字段参考 <code>ElementType</code> 枚举。</p><p>JDK 8 扩展了注解的上下文，现在注解几乎可以加到任何地方：局部变量、泛型类、⽗类与接⼝的实现，就连⽅法的异常也能添加注解。</p><p>JDK 8 引入的这两个枚举如下：</p><ul><li><code>ElementType.TYPE_PARAMETER</code> 用于标注泛型的类型参数。</li><li><code>ElementType.TYPE_USE</code> 用于标注各种类型。</li></ul><p><img src="/img/java/reflection/extended_annotations_support.png" alt="extended_annotations_support"></p><h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h2><p><code>@Retention</code> 用于定义注解的生命周期。可用字段参考下面的 <code>RetentionPolicy</code> 枚举源码，常用的是 <code>RUNTIME</code> 类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Annotation retention policy.  The constants of this enumerated type</span></span><br><span class="line"><span class="comment">* describe the various policies for retaining annotations.  They are used</span></span><br><span class="line"><span class="comment">* in conjunction with the &#123;<span class="doctag">@link</span> Retention&#125; meta-annotation type to specify</span></span><br><span class="line"><span class="comment">* how long annotations are to be retained.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span>  Joshua Bloch</span></span><br><span class="line"><span class="comment">* <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be discarded by the compiler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SOURCE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler</span></span><br><span class="line"><span class="comment">     * but need not be retained by the VM at run time.  This is the default</span></span><br><span class="line"><span class="comment">     * behavior.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CLASS,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Annotations are to be recorded in the class file by the compiler and</span></span><br><span class="line"><span class="comment">     * retained by the VM at run time, so they may be read reflectively.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.reflect.AnnotatedElement</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h2><p>JDK 8 引入了 <code>@Repeatable</code>，表示该注解是否可重复标注。配套引入的还有为 <code>AnnotatedElement</code> 接口新增了两个方法 <code>getAnnotationsByType</code>、<code>getDeclaredAnnotationsByType</code>。</p><h1 id="AnnotatedElement"><a href="#AnnotatedElement" class="headerlink" title="AnnotatedElement"></a>AnnotatedElement</h1><p>读取运行时（<code>@Retention(RetentionPolicy.RUNTIME)</code>）的注解，需要用到反射 API。<code>java.lang.reflect.AnnotatedElement</code> 接口提供了一组方法，用于获取注解信息：</p><p><img src="/img/java/reflection/AnnotatedElement_methods.png" alt="AnnotatedElement_methods"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断某个注解是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAnnotationPresent</span><span class="params">(Class&lt;? extends Annotation&gt; annotationClass)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取注解（包括父类）</span></span></span><br><span class="line"><span class="function">&lt;T extends Annotation&gt; T <span class="title">getAnnotation</span><span class="params">(Class&lt;T&gt;)</span></span></span><br><span class="line"><span class="function">&lt;T extends Annotation&gt; T[] <span class="title">getAnnotationsByType</span><span class="params">(Class&lt;T&gt;)</span></span></span><br><span class="line"><span class="function">Annotation[] <span class="title">getAnnotations</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取注解（不包括父类）</span></span></span><br><span class="line"><span class="function">&lt;T extends Annotation&gt; T <span class="title">getDeclaredAnnotation</span><span class="params">(Class&lt;T&gt;)</span></span></span><br><span class="line"><span class="function">&lt;T extends Annotation&gt; T[] <span class="title">getDeclaredAnnotationsByType</span><span class="params">(Class&lt;T&gt;)</span></span></span><br><span class="line"><span class="function">Annotation[] <span class="title">getDeclaredAnnotations</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>由于下列类都实现了该接口，因此都拥有这些方法获取注解信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Class</span><br><span class="line">java.lang.Package</span><br><span class="line">java.lang.reflect.Field</span><br><span class="line">java.lang.reflect.Method</span><br><span class="line">java.lang.reflect.Constructor</span><br><span class="line">java.lang.reflect.Parameter</span><br></pre></td></tr></table></figure><p><img src="/img/java/reflection/main_api.png" alt="main_api"></p><p>举个例子，看下哪些情况通过反射可以拿到注解（或拿不到）：</p><p>注解如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;&#125;</span><br></pre></td></tr></table></figure><p>例子一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Check</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(String msg)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String childName = <span class="string">"Hello"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ToString annotation = Child<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">ToString</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        assertNull(<span class="string">"结果为 null 因为 @ToString 标注为 @Retention(RetentionPolicy.SOURCE)"</span>, annotation);</span><br><span class="line"></span><br><span class="line">        Check annotation1 = Child<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Check</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        assertNotNull(<span class="string">"结果不为 null 因为 @Check 标注为 @Retention(RetentionPolicy.RUNTIME)、@Inherited 并且 @Check 被标注在父类上，可以被子类继承"</span>, annotation1);</span><br><span class="line"></span><br><span class="line">        Check annotation2 = Child<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredAnnotation</span>(<span class="title">Check</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        assertNull(<span class="string">"结果为 null 因为 getDeclaredAnnotation 方法无法拿到父类注解"</span>, annotation2);</span><br><span class="line"></span><br><span class="line">        Method sayString = Child.class.getMethod("say", String.class);</span><br><span class="line">        Check annotation3 = sayString.getAnnotation(Check<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        assertNotNull(<span class="string">"结果不为 null 因为 say 方法未被子类重写，被完整继承下来"</span>, annotation3);</span><br><span class="line"></span><br><span class="line">        Method say = Child.class.getMethod("say");</span><br><span class="line">        Check annotation4 = say.getAnnotation(Check<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        assertNull(<span class="string">"结果为 null 因为 say 方法被子类重写了"</span>, annotation4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Check</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sayable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Sayable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Check annotation5 = Student<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Check</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        assertNull(<span class="string">"结果为 null 因为接口上的注解无法被子类继承"</span>, annotation5);</span><br><span class="line"></span><br><span class="line">        Check annotation6 = Student.class.getMethod("say").getAnnotation(Check.class);</span><br><span class="line">        assertNull(<span class="string">"结果为 null"</span>, annotation6);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AnnotatedType"><a href="#AnnotatedType" class="headerlink" title="AnnotatedType"></a>AnnotatedType</h1><p>JDK 8 引入了 <code>java.lang.reflect.AnnotatedType</code>：</p><p><img src="/img/java/reflection/AnnotatedType.png" alt="AnnotatedType"></p><p>类、字段、方法、构造方法相应增加了一组方法用于获取 <code>AnnotatedType</code>：</p><ul><li><p><code>Class</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AnnotatedType <span class="title">getAnnotatedSuperclass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">AnnotatedType[] <span class="title">getAnnotatedInterfaces</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>Field</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AnnotatedType <span class="title">getAnnotatedType</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>Method</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AnnotatedType <span class="title">getAnnotatedReturnType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">AnnotatedType[] <span class="title">getAnnotatedParameterTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">AnnotatedType[] <span class="title">getAnnotatedExceptionTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">AnnotatedType <span class="title">getAnnotatedReceiverType</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>Constructor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AnnotatedType <span class="title">getAnnotatedReturnType</span><span class="params">()</span></span></span><br><span class="line"><span class="function">AnnotatedType[] <span class="title">getAnnotatedParameterTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">AnnotatedType[] <span class="title">getAnnotatedExceptionTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">AnnotatedType <span class="title">getAnnotatedReceiverType</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://mp.weixin.qq.com/s?__biz=MzAxMjY1NTIxNA==&mid=2454441897&idx=1&sn=729688d470c94560c1e73e79f0c13adc&chksm=8c11e0a8bb6669be1cc4daee95b221ba437d536d598520d635fac4f18612dded58d6fddb0dce&scene=21#wechat_redirect" target="_blank" rel="noopener">深入理解java注解的实现原理</a>》</p><p>API：</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Annotation.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Annotation.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedType.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedType.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 反射篇（一）基础 API 总结</title>
      <link href="2018/11/07/java-reflection-api/"/>
      <url>2018/11/07/java-reflection-api/</url>
      
        <content type="html"><![CDATA[<p>什么是反射？</p><blockquote><p>反射机制是 Java 语言提供的一种基础功能，赋予程序在<strong>运行时自省</strong>（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p></blockquote><p>主要类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Class</span><br><span class="line">java.lang.Package</span><br><span class="line">java.lang.reflect.Field</span><br><span class="line">java.lang.reflect.Method</span><br><span class="line">java.lang.reflect.Constructor</span><br><span class="line"><span class="comment">// JDK 1.8 新引入，通过该类的 getName 方法能在运行时得到参数的名称（前提是通过 -parameters 指定编译器在编译的时候将参数名编译进去）</span></span><br><span class="line">java.lang.reflect.Parameter</span><br><span class="line"></span><br><span class="line">java.lang.reflect.Array</span><br></pre></td></tr></table></figure><p>工具类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.reflect.Modifier</span><br></pre></td></tr></table></figure><p>继承关系：</p><p><img src="/img/java/reflection/main_api.png" alt="main_api"></p><h1 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h1><p>如何获取一个 <code>class</code> 的 <code>Class</code> 实例？有几种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：直接通过一个 class 的静态变量 class 获取</span></span><br><span class="line">Class&lt;String&gt; aClass = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：通过实例变量提供的 getClass() 方法获取</span></span><br><span class="line">Class&lt;? extends String&gt; aClass2 = <span class="string">"Hello"</span>.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：通过 class 的完整类名获取，底层调用的是应用类加载器 Application ClassLoader (sun.misc.Launcher$AppClassLoader)</span></span><br><span class="line">Class&lt;?&gt; aClass3 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法四：通过自定义 ClassLoader 获取</span></span><br><span class="line">URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:/c:/"</span>)&#125;);</span><br><span class="line">Class&lt;?&gt; aClass4 = classLoader.loadClass(<span class="string">"java.lang.String"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取父类</span></span><br><span class="line">Class&lt;? <span class="keyword">super</span> String&gt; superclass = String<span class="class">.<span class="keyword">class</span>.<span class="title">getSuperclass</span>()</span>;  <span class="comment">// class java.lang.Object</span></span><br><span class="line"><span class="comment">// 获取外部类</span></span><br><span class="line">Class&lt;?&gt; enclosingClass = Map.Entry<span class="class">.<span class="keyword">class</span>.<span class="title">getEnclosingClass</span>()</span>;  <span class="comment">// interface java.util.Map</span></span><br><span class="line"><span class="comment">// 获取内部类</span></span><br><span class="line">Class&lt;?&gt;[] classes = HashMap<span class="class">.<span class="keyword">class</span>.<span class="title">getClasses</span>()</span>;  <span class="comment">// 2 个内部类</span></span><br><span class="line">Class&lt;?&gt;[] declaredClasses = HashMap<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredClasses</span>()</span>;  <span class="comment">// 13 个内部类</span></span><br></pre></td></tr></table></figure><p>由于 <code>Class</code> 实例在 JVM 中是唯一的，因此，上述方法获取的 <code>Class</code> 实例都是同一个实例。可以用 <code>==</code> 比较两个 <code>Class</code> 实例求证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// true</span></span><br><span class="line">assertTrue(aClass == aClass2);</span><br><span class="line">assertTrue(aClass == aClass3);</span><br><span class="line">assertTrue(aClass2 == aClass3);</span><br></pre></td></tr></table></figure><p>拿到 <code>Class</code> 实例后，可以通过下列方法获取字段、方法、构造方法、注解，以进行后续操作。方法名以 <code>getDeclared</code> 开头的表示仅获取当前类的信息（不包括父类）：</p><table><thead><tr><th>Member</th><th>Class API</th><th>Param  type</th><th>Return type</th><th>Inherited members</th><th>Private members</th></tr></thead><tbody><tr><td><code>Class</code></td><td><code>getDeclaredClasses()</code></td><td></td><td>Array</td><td>N</td><td>Y</td></tr><tr><td></td><td><code>getClasses()</code></td><td></td><td>Array</td><td>Y</td><td>N</td></tr><tr><td><code>Field</code></td><td><code>getDeclaredField()</code></td><td><code>String</code></td><td>Single</td><td>N</td><td>Y</td></tr><tr><td></td><td><code>getField()</code></td><td><code>String</code></td><td>Single</td><td>Y</td><td><code>java.lang.NoSuchFieldException</code></td></tr><tr><td></td><td><code>getDeclaredFields()</code></td><td></td><td>Array</td><td>N</td><td>Y</td></tr><tr><td></td><td><code>getFields()</code></td><td></td><td>Array</td><td>Y</td><td>N</td></tr><tr><td><code>Method</code></td><td><code>getDeclaredMethod()</code></td><td><code>String</code>, <code>Class&lt;?&gt;...</code></td><td>Single</td><td>N</td><td>Y</td></tr><tr><td></td><td><code>getMethod()</code></td><td><code>String</code>, <code>Class&lt;?&gt;...</code></td><td>Single</td><td>Y</td><td><code>java.lang.NoSuchMethodException</code></td></tr><tr><td></td><td><code>getDeclaredMethods()</code></td><td></td><td>Array</td><td>N</td><td>Y</td></tr><tr><td></td><td><code>getMethods()</code></td><td></td><td>Array</td><td>Y</td><td>N</td></tr><tr><td><code>Constructor</code></td><td><code>getDeclaredConstructor()</code></td><td><code>Class&lt;?&gt;...</code></td><td>Single</td><td>N/A</td><td>Y</td></tr><tr><td></td><td><code>getConstructor()</code></td><td><code>Class&lt;?&gt;...</code></td><td>Single</td><td>N/A</td><td><code>java.lang.NoSuchMethodException</code></td></tr><tr><td></td><td><code>getDeclaredConstructors()</code></td><td></td><td>Array</td><td>N/A</td><td>Y</td></tr><tr><td></td><td><code>getConstructors()</code></td><td></td><td>Array</td><td>N/A</td><td>N</td></tr><tr><td><code>Annotation</code></td><td><code>getDeclaredAnnotation()</code></td><td><code>Class&lt;T&gt;</code></td><td>Single</td><td>N</td><td>N/A</td></tr><tr><td></td><td><code>getAnnotation()</code></td><td><code>Class&lt;T&gt;</code></td><td>Single</td><td>Y</td><td>N/A</td></tr><tr><td></td><td><code>getDeclaredAnnotationsByType()</code></td><td><code>Class&lt;T&gt;</code></td><td>Array</td><td>N</td><td>N/A</td></tr><tr><td></td><td><code>getAnnotationsByType()</code></td><td><code>Class&lt;T&gt;</code></td><td>Array</td><td>Y</td><td>N/A</td></tr><tr><td></td><td><code>getDeclaredAnnotations()</code></td><td></td><td>Array</td><td>N</td><td>N/A</td></tr><tr><td></td><td><code>getAnnotations()</code></td><td></td><td>Array</td><td>Y</td><td>N/A</td></tr></tbody></table><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><p>一个 <code>Field</code> 对象包含了一个字段的所有信息，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字段名称</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 字段类型</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt; <span class="title">getType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 字段的修饰符，返回值是一个int，不同的 bit 表示不同的含义。使用 Modifier 工具类进行解析</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>以 <code>String</code> 类的 <code>value</code> 字段为例，它的定义是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用反射获取该字段的信息，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Field f = String.class.getDeclaredField("value");</span><br><span class="line">f.getName(); <span class="comment">// "value"</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>获取或设置字段值，使用如下方法。注意如果试图获取非 <code>public</code> 字段，将抛出异常 <code>java.lang.IllegalAccessException</code>，解决办法是先设置 <code>setAccessible(true)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取字段值</span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">getChar</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">getShort</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLong</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置字段值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBoolean</span><span class="params">(Object obj, <span class="keyword">boolean</span> z)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setByte</span><span class="params">(Object obj, <span class="keyword">byte</span> b)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setChar</span><span class="params">(Object obj, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setShort</span><span class="params">(Object obj, <span class="keyword">short</span> s)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(Object obj, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLong</span><span class="params">(Object obj, <span class="keyword">long</span> l)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(Object obj, <span class="keyword">float</span> f)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDouble</span><span class="params">(Object obj, <span class="keyword">double</span> d)</span></span></span><br></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>一个 <code>Method</code> 对象包含一个方法的所有信息，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法名称</span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 方法参数个数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getParameterCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 方法参数类型</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt;[] <span class="title">getParameterTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 方法参数注解</span></span></span><br><span class="line"><span class="function">Annotation[][] <span class="title">getParameterAnnotations</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 方法返回值类型</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt; <span class="title">getReturnType</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 方法异常类型</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt;[] <span class="title">getExceptionTypes</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 方法的修饰符，返回值是一个int，不同的 bit 表示不同的含义。使用 Modifier 工具类进行解析</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getModifiers</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>方法调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数为指定的实例对象。</span></span><br><span class="line"><span class="comment">// 如果是静态方法，可传 null。</span></span><br><span class="line"><span class="comment">// 如果是非 public 方法，需先设置 setAccessible(true)</span></span><br><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span></span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>创建新实例的几种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：通过 new 操作符</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：通过反射，调用 Class 提供的 newInstance() 方法。局限是只能调用其 public 无参构造方法</span></span><br><span class="line">Person p = Person<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式三：通过反射，调用 Constructor 提供的 newInstance() 方法。如果是非 public 方法，需先设置 setAccessible(true)</span></span><br><span class="line"><span class="comment">// 这里通过 private Person(String name) 构造新实例</span></span><br><span class="line">Constructor&lt;Person&gt; constructor = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredConstructor</span>(<span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Person peter = constructor.newInstance(<span class="string">"Peter"</span>);</span><br></pre></td></tr></table></figure><h1 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h1><p>通过以下方法获取父类或已实现接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取父类（Object 的父类是 null，其他任何非 interface 的 Class 都必定存在一个父类类型）</span></span><br><span class="line">Class&lt;? <span class="keyword">super</span> T&gt; getSuperclass()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取已实现接口（只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型）</span></span><br><span class="line">Class&lt;?&gt;[] getInterfaces()</span><br></pre></td></tr></table></figure><h2 id="isInstance"><a href="#isInstance" class="headerlink" title="isInstance"></a>isInstance</h2><p>使用 <code>instanceof</code> 操作符或者 <code>Class#isInstance</code> 方法，可以判断一个实例的继承关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object n = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">boolean</span> isDouble = n <span class="keyword">instanceof</span> Double; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">boolean</span> isInteger = n <span class="keyword">instanceof</span> Integer; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isNumber = n <span class="keyword">instanceof</span> Number; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> isSerializable = n <span class="keyword">instanceof</span> java.io.Serializable; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isDouble = Double<span class="class">.<span class="keyword">class</span>.<span class="title">isInstance</span>(<span class="title">n</span>)</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h2><p>如果 <code>instanceof</code> 为 <code>true</code>，可以使用以下方法对实例进行强制类型转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number num1 = (Number) n;</span><br><span class="line">Number num2 = Number<span class="class">.<span class="keyword">class</span>.<span class="title">cast</span>(<span class="title">n</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="isAssignableFrom"><a href="#isAssignableFrom" class="headerlink" title="isAssignableFrom"></a>isAssignableFrom</h2><p>如果是两个 <code>Class</code> 实例，要判断向上转型是否成立，可以调用 <code>Class#isAssignableFrom</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Integer</span></span><br><span class="line">Number<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Number</span></span><br><span class="line">Object<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Integer</span>.<span class="title">class</span>)</span>; <span class="comment">// true，因为Integer可以赋值给Object</span></span><br><span class="line">Integer<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">Number</span>.<span class="title">class</span>)</span>; <span class="comment">// false，因为Number不能赋值给Integer</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/index.html</a></p><p><a href="https://docs.oracle.com/javase/tutorial/reflect/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/reflect/index.html</a></p><p><a href="https://www.cnblogs.com/Kidezyq/p/11763988.html" target="_blank" rel="noopener">JDK1.8 反射包新增了<code>Parameter</code>类</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512</a></p><p>API：</p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Package.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/Package.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Method.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Constructor.html</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Parameter.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Parameter.html</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 类加载篇（二）Java SPI 机制总结</title>
      <link href="2018/11/05/java-spi/"/>
      <url>2018/11/05/java-spi/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h1><p>SPI 全称 Service Provider Interface，Java 1.6 引入，是 Java 在语言层面为我们提供了一种方便地创建可扩展应用的途径。SPI 提供了一种 JVM 级别的服务发现机制，我们只需要按照 SPI 的要求，在 jar 包中进行适当的配置，JVM 就会在运行时通过懒加载，帮我们找到所需的服务并加载。如果我们一直不使用某个服务，那么它不会被加载，一定程度上避免了资源的浪费。</p><p>整体机制图如下：</p><p><img src="/img/java/spi/java-spi.webp" alt="Java SPI"></p><h2 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h2><p>以 JDBC 为例，<strong>标准服务接口</strong>为 <code>com.mysql.jdbc.Driver</code>。</p><p>MySQL 作为<strong>服务提供方</strong>，以 mysql-connector-java 5.1.44 为例，按规范要求其 <code>META-INF/services/java.sql.Driver</code> 配置文件中声明了两个<strong>实现类</strong>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.mysql.jdbc.Driver</span><br><span class="line">com.mysql.fabric.jdbc.FabricMySQLDriver</span><br></pre></td></tr></table></figure><p>当类加载器载入 <code>java.sql.DriverManager</code> 类时，会执行其静态代码块，从而执行其中的 SPI 代码加载 JDBC Driver 实现，源码如下，详见：<a href="/2019/01/23/java-jdbc-driver/">《Java 数据持久化系列（一）JDBC Driver 驱动程序总结》</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"><span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">    Driver driver = driversIterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下：</p><p><img src="/img/java/spi/spi_flow_diagram.png" alt="spi_flow_diagram"></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p><code>ServiceLoader</code> 的结构如下：</p><p><img src="/img/java/spi/ServiceLoader.png" alt="ServiceLoader"></p><p>其成员变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类加载器加载配置文件时 所用的固定目录</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代表被加载的类或者接口</span></span><br><span class="line">    <span class="comment">// The class or interface representing the service being loaded</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于定位，加载和实例化 providers 的类加载器</span></span><br><span class="line">    <span class="comment">// The class loader used to locate, load, and instantiate providers</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 ServiceLoader 时采用的访问控制上下文</span></span><br><span class="line">    <span class="comment">// The access control context taken when the ServiceLoader is created</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存 providers，按实例化的顺序排列</span></span><br><span class="line">    <span class="comment">// Cached providers, in instantiation order</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒查找迭代器</span></span><br><span class="line">    <span class="comment">// The current lazy-lookup iterator</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SPI 的核心在于内部类 <code>LazyIterator</code>，承担了以下职责：</p><ol><li>加载配置文件，解析、验证其内容</li><li>加载类</li><li>反射构造实例</li></ol><p>核心源码及注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Private inner class implementing fully-lazy provider lookup</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;S&gt; service;</span><br><span class="line">        ClassLoader loader;</span><br><span class="line">        Enumeration&lt;URL&gt; configs = <span class="keyword">null</span>;</span><br><span class="line">        Iterator&lt;String&gt; pending = <span class="keyword">null</span>;</span><br><span class="line">        String nextName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否首次使用</span></span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 本例中值为 META-INF/services/java.sql.Driver</span></span><br><span class="line">                    String fullName = PREFIX + service.getName();</span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// 使用类加载器从类路径中加载文件：META-INF/services/java.sql.Driver，如果多个 jar 包都存在该文件则结果为多个 URL 实例</span></span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                    fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 依次解析 URL，获取 URL 内容的迭代器</span></span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 依次获取 URL 内容，例如第一条为 com.mysql.jdbc.Driver</span></span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            String cn = nextName;</span><br><span class="line">            nextName = <span class="keyword">null</span>;</span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 使用指定的类加载器查找并加载类：com.mysql.jdbc.Driver</span></span><br><span class="line">                c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过反射，调用 com.mysql.jdbc.Driver 的 public 无参构造方法创建 Object 实例对象，并强制转换为 interface java.sql.Driver 类型</span></span><br><span class="line">                S p = service.cast(c.newInstance());</span><br><span class="line">                <span class="comment">// 塞入缓存，key 为 com.mysql.jdbc.Driver 字符串，value 是对应的实例对象</span></span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">                     x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>Java SPI 实际上是“<strong>基于接口的编程＋策略模式＋配置文件</strong>”组合实现的动态加载机制。这种动态加载机制的使用场景如下：</p><ul><li>JDBC Driver 驱动程序管理类 <a href="https://docs.oracle.com/javase/8/docs/api/java/sql/DriverManager.html" target="_blank" rel="noopener"><code>java.sql.DriverManager</code></a>。详见：<a href="/2018/02/03/java-jdbc-driver/">JDBC Driver 驱动程序总结</a></li><li>JSR-303 Bean Validation 的 <a href="https://docs.oracle.com/javaee/7/api/javax/validation/Validation.html" target="_blank" rel="noopener"><code>javax.validation.Validation</code></a></li><li>日志门面接口实现类加载，SLF4J 加载不同提供商的日志实现类。</li><li>Spring<ul><li>对 servlet3.0 规范对 <code>ServletContainerInitializer</code> 的实现</li><li>自动类型转换 Type Conversion SPI (Converter SPI、Formatter SPI) 等</li><li>Spring Factories 机制（<code>SpringFactoriesLoader</code>）</li></ul></li><li>Dubbo 通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。详见：<a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html</a></li></ul><h1 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h1><p>下面总结下这几个加载类：</p><ul><li>Java <code>java.util.ServiceLoader</code></li><li>Spring <code>org.springframework.core.io.support.SpringFactoriesLoader</code></li><li>Dubbo <code>com.alibaba.dubbo.common.extension.ExtensionLoader</code></li></ul><table><thead><tr><th></th><th>Java SPI</th><th>Spring Factories</th><th>Dubbo SPI</th></tr></thead><tbody><tr><td>加载类</td><td><code>ServiceLoader</code></td><td><code>SpringFactoriesLoader</code></td><td><code>ExtensionLoader</code></td></tr><tr><td>加载文件</td><td><code>META-INF/services/接口全限定名</code></td><td><code>META-INF/spring.factories</code></td><td><code>META-INF/dubbo</code></td></tr><tr><td>文件内容</td><td>接口实现类，多值以<strong>换行</strong>分隔</td><td>通过键值对方式（key=value）配置，多值以<strong>逗号</strong>分隔</td><td>通过键值对方式（key=value）配置，支持按需加载接口实现类</td></tr><tr><td>接口注解</td><td>/</td><td>/</td><td><code>@SPI</code></td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.jianshu.com/p/46b42f7f593c" target="_blank" rel="noopener">https://www.jianshu.com/p/46b42f7f593c</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 类加载篇（一）类加载机制总结</title>
      <link href="2018/11/04/java-classloader/"/>
      <url>2018/11/04/java-classloader/</url>
      
        <content type="html"><![CDATA[<h1 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h1><p>单个 .java 源文件的从加载到创建对象的过程如下：</p><p><img src="/img/java/classloader/classloaoder_process.jpg" alt="classloaoder_process"></p><p>多个 .java 源文件经过 <code>javac</code> 编译后生成 .class 类文件（内含字节码），然后通过 <code>jar</code> 命令或其它构建工具（如 Maven、Gradle）打包生成可运行的 jar 包。最终通过 <code>java -jar</code> 命令运行 jar 包，执行其中清单文件（<code>META-INF/MANIFEST.MF</code>）中通过 <code>Main-Class</code> 指定的入口类的 <code>main</code> 方法以启动程序，并按照其 <code>Class-Path</code> 设置类路径。</p><p>从这里开始，就需要使用到类加载器将入口类（<code>Main-Class</code>）加载到 JVM。入口类在使用过程中如果使用到其它类，会根据类路径查找类文件并逐一加载。因此， jar 包中的类、及类路径中指定的类并不是一次性全部加载到 JVM 内存，而是使用到时才<strong>动态加载</strong>。可以指定启动参数 <code>-verbose:class</code> 输出类加载日志进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String param)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(String param)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"==============="</span>);</span><br><span class="line">        Bird bird = <span class="keyword">new</span> Bird();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类加载日志输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Opened D:\tool\jdk1.8.0_131\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.Object from D:\tool\jdk1.8.0_131\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.io.Serializable from D:\tool\jdk1.8.0_131\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.Comparable from D:\tool\jdk1.8.0_131\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.CharSequence from D:\tool\jdk1.8.0_131\jre\lib\rt.jar]</span><br><span class="line">[Loaded java.lang.String from D:\tool\jdk1.8.0_131\jre\lib\rt.jar]</span><br><span class="line">...</span><br><span class="line">[Loaded Test from file:&#x2F;D:&#x2F;workspaces&#x2F;project-test&#x2F;target&#x2F;classes&#x2F;]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">[Loaded com.github.proxy.Flyable from file:&#x2F;D:&#x2F;workspaces&#x2F;project-test&#x2F;target&#x2F;classes&#x2F;]</span><br><span class="line">[Loaded com.github.proxy.Bird from file:&#x2F;D:&#x2F;workspaces&#x2F;project-test&#x2F;target&#x2F;classes&#x2F;]</span><br></pre></td></tr></table></figure><h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>类从加载到 JVM 内存到被从内存中释放，经历的生命周期如下：</p><p><img src="/img/java/classloader/lifecycle_of_class.png" alt="lifecycle_of_class"></p><ul><li>加载阶段：包括根据类或接口的二进制名称（<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#name" target="_blank" rel="noopener">binary name</a>）查找其字节码文件（可能是之前由 <code>javac</code> 编译器源代码编译出的字节码文件；或者是通过动态编译，例如 JDK 动态代理使用的 <code>sun.misc.ProxyGenerator</code> 工具类编译出的字节码文件 <code>$Proxy0.class</code>），并构造成一个表示该类或接口的 <code>Class</code> 类对象。<strong>加载阶段由类加载器 <code>ClassLoader</code> 及其子类负责实现：<code>findClass</code> 方法负责查找字节码文件，<code>defineClass</code> 方法负责构造成 <code>Class</code> 对象。</strong></li><li>验证阶段：确保类或接口的二进制代码在结构上是正确的。类文件校验器（Class File Verifier）会进行以下四类校验：<ul><li>文件完整性校验（File Integrity Check）：第一步也是最简单的一步是检查类文件的结构。 它确保类文件具有适当的签名（前四个字节为魔数 <code>0xCAFEBABE</code>），并且类文件中的每个结构都具有适当的长度。它检查类文件本身不能内容过长或过短，并且常量池仅包含有效条目。当然，类文件的长度可能有所不同，但是每个结构（例如常量池）的长度作为文件规范的一部分都包含其中。</li><li>类完整性校验（Class Integrity Check）：<ul><li>该类具有父类（除非该类是 <code>Object</code>）。</li><li>该父类不是一个 <code>final</code> 类，并且该子类不会尝试覆盖其父类中的 <code>final</code> 方法。</li><li>常量池的条目格式正确，并且所有方法和字段引用均具有合法的名称和签名。</li></ul></li><li>字节码完整性校验（Bytecode Integrity Check）：执行字节码校验器（Bytecode Verifier），检查每个字节码以确定代码在运行时的实际行为，包括对方法参数和字节码操作数的数据流分析，堆栈检查和静态类型检查。是整个验证阶段中最复杂的一步。</li><li>运行时完整性校验（Runtime Integrity Check）</li></ul></li><li>准备阶段：包括为类或接口创建 <code>static</code> 静态字段（包括类变量和常量），并赋默认值。</li><li>解析阶段：包括检查符号引用是否正确、将符号引用替换为直接引用。</li><li>初始化阶段：<ul><li>类的初始化阶段包括执行 <code>static</code> 静态代码块、为 <code>static</code> 静态字段（变量）赋值。</li><li>接口的初始化阶段包括为字段（接口字段默认为 <code>public static final</code> 常量）赋值。</li></ul></li></ul><p>各个步骤可以详见官方文档 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html" target="_blank" rel="noopener">“Execution” chapter of The Java™ Language Specification</a>：</p><p><img src="/img/java/classloader/execution.png" alt="execution"></p><h1 id="类加载器源码解析"><a href="#类加载器源码解析" class="headerlink" title="类加载器源码解析"></a>类加载器源码解析</h1><p>Java 虚拟机中的类加载器（<code>ClassLoader</code>）负责加载来自文件系统、网络或其它来源的类文件。<code>ClassLoader</code> 是一个抽象类，其继承结构如下：</p><p><img src="/img/java/classloader/ClassLoader.png" alt="ClassLoader"></p><p>类加载后，每个 <code>Class</code> 对象都包含一个定义它的类加载器的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#getClassLoader--" target="_blank" rel="noopener">引用</a>。可以通过以下方式查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 结果为 null，因为启动类加载器为 C++ 编写</span></span><br><span class="line">        ClassLoader bootstrapClassLoader = java.lang.String<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        <span class="comment">// sun.misc.Launcher$ExtClassLoader</span></span><br><span class="line">        ClassLoader extClassLoader = com.sun.crypto.provider.DESKeyFactory<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">        <span class="comment">// sun.misc.Launcher$AppClassLoader</span></span><br><span class="line">        ClassLoader appClassLoader = Test<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClassLoader</code> 的核心方法如下：</p><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h3><p><code>loadClass</code> 方法使用二进制名称（<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#name" target="_blank" rel="noopener">binary name</a>）加载指定类。此方法的默认实现按以下顺序查找类：</p><ol><li>调用自身的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#findLoadedClass-java.lang.String-" target="_blank" rel="noopener"><code>findLoadedClass(String)</code></a> 方法以检查是否已加载该类。</li><li>递归调用父加载器的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#loadClass-java.lang.String-" target="_blank" rel="noopener"><code>loadClass</code></a> 方法。 如果父加载器为 <code>null</code>，则使用虚拟机内置的启动类加载器（Bootstrap ClassLoader）。</li><li>调用自身的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#findClass-java.lang.String-" target="_blank" rel="noopener"><code>findClass(String)</code></a> 方法查找类。</li></ol><p>如果上述步骤找到了类，并且 <code>resolve</code> 标记为 <code>true</code>，则此方法将在目标 <code>Class</code> 对象上调用 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#resolveClass-java.lang.Class-" target="_blank" rel="noopener"><code>resolveClass(Class)</code></a> 方法。</p><p><code>ClassLoader</code> 整个过程的源码及注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先，检查类是否已经被加载</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 未被加载的情况</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果父加载器不为 null，则委托父加载器去加载类</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 调用父加载器的 loadClass 方法，委托其去加载类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果父加载器为 null，则委托 Bootstrap ClassLoader 去加载类</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果父加载器都加载不到，则调用自身的 findClass 方法查找类</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果上述步骤找到了类，并且 resolve 标记为 true，则在目标 Class 对象上调用 resolveClass(Class) 方法，进入“连接（Linking）”阶段（详见官方文档）</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这整个加载过程被称为“双亲委派模型 (Delegation Model)”（流程见下图）。这种设计的好处体现在：</p><ul><li>沙箱安全机制：例如自己写的 <code>java.lang.String</code> 类不会被加载，否则在 <code>defineClass</code> 方法这一步会报错，<strong>防止恶意代码污染，核心 API 库被随意篡改。</strong>核心 API 库只能由 <code>Bootstrap ClassLoader</code> 从<code>$JAVA_HOME/jre/lib</code> 目录进行加载。</li><li>避免类的重复加载：当父加载器已经加载了该类时，就没有必要再加载一次，<strong>保证被加载类的唯一性。</strong></li></ul><p><img src="/img/java/classloader/classloader_hierarchy.png" alt="classloader_hierarchy"></p><p>这三个自带的 <code>ClassLoader</code> 细节详见类路径一节。</p><p>加载到的 <code>Class</code> 可以通过反射的方式实例化对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"com.github.parent.HelloWorld"</span>);</span><br><span class="line">Object instance = clazz.newInstance();</span><br></pre></td></tr></table></figure><h3 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h3><p>实现“加载阶段（Loading）”的查找功能。该方法应当被子类覆盖重写，用于使用指定的二进制名称（<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#name" target="_blank" rel="noopener">binary name</a>）查找类或接口的字节码文件。<code>ClassLoader</code> 的默认实现是抛出一个 <code>ClassNotFoundException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过覆盖这个方法实现一个自定义的类加载器（参考 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html" target="_blank" rel="noopener">ClassLoader</a> 介绍的例子，自定义 <code>NetworkClassLoader</code>）。</p><p>类可以按需动态加载到内存，这是 Java 的一大特点，也称为运行时绑定，或动态绑定。类文件的获取途径如下：</p><ul><li>从 ZIP 包中读取，最常见，JAR，WAR，EAR 格式的基础。</li><li>从网络中获取，典型场景是 Applet。</li><li>运行时计算生成，典型情景是 JDK 动态代理技术。</li><li>从其它文件中生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Servlet Class 类。</li></ul><p>如果用户想从其它位置加载类文件，可以自定义类加载器，或者使用自带的 <code>URLClassLoader</code> 从本地路径（<code>file:/</code>）或网络路径（<code>http://</code>）加载类文件，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 E 盘中加载类文件</span></span><br><span class="line">URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:/e:/"</span>)&#125;);</span><br><span class="line"><span class="comment">// 从 localhost 中加载类文件</span></span><br><span class="line"><span class="comment">// URLClassLoader classLoader = new URLClassLoader(new URL[] &#123;new URL("http://localhost/testfile/")&#125;);</span></span><br><span class="line">Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"com.github.parent.HelloWorld"</span>);</span><br><span class="line">Object instance = clazz.newInstance();</span><br><span class="line"><span class="comment">// java.net.URLClassLoader</span></span><br><span class="line">String name = instance.getClass().getClassLoader().getClass().getName();</span><br></pre></td></tr></table></figure><p>下面是子类 <code>URLClassLoader</code> 的默认实现，源码及注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                    <span class="comment">// 将二进制名称替换为文件路径（类似全限定名），例如：com.github.HelloWorld &gt; com/github/HelloWorld.class</span></span><br><span class="line">                    String path = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>).concat(<span class="string">".class"</span>);</span><br><span class="line">                    <span class="comment">// 从 URLClassPath 对象中查找文件</span></span><br><span class="line">                    Resource res = ucp.getResource(path, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 如果找到文件，则构造为 Class 类实例</span></span><br><span class="line">                            <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, acc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，如果找不到类（<code>result == null</code>），最底层的 <code>ClassLoader</code> 将抛出 <code>ClassNotFoundException</code>。</p><h3 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h3><p>实现“加载阶段（Loading）”的构造功能。</p><p><code>ClassLoader</code> 提供了四个 <code>defineClass</code> 方法可供自定义类加载器时使用，如下图。其中，第二个方法最常使用：<code>defineClass(String name, byte[] b, int off, int len)</code>。</p><p><img src="/img/java/classloader/defineClass.png" alt="defineClass"></p><p>其调用的底层源码如下，会调用 <code>preDefineClass</code> 和 <code>postDefineClass</code> 进行预处理和后置处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">                                     ProtectionDomain protectionDomain)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">&#123;</span><br><span class="line">    protectionDomain = preDefineClass(name, protectionDomain);</span><br><span class="line">    String source = defineClassSourceLocation(protectionDomain);</span><br><span class="line">    Class&lt;?&gt; c = defineClass1(name, b, off, len, protectionDomain, source);</span><br><span class="line">    postDefineClass(c, protectionDomain);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果自定义类加载器打破了双亲委派模型，然后还去加载核心 API 库，例如自己伪造一个 <code>java.lang.String</code>，会报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.SecurityException: Prohibited package name: java.lang</span><br><span class="line">    at java.lang.ClassLoader.preDefineClass(ClassLoader.java:659)</span><br><span class="line">    at java.lang.ClassLoader.defineClass(ClassLoader.java:758)</span><br><span class="line">    at java.lang.ClassLoader.defineClass(ClassLoader.java:642)</span><br><span class="line">    at com.github.MyClassLoader.findClass(...)</span><br><span class="line">    at com.github.MyClassLoader.loadClass(...)</span><br><span class="line">    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>这是由于 <code>preDefineClass</code> 预处理方法进行了二进制名称的前缀校验，源码如下，关键判断 <code>name.startsWith(&quot;java.&quot;)</code> 抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine protection domain, and check that:</span></span><br><span class="line"><span class="comment">    - not define java.* class,</span></span><br><span class="line"><span class="comment">    - signer of this class matches signers for the rest of the classes in</span></span><br><span class="line"><span class="comment">      package.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ProtectionDomain <span class="title">preDefineClass</span><span class="params">(String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        ProtectionDomain pd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(<span class="string">"IllegalName: "</span> + name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias</span></span><br><span class="line">    <span class="comment">// relies on the fact that spoofing is impossible if a class has a name</span></span><br><span class="line">    <span class="comment">// of the form "java.*"</span></span><br><span class="line">    <span class="comment">// 关键判断</span></span><br><span class="line">    <span class="keyword">if</span> ((name != <span class="keyword">null</span>) &amp;&amp; name.startsWith(<span class="string">"java."</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException</span><br><span class="line">            (<span class="string">"Prohibited package name: "</span> +</span><br><span class="line">             name.substring(<span class="number">0</span>, name.lastIndexOf(<span class="string">'.'</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        pd = defaultDomain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name != <span class="keyword">null</span>) checkCerts(name, pd.getCodeSource());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resolveClass"><a href="#resolveClass" class="headerlink" title="resolveClass"></a>resolveClass</h3><p>进入类加载的“连接（Linking）”阶段（详见官方文档 “Execution” chapter of The Java™ Language Specification）。</p><h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><p>使用场景：例如 Spring Factories 机制中 <code>SpringFactoriesLoader</code> 加载类路径下的文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classLoader.getResources(<span class="string">"META-INF/spring.factories"</span>)</span><br></pre></td></tr></table></figure><p>文件加载后，通过 key-value 的方式读取指定 key，并以反射的方式实例化指定的类型。</p><h3 id="getResource"><a href="#getResource" class="headerlink" title="getResource"></a>getResource</h3><p>查找指定名称的资源（图像、音频、文本等）。资源的名称是用“/”分隔的路径名，用于标识资源。<br>该方法首先递归调用父加载器查找资源；如果父加载器为 <code>null</code>，则使用虚拟机内置的启动类加载器（Bootstrap ClassLoader）。如果父加载器查找失败，则调用自身的 <code>findResource(String)</code> 查找资源。整个资源加载过程仍然为“双亲委派模型 (Delegation Model)”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URL <span class="title">getResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    URL url;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        url = parent.getResource(name);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        url = getBootstrapResource(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        url = findResource(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="findResource"><a href="#findResource" class="headerlink" title="findResource"></a>findResource</h3><p>查找指定名称的资源。类加载器实现应当重写此方法以指定在何处查找资源。默认返回 <code>null</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是子类 <code>URLClassLoader</code> 的默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URL <span class="title">findResource</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The same restriction to finding classes applies to resources</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    URL url = AccessController.doPrivileged(</span><br><span class="line">        <span class="keyword">new</span> PrivilegedAction&lt;URL&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> URL <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> ucp.findResource(name, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, acc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> url != <span class="keyword">null</span> ? ucp.checkURL(url) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h1><p>Java Launcher（即使用 <code>java</code> 命令）启动 Java 虚拟机时，类加载器按以下顺序搜索指定路径并加载类：</p><p><img src="/img/java/classloader/default_classloader.png" alt="Class Loader"></p><p>三个类加载器使用的类路径，从以下系统属性中获取，可以通过 <code>System.getProperty(...)</code> 获取查看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bootstrap ClassLoader</span></span><br><span class="line">String property1 = System.getProperty(<span class="string">"sun.boot.class.path"</span>);</span><br><span class="line"><span class="comment">// Extension ClassLoader</span></span><br><span class="line">String property2 = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line"><span class="comment">// Application ClassLoader</span></span><br><span class="line">String property3 = System.getProperty(<span class="string">"java.class.path"</span>);</span><br></pre></td></tr></table></figure><p>下面详细介绍各个类加载器：</p><h2 id="Bootstrap-ClassLoader"><a href="#Bootstrap-ClassLoader" class="headerlink" title="Bootstrap ClassLoader"></a>Bootstrap ClassLoader</h2><p>负责加载构成 Java 平台的基础类（Bootstrap classes），位于 <code>$JAVA_HOME/jre/lib</code> 目录，包括 <code>rt.jar</code> 和其它几个重要 jar 文件中的类。这些基础类包括 Java 类库（<a href="https://en.wikipedia.org/wiki/Java_Class_Library" target="_blank" rel="noopener">Java Class Library (JCL)</a>）的公共类，以及此库可用的私有类。</p><p>几乎所有的 Java 类库（JCL） 都存储在一个名为“<code>rt.jar</code>”的 <a href="https://en.wikipedia.org/wiki/JAR_(file_format)" target="_blank" rel="noopener">Java archive (jar)</a> 归档文件中，该文件随 <a href="https://en.wikipedia.org/wiki/Java_Runtime_Environment" target="_blank" rel="noopener">JRE</a> 和 <a href="https://en.wikipedia.org/wiki/Java_Development_Kit" target="_blank" rel="noopener">JDK</a> 发行版一起提供。Java 类库（<code>rt.jar</code>）位于默认的 bootstrap classpath（<code>$JAVA_HOME/jre/lib</code>）下，不必出现在为应用程序声明的 <a href="https://en.wikipedia.org/wiki/Classpath_(Java)" target="_blank" rel="noopener">classpath</a> 中。JRE 会使用引导类加载器（bootstrap class loader）找到 JCL。</p><p>Java 9 的<a href="https://en.wikipedia.org/wiki/Java_Module_System" target="_blank" rel="noopener">模块系统</a>目前已将这个单块的 <code>rt.jar</code> jar 包拆分并模块化。</p><h2 id="Extension-ClassLoader"><a href="#Extension-ClassLoader" class="headerlink" title="Extension ClassLoader"></a>Extension ClassLoader</h2><p>负责加载扩展 Java 平台的扩展类（Extension classes）。位于 <code>$JAVA_HOME/jre/lib/ext</code> 扩展目录的每个 <code>.jar</code> 文件都被假定为扩展文件，并使用 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/extensions/index.html" target="_blank" rel="noopener">Java Extension Framework</a> 扩展机制加载。</p><p><code>sun.misc.Launcher$ExtClassLoader</code> 执行过程中，<code>URLClassPath</code> 的值如下：</p><p><img src="/img/java/classloader/ext_classpath.png" alt="ext_classpath"></p><p>例如，可以将 MySQL 厂商驱动程序 <code>mysql-connector-java</code> 放到该扩展目录中。</p><h2 id="Application-ClassLoader"><a href="#Application-ClassLoader" class="headerlink" title="Application ClassLoader"></a>Application ClassLoader</h2><p>负责加载由开发人员和第三方定义的未利用 Java 扩展机制的类（User classes）。可以使用命令行上的 <code>-classpath</code> 选项（首选方法）或使用 <code>CLASSPATH</code> 环境变量来标识这些类的位置 。(See <strong>Setting the Classpath</strong> for <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/classpath.html" target="_blank" rel="noopener">Windows</a> or <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/classpath.html" target="_blank" rel="noopener">Unix</a>.)</p><h1 id="应用类加载器如何查找-User-classes？"><a href="#应用类加载器如何查找-User-classes？" class="headerlink" title="应用类加载器如何查找 User classes？"></a>应用类加载器如何查找 User classes？</h1><p>为了查找 User classes，Java Launcher 启动程序将引用 <em>User Classpath</em> - 一个包含了用户定义的类文件的目录、jar 包和 zip 包列表。作为 Java 虚拟机或 Java 编译器中的一个参数，可以在命令行上或通过环境变量进行设置。</p><p><em>User Classpath</em> 使用字符串格式指定，路径不要含有空格，否则转义为 <code>%20</code> 之后会报错，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Cannot resolve classpath entry: java.lang.RuntimeException: Cannot resolve classpath entry: D:\myprogram\mybatis%20tool\mybatis-generator-gui-0.8.4\target\classes\lib\mysql-connector-java-5.1.38.jar</span><br></pre></td></tr></table></figure><p>每个路径使用以下方式进行分隔：</p><ul><li>在类 Unix 系统中，以冒号（<code>:</code>）分隔</li><li>在 Windows 系统中，以分号（<code>;</code>）分隔</li></ul><p>Java Launcher 启动程序将这个 <em>User Classpath</em> 字符串放到 <code>java.class.path</code> 系统属性中。该值的来源及优先级如下：</p><ul><li>默认值“ <code>.</code>”，表示当前工作目录下的所有类文件（如果在 jar 包中，则位于其下）。</li><li><code>CLASSPATH</code> 环境变量，覆盖默认值。查看方式：<code>echo $CLASSPATH</code>，设置方式：<code>set CLASSPATH=</code></li><li><code>-cp</code> 或 <code>-classpath</code> 命令行选项，覆盖默认值以及 <code>CLASSPATH</code> 环境变量。</li><li>由 <code>-jar</code> 选项指定的 jar 包，它覆盖上述所有值。如果使用此选项，则所有用户类必须来自指定的 jar 包。</li></ul><p>类文件具有反映“类的完全限定名称（class’s fully-qualified name）”的子路径名。例如，如果类 <code>com.mypackage.MyClass</code> 存储在 <code>/myclasses</code> 目录，则 <code>/myclasses</code> 必须在 <em>User Classpath</em> 中，并且类文件的完整路径必须为 <code>/myclasses/com/mypackage/MyClass.class</code>。</p><p>如果类存储在名为 <code>myclasses.jar</code> 的 jar 包中，则 <code>myclasses.jar</code> 必须在  <em>User Classpath</em>  中，并且类文件必须存储 <code>myclasses.jar/com/mypackage/MyClass.class</code>。</p><p>下面来看几个例子，总结如下：</p><p><img src="/img/java/classloader/User_Classpath.png" alt="CLASSPATH 例子"></p><h2 id="Unpacked-Classes"><a href="#Unpacked-Classes" class="headerlink" title="Unpacked Classes"></a>Unpacked Classes</h2><p>假设我们有一个名为主类：HelloWorld，存储在 <em>D:\myprogram</em> 目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">D:\myprogram\</span><br><span class="line">      |</span><br><span class="line">      ---&gt; org\  </span><br><span class="line">            |</span><br><span class="line">            ---&gt; mypackage\</span><br><span class="line">                     |</span><br><span class="line">                     ---&gt; HelloWorld.class       </span><br><span class="line">                     ---&gt; SupportClass.class   </span><br><span class="line">                     ---&gt; UtilClass.class</span><br></pre></td></tr></table></figure><p>查看 Windows 下 <code>CLASSPATH</code> 环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$CLASSPATH</span></span><br><span class="line">.;E:\Developer\Java\jdk1.8.0_191\lib;</span><br></pre></td></tr></table></figure><p>由于 <code>CLASSPATH</code> 环境变量默认包含当前目录（<code>.</code>），这意味着当我们的工作目录为 <code>D:\myprogram\</code> 时，我们不需要显式指定 <code>CLASSPATH</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /D/myprogram</span><br><span class="line">$ java org.mypackage.HelloWorld</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>否则，需要使用 <code>-classpath</code> 参数显式指定如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java -classpath D:\myprogram org.mypackage.HelloWorld</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>总结，设置 <em>Classpath</em> 的两种方式：</p><ul><li>永久设置：使用 <code>CLASSPATH</code> 环境变量</li><li>临时设置：使用 <code>-cp</code> 或 <code>-classpath</code> 命令行选项</li></ul><h2 id="JAR-files"><a href="#JAR-files" class="headerlink" title="JAR files"></a>JAR files</h2><ul><li>单个 jar 包：使用绝对路径指定具体某个 jar 包</li><li>多个 jar 包：使用绝对路径加上通配符 <code>*</code></li></ul><h2 id="META-INF-MANIFEST-MF"><a href="#META-INF-MANIFEST-MF" class="headerlink" title="META-INF/MANIFEST.MF"></a>META-INF/MANIFEST.MF</h2><p>如果程序已经打成 jar 包，需要使用<a href="https://en.wikipedia.org/wiki/Manifest_file" target="_blank" rel="noopener">清单文件</a>指定入口类及 <code>CLASSPATH</code>，并使用 <code>java -jar</code> 命令启动。例如 Tomcat 的 <code>bootstrap.jar</code> 引导包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">Main-Class: org.apache.catalina.startup.Bootstrap</span><br><span class="line">Class-Path: commons-daemon.jar</span><br></pre></td></tr></table></figure><h1 id="IDEA-如何查找类？"><a href="#IDEA-如何查找类？" class="headerlink" title="IDEA 如何查找类？"></a>IDEA 如何查找类？</h1><p>首先，为 IDEA 平台配置上你所拥有的 JDK：</p><p><img src="/img/java/idea/platform_sdks.png" alt="Platform Settings SDKs"></p><p>然后，为你的项目指定一个默认 SDK：</p><p><img src="/img/java/idea/project_sdk.png" alt="Project SDK"></p><p>搞掂之后，IDEA 会为项目载入指定版本的 SDK，将基础目录  <code>jre/lib/</code> 的 Bootstrap classes 和扩展目录  <code>jre/lib/ext/</code> 的 Extension classes 加入 classpath：</p><p><img src="/img/java/idea/external_libraries.png" alt="External Libraries"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>JavaDoc</p><ul><li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html</a></p></li><li><p><a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se8/html/jls-12.html</a></p></li><li><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/findingclasses.html</a></p></li><li><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p></li><li><p><a href="http://cr.openjdk.java.net/~mr/jigsaw/ea/module-summary.html" target="_blank" rel="noopener">http://cr.openjdk.java.net/~mr/jigsaw/ea/module-summary.html</a></p></li><li><p><a href="http://medialab.di.unipi.it/web/doc/JNetSec/jns_ch5.htm" target="_blank" rel="noopener">The Class Loader and Class File Verifier</a></p></li></ul><p>Wikipedia</p><ul><li><a href="https://en.wikipedia.org/wiki/Classpath_(Java)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Classpath_(Java)</a></li><li><a href="https://en.wikipedia.org/wiki/Java_class_file" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Java_class_file</a></li><li><a href="https://en.wikipedia.org/wiki/Java_Class_Library" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Java_Class_Library</a></li></ul><p>其它：</p><ul><li><p><a href="https://blog.csdn.net/briblue/article/details/54973413" target="_blank" rel="noopener">https://blog.csdn.net/briblue/article/details/54973413</a></p></li><li><p><a href="https://www.cnblogs.com/doit8791/p/5820037.html" target="_blank" rel="noopener">https://www.cnblogs.com/doit8791/p/5820037.html</a></p></li><li><p>《<a href="https://www.cnblogs.com/Kidezyq/p/11769839.html" target="_blank" rel="noopener">理解java对象初始化顺序</a>》先父后子，先静后动</p></li><li><p>《<a href="https://mp.weixin.qq.com/s/iGKprJEqCZpIO77sAMYRCQ" target="_blank" rel="noopener">原来热加载如此简单，手动写一个 Java 热加载吧</a>》</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/54693308" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54693308</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《格鲁夫给经理人的第一课》读书笔记</title>
      <link href="2018/09/23/high-output-management/"/>
      <url>2018/09/23/high-output-management/</url>
      
        <content type="html"><![CDATA[<p>最近阅读了《格鲁夫给经理人的第一课》，获益良多，书中系统性的总结了许多管理经验，对于新晋经理人的观念转变及管理技能提升有较大帮助。</p><p>附上读书笔记：</p><p><img src="/img/management/high-output-management/%E3%80%8A%E7%BB%99%E7%BB%8F%E7%90%86%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E8%AF%BE%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.png" alt="《给经理人的第一课》学习笔记"></p><p>书摘：<a href="/img/management/high-output-management/《给经理人的第一课》书摘.pdf">《给经理人的第一课》书摘</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《证券投资基金》读书笔记——基金知识总结</title>
      <link href="2018/08/31/financial-funds/"/>
      <url>2018/08/31/financial-funds/</url>
      
        <content type="html"><![CDATA[<p>证券投资基金是资产管理的主要方式之一，它是一种组合投资、专业管理、利益共享、风险共担的集合投资方式。它主要通过向投资者发行受益凭证（基金份额），将众多不特定投资者的资金汇集起来，形成独立财产，委托<strong>基金管理人</strong>进行投资管理，<strong>基金托管人</strong>进行财产托管，由<strong>基金投资人</strong>共享投资收益、共担投资风险的集合投资方式。</p><p>投资基金是一种<strong>间接投资</strong>工具，基金投资者、基金管理人、托管人是基金运作中的主要当事人。</p><p>基金管理机构和托管机构分别作为基金管理人和基金托管人，一般按照基金的资产规模获得一定比例的<strong>管理费收入和托管费收入（即为净值型产品）</strong>。</p><h1 id="基金概况"><a href="#基金概况" class="headerlink" title="基金概况"></a>基金概况</h1><p><img src="/img/finance/financial_funds.png" alt="证券投资基金概况"></p><h1 id="基金分类"><a href="#基金分类" class="headerlink" title="基金分类"></a>基金分类</h1><p><img src="/img/finance/financial_funds_classification.png" alt="证券投资基金分类"></p><h2 id="按法律形式"><a href="#按法律形式" class="headerlink" title="按法律形式"></a>按法律形式</h2><table><thead><tr><th></th><th>契约型基金</th><th>公司型基金</th></tr></thead><tbody><tr><td>法律主体资格不同</td><td>不具有法人资格</td><td>具有法人资格</td></tr><tr><td>投资者的地位不同</td><td>依据基金合同成立，基金投资者可通过持有人大会表达意见，但权利相对较小</td><td>通过股东大会，持有人权利较大</td></tr><tr><td>基金组织方式和营运依据不同</td><td>借用了信托法律制度，依据基金合同营运基金，基金投资人和基金管理人、托管人之间是信托委托人、受托人和受益人。基金投资人通过基金持有人大会行使权力。</td><td>借用了《公司法》规定的股份有限公司的组织方式，其依据投资公司章程营运基金，设有股东会、董事会等决策监督机构，基金投资人通过股东会行使权力，设立董事会进行相关事务的决策与监督，基金管理人的身份是公司董事会聘请的投资顾问。</td></tr><tr><td>优点</td><td>在设立上更为简单易行</td><td>法律关系明确清晰，监督约束机制较为完善</td></tr><tr><td>范围</td><td>中国的基金均是契约型基金</td><td>美国的投资公司为代表</td></tr></tbody></table><h2 id="按运作方式"><a href="#按运作方式" class="headerlink" title="按运作方式"></a>按运作方式</h2><table><thead><tr><th></th><th>开放式基金</th><th>封闭式基金</th></tr></thead><tbody><tr><td>份额</td><td>不固定</td><td>固定</td></tr><tr><td>存续期限</td><td>不确定，理论上可以无限期存续</td><td>确定</td></tr><tr><td>交易方式</td><td>一般不上市，通过向基金管理公司和代销机构进行申购、赎回</td><td>上市流通</td></tr><tr><td>交易价格</td><td>按照每日基金单位资产净值（NAVPS）</td><td>根据市场行情变化，相对于单位资产净值可能折价或溢价，多为折价</td></tr><tr><td>估值频率</td><td>每个交易日估值，次日公告</td><td>每个交易日估值，每周披露</td></tr><tr><td>信息披露</td><td>每日公布基金单位资产净值（NAVPS），每季度公布资产组合，每六个月公布变更的招募说明书</td><td>每周公布基金单位资产净值（NAVPS），每季度公布资产组合</td></tr><tr><td>投资策略</td><td>强调流动性管理，基金资产中要保持一定现金及流动性资产</td><td>全部资金在封闭期内可进行长期投资</td></tr><tr><td>收益分配频率</td><td>开放式基金的基金合同应当约定每年基金收益分配的最多次数和基金收益分配的最低比例。实践中，许多基金合同规定每年至少一次。如果是货币基金，一般为每日结转收益或按月结转收益。</td><td>每年不得少于一次</td></tr><tr><td>收益分配方式</td><td>1、现金分红；2、分红再投资转换为基金份额</td><td>现金分红</td></tr><tr><td>总结</td><td>基金份额不固定，基金份额可以在基金合同约定的时间和场所进行申购、赎回的一种基金运作方式</td><td>基金份额在基金合同期限内固定不变，基金份额可以在证交所交易，但基金份额持有人不得申请赎回</td></tr></tbody></table><h2 id="按资金募集方式"><a href="#按资金募集方式" class="headerlink" title="按资金募集方式"></a>按资金募集方式</h2><table><thead><tr><th></th><th>公募基金</th><th>私募基金</th></tr></thead><tbody><tr><td>制度</td><td>基金募集注册制。即证监会不进行实质性审核，而只是进行合规性审查。</td><td>基金管理人登记制，即私募基金的基金管理人只需向基金业协会登记即可，无须中国证监会审批。</td></tr><tr><td>申请期限</td><td>依据《证券投资基金法》的规定，公募基金应当经中国证监会注册。证监会在受理申请之日起 6 个月内依照法律法规进行审查，作出注册或者不予注册的决定。</td><td>基金业协会应当在私募基金管理人登记材料齐备后的 20 个工作日内，通过网站公告私募基金管理人名单及其基本情况的方式，为私募基金管理人办理登记手续。</td></tr><tr><td>监管主体</td><td>由证监会监管</td><td>由基金业协会制定相关指引和准则，实行自律管理。</td></tr><tr><td>提交文件</td><td>1、申请报告；2、基金合同草案；3、基金托管协议草案；4、招募说明书草案；5、律所出具的法律意见书；6、中国证监会规定提交的其它文件。</td><td>1、工商登记和营业执照正副本复印件；2、公司章程或者合伙协议；3、主要股东或者合伙人名单；4、高级管理人员的基本信息；5、基金业协会规定的其它信息。</td></tr><tr><td>募集群体</td><td>不特定对象、或特定对象累计超过 200 人。</td><td>合格投资者，且累计不得超过 200 人。</td></tr></tbody></table><h2 id="按投资对象"><a href="#按投资对象" class="headerlink" title="按投资对象"></a>按投资对象</h2><h3 id="股票基金"><a href="#股票基金" class="headerlink" title="股票基金"></a>股票基金</h3><h3 id="债券基金"><a href="#债券基金" class="headerlink" title="债券基金"></a>债券基金</h3><table><thead><tr><th></th><th>债券</th><th>债券基金</th></tr></thead><tbody><tr><td>利息</td><td>有固定的利息收入</td><td>不同债券的组合，利息不固定</td></tr><tr><td>到期日</td><td>有确定的到期日</td><td>没有确定的到期日</td></tr><tr><td>收益率</td><td>单一债券的收益率可以根据购买价格、现金流以及到期收回的本金计算其投资收益率</td><td>较难计算和预测收益率</td></tr><tr><td>投资风险</td><td>单一债券的信用风险比较集中，随着到期日的临近，所承担的利率风险会下降</td><td>债券基金通过分散投资可以有效避免单一债券可能面临的较高的信用风险。由于没有固定到期日，所承担的利率风险将取决于所持有的债券的平均到期日</td></tr></tbody></table><p>债券基金的风险如下：</p><ol><li>利率风险</li><li>再投资风险</li><li>信用风险</li><li>流动性风险</li><li>提前赎回风险</li><li>可转债的特定风险</li><li>债券回购风险</li></ol><h3 id="货币基金"><a href="#货币基金" class="headerlink" title="货币基金"></a>货币基金</h3><h4 id="货币市场基金在投资组合中的作用"><a href="#货币市场基金在投资组合中的作用" class="headerlink" title="货币市场基金在投资组合中的作用"></a>货币市场基金在投资组合中的作用</h4><blockquote><p>与其它类型基金相比，货币市场基金具有风险低、流动性好的特点，是厌恶风险、对资产<strong>流动性</strong>和<strong>安全性</strong>要求较高的投资者进行短期投资和<strong>现金管理</strong>的理想工具，或是暂时存放现金的理想场所。</p></blockquote><h4 id="货币市场基金的投资对象与货币市场工具"><a href="#货币市场基金的投资对象与货币市场工具" class="headerlink" title="货币市场基金的投资对象与货币市场工具"></a>货币市场基金的投资对象与货币市场工具</h4><blockquote><p> 货币市场基金的投资对象是货币市场工具，通常指到期日不足 1 年的短期金融工具，也成为<strong>现金投资工具</strong>。货币市场工具通常由政府、金融机构以及信誉卓著的大型工商企业发行，流动性好、安全性高，但其收益率与其它证券相比则非常低。货币市场与股票市场的一个主要区别是：货币市场进入门槛通常很高，在很大程度上限制了一般投资者的进入。此外，货币市场属于场外交易市场，交易主要由买卖双方通过电话或电子交易系统以协商价格完成。货币市场基金的投资门槛极低，因此，货币市场基金为普通投资者进入货币市场提供了重要通道。</p><p>按照中国证监会和中国人民银行 2015 年颁布的《货币市场基金监督管理办法》的规定，货币市场基金应当投资于以下金融工具：</p><ol><li>现金；</li><li>期限在 1 年以内（含 1 年）的银行存款、债券回购、中央银行票据、同业存单；</li><li>剩余期限在 397 天以内（含 397 天）的债券、非金融企业债务融资工具、资产支持证券；</li><li>中国证监会、中国人民银行认可的其它具有良好流动性的货币市场工具。</li></ol><p>货币市场基金不得投资于以下金融工具：</p><ol><li>股票；</li><li>可转换债券、可交换债券；</li><li>以定期存款利率为基准利率的浮动利率债券，已进入最后一个利率调整期的除外；</li><li>信用等级在 AA+ 以下的债券与非金融企业债务融资工具；</li><li>中国证监会、中国人民银行禁止投资的其它金融工具。</li></ol></blockquote><h4 id="货币市场基金的支付功能"><a href="#货币市场基金的支付功能" class="headerlink" title="货币市场基金的支付功能"></a>货币市场基金的支付功能</h4><blockquote><p>由于货币市场基金风险低、流动性好，通过以下机制设计，基金管理公司将货币市场基金的功能从投资拓展为类似货币的支付功能：</p><ol><li>每个交易日办理基金份额申购、赎回；</li><li>在基金合同中将<strong>收益分配</strong>的方式约定为<strong>红利再投资</strong>，并<strong>每日</strong>进行收益分配（每日结转收益）；</li><li>每日按照面值（一般为 1 元）进行报价。</li></ol></blockquote><h1 id="基金术语"><a href="#基金术语" class="headerlink" title="基金术语"></a>基金术语</h1><h2 id="基金分红"><a href="#基金分红" class="headerlink" title="基金分红"></a>基金分红</h2><p>基金<strong>收益分配</strong>（即分红）是指将本基金的<strong>净收益</strong>根据持有基金单位的数量（即持有份额）按比例向基金持有人进行分配。若基金上一年度亏损，当年收益应先用于弥补上年亏损，在基金亏损完全弥补后尚有剩余的，方能进行当年收益分配。基金当年发生亏损无净收益的，不进行收益分配。</p><p>基金进行收益分配会导致<strong>基金份额净值</strong>的下降，但对投资者的利益没有实际影响。一只基金在收益分配前份额净值为1.2元，每份基金分配0.05元收益，在分配后基金份额净值将会下降到1.15元。但对投资者来说，分红前后的价值是不变的。</p><p>收益分配后基金份额净值<strong>不得低于面值</strong>。</p><p>现有制度下，基金分红主要有两种形式：</p><ol><li>现金分红。是指直接获得现金红利，落袋为安；</li><li>红利再投资转换为基金份额。红利再投资是指将所分得的现金红利再投资该基金或者购买的个股，从而达到增加原先持有基金或股票的份额，俗称“利滚利”，这样做既可免掉再投资的申购费，而且再投资所获得的基金份额还可以享受或增加下次分红的数额，可使基金份额随着分红的次数而增加。</li></ol><p>假如选择红利再投资方式对开放式基金进行长期投资，则可享受基金投资增值的<strong>复利增长</strong>效果。例如，假如开放式基金<strong>每年</strong>分红5%，选择红利再投资，则10年后资金将增值为62.89%；而假如同样的收益情况，选择现金分红方式，则10年后资金只增值为50%，收益少了12.89%。假如投资时间更长，则差别更大。</p><p>中国法律规定默认的基金分红方式是现金分红，投资者可以通过销售机构将分红方式变更为红利再投资，以获得更大的回报。</p><p>现金分红涉；及三个日期：</p><ol><li><p>权益登记日：是基金公司进行红利分配时，需要定出某一天，界定哪些基金持有人可以参加分红，定出的这一天就是权益登记日。也就说，在权益登记日当天仍持有或申购基金并得到确认的投资者均可享受此次分红。</p></li><li><p>除息日：分红方案中确定的将红利从基金资产中扣除的日期。除息日当天，基金净值将会降低，如果不考虑当日市场波动，下降的幅度就是单位基金的现金分红额。</p></li><li><p>派息日：也就是基金分红拨付给基金持有人的日子。</p></li></ol><h2 id="基金分拆"><a href="#基金分拆" class="headerlink" title="基金分拆"></a>基金分拆</h2><p>基金分拆是指保证投资者的投资总额不发生改变的前提下，将一份基金按照一定的比例分拆为若干份，每一基金份额的单位净值也按相同比例降低：</p><ul><li>分拆比例大于 1 的分拆为基金分拆；</li><li>分拆比例小于 1 的分拆为基金合并。</li></ul><h2 id="基金份额净值"><a href="#基金份额净值" class="headerlink" title="基金份额净值"></a>基金份额净值</h2><ul><li>基金资产估值：通过对基金所拥有的全部资产及全部负债按一定的原则和方法进行估算，进而确定基金资产公允价值的过程。</li><li>基金资产总值（AV, Asset Value）：基金全部资产的价值总和。</li><li>基金资产净值（NAV, Net Asset Value）：基金资产 - 基金负债（NAV = Assets - Liabilities）</li><li>基金份额净值（<a href="https://www.investopedia.com/terms/n/navpershare.asp" target="_blank" rel="noopener">NAVPS, Net Asset Value Per Share</a>）：基金资产净值 / 基金总份额（NAVPS = Net Asset Value (NAV) / Number of Shares Outstanding）。也叫“<strong>单位净值</strong>”，与“累计净值”的区别<a href="/img/finance/NAVPS.jpg">查看这里</a>。</li><li>基金份额：是指基金发起人向投资者公开发行的，表示持有人按其所持份额对基金财产享有收益分配权、清算后剩余财产取得权和其他相关权利，并承担相应义务的凭证。</li></ul><p>一图看清“基金份额净值”：<a href="/img/finance/net_value_of_the_fund_assets_per_shares.jpg">基金份额净值</a></p><h2 id="基金份额类型（费率模式）"><a href="#基金份额类型（费率模式）" class="headerlink" title="基金份额类型（费率模式）"></a>基金份额类型（费率模式）</h2><p>常见的基金收费有申购费、赎回费、管理费、托管费、销售服务费。还有一个认购费，但那是只有在基金募集期才会用到的。这么多费率，怎么区分？</p><h3 id="货币基金-1"><a href="#货币基金-1" class="headerlink" title="货币基金"></a>货币基金</h3><p>一般来说，我们常见的货币基金主要分A类、B类，其实货基的A、B类相差并不大，在收益方面的差别也不是很大，但门槛方面相差还是比较多的（具体以基金合同为准）：</p><table><thead><tr><th>基金份额类型（费率模式）</th><th>描述</th></tr></thead><tbody><tr><td>A类份额</td><td>货币基金中的低门槛份额，适用于认购、申购金额低于500万的投资者，散户投资者买货基都是此类；</td></tr><tr><td>B类份额</td><td>货币基金中的高门槛份额，适用于认购、申购金额高于500万的投资者，专为高净值客户或机构客户设置。</td></tr></tbody></table><h3 id="股票型-混合型-债券型基金"><a href="#股票型-混合型-债券型基金" class="headerlink" title="股票型/混合型/债券型基金"></a>股票型/混合型/债券型基金</h3><table><thead><tr><th>基金份额类型（费率模式）</th><th>费用差别</th><th>适合人群</th></tr></thead><tbody><tr><td>A类份额</td><td>前端收费，即申购时收取申购费（不同的销售渠道会有打折）</td><td>投资时间没有明确判断</td></tr><tr><td>B类份额</td><td>后端收费，即赎回时收取申购费（持有的时间越长，申购费越少，持有超过一定年限后，不再收取）</td><td>长期持有（一般3~5年）</td></tr><tr><td>C类份额</td><td>无申购费，但按日收取销售服务费</td><td>短期持有（一般1~2年）</td></tr></tbody></table><p>值得注意的是：A类份额和B类份额，都要收取一定的基金管理费和托管费，但是不收取销售服务费。</p><p>A类基金：前端申购费+赎回费+管理费+托管费<br>B类基金：后端申购费+赎回费+管理费+托管费<br>C类基金：销售服务费+赎回费+管理费+托管费</p><h2 id="持有区间收益率"><a href="#持有区间收益率" class="headerlink" title="持有区间收益率"></a>持有区间收益率</h2><ul><li>资产回报：是指股票、债券、房地产等资产价格的增加或减少。</li><li>资产回报率 = (期末资产价格 - 期初资产价格) ÷ 期初资产价格 × 100%</li><li>收入回报：包括分红、利息等。</li><li>收入回报率 = 期间收入 ÷ 期初资产价格 × 100%</li><li>持有区间收益 = 资产回报 + 收入回报</li><li>持有区间收益率 = 资产回报率 + 收入回报率</li></ul><ul><li>除权：因<strong>送股或配股</strong>而形成的剔除行为。</li><li>除息：因<strong>派息</strong>而引起的剔除行为。</li><li>除权（息）参考价 = (前收盘价 - 现金红利 + 配股价格 × 股份变动比例) ÷ (1+ 股份变动比例)</li></ul><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><h3 id="申购计算公式"><a href="#申购计算公式" class="headerlink" title="申购计算公式"></a>申购计算公式</h3><p>净申购金额=申购金额/(1+申购费率)</p><p>申购费用=申购金额-净申购金额</p><p>申购份额=净申购金额/T日基金份额净值</p>]]></content>
      
      
      
        <tags>
            
            <tag> 金融 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《证券投资基金》读书笔记——资产管理小结</title>
      <link href="2018/08/08/financial-asset-management/"/>
      <url>2018/08/08/financial-asset-management/</url>
      
        <content type="html"><![CDATA[<p>在金融市场上，资金的供给者通过投资<strong>金融工具</strong>获得各种类型的<strong>金融资产</strong>。金融资产是代表未来收益或资产合法要求权的<strong>凭证</strong>，标示了明确的价值，表明了交易双方的所有权关系和债权关系。它分为<strong>债券类</strong>金融资产和<strong>股权类</strong>金融资产两类。债券类金融资产以票据、债券等契约型投资工具为主，股权类金融资产以各类股票为主。资金的供给者产生了对金融资产进行管理的需求。</p><p>资产管理并没有一个得到广泛认可的明确定义，根据国内外行业共识，资产管理一般是指金融机构受投资者委托，为实现投资者的特定目标和利益，进行证券和其它金融产品的投资并提供金融资产管理服务、收取费用的行为。<br>从资产管理的外延来看，资产管理广泛涉及银行、证券、保险、基金、信托、期货等行业，但是具体范围并无明确界定。</p><p>资产管理提供的是代客理财服务，与储蓄产品有着本质区别：</p><ol><li>对储蓄而言，存款人与银行是债权人与债务人关系，银行必须按照约定到期偿还本金，支付利息；而对资产管理而言，投资人与管理人是委托人和受托人关系，投资人自担风险、自享收益，管理人只作为管理顾问收取一定比例的管理费。</li><li>资产管理人对于投资人的根本效用价值在于通过集合资金、组合投资，有效管理风险，获取更合理的风险回报。所获取的收益与其承担的风险相匹配。</li></ol><p>资产管理的简单总结如下图：</p><p><img src="/img/finance/financial_asset_management.png" alt="金融资产管理总结"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 金融 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《金融学》读书笔记——金融市场总结</title>
      <link href="2018/08/05/financial-market/"/>
      <url>2018/08/05/financial-market/</url>
      
        <content type="html"><![CDATA[<p>金融市场和金融机构作为金融的<strong>微观运作载体</strong>，也是人们日常生活中接触最多的内容。下面总结一点《金融学》学习过程中总结的笔记。</p><p>什么是金融市场？</p><ul><li>广义的金融市场：是货币借贷、资金融通、买卖票据和有价证券等所有金融交易活动的总称，包括直接融资和间接融资在内的所有金融投融资活动。</li><li>狭义的金融市场：专指以<strong>金融工具</strong>为载体的交易活动，即直接融资和金融投资活动。</li></ul><p>金融的两大投资：</p><ul><li>产业投资：投资于<strong>实体经济</strong>的活动，如投资于工业、农业、服务业等，这些投资最后会形成各种各样的固定资产和流动资产，通过生产经营会产品利润，从而给投资者带来相应的回报。产业投资是最基本、最重要的投资，是经济发展的根基和利润的源泉。</li><li>金融投资：以<strong>金融资产</strong>为标的物的投资活动，如买卖股票、债券、外汇等的投资活动。与产业投资相比，金融投资具有流动性强、交易成本低、风险和收益相对较高的特点。</li></ul><p>金融市场的特点：</p><ul><li>以资金为交易对象，借助<strong>金融工具</strong>完成交易。</li><li>交易之间不单纯是买卖关系，更主要的是<strong>信用关系</strong>，体现了货币所有权和使用权相分离的原则。</li><li>可以是有形市场，也可以是无形市场。</li></ul><p>金融市场的功能：</p><ul><li>资产配置与转化</li><li>价格发现</li><li>风险分散和规避</li><li>宏观调控传导</li></ul><p>总结：</p><ul><li>金融市场理论是现代金融学最前沿和最核心的内容。</li><li>金融市场是资金供求双方借助<strong>金融工具</strong>以一定的价格进行各种<strong>投融资活动</strong>的场所。</li><li><strong>投融资需求</strong>是金融市场产生和发展的基础。</li><li>金融市场的交易对象主要是<strong>金融工具</strong>，<strong>金融资产价格</strong>是市场交易最敏感的因素。</li><li><strong>利率、汇率</strong>和<strong>金融资产价格</strong>是金融市场交易最主要的价格机制。</li><li>各经济主体都可以通过金融市场利用相应的<strong>信用</strong>形式进行投融资活动。</li></ul><h1 id="金融市场的分类"><a href="#金融市场的分类" class="headerlink" title="金融市场的分类"></a>金融市场的分类</h1><p><img src="/img/finance/financial_market_classification.png" alt="金融市场的构成要素"></p><h1 id="金融市场的构成要素"><a href="#金融市场的构成要素" class="headerlink" title="金融市场的构成要素"></a>金融市场的构成要素</h1><p>金融市场的构成三要素如下：</p><ul><li>市场参与者</li><li>金融工具</li><li>金融交易的组织形式</li></ul><p><img src="/img/finance/financial_market_components.png" alt="金融市场的构成要素"></p><h2 id="市场参与者"><a href="#市场参与者" class="headerlink" title="市场参与者"></a>市场参与者</h2><p>金融市场的参与者主要包括政府、中央银行、金融机构、个人和企业。</p><h3 id="政府"><a href="#政府" class="headerlink" title="政府"></a>政府</h3><h3 id="中央银行"><a href="#中央银行" class="headerlink" title="中央银行"></a>中央银行</h3><p>中央银行被称为银行的银行。如果把每家商业银行看作一家分行，央行相当于总行。</p><p>对于商业银行来说，中央银行扮演了三个角色：</p><ul><li>第一个角色，<strong>监管人</strong>。商业银行必须把吸纳的一部分存款，存到央行，称为<strong>存款准备金</strong>。</li><li>中央银行的第二个角色是，<strong>金融中心</strong>。商业银行之间转账，只需要在双方的央行准备金账户上增减数字，不需要实际转移资金。央行充当了<strong>交易清算的处理中心</strong>。 </li><li>央行的第三个角色是，<strong>最终贷款人</strong>。如果一家商业银行没有足够的资金，可以进行银行间同业拆借（参考：<a href="http://www.shibor.org/" target="_blank" rel="noopener">shibor</a>，上海银行间同业拆放利率，Shanghai Interbank Offered Rate）；如果其它商业银行也没有足够的资金，他们有一个最终的求助对象，那就是央行。求助的途径有两个：<ul><li><strong>再贷款</strong>，即商业银行向央行寻求贷款；</li><li><strong>再贴现</strong>，即商业银行把手中没有到期的票据卖给央行。</li></ul></li></ul><p>央行通过三大<strong>货币政策工具</strong>，最终决定全社会货币量：</p><ul><li><p>首先，央行通过<strong>再贷款和再贴现</strong>，可以扩大商业银行系统的贷款和投资规模，从而增加货币数量。</p></li><li><p>其次，央行通过<strong>存款准备金率</strong>，设定了商业银行贷款和投资额度的上限，也就为货币的派生数量设定了上限。银行<a href="http://finance.sina.com.cn/zl/china/2020-02-14/zl-iimxyqvz2821700.shtml" target="_blank" rel="noopener">贷款派生存款（货币）</a>过程如下：</p><blockquote><p>存款生贷款、贷款生存款，循环派生，但是每次新增贷款的数量都在减少，最终派生的货币数量会有上限，即创造的货币数量会有上限，它是初始存款金额的一个倍数，称为「<a href="https://wiki.mbalib.com/wiki/%E6%B4%BE%E7%94%9F%E5%AD%98%E6%AC%BE%E4%B9%98%E6%95%B0" target="_blank" rel="noopener">派生倍数</a>」，计算公式：<code>1 / 准备金率</code>。例如：100W / 20% = 500W，即 100W 的存款，理论上最多创造出 400W 货币，派生过程如下：</p><p>80</p><p>64</p><p>51.2</p><p>40.96</p><p>32.768</p><p>26.2144</p><p>20.97152</p><p>16.777216</p><p>13.4217728</p><p>10.73741824</p><p>…</p><p>可见，存款准备金率和派生货币量存在反比关系。</p></blockquote></li><li><p>最后，央行还可以通过<strong>公开市场操作（OMO）</strong>，影响商业银行体系的准备金数量，进而调节货币数量。（在多数发达国家，公开市场操作是中央银行吞吐基础货币，调节市场流动性的主要货币政策工具。）</p></li></ul><p><img src="/img/finance/monetary_policy_tool.png" alt="货币政策工具"></p><p>参考：</p><ul><li><a href="https://wiki.mbalib.com/wiki/Category:%E4%B8%89%E5%A4%A7%E8%B4%A7%E5%B8%81%E6%94%BF%E7%AD%96%E5%B7%A5%E5%85%B7" target="_blank" rel="noopener">三大货币政策工具</a></li><li><a href="https://core.ac.uk/download/pdf/41434451.pdf" target="_blank" rel="noopener">国内外货币政策工具的差异性之比较分析</a></li></ul><h3 id="金融机构"><a href="#金融机构" class="headerlink" title="金融机构"></a>金融机构</h3><p>金融机构是金融市场上最重要的<strong>中介机构</strong>，它的作用较为特殊：</p><ol><li>它是金融市场上最重要的中介机构，是储蓄转化为投资的重要渠道。</li><li>金融机构在金融市场上充当资金的供给者、需求者和中间人等<strong>多重角色</strong>，它既发行、创造<strong>金融工具</strong>，也在市场上购买各类金融工具。既是金融市场的中介人，也是金融市场的投资者、货币政策的传递者和承受者。</li><li>金融机构作为<strong>机构投资者</strong>在金融市场具有支配性的作用。</li></ol><p>金融机构的主要功能如下：</p><ul><li>便利支付结算</li><li>促进资金融通</li><li>降低交易成本</li><li>改善信息不对称</li><li>转移与管理风险</li><li>创造信用与存款货币</li></ul><p>金融机构的经营体制有两种：</p><ul><li><strong>分业经营</strong>，即对金融机构业务范围进行某种程度的分离管制。</li><li><strong>混业经营</strong>，即允许各类金融机构业务范围有交叉，可以进行综合经营的金融制度。</li></ul><p>两种经营体制存在的争论如下：</p><ul><li>对金融机构稳健经营的影响？</li><li>混业经营是否会产生利益冲突？</li><li>加强竞争和提高效率方面的比较？</li><li>规模经济和范围经济优势的比较？</li></ul><p>由于金融机构是如此重要，因此国家需要进行重点监管，避免出现系统性风险，下图我画了一张图总结中国的金融监管体系和金融机构体系：</p><p><img src="/img/finance/financial_regulation_and_institution.jpg" alt="中国的金融监管体系和金融机构体系"></p><p>上图主要采用 IMF 的统计分类法，其将金融机构分为：</p><ul><li>存款类金融机构：以<strong>吸收存款</strong>作为资金主要来源，以<strong>发放贷款</strong>为主要的资金运用方式，以办理转账结算为主要中间业务，参与存款货币创造的金融机构，也称银行业金融机构。</li><li>非存款类金融机构：以发行<strong>金融工具</strong>或<strong>签订契约</strong>等方式获得资金，通过特定的方式运营这些资金，也称非银行类金融机构。</li></ul><p>其中，<strong>商业银行</strong>作为存款类金融机构中最具代表性和占比最大的机构，其特点与主要业务如下：</p><p><img src="/img/finance/commercial_bank.png" alt="商业银行"></p><h3 id="个人居民"><a href="#个人居民" class="headerlink" title="个人居民"></a>个人居民</h3><p>个人居民是金融市场上主要的<strong>资金供给者</strong>。个人居民为了预防未来支出的不确定性或出于节俭等目的。将收入的一部分用于储蓄。不少个人居民动用储蓄资金投资于股票、债券、基金等资本市场工具，投资于保险市场或参与黄金市场交易。组合其金融资产，实现风险和收益的最佳匹配。个人居民投资者是金融市场供求均衡的重要力量。</p><h2 id="金融工具"><a href="#金融工具" class="headerlink" title="金融工具"></a>金融工具</h2><p>金融工具是金融市场上进行交易的载体。金融工具最初被称为<strong>信用工具</strong>，是证明债权债务关系并据以进行货币资金交易的合法<strong>凭证</strong>。金融工具是<strong>法律契约</strong>，交易双方的权利和义务受法律保护。</p><p>金融工具一般具有广泛的社会可接受性，随时可以流通转让。不同的金融工具具有不同的特点，能分别满足资金供需双方在数量、期限和条件等方面的不同需要，在不同的市场上为不同交易者服务。</p><p>金融工具的四个特征：</p><ul><li>法律性</li><li>流动性</li><li>收益性</li><li>风险性</li></ul><p>金融工具的分类方法如下：</p><p><img src="/img/finance/financial_instrument_classification.png" alt="金融工具的分类方法"></p><p>在金融市场上，资金的供给者通过投资<strong>金融工具</strong>获得各种类型的<strong>金融资产</strong>。金融资产是代表未来收益或资产合法要求权的<strong>凭证</strong>，标示了明确的价值，表明了交易双方的所有权关系和债权关系。</p><h2 id="金融交易的组织形式"><a href="#金融交易的组织形式" class="headerlink" title="金融交易的组织形式"></a>金融交易的组织形式</h2><p>金融交易的组织形式是指组织金融工具交易时采用的方式。受市场本身的发育程度、交易技术的发达程度、交易双方的交易意愿影响。<br>目前场内市场与场外市场之间的截然划分已经不复存在，出现了多层次的证券市场结构。很多传统意义上的场外市场由于报价商和电子撮合系统的出现而具有了集中交易特征，证券交易所市场也开始逐步推出兼容场外交易的交易组织形式，场内市场和场外市场的物理界限逐渐模糊。<br>如今，场内市场和场外市场的概念逐步演变为风险分层管理的概念，即不同层次市场按照上市品种的风险大小，通过对上市或挂牌条件、信息披露制度、交易结算制度、证券产品设计以及投资者约束条件等做出差异化安排，实现了资本市场交易产品的风险纵向分层。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《金融学》——李健</p><p>《<a href="http://www.cbrc.gov.cn/chinese/jrjg/index.html" target="_blank" rel="noopener">国内银行业金融机构</a>》</p><p>《<a href="http://baijiahao.baidu.com/s?id=1603128633482367977" target="_blank" rel="noopener">17家民营银行大盘点</a>》</p><p>《<a href="https://www.zhihu.com/question/41235539" target="_blank" rel="noopener">债权转让和收益权转让的区别？</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 金融 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 的一些使用总结</title>
      <link href="2018/07/29/java-idea/"/>
      <url>2018/07/29/java-idea/</url>
      
        <content type="html"><![CDATA[<p>年初也转投 IDEA 阵营了，相比 Eclipse 确实顺畅很多，尤其是多开项目的时候，已经有种回不去的感觉了。这里介绍一些两个 IDE 之间的区别。</p><h1 id="版本选择"><a href="#版本选择" class="headerlink" title="版本选择"></a>版本选择</h1><p>首先是 IDEA 版本的选择，建议使用 Community 社区免费版即可，对比 Ultimate 收费版并无太大区别。都支持 Java、Maven、Git 等基本功能。但社区版会少了一些插件，例如 Spring Initializr。</p><p>版本区别详见：<a href="https://www.jetbrains.com/idea/features/editions_comparison_matrix.html" target="_blank" rel="noopener">https://www.jetbrains.com/idea/features/editions_comparison_matrix.html</a></p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>其次创建项目，需要了解 IDEA 的 Project 和 Module 两个概念：</p><ul><li>IntelliJ 系中的 Module 相当于 Eclipse 系中的 Project；</li><li>IntelliJ 系中的 Project 相当于 Eclipse 系中的 Workspace。可以选择创建一个 Empty project without modules，之后再放入同一类型的 module 集合，此时只会生成一个 .idea 目录。也可以选择直接创建某一类型的 Project，如 Maven Project，此时需要添加 Maven 项目信息，完成后会生成 pom.xml、src 目录、*.iml。</li></ul><p>最后尝试新建一个 HelloWorld 示例项目，<code>.idea</code> 文件夹和 <code>HelloWorld.iml</code> 是 IDEA 帮助我们建立的辅助文件夹和文件，类似于 Eclipse 在我们的 Workspace 下建立的 <code>.settings</code> 文件夹和 <code>.classpath</code> 、<code>.project</code> 文件。 </p><p><img src="/img/java/idea/hello_world.png" alt="IDEA Hello World"></p><p>Project 作为工作空间可以自由切换、多开，从 File &gt; Open Recent 中选择即可。</p><h1 id="配置-Tomcat"><a href="#配置-Tomcat" class="headerlink" title="配置 Tomcat"></a>配置 Tomcat</h1><p>1、下载 Tomcat</p><p>2、IDEA 新建 Tomcat（Run &gt; Edit Configurations）</p><p><img src="/img/java/idea/add_new_tomcat_server_config.png" alt="add_new_tomcat_server_config"></p><p>3、新建完毕，配置本地 Tomcat 安装目录：</p><p><img src="/img/java/idea/tomcat_server_config.png" alt="tomcat_server_config"></p><p>4、配置端口号、必要的 VM options：</p><p><img src="/img/java/idea/tomcat_server_config2.png" alt="tomcat_server_config2"></p><p>5、配置运行项目，配置上下文：</p><p><img src="/img/java/idea/deployment.png" alt="deployment"></p><h1 id="创建-java-resource-目录"><a href="#创建-java-resource-目录" class="headerlink" title="创建 java/resource 目录"></a>创建 java/resource 目录</h1><p><code>Ctrl+Alt+Shift+S</code>，打开 Project Structure &gt; Modules：</p><p><img src="/img/java/idea/project_structure_modules.png" alt="Project Structure &gt; Modules"></p><h1 id="场景演示"><a href="#场景演示" class="headerlink" title="场景演示"></a>场景演示</h1><p>以特性开发与合版这个场景为例，看下如何利用 IDEA 完成整个流程：</p><h2 id="特性开发"><a href="#特性开发" class="headerlink" title="特性开发"></a>特性开发</h2><p>第一步，本地建一个工作目录，以特性名称命名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir feature-xxx</span><br></pre></td></tr></table></figure><p>第二步，从远程仓库 <code>clone</code> 该特性涉及的所有模块到该工作目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> !$</span><br><span class="line">$ git <span class="built_in">clone</span> module1</span><br><span class="line">$ git <span class="built_in">clone</span> moduleN</span><br></pre></td></tr></table></figure><p>第三步，新建 Project。打开 IDEA，File &gt; New &gt; Project from Existing Sources… &gt; 选择该工作目录，并按如下操作：</p><p><img src="/img/java/idea/import_module.png" alt="Import Module"></p><p><img src="/img/java/idea/import_module_search_for_projects_recursively.png" alt="Import Module"></p><p>第四步，开始特性开发，批量从 master 分支 <code>checkout</code> 创建出特性分支 <code>feature-xxx</code>。并批量修改 <code>pom.xml</code> 的版本号：</p><p><img src="/img/java/idea/new_branch.png" alt="new_branch"></p><h2 id="特性合版"><a href="#特性合版" class="headerlink" title="特性合版"></a>特性合版</h2><p>第一步，项目管理员创建发布分支，根据本次发布周期涉及的所有特性，批量从 master 分支 <code>checkout</code> 创建出发布分支 <code>release-xxx</code>（操作同上）。该操作只能由项目管理员操作，因为 <code>release-*</code> 是受保护分支。</p><p>第二步，升级 <code>pom.xml</code> 版本号并推送。</p><p>第三步，批量 <code>merge</code> 特性分支：</p><p><img src="/img/java/idea/merge_into_current.png" alt="merge_into_current"></p><p>第四步，解决冲突（例如 <code>pom.xml</code> 版本号冲突、代码冲突，如有）：</p><p><img src="/img/java/idea/conflicts.png" alt="conflicts"></p><p><img src="/img/java/idea/version_control_local_changes.png" alt="version_control_local_changes"></p><p>第五步，合版完毕，<code>Ctrl+K</code> 批量提交并推送到远程分支 <code>release-xxx</code> 即可。</p><h1 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h1><p>File &gt; Other Setting &gt; Default Settings</p><p>全局配置 IDE 的界面、编辑器、VCS、构建、终端等</p><p>File &gt; Other Setting &gt; Default Project Structure</p><p>全局配置项目的 SDK 版本、类库等。</p><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>File &gt; Other Setting &gt; Default Settings，<code>Projects SDK</code> 可控制全局版本，<code>Language Level</code> 可控制语言级别，方便使用其特性。配置后全部 project modules 都会生效。</p><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>File &gt; Other Setting &gt; Default Settings &gt; Build, Execution, Deployment &gt; Build Tools &gt; Maven</p><ul><li><p>可配置 <code>Maven home directory</code>、<code>User settings file</code> (自定义 setting.xml)、<code>Local repository</code> 本地仓库。</p></li><li><p>自动下载源码：Importing，找到<code>Automatically download</code> 并勾选 <code>Sources</code> 和 <code>Documentation</code>，然后 reimport 即可。</p></li></ul><h2 id="Terminal"><a href="#Terminal" class="headerlink" title="Terminal"></a>Terminal</h2><p>File &gt; Other Setting &gt; Default Settings &gt; Terminal，修改 <code>Shell path</code> 为：<code>D:\Developer\PortableGit\bin\sh.exe</code>，可配置 Terminal 终端为 GitBash。</p><h2 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h2><p>调整完当前窗口的布局之后，可以保存当前的窗口布局，以便全局生效：Window &gt; Store Current Layout as Default</p><h2 id="Code-Template"><a href="#Code-Template" class="headerlink" title="Code Template"></a>Code Template</h2><p>File &gt; Other Setting &gt; Default Settings &gt; 搜索 File and Code Templates，打开 Includes &gt; File Header，配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;&#x2F;p&gt;</span><br><span class="line"> *</span><br><span class="line"> * @author abc@xyz.com</span><br><span class="line"> * @since $&#123;DATE&#125;</span><br><span class="line"> **&#x2F;</span><br></pre></td></tr></table></figure><h2 id="Auto-Import"><a href="#Auto-Import" class="headerlink" title="Auto Import"></a>Auto Import</h2><p>File &gt; Settings &gt; Editor &gt; General &gt; Auto Import，然后勾选：</p><p><code>Add unambiguous imports on the fly</code>：快速添加明确的导入。</p><p><code>Optimize imports on the fly</code>：快速优化导入，优化的意思即自动帮助删除无用的导入。</p><h2 id="Quick-documentation"><a href="#Quick-documentation" class="headerlink" title="Quick documentation"></a>Quick documentation</h2><p>File &gt; Settings &gt; Editor &gt; General &gt; 开启 <code>Show quick documentation on mouse move</code>，可用于鼠标放到类、方法、变量上时显示完整 java doc 注释</p><h2 id="Show-tabs-in-one-row"><a href="#Show-tabs-in-one-row" class="headerlink" title="Show tabs in one row"></a>Show tabs in one row</h2><p>File &gt; Settings &gt; Editor &gt; General &gt; Editor Tabs，去掉勾选 <code>Show tabs in one row</code></p><h1 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h1><p>老版本可以<a href="https://www.jetbrains.com/lp/mono/#how-to-install" target="_blank" rel="noopener">安装 JetBrains Mono 字体</a>，v2019.3 版本后自带。</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>官方插件（内置）：</p><ul><li>Maven Integration：官方 Maven 插件，参考：<a href="/2018/05/01/maven-build-lifecycle/">IDEA Maven 插件</a></li><li>JUnit：快速创建、运行、查看单元测试，在单元测试和目标之间跳转。</li></ul><p>官方插件（需安装）：</p><ul><li>IdeaVim：Vim 程序员必装。</li><li>NodeJS：运行前端项目、or 构建前端项目时都是需要的。</li></ul><p>规范类：</p><ul><li>Alibaba Java Coding Guidelines：阿里巴巴 Java 开发规范</li><li>Git Commit Template：参考<ul><li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Git 代码提交规范</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247498589&idx=1&sn=c0419f08bd455de9147e47387778943e" target="_blank" rel="noopener">如何规范你的Git commit？</a></li></ul></li></ul><p>代码生成类：</p><ul><li>Lombok Plugin：用于精简冗余代码，必装。</li><li><a href="https://plugins.jetbrains.com/plugin/6585-builder-generator" target="_blank" rel="noopener">Builder-Generator</a>：如果项目可以使用 Lombok，就不必装。</li></ul><p>MyBatis：</p><ul><li><del><a href="https://plugins.jetbrains.com/plugin/7293-mybatis-plugin" target="_blank" rel="noopener">MyBatis Plugin</a>：最强大的 MyBatis 插件，不过是收费版。</del></li><li>Free MyBatis plugin：免费的 MyBatis 插件，提供了一些基本的跳转和代码生成功能。</li><li>MyBatis Log Plugin：把 MyBatis 输出的 SQL 日志还原成完整的 SQL 语句。将日志输出的 SQL 语句中的问号 ? 替换成真正的参数值。</li></ul><p>辅助类：</p><ul><li>Maven Helper：方便查询依赖树及排除依赖</li><li>Grep Console：Grep, tail, filter, highlight… everything you need for a console. Also can highlight the editor - nice for analyzing logs…</li><li>SequenceDiagram for IntelliJ IDEA：查看类调用时序图</li><li>Rainbow Brackets：彩色括号</li><li>HighlightBracketPair：高亮提示括号的开始结尾</li></ul><p>其它：</p><ul><li><a href="https://plugins.jetbrains.com/plugin/8006-material-theme-ui" target="_blank" rel="noopener">Material Theme UI</a>：将默认外观改为 <a href="https://material.io/" target="_blank" rel="noopener">Material Design</a> 风格。</li><li><a href="https://plugins.jetbrains.com/plugin/9492-smart-tomcat" target="_blank" rel="noopener">Smart Tomcat</a>：社区版没有提供该功能（<a href="https://stackoverflow.com/questions/22047860/tomcat-in-intellij-idea-community-edition" target="_blank" rel="noopener">点我</a>），可以用这个插件替代，参考<a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247509848&idx=3&sn=bec775d8f6bf98027625511491ec74cf" target="_blank" rel="noopener">这篇</a>。</li><li><a href="http://kidneyball.iteye.com/blog/1814028" target="_blank" rel="noopener">Ace Jump</a>：使用这个插件，直接使用键盘定位到你想去的地方 。</li></ul><p>IdeaVim 如果与原 IDEA 快捷键冲突，可以修改如下：</p><p><img src="/img/java/idea/IdeaVim.png" alt="IdeaVim"></p><p>如果被墙导致无法连接到 Marketplace 或插件无法下载，可以配置如下：</p><p><img src="/img/java/idea/use_secure_connection.png" alt="IDEA 无法下载插件"></p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><img src="img/java/idea/git_branch_management.png" alt="git branch management"></p><table><thead><tr><th>分支操作</th><th>对应命令</th></tr></thead><tbody><tr><td>Checkout</td><td><code>git checkout [selected-branch]</code></td></tr><tr><td>New Branch from Selected…</td><td><code>git checkout -b [new-branch] [selected-branch]</code></td></tr><tr><td>Checkout and Rebase onto Current</td><td><code>git rebase HEAD [selected-branch]</code></td></tr><tr><td>Rebase Current onto Selected</td><td><code>git rebase [selected-branch]</code></td></tr><tr><td>Merge into Current</td><td><code>git merge [selected-branch]</code></td></tr><tr><td>Delete</td><td><code>git branch -d [selected-branch]</code></td></tr></tbody></table><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><h2 id="自定义-keymap"><a href="#自定义-keymap" class="headerlink" title="自定义 keymap"></a>自定义 keymap</h2><p>自定义快捷键，例如我配置了：</p><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>Close</td><td><code>Alt+W</code></td></tr><tr><td>Hide All Tool Windows</td><td><code>Alt+M</code></td></tr><tr><td>Delete Line</td><td><code>Alt+D</code></td></tr><tr><td>Redo</td><td><code>Ctrl+Y</code></td></tr><tr><td>Rename</td><td><code>Alt+R</code></td></tr><tr><td>Completion</td><td><code>Alt+/</code></td></tr></tbody></table><h2 id="VCS"><a href="#VCS" class="headerlink" title="VCS"></a>VCS</h2><p>Git 自定义快捷键：</p><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>Reset HEAD</td><td><code>Ctrl+Alt+Q</code></td></tr><tr><td>Annotate（git blame）</td><td><code>Ctrl+Alt+1</code></td></tr><tr><td>Compare with the Same Repository Version</td><td><code>Ctrl+Alt+2</code></td></tr><tr><td>Show History</td><td><code>Ctrl+Alt+3</code></td></tr><tr><td>Commit File</td><td><code>Ctrl+Alt+4</code></td></tr><tr><td>PULL</td><td><code>Ctrl+Alt+5</code></td></tr></tbody></table><p>Git 默认的其它命令：</p><table><thead><tr><th>功能</th><th>快捷键</th></tr></thead><tbody><tr><td>Add</td><td><code>Ctrl+Alt+A</code></td></tr><tr><td>Revert Changes 回退更改</td><td><code>Ctrl+Alt+Z</code></td></tr><tr><td>Commit Changes 提交更改</td><td><code>Ctrl+K</code></td></tr><tr><td>Push Commits 推送</td><td><code>Ctrl+Shift+K</code></td></tr><tr><td>Update Project（批量 git pull）</td><td><code>Ctrl+T</code></td></tr></tbody></table><h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><blockquote><p>Alt + Insert 创造万物</p></blockquote><h2 id="查找-替换类"><a href="#查找-替换类" class="headerlink" title="查找/替换类"></a>查找/替换类</h2><blockquote><p>Ctrl + F 在当前文件中查找（关键字）</p><p>Ctrl + R 在当前文件中替换（关键字）</p><p>Ctrl + Shift + F 在路径中查找（关键字）</p><p>Ctrl + Shift + R 在路径中替换（关键字）</p></blockquote><h2 id="浏览类"><a href="#浏览类" class="headerlink" title="浏览类"></a>浏览类</h2><blockquote><p>Ctrl+N 查找类</p><p>Ctrl+Shift+N 查找文件</p><p>Shift+Shift 查找所有（包括类、资源、配置项、方法等等）</p></blockquote><blockquote><p>Ctrl+E 最近打开的文件</p><p>Alt+F7 查找引用（Find Usage）</p><p>Ctrl+Shift+Backspace 回到上次修改的地方</p><p>Ctrl+Alt+Left/Right 返回/前进至上次浏览的位置</p><p>Ctrl+鼠标左键：打开接口（Declaration）</p><p>Ctrl+Alt+鼠标左键：打开实现（Implementation(s)）</p></blockquote><blockquote><p>Ctrl+H 打开类层次窗口（继承关系）</p><p>Ctrl+F12 查看当前类的所有方法</p><p>Ctrl+Alt+U 类关系图、Maven关系图</p></blockquote><h2 id="编辑类"><a href="#编辑类" class="headerlink" title="编辑类"></a>编辑类</h2><blockquote><p>Ctrl+D 复制行</p><p>Ctrl+Y 删除行</p><p>Alt+Shift+向上箭头 Move Line Up</p><p>Alt+Shift+向下箭头 Move Line Down</p><p>Ctrl+Shift+U 大小写转换</p><p>Ctrl+Alt+L 格式化代码</p><p>Ctrl+W、Ctrl+Shift+W 这个动作的实际操作是选中更上一层的语法结构。例如，如果你在一个字符串的一个单词中，按一下Ctrl+W，会选中光标所在单词。再按一下，会选中整个字符串的内容，不包括引号。再按一下，会选中包括引号的字符串。再按一下，会选中整个表达式（如果表达式含有括号，会逐层选中）。再按一下，会选中整个语句块。再按一下，会选中整个方法。再按一下，会选中整个类。</p></blockquote><h2 id="重构类"><a href="#重构类" class="headerlink" title="重构类"></a>重构类</h2><blockquote><p>// Ctrl+Alt+Shift+T 重构菜单</p><p>// Ctrl+f6 修改类\方法签名<br><a href="https://www.jetbrains.com/help/idea/change-class-signature.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/idea/change-class-signature.html</a></p><p>// F6 Move 类、方法、变量移动</p><p>// Ctrl+Shift+f6 重构变量的类型</p><p>// Shift+f6 重命类、方法、变量</p><p>// Ctrl+Alt+C 提取常量<br>// Ctrl+Alt+V 提取变量<br>// Ctrl+Alt+F 提取成员变量<br>// Ctrl+Alt+P 提取方法入参</p><p>// Refactor | Generify 泛型自动补全<br>// Refactor | Invert Boolean 布尔类型取反<br>// Refactor | Make Static 将类、方法设置成静态<br>// Refactor | Find and Replace Code Duplicates</p><p>// Safe Delete 安全删除</p><p>// Ctrl+Alt+M 方法提取<br>// Ctrl+alt+N 方法内联(变量\方法\构造函数)<br><a href="https://www.jetbrains.com/help/idea/inline.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/idea/inline.html</a></p><p>// Pull Members Up 将方法提升到父类<br>// Pull Members Down 将方法推迟到之类</p></blockquote><h2 id="调试类"><a href="#调试类" class="headerlink" title="调试类"></a>调试类</h2><blockquote><p>调试：F7/F8/F9 分别对应 Step into，Step over，Continue。</p><p>运行：Alt+Shift+F10 运行程序，Shift+F9 启动调试，Ctrl+F2 停止。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/img/java/idea/keymap.png" alt="IDEA 快捷键"></p><p>摘录 10 个最常用的快捷键：</p><blockquote><p>Top #10切来切去：Ctrl+Tab</p><p>Top #9选你所想：Ctrl+W</p><p>Top #8代码生成：Template/Postfix +Tab</p><p>Top #7发号施令：Ctrl+Shift+A</p><p>Top #6无处藏身：Shift+Shift</p><p>Top #5自动完成：Ctrl+Shift+Enter</p><p>Top #4创造万物：Alt+Insert</p><p>Top #3智能补全：Ctrl+Shift+Space</p><p>Top #2自我修复：Alt+Enter</p><p>Top #1重构一切：Ctrl+Shift+Alt+T</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>下载地址：<br><a href="http://www.jetbrains.com/idea/download/#section=windows" target="_blank" rel="noopener">http://www.jetbrains.com/idea/download/#section=windows</a></p><p>插件：<br><a href="https://plugins.jetbrains.com/idea" target="_blank" rel="noopener">https://plugins.jetbrains.com/idea</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247488006&idx=1&sn=d5c66d84724b1deebac6604749d04bf5&chksm=ebd62d2adca1a43cb136b5740621e25854537054b9b3cac7451fd21ea55c0fc247e07a49d8cd&mpshare=1&scene=23&srcid=#rd" target="_blank" rel="noopener">常用插件推荐</a></p><p>IDEA 重构官方文档：<br><a href="https://www.jetbrains.com/help/idea/refactoring-source-code.html" target="_blank" rel="noopener">https://www.jetbrains.com/help/idea/refactoring-source-code.html</a></p><p>IDEA 高级调试技巧：</p><p><a href="http://www.mamicode.com/info-detail-1761996.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-1761996.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 加密篇之算法总结</title>
      <link href="2018/06/01/java-cryptography-api/"/>
      <url>2018/06/01/java-cryptography-api/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/security/encryption_algorithm.png" alt="encryption_algorithm"></p><h1 id="单向加密"><a href="#单向加密" class="headerlink" title="单向加密"></a>单向加密</h1><p>单向加密又称为不可逆加密算法，其密钥是由加密散列函数生成的。单向散列函数一般用于产生消息摘要，密钥加密等。</p><p>例如下图摘要由 <code>SHA-1</code> 生成。<code>SHA1</code> 摘要长度为 20 Bytes (160 bit)，一般用 40 位十六进制数表示（1 Byte = 8 bit，4 bit (2^4) = 1 位十六进制数，因此 160 bit / 4 = 40 位十六进制数表）：</p><p><img src="/img/security/digest.png" alt="digest"></p><h1 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h1><p><img src="/img/security/symmetric_encryption.png" alt="symmetric_encryption"></p><h1 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h1><p>数字签名作为维护数据信息安全的重要方法之一，可以解决伪造、抵赖、冒充和篡改等问题。其主要作用体现在以下几个方面：</p><ul><li>防冒充（身份认证）。在数字签名中，当使用私钥签名时，如果接收方或验证方用其公钥进行验证并获通过，那么可以肯定，签名人就是拥有私钥的那个人，因为私钥只有签名人拥有，其他人不可能冒充签名者。</li><li>防伪造。其他人不能伪造对数据的签名，因为私钥只有签名者自己拥有，所以其他人不可能构造出正确的签名结果数据。</li><li>防篡改。私钥加签后的摘要和数据一起发送给接收者，一旦信息被篡改，接收者可通过计算摘要和验证签名来判断该文件无效，从而保证了文件的完整性。</li><li>防抵赖。数字签名既可以作为身份认证的依据，也可以作为签名者签名操作的证据。要防止接收者抵赖，可以在数字签名系统中要求接收者返回一个自己签名的表示收到的报文，给发送者或受信任第三方。如果接收者不返回任何消息，此次通信可终止或重新开始，签名方也没有任何损失，由此双方均不可抵赖。</li><li>保密性。手写签字的文件一旦丢失，文件信息就极可能泄露。但在网络传输中，数字签名的公钥可以用于加密报文，以保证信息机密性。</li></ul><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>公钥加密，私钥解密</p><p><img src="/img/security/asymmetric_encryption.png" alt="asymmetric_encryption"></p><h2 id="签名验签"><a href="#签名验签" class="headerlink" title="签名验签"></a>签名验签</h2><p>私钥签名，公钥验签</p><p><img src="/img/security/sign.png" alt="sign"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行业政策法规汇总</title>
      <link href="2018/05/28/law-and-regulations/"/>
      <url>2018/05/28/law-and-regulations/</url>
      
        <content type="html"><![CDATA[<p>日常工作中，经常需要关注互金及支付行业相关的政策法规及最新动向，本文整理了相关的资料，以供集中查阅，后续会持续更新：</p><h1 id="央行支付类"><a href="#央行支付类" class="headerlink" title="央行支付类"></a>央行支付类</h1><table><thead><tr><th>编号</th><th>文件</th><th>解读</th><th>时间</th></tr></thead><tbody><tr><td>261 号文</td><td>《中国人民银行关于加强支付结算管理防范电信网络新型违法犯罪有关事项的通知》</td><td><a href="http://www.sinotf.com/GB/News/1001/2016-11-15/2NMDAwMDIxMzk2NQ.html" target="_blank" rel="noopener">点我</a></td><td>2016.09.30 发布，2016.12.1 起实行</td></tr><tr><td>302 号文</td><td>《中国人民银行关于落实个人银行账户分类管理制度的通知》</td><td><a href="http://zhuanlan.cebnet.com.cn/20161126/102339299.html" target="_blank" rel="noopener">点我</a></td><td>2016.11.25 晚间紧急发布</td></tr><tr><td>296 号文</td><td>《中国人民银行关于印发《条码支付业务规范（试行）》的通知》</td><td><a href="https://www.sohu.com/a/213288138_208700" target="_blank" rel="noopener">点我</a></td><td>2017.12.25</td></tr><tr><td>217 号文</td><td>《关于进一步加强无证经营支付业务整治工作的通知》</td><td><a href="http://baijiahao.baidu.com/s?id=1586747705978560129&wfr=spider&for=pc" target="_blank" rel="noopener">点我</a></td><td>2017</td></tr><tr><td>281 号文</td><td>《关于规范支付创新业务通知》</td><td><a href="http://www.zfzj.cn/portal.php?mod=view&aid=782" target="_blank" rel="noopener">点我</a></td><td>2017</td></tr></tbody></table><h1 id="互联网金融"><a href="#互联网金融" class="headerlink" title="互联网金融"></a>互联网金融</h1><h2 id="全国性综合法律规范指引"><a href="#全国性综合法律规范指引" class="headerlink" title="全国性综合法律规范指引"></a>全国性综合法律规范指引</h2><table><thead><tr><th>文件</th><th>发文部门</th><th>发布时间</th></tr></thead><tbody><tr><td>《关于开展 P2P 网络借贷机构合规检查工作的通知》</td><td>P2P 网贷风险专项整治工作领导小组办公室</td><td>2018.08.13</td></tr><tr><td>《网络借贷信息中介机构合规检查问题清单》</td><td>P2P 网贷风险专项整治工作领导小组办公室</td><td>2018.08.13</td></tr><tr><td>《互联网金融个体网络借贷电子合同安全规范》</td><td>中国互联网金融协会</td><td>2018.04.23</td></tr><tr><td>《互联网金融逾期债务催收自律公约（试行）》</td><td>中国互联网金融协会</td><td>2018.03.28</td></tr><tr><td>《关于做好 P2P 网络借贷风险专项整治改验收工作的通知》</td><td>P2P 网贷风险专项整治工作领导小组办公室</td><td>2017.12.13</td></tr><tr><td>《小额贷款公司网络业务风险专项整治实施方案》</td><td>P2P 网贷风险专项整治工作领导小组办公室</td><td>2017.12.08</td></tr><tr><td>《互联网金融个体络借贷资存管业务规范》</td><td>中国互联网金融协会</td><td>2017.12.07</td></tr><tr><td>《关于规范整顿 “现金贷 ”业务的通知》</td><td>P2P 网贷风险专项整治工作领导小组办公室</td><td>2017.12.01</td></tr><tr><td>《互联网金融个体网络借贷 借贷合同要素》</td><td>中国互联网金融协会</td><td>2017.09.21</td></tr></tbody></table><h2 id="地方性法律法规"><a href="#地方性法律法规" class="headerlink" title="地方性法律法规"></a>地方性法律法规</h2><p>广东省</p><table><thead><tr><th>文件</th><th>发布时间</th></tr></thead><tbody><tr><td>广州市网络借贷信息中介机构业务退出指引（试行）</td><td>2018.07.30</td></tr><tr><td>广州互联网金融协会发布《关于下架计划类理财产品及打击逃废债行为的通知》</td><td>2018.07.27</td></tr><tr><td>深圳市关于积极稳妥应对当前 P2P 行业流动性风险及做好退出工作的通知</td><td>2018.07.13</td></tr><tr><td>广州市网络借贷信息中介机构整改验收工作方案</td><td>2018.03.21</td></tr><tr><td>广东省《关于贯彻落实网络借贷信息中介机构业务活动管理暂行办法的通知》</td><td>2018.02.11</td></tr><tr><td>广东省《网络借贷中介机构现场检查细则（ 征求意见稿）》</td><td>2017.12.26</td></tr><tr><td>深圳市网络借贷信息中介机构业务退出指引</td><td>2017.09.29</td></tr><tr><td>深圳市网络借贷信息中介机构备案登记管理办法（征求意见稿）</td><td>2017.07.03</td></tr></tbody></table><p>北京市</p><table><thead><tr><th>文件</th><th>发布时间</th></tr></thead><tbody><tr><td>北京市网络借贷信息中介机构业务退出指引（草案）</td><td>2018.07.20</td></tr><tr><td>北京市加强业务合规性的风险提示函</td><td>2018.07.19</td></tr><tr><td>北京互金协会：关于防范化解 北京互金协会：关于防范化解 “多头借贷 ”、“高收益转贷 ”、“羊毛党”风险的提示函</td><td>2018.04.04</td></tr></tbody></table><p>上海市</p><table><thead><tr><th>文件</th><th>发布时间</th></tr></thead><tbody><tr><td>上海市网络借贷信息中介机构业务退出指导意见（试行）</td><td>2018.08.03</td></tr><tr><td>上海市规范整顿“现金贷”业务实施方案的通知</td><td>2017.01.13</td></tr></tbody></table><p>附录</p><table><thead><tr><th>文件</th><th>发布时间</th></tr></thead><tbody><tr><td>江苏省网络借贷信息中介机构备案登记管理暂行办法(征求意见稿)</td><td>2017.12.29</td></tr><tr><td>浙江省网络借贷信息中介机构备案登记管理实施细则（试行）（征求意见稿）</td><td>2017.12.18</td></tr></tbody></table><h1 id="电子合同"><a href="#电子合同" class="headerlink" title="电子合同"></a>电子合同</h1><p>在合规备案的过程中，我主要负责了电子合同的工作。这里整理出一些相关的背景知识：</p><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p><img src="/img/finance/e-sign/history_of_e_sign.png" alt="电子签名的发展历程"></p><h2 id="中国电子签约法律法规"><a href="#中国电子签约法律法规" class="headerlink" title="中国电子签约法律法规"></a>中国电子签约法律法规</h2><p><img src="/img/finance/e-sign/law_of_e_sign.png" alt="中国电子签约法律法规"></p><p>2018年4月，中国互联网金融协会发布《互联网金融个体网络借贷电子合同安全规范》，从内容上看，主要分为电子签名合法性要求、电子合同订立、电子合同存储和司法举证要求四个部分，对互联网金融领域中个体网络借贷合同的电子签名的合法性，及电子合同订立、存储、举证，做出了进一步详细的规定。</p><h2 id="电子合同样式"><a href="#电子合同样式" class="headerlink" title="电子合同样式"></a>电子合同样式</h2><p><img src="/img/finance/e-sign/style_of_e_sign.png" alt="电子合同样式"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 金融 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合框架系列（八）LinkedHashMap 有序散列表实现总结</title>
      <link href="2018/05/20/java-collections-linkedhashmap/"/>
      <url>2018/05/20/java-collections-linkedhashmap/</url>
      
        <content type="html"><![CDATA[<h1 id="遍历散列表"><a href="#遍历散列表" class="headerlink" title="遍历散列表"></a>遍历散列表</h1><p>Java 提供了下面几种 API 用于遍历散列表：</p><h2 id="内部循环-API"><a href="#内部循环-API" class="headerlink" title="内部循环 API"></a>内部循环 API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((key, value) -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><h2 id="外部循环-API"><a href="#外部循环-API" class="headerlink" title="外部循环 API"></a>外部循环 API</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key 迭代</span></span><br><span class="line"><span class="keyword">for</span> (String key : map.keySet()) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// value 迭代</span></span><br><span class="line"><span class="keyword">for</span> (String value : map.values()) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// entry 显式迭代器</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;String, String&gt; entry = it.next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foreach 循环增强，不再需要显式迭代器，简化迭代集合操作</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/java/collection/map_entryset.png" alt="map_entryset"></p><h1 id="如何顺序遍历散列表？"><a href="#如何顺序遍历散列表？" class="headerlink" title="如何顺序遍历散列表？"></a>如何顺序遍历散列表？</h1><p>但是，众所周知，散列表这种动态数据结构虽然支持非常高效的数据插入、删除、查找操作（时间复杂度都为常数阶 <code>O(1)</code>），但由于散列表中的数据都是<strong>通过散列函数打乱之后无序存储的</strong>，因此无法按照某种顺序遍历数据。</p><p>有两种解决方案：</p><ul><li><p>实现排序算法。每当我们希望按照某种顺序遍历散列表中的数据时，自行将散列表中的数据拷贝到数组中，然后通过某种排序算法完成排序，再进行遍历。但如此一来，效率势必会很低。</p></li><li><p>设计一种复合型数据结构，例如将散列表和链表（或者跳表）结合在一起，实现顺序遍历。</p></li></ul><h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><p><code>LinkedHashMap</code> 继承自 <code>HashMap</code>，正是这样一种复合型数据结构。它在 <code>HashMap</code> 的基础上，通过维护一条<strong>双向链表</strong>来进行元素排序，从而实现以下两种顺序遍历方式：</p><h2 id="按插入顺序遍历"><a href="#按插入顺序遍历" class="headerlink" title="按插入顺序遍历"></a>按插入顺序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">"apple"</span>, <span class="string">"苹果"</span>);</span><br><span class="line">    map.put(<span class="string">"watermelon"</span>, <span class="string">"西瓜"</span>);</span><br><span class="line">    map.put(<span class="string">"banana"</span>, <span class="string">"香蕉"</span>);</span><br><span class="line">    map.put(<span class="string">"peach"</span>, <span class="string">"桃子"</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iter = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apple&#x3D;苹果</span><br><span class="line">watermelon&#x3D;西瓜</span><br><span class="line">banana&#x3D;香蕉</span><br><span class="line">peach&#x3D;桃子</span><br></pre></td></tr></table></figure><h2 id="按访问顺序遍历"><a href="#按访问顺序遍历" class="headerlink" title="按访问顺序遍历"></a>按访问顺序遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;(<span class="number">16</span>,<span class="number">0.75f</span>,<span class="keyword">true</span>);</span><br><span class="line">    map.put(<span class="string">"apple"</span>, <span class="string">"苹果"</span>);</span><br><span class="line">    map.put(<span class="string">"watermelon"</span>, <span class="string">"西瓜"</span>);</span><br><span class="line">    map.put(<span class="string">"banana"</span>, <span class="string">"香蕉"</span>);</span><br><span class="line">    map.put(<span class="string">"peach"</span>, <span class="string">"桃子"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被访问的元素置底</span></span><br><span class="line">    map.get(<span class="string">"banana"</span>);</span><br><span class="line">    map.get(<span class="string">"apple"</span>);</span><br><span class="line"></span><br><span class="line">    Iterator iter = map.entrySet().iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        Map.Entry entry = (Map.Entry) iter.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">watermelon&#x3D;西瓜</span><br><span class="line">peach&#x3D;桃子</span><br><span class="line">banana&#x3D;香蕉</span><br><span class="line">apple&#x3D;苹果</span><br></pre></td></tr></table></figure><h2 id="数据结构分析"><a href="#数据结构分析" class="headerlink" title="数据结构分析"></a>数据结构分析</h2><p>通过源码分析，<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，同时 <code>LinkedHashMap</code> 的节点 <code>Entry</code> 也继承自 <code>HashMap</code> 的 <code>Node</code>，并且在此基础上增加了两个属性：</p><ul><li>前驱节点 <code>Entry&lt;K, V&gt; before</code></li><li>后继节点 <code>Entry&lt;K, V&gt; after</code></li></ul><p><img src="/img/java/collection/LinkedHashMap_Entry.png" alt="LinkedHashMap Entry"></p><p>通过这两个属性就可以维护一条有序排列的双向链表，如下图：</p><p><img src="/img/java/collection/LinkedHashMap_Entry_sorted.png" alt="LinkedHashMap Entry"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合框架系列（七）HashMap 散列表实现总结</title>
      <link href="2018/05/16/java-collections-hashmap/"/>
      <url>2018/05/16/java-collections-hashmap/</url>
      
        <content type="html"><![CDATA[<p>散列表是一种通过散列函数可以快速定位数据的数据结构。散列表利用了数组支持按照下标随机访问数据的时候，时间复杂度为 O(1) 的特性，<strong>所以散列表其实就是数组的一种扩展，由数组演化而来</strong>。可以说，如果没有数组，就没有散列表。</p><p>散列表的要点总结如下：</p><p><img src="/img/java/collection/keynote_of_hash_table.png" alt="keynote_of_hash_table"></p><h1 id="节点设计"><a href="#节点设计" class="headerlink" title="节点设计"></a>节点设计</h1><p>散列表的节点设计如下：</p><table><thead><tr><th>接口和类</th><th>描述</th></tr></thead><tbody><tr><td><code>java.util.Map#Entry</code></td><td><code>Entry</code> 接口定义了 <code>getKey</code>、<code>getValue</code>、<code>setValue</code>、<code>equals</code>、<code>hashCode</code> 五个待实现方法。</td></tr><tr><td><code>java.util.HashMap#Node</code></td><td>单链表节点实现，用于解决<strong>散列冲突</strong>。</td></tr><tr><td><code>java.util.LinkedHashMap#Entry</code></td><td>单链表节点实现，并在此基础上增加了前驱节点 <code>before</code>、后继节点 <code>after</code> 以实现节点的<strong>顺序遍历</strong>。</td></tr><tr><td><code>java.util.HashMap#TreeNode</code></td><td>红黑树节点实现，用于解决<strong>散列冲突</strong>。同时为了避免链表过长及散列表碰撞攻击，如果节点数超过 8 个，则进行树化 <code>treeifyBin</code>，避免大量散列冲突导致散列表退化成单链表，导致查询时间复杂度从 <code>O(1)</code> 退化成 <code>O(n)。</code></td></tr></tbody></table><p><img src="/img/java/collection/Map_Entry.png" alt="Entry"></p><h2 id="单链表节点实现"><a href="#单链表节点实现" class="headerlink" title="单链表节点实现"></a>单链表节点实现</h2><p>单链表节点的散列表结构如下，下图体现了单链表节点 <code>key</code> 和 <code>next</code> 属性：</p><p><img src="/img/java/collection/hashtable_examples.png" alt="hashtable_examples"></p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="红黑树节点实现"><a href="#红黑树节点实现" class="headerlink" title="红黑树节点实现"></a>红黑树节点实现</h2><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment"> * extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment"> * linked node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常量及字段"><a href="#常量及字段" class="headerlink" title="常量及字段"></a>常量及字段</h1><p><img src="/img/java/collection/HashMap_fields.png" alt="HashMap_fields"></p><h2 id="常量值"><a href="#常量值" class="headerlink" title="常量值"></a>常量值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> * 数组默认初始容量为 16，必须是 2 的 n 次幂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 数组最大容量，，必须是 2 的 n 次幂，且小于等于 2^30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> * 默认装载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 桶树化时的阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 桶非树化时的阈值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 树化时数组最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure><h2 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 底层数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 实际存储的键值对数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 修改次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * resize 操作的阈值（capacity * load factor）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 装载因子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>关键的几个字段：</p><ul><li><code>table</code> 散列表的底层数据结构为数组，其容量用 <code>capacity</code> 表示。此外，Java 通过链表法解决散列冲突的问题，因此数组类型为 <code>Node&lt;K,V&gt;[]</code> 节点数组。</li><li><code>loadFactor</code> 散列表的装载因子。当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子来表示散列表满的程度，默认值是 <code>0.75f</code>，也就是说默认情况下，当散列表中元素个数达到了容量的 3/4 时就会进行扩容。</li><li><code>threshold</code> 散列表的扩容阈值，计算公式：<code>threshold = capacity * load factor</code>，即默认配置下的扩容阈值为：<code>12=16*0.75</code>。</li><li><code>size</code> 散列表实际存储的键值对数量，如果 <code>size &gt; threshold</code> 则对 hash <code>table</code> 进行双倍扩容（resize）,并对原数组每个元素进行重新散列（rehash）。</li><li><code>modCount</code> 修改次数。</li></ul><p><img src="/img/java/collection/fields_of_hash_table.png" alt="fields_of_hash_table"></p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>构造方法的参数主要用于指定数组的初始容量 <code>initialCapacity</code>、装载因子 <code>loadFactor</code>，并计算扩容阈值 <code>threshold</code>。</p><p><img src="/img/java/collection/HashMap_constructors.png" alt="HashMap_constructors"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 参数校验及默认值设置</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 装载因子及扩容阈值赋值</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</span></span><br><span class="line"><span class="comment"> * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment"> * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment"> * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment"> * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始容量"><a href="#初始容量" class="headerlink" title="初始容量"></a>初始容量</h2><p>在集合初始化时，建议指定 <code>initialCapacity</code> 初始容量：</p><p><img src="/img/java/collection/map_constructor.png" alt="map_constructor"></p><p>如果不想手工计算初始容量 <code>initialCapacity</code>，可以使用 Guava 的静态工厂方法 <code>Maps.newHashMapWithExpectedSize</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> HashMap&#125; instance, with a high enough "initial capacity"</span></span><br><span class="line"><span class="comment"> * that it &lt;i&gt;should&lt;/i&gt; hold &#123;<span class="doctag">@code</span> expectedSize&#125; elements without growth.</span></span><br><span class="line"><span class="comment"> * This behavior cannot be broadly guaranteed, but it is observed to be true</span></span><br><span class="line"><span class="comment"> * for OpenJDK 1.7. It also can't be guaranteed that the method isn't</span></span><br><span class="line"><span class="comment"> * inadvertently &lt;i&gt;oversizing&lt;/i&gt; the returned map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expectedSize the number of entries you expect to add to the</span></span><br><span class="line"><span class="comment"> *        returned map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new, empty &#123;<span class="doctag">@code</span> HashMap&#125; with enough capacity to hold &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> *         expectedSize&#125; entries without resizing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> expectedSize&#125; is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K, V&gt; <span class="function">HashMap&lt;K, V&gt; <span class="title">newHashMapWithExpectedSize</span><span class="params">(<span class="keyword">int</span> expectedSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K, V&gt;(capacity(expectedSize));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a capacity that is sufficient to keep the map from being resized as</span></span><br><span class="line"><span class="comment"> * long as it grows no larger than expectedSize and the load factor is &gt;= its</span></span><br><span class="line"><span class="comment"> * default (0.75).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">(<span class="keyword">int</span> expectedSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (expectedSize &lt; <span class="number">3</span>) &#123;</span><br><span class="line">    checkNonnegative(expectedSize, <span class="string">"expectedSize"</span>);</span><br><span class="line">    <span class="keyword">return</span> expectedSize + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (expectedSize &lt; Ints.MAX_POWER_OF_TWO) &#123;</span><br><span class="line">    <span class="comment">// This is the calculation used in JDK8 to resize when a putAll</span></span><br><span class="line">    <span class="comment">// happens; it seems to be the most conservative calculation we</span></span><br><span class="line">    <span class="comment">// can make.  0.75 is the default load factor.</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) ((<span class="keyword">float</span>) expectedSize / <span class="number">0.75F</span> + <span class="number">1.0F</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Integer.MAX_VALUE; <span class="comment">// any large value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管是通过手工指定还是通过 Guava 的静态工厂方法，计算出来的初始容量都只是一个参考值。因为在随后 <code>resize</code> 会重新计算。</p><h2 id="扩容阈值"><a href="#扩容阈值" class="headerlink" title="扩容阈值"></a>扩容阈值</h2><p>第一个构造方法中调用了 <code>tableSizeFor</code> 方法，用于产生一个大于等于 <code>initialCapacity</code> 的最小的 2 的整数次幂。做法是通过右移操作让每一位都变为 1，最后 +1 变成 2 的 n 次幂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关键私有方法"><a href="#关键私有方法" class="headerlink" title="关键私有方法"></a>关键私有方法</h1><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>在 <code>HashMap</code> 源码中，散列函数是分三步走的：</p><p>第一步，获取 <code>hashcode</code>。<code>hashCode</code> 需要遵循以下规则：</p><p><img src="/img/java/collection/equals_and_hashcode.png" alt="equals_and_hashcode"></p><p>第二步，hash 值的计算，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment"> * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment"> * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment"> * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment"> * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment"> * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment"> * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment"> * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment"> * are already reasonably distributed (so don't benefit from</span></span><br><span class="line"><span class="comment"> * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment"> * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment"> * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment"> * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment"> * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数也叫扰动函数：先获取 32 位长度的 hashCode，再进行高 16 位与低 16 位异或，在低位加入高位特征，目的是减少碰撞冲突的概率。</p><p>第三步，在更新、插入或删除的时候，计算 Key 被映射到的桶的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// capacity 表示 table.length</span></span><br><span class="line"><span class="keyword">int</span> index = hash(key) &amp; (capacity - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>该按位与运算相当于通过<strong>取模法（除留余数法）</strong>计算存放的数组下标。</p><p>总结：</p><blockquote><p>JDK HashMap 中 hash 函数的设计，确实很巧妙：</p><p>首先 hashcode 本身是个 32 位整型值，在系统中，这个值对于不同的对象必须保证唯一（JAVA 规范），这也是大家常说的，重写 equals 必须重写 hashcode 的重要原因。</p><p>获取对象的 hashcode 以后，先进行移位运算，然后再和自己做异或运算，即：hashcode ^ (hashcode &gt;&gt;&gt; 16)，这一步甚是巧妙，是将高 16 位移到低 16 位，这样计算出来的整型值将“具有”高位和低位的性质。</p><p>最后，用 hash 表当前的容量减去一，再和刚刚计算出来的整型值做位与运算。进行位与运算，很好理解，是为了计算出数组中的位置。但这里有个问题：</p><p>为什么要用容量减去一？</p><p>因为 A % B = A &amp; (B - 1)，注意这个公式只有当 B 为 2 的幂次方时才有效，所以 HashMap 中的数组容量要求必须是 2 的幂次方。</p><p>最后，(h ^ (h &gt;&gt;&gt; 16)) &amp; (capitity -1) = (h ^ (h &gt;&gt;&gt; 16)) % capitity，可以看出这里本质上是使用了「除留余数法」</p><p>综上，可以看出，hashcode 的随机性，加上移位异或算法，得到一个非常随机的 hash 值，再通过「除留余数法」，得到 index。</p></blockquote><p>整个散列函数的整体过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode();</span><br><span class="line">    h = h ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span> h &amp; (capitity - <span class="number">1</span>); <span class="comment">//capicity 表示散列表的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>用于初始化或扩容散列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment"> * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment"> * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment"> * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment"> * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h2><p><code>putVal</code> 的核心流程如下：</p><p><img src="/img/java/collection/putval_of_hashmap.png" alt="putval_of_hashmap"></p><p>一些关键代码分析：</p><ul><li>散列表只在首次设值时，才初始化；</li><li>散列函数：<code>(n - 1) &amp; hash</code>，通过<strong>取模法</strong>计算存放的数组下标。通过该散列函数将元素的键值（key）映射为数组下标，然后将数据存储在数组中对应的下标位置。当我们按照键值查询元素时，用同样的散列函数，将键值转化为数组下标，从对应的数组下标的位置取数据。因此散列函数在散列表中起着非常关键的作用。</li><li>为了避免散列值冲突，除了对比散列值是否相等之外，还需要对比 <code>key</code> 是否相等；</li><li>散列冲突解决方法：链表法。同时为了避免链表过长及<strong>散列表碰撞攻击</strong>，如果节点数超过 8 个，则进行树化 <code>treeifyBin</code>，避免大量散列冲突导致散列表退化成单链表，导致查询时间复杂度从 <code>O(1)</code> 退化成 <code>O(n)</code>；</li><li>如果实际映射数量超过阈值，则进行 <code>resize</code> 扩容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tab 表示底层数组</span></span><br><span class="line">    <span class="comment">// p 表示头结点</span></span><br><span class="line">    <span class="comment">// n 表示数组长度</span></span><br><span class="line">    <span class="comment">// i 表示数组下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 节点数组为空，则首次初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算数组下标，并获取指定下标元素，如果为空，表示无散列冲突，则创建节点并放入指定下标对应的桶</span></span><br><span class="line">    <span class="comment">// 无散列冲突情况：</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 有散列冲突情况：</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// e 表示当前节点</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 判断头结点是否为重复键，如果是则后续覆盖值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果是根节点是树节点类型，则进行相关操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 否则就是单链表节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历单链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 找到尾结点</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 创建新节点并追加到单链表末尾</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果节点数超过 8 个，则进行树化，避免大量散列冲突导致散列表退化成单链表，导致查询时间复杂度从 0(1) 退化成 0(n)</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">// 树化操作可能会引起数组容量翻倍、扩容阈值翻倍</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果桶中的节点有重复键，则后续覆盖值</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果存在重复键，则覆盖值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际数量加一。同时如果超过阈值，则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树化前，会先判断数组容量是否达到阈值 <code>MIN_TREEIFY_CAPACITY = 64</code>，如果是则将指定散列值对应数组下标的桶中所有链表节点都替换为红黑树节点，否则进行 <code>resize</code> 扩容操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Replaces all linked nodes in bin at index for given hash unless</span></span><br><span class="line"><span class="comment"> * table is too small, in which case resizes instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getNode"><a href="#getNode" class="headerlink" title="getNode"></a>getNode</h2><p>关键的 <code>getNode</code> 查找节点方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 判断散列表是否为空，且散列值对应头节点是否为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 头节点散列值、键值匹配，则返回该节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 否则遍历下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 树节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 顺序遍历单链表，查找匹配结果</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode"></a>removeNode</h2><p>关键的 <code>removeNode</code> 删除节点方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.remove and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line"></span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="设值"><a href="#设值" class="headerlink" title="设值"></a>设值</h2><p>主要使用到了关键的 <code>hash</code>、<code>putVal</code>、<code>resize</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copies all of the mappings from the specified map to this map.</span></span><br><span class="line"><span class="comment"> * These mappings will replace any mappings that this map had for</span></span><br><span class="line"><span class="comment"> * any of the keys currently in the specified map.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m mappings to be stored in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.putAll and Map constructor</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> m the map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict false when initially constructing this map, else</span></span><br><span class="line"><span class="comment"> * true (relayed to method afterNodeInsertion).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h2><p>下面这组方法都使用到了关键的 <code>getNode</code> 方法查找指定节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e; V v;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        ((v = e.value) == oldValue || (v != <span class="keyword">null</span> &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">        e.value = newValue;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">replace</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V oldValue = e.value;</span><br><span class="line">        e.value = value;</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="清空-map"><a href="#清空-map" class="headerlink" title="清空 map"></a>清空 map</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内部数组不为空，则遍历并清空所有元素</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-8-新增方法"><a href="#Java-8-新增方法" class="headerlink" title="Java 8 新增方法"></a>Java 8 新增方法</h2><p>Java 8 为 <code>Map</code> 接口引入了一组新的 <code>default</code> 默认方法，如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java.util.Map#forEach</span><br><span class="line">java.util.Map#remove(java.lang.Object, java.lang.Object)</span><br><span class="line">java.util.Map#replace</span><br><span class="line">java.util.Map#replaceAll</span><br><span class="line">java.util.Map#getOrDefault</span><br><span class="line">java.util.Map#putIfAbsent</span><br><span class="line">java.util.Map#computeIfAbsent</span><br><span class="line">java.util.Map#computeIfPresent</span><br><span class="line">java.util.Map#compute</span><br><span class="line">java.util.Map#merge</span><br></pre></td></tr></table></figure><p>我们重点看下其中几个，</p><p><code>putIfAbsent</code> 和 <code>computeIfAbsent</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; ipStats = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// previousValue is null</span></span><br><span class="line">Integer previousValue = ipStats.putIfAbsent(<span class="number">100000000</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// currentValue is 1</span></span><br><span class="line">Integer currentValue = ipStats.computeIfAbsent(<span class="number">200000000</span>, key -&gt; &#123;</span><br><span class="line">    <span class="comment">// key = 200000000</span></span><br><span class="line">    log.info(<span class="string">"key = &#123;&#125;"</span>, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>computeIfPresent</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newValue is 2</span></span><br><span class="line">Integer newValue = ipStats.computeIfPresent(<span class="number">200000000</span>, (key, oldValue) -&gt; &#123;</span><br><span class="line">    <span class="comment">// key = 200000000, oldValue = 1</span></span><br><span class="line">    log.info(<span class="string">"key = &#123;&#125;, oldValue = &#123;&#125;"</span>, key, oldValue);</span><br><span class="line">    <span class="keyword">return</span> oldValue += <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用 <code>compute</code> 实现类似 Redis 散列表的原子递增命令 <code>HINCRBY</code> key field increment 的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// newValue2 is 1</span></span><br><span class="line">Integer newValue2 = ipStats.compute(<span class="number">300000000</span>, (key, oldValue) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> oldValue += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最终结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// result is &#123;300000000=1, 100000000=1, 200000000=2&#125;</span></span><br><span class="line">log.info(<span class="string">"result is &#123;&#125;"</span>, ipStats.toString());</span><br></pre></td></tr></table></figure><h2 id="使用-Guava-快速创建-Map"><a href="#使用-Guava-快速创建-Map" class="headerlink" title="使用 Guava 快速创建 Map"></a>使用 Guava 快速创建 Map</h2><p>创建不可变的 Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = ImmutableMap.of(<span class="string">"A"</span>, <span class="string">"Apple"</span>, <span class="string">"B"</span>, <span class="string">"Boy"</span>, <span class="string">"C"</span>, <span class="string">"Cat"</span>);</span><br></pre></td></tr></table></figure><p>创建指定 <code>initialCapacity</code> 初始容量的 Map：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maps.newHashMapWithExpectedSize(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>Guava 的 <code>Maps</code> 还提供了更多的 API，可以自行研究使用。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Hash_table</a></p><p>《<a href="http://www.nowamagic.net/academy/detail/3008040" target="_blank" rel="noopener">散列函数设计：除留余数法</a>》</p><p><a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/index.html</a></p><p>《<a href="https://blog.csdn.net/majinggogogo/article/details/80260400" target="_blank" rel="noopener">Java中hash算法细述</a>》</p><p>《<a href="https://mp.weixin.qq.com/s/kbLASf0lcF4PDJ3qBsFyUg" target="_blank" rel="noopener">HashMap的负载因子不设置成1？</a>》</p><p>《<a href="https://www.jianshu.com/p/64f6de3ffcc1" target="_blank" rel="noopener">HashMap的loadFactor为什么是0.75？</a>》</p><p>《<a href="https://www.jianshu.com/p/2db05dbcba2d" target="_blank" rel="noopener">自问自答 - HashMap的底层原理探索</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合框架系列（六）Comparator API 总结</title>
      <link href="2018/05/10/java-collections-comparator/"/>
      <url>2018/05/10/java-collections-comparator/</url>
      
        <content type="html"><![CDATA[<p>本文总结下集合元素排序的常用 API：</p><p><img src="/img/java/collection/java.util.Comparator.png" alt="java.util.Comparator"></p><h1 id="基于可比较对象排序"><a href="#基于可比较对象排序" class="headerlink" title="基于可比较对象排序"></a>基于可比较对象排序</h1><p>如果集合元素已实现 <code>Comparable</code> 接口，可以直接使用 <code>naturalOrder</code>、<code>reverseOrder</code> 方法进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = Arrays.asList(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 升序</span></span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line">integers.sort(Comparator.naturalOrder());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line"><span class="comment">// [4, 3, 2, 1]</span></span><br><span class="line">integers.sort(Comparator.reverseOrder());</span><br></pre></td></tr></table></figure><p>上述排序不支持 <code>null</code> 值（会抛 NPE 异常），如果自定义实现的话，代码比较冗余，容易出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = Arrays.asList(<span class="number">3</span>, <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [null, 1, 2, 3, 4]</span></span><br><span class="line">integers.sort((o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 写法1：</span></span><br><span class="line">    <span class="keyword">if</span> (o1 != <span class="keyword">null</span> &amp;&amp; o2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1 == <span class="keyword">null</span> ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写法2：</span></span><br><span class="line">    <span class="comment">// return o1 == null ? -1 : (o2 == null ? 1 : o1.compareTo(o2));</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [4, 3, 2, 1, null]</span></span><br><span class="line">integers.sort((o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="comment">// 写法1：</span></span><br><span class="line">    <span class="keyword">if</span> (o1 != <span class="keyword">null</span> &amp;&amp; o2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1 == <span class="keyword">null</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写法2：</span></span><br><span class="line">    <span class="comment">// return o1 == null ? 1 : (o2 == null ? -1 : o2.compareTo(o1));</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可采用 <code>nullsFirst</code>、<code>nullsLast</code> 方法兼容 <code>null</code> 值情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = Arrays.asList(<span class="number">3</span>, <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// null 值在前</span></span><br><span class="line"><span class="comment">// [null, 1, 2, 3, 4]</span></span><br><span class="line">integers.sort(Comparator.nullsFirst(Comparator.naturalOrder()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// null 值在后</span></span><br><span class="line"><span class="comment">// [4, 3, 2, 1, null]</span></span><br><span class="line">integers.sort(Comparator.nullsLast(Comparator.reverseOrder()));</span><br></pre></td></tr></table></figure><h1 id="基于不可比较对象排序"><a href="#基于不可比较对象排序" class="headerlink" title="基于不可比较对象排序"></a>基于不可比较对象排序</h1><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdName</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果集合元素未实现 <code>Comparable</code> 接口，需要抽取关键字（关键字需实现 <code>Comparable</code> 接口）排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;IdName&gt; idNames = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> IdName(<span class="number">3</span>, <span class="string">"Pete"</span>),</span><br><span class="line">    <span class="keyword">new</span> IdName(<span class="number">1</span>, <span class="string">"Tom"</span>),</span><br><span class="line">    <span class="keyword">new</span> IdName(<span class="number">2</span>, <span class="string">"Ben"</span>),</span><br><span class="line">    <span class="keyword">new</span> IdName(<span class="number">2</span>, <span class="string">"Allen"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID 升序</span></span><br><span class="line"><span class="comment">// [IdName(id=1, name=Tom), IdName(id=2, name=Ben), IdName(id=2, name=Allen), IdName(id=3, name=Pete)]</span></span><br><span class="line">idNames.sort(Comparator.comparing(IdName::getId));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID、Name 复合排序（升序）</span></span><br><span class="line"><span class="comment">// [IdName(id=1, name=Tom), IdName(id=2, name=Allen), IdName(id=2, name=Ben), IdName(id=3, name=Pete)]</span></span><br><span class="line">idNames.sort(Comparator.comparing(IdName::getId)</span><br><span class="line">             .thenComparing(IdName::getName));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据 ID、Name 复合排序（降序）</span></span><br><span class="line"><span class="comment">// [IdName(id=3, name=Pete), IdName(id=2, name=Ben), IdName(id=2, name=Allen), IdName(id=1, name=Tom)]</span></span><br><span class="line">idNames.sort(Comparator.comparing(IdName::getId)</span><br><span class="line">             .thenComparing(IdName::getName)</span><br><span class="line">             .reversed());</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://blog.csdn.net/u013066244/article/details/78997869" target="_blank" rel="noopener">java comparator 升序、降序、倒序从源码角度理解</a>》</p><p><a href="https://blog.csdn.net/weixin_44270183/article/details/87026995" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44270183/article/details/87026995</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合框架系列（五）Iterator API 总结</title>
      <link href="2018/05/01/java-collections-iterator/"/>
      <url>2018/05/01/java-collections-iterator/</url>
      
        <content type="html"><![CDATA[<p>本文总结下集合元素迭代的常用 API。</p><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><blockquote><p>迭代器模式（Iterator）是一种行为型设计模式，让你能在不暴露集合底层表现形式（列表、栈和树等）的情况下遍历集合中所有的元素。</p></blockquote><p><img src="/img/java/design-pattern/Iterator.png" alt="Iterator"></p><h1 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h1><p>在 Java 中，迭代器模式的实现有以下几种：</p><p><img src="/img/java/design-pattern/Iterator_impl.png" alt="Iterator_impl"></p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Enumeration.html" target="_blank" rel="noopener"><code>java.util.Enumeration&lt;E&gt;</code></a>：Java 1.0 引入，用于枚举集合元素。这种传统接口已被 <code>Iterator</code> 迭代器取代，虽然 <code>Enumeration</code> 还未被废弃，但在现代代码中已经被很少使用了。主要用于诸如 <code>java.util.Vector</code> 和 <code>java.util.Properties</code> 这些传统集合类。</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html" target="_blank" rel="noopener"><code>java.util.Iterator&lt;E&gt;</code></a>：Java 1.2 引入。作为 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html" target="_blank" rel="noopener">Java 集合框架</a>的成员，迭代器取代了枚举。迭代器与枚举有两个不同之处：<ul><li>引入 <code>remove</code> 方法，允许调用者在迭代期间从集合中删除元素。</li><li>方法名改进。</li></ul></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html" target="_blank" rel="noopener"><code>java.lang.Iterable&lt;T&gt;</code></a>：Java 1.5 引入。<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/foreach.html" target="_blank" rel="noopener">For-each Loop</a> 语法糖的底层实现，实现这个接口的对象可以用于 “For-each Loop”语句，简化迭代器繁琐的使用语法。</li></ul><p>上述三种迭代器实现都属于<strong>命令式编程范式</strong>，即使访问值的方法仅由迭代器负责实现。但实际上，是由开发者来决定何时访问序列中的 <code>next()</code> 项。</p><h1 id="与-Stream-API-对比"><a href="#与-Stream-API-对比" class="headerlink" title="与 Stream API 对比"></a>与 Stream API 对比</h1><p><a href=""><code>java.util.stream.Stream&lt;T&gt;</code></a>：Java 8 引入，用于实现 Stream API。与迭代器的区别在于：</p><ul><li><p><code>Iterator</code> 外部迭代，使用命令式编程范式，完全由用户来决定”做什么“和”怎么做“，例如：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; example = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(example.size());</span><br><span class="line">    <span class="comment">// 怎么做（通过 Iterator API 遍历 List）</span></span><br><span class="line">    Iterator&lt;String&gt; iterator = example.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="comment">// 做什么（把大写转成小写）</span></span><br><span class="line">        result.add(iterator.next().toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; example = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>);</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(example.size());</span><br><span class="line">    <span class="comment">// 怎么做（通过 For-each Loop 遍历 List）</span></span><br><span class="line">    <span class="keyword">for</span> (String s : example) &#123;</span><br><span class="line">        <span class="comment">// 做什么（把大写转成小写）</span></span><br><span class="line">        result.add(s.toLowerCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/img/java/collection/outer_iterator.png" alt="outer_iterator"></p></li><li><p><code>Stream</code> 内部迭代，使用声明式编程范式 &gt; 函数式编程，用户仅需要决定“做什么”，而把“怎么做”的任务交给 JVM：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">streamApi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; result = Arrays.asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>)</span><br><span class="line">        <span class="comment">// 这里遍历方式由 Stream API 实现，用户仅调用相应 API，数据量小可以用串行，数据量大可以用并行，怎么做、怎么实现用户并不用关心</span></span><br><span class="line">        .stream()</span><br><span class="line">        <span class="comment">// 做什么（把大写转成小写）</span></span><br><span class="line">        .map(String::toLowerCase)</span><br><span class="line">        <span class="comment">// 这里转成线性表由 Stream API 实现，用户仅调用相应 API，也可以转成集合、散列表，怎么实现用户并不关心。</span></span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/java/collection/inner_iterator.png" alt="inner_iterator"></p></li></ul><p>使用内部迭代的优势在于：</p><ul><li>用户只需要关注问题本身，无需关注如何解决问题的细节。</li><li>Java 可以利用短路、并行等对性能进行优化，用户无需关心。</li></ul><h1 id="与-Reactive-Stream-对比"><a href="#与-Reactive-Stream-对比" class="headerlink" title="与 Reactive Stream 对比"></a>与 Reactive Stream 对比</h1><p>响应式编程范式通常在面向对象语言中作为<strong>观察者模式</strong>的扩展出现。可以将其与大家熟知的<strong>迭代器模式</strong>作对比，主要区别在于：</p><ul><li>迭代器、Stream API 基于<strong>拉模式（PULL）</strong></li><li>响应式流基于<strong>推模式（PUSH）</strong></li></ul><p>参考：<a href="/2020/08/01/java-reactive-programming/">响应式编程总结</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://refactoringguru.cn/design-patterns/iterator" target="_blank" rel="noopener">https://refactoringguru.cn/design-patterns/iterator</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合框架系列（四）各版本功能增强总结</title>
      <link href="2018/04/28/java-collections-framework-enhancements/"/>
      <url>2018/04/28/java-collections-framework-enhancements/</url>
      
        <content type="html"><![CDATA[<p>Java 集合框架并不是一蹴而就写成的，也是经过了好多个版本迭代的演进与发展，才走到今天。本文总结下集合框架各版本的功能增强。</p><h1 id="Java-SE-9"><a href="#Java-SE-9" class="headerlink" title="Java SE 9"></a>Java SE 9</h1><p><code>List</code>、<code>Set</code> 和 <code>Map</code> 接口中，新的静态工厂方法可以创建这些集合的<em>不可变实例（immutable）</em>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"banana"</span>);</span><br><span class="line">Set&lt;String&gt; set = Set.of(<span class="string">"aggie"</span>, <span class="string">"alley"</span>, <span class="string">"steely"</span>);</span><br><span class="line">Map&lt;String, String&gt; map = Map.of(<span class="string">"A"</span>, <span class="string">"Apple"</span>, <span class="string">"B"</span>, <span class="string">"Boy"</span>, <span class="string">"C"</span>, <span class="string">"Cat"</span>);</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.linuxidc.com/Linux/2017-10/147683.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-10/147683.htm</a></p><h1 id="Java-SE-8"><a href="#Java-SE-8" class="headerlink" title="Java SE 8"></a>Java SE 8</h1><ul><li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">Lambda 表达式</a></li><li>Stream API，参考《<a href="https://mp.weixin.qq.com/s/adKZrOe6nFEmuADHijsAtA" target="_blank" rel="noopener">Java 8 中处理集合的优雅姿势——Stream</a>》</li><li><a href="https://docs.oracle.com/javase/tutorial/collections/streams/" target="_blank" rel="noopener">聚合操作</a>，例如 <code>forEach</code></li><li>作为 <a href="http://openjdk.java.net/jeps/180" target="_blank" rel="noopener">JEP 180</a> 提案的成果，<code>HashMap</code>、<code>LinkedHashMap</code>、<code>ConcurrentHashMap</code> 的性能得到提升。当出现大量散列冲突时，值将存储在红黑树而不是链表，以提升查找性能。</li></ul><h1 id="Java-SE-7"><a href="#Java-SE-7" class="headerlink" title="Java SE 7"></a>Java SE 7</h1><ul><li>新增一个集合接口：<code>TransferQueue</code>，以及实现类 <code>LinkedTransferQueue</code>。</li><li>为 <code>Map</code> 及其派生实现类引入了一个性能改进的替代版散列函数（但在 Java SE 8 已被移除并取代）。</li></ul><h1 id="Java-SE-6"><a href="#Java-SE-6" class="headerlink" title="Java SE 6"></a>Java SE 6</h1><p>新增几个集合接口：</p><ul><li><code>Deque</code></li><li><code>BlockingDeque</code></li><li><code>NavigableSet</code></li><li><code>NavigableMap</code></li><li><code>ConcurrentNavigableMap</code></li></ul><p>新增几个集合实现类：</p><ul><li><code>ArrayDeque</code></li><li><code>ConcurrentSkipListSet</code></li><li><code>ConcurrentSkipListMap</code></li><li><code>LinkedBlockingDeque</code></li><li><code>AbstractMap.SimpleEntry</code></li><li><code>AbstractMap.SimpleImmutableEntry</code></li></ul><p>现有实现类增强：</p><ul><li><code>LinkedList</code> 实现 <code>Deque</code> 接口</li><li><code>TreeSet</code> 实现 <code>NavigableSet</code> 接口</li><li><code>TreeMap</code> 实现 <code>NavigableMap</code> 接口</li></ul><p><code>Collections</code> 工具类新增两个适配器方法：</p><ul><li><code>newSetFromMap(Map)</code> 根据 <code>Map</code> 的通用实现创建一个 <code>Set</code> 的通用实现</li><li><code>asLifoQueue(Deque)</code> 以后进先出（Lifo）队列的形式返回 <code>Deque</code> 的视图。</li></ul><p><code>Arrays</code> 工具类新增两个方法：</p><ul><li><code>copyOf</code></li><li><code>copyOfRange</code></li></ul><h1 id="Java-SE-5"><a href="#Java-SE-5" class="headerlink" title="Java SE 5"></a>Java SE 5</h1><p>三个新增的<strong>语法糖</strong>显著增强了集合框架：</p><ul><li><p>泛型：为集合框架添加编译时类型安全，并在读取元素时不再需要做类型转换。</p></li><li><p>自动装箱/拆箱：往集合插入元素时自动装箱（将原始数据类型转换为对应的包装类型），读取元素时自动拆箱。</p></li><li><p>增强 <code>for</code> 循环：迭代集合时不再需要显式迭代器（<code>Iterator</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组迭代</span></span><br><span class="line">String[] strArray = &#123;<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"banana"</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (String s : strArray) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// List 迭代</span></span><br><span class="line">List&lt;String&gt; strList = Arrays.asList(<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"banana"</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : strList) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>通用实现与并发实现：</p><ul><li>新增三个集合接口：<ul><li><code>Queue</code></li><li><code>BlockingQueue</code></li><li><code>ConcurrentMap</code></li></ul></li><li>新增几个 <code>Queue</code> 实现类：<ul><li><code>PriorityQueue</code></li><li><code>ConcurrentLinkedQueue</code></li><li><code>LinkedList</code> 实现 <code>Queue</code> 接口</li><li><code>AbstractQueue</code> 抽象类实现</li></ul></li><li>新增五个 <code>BlockingQueue</code> 实现类，位于 <code>java.util.concurrent</code> 包下：<ul><li><code>LinkedBlockingQueue</code></li><li><code>ArrayBlockingQueue</code></li><li><code>PriorityBlockingQueue</code></li><li><code>DelayQueue</code></li><li><code>SynchronousQueue</code></li></ul></li><li>新增一个 <code>ConcurrentMap</code> 实现类：<ul><li><code>ConcurrentHashMap</code></li></ul></li></ul><p>特殊实现：</p><ul><li>新增两个特殊用途的 <code>List</code> 和 <code>Set</code> 实现类，用于读远大于写以及迭代无法线程同步的情况：<ul><li><code>CopyOnWriteArrayList</code></li><li><code>CopyOnWriteArraySet</code></li></ul></li><li>新增两个特殊用途的 <code>Set</code> 和 <code>Map</code> 实现类，用于枚举：<ul><li><code>EnumSet</code></li><li><code>EnumMap</code></li></ul></li></ul><p>包装器实现：</p><ul><li>新增一位包装器实现家族的新成员 <code>Collections.checkedInterface</code> ，主要用于通用集合。</li></ul><p><code>Collections</code> 工具类新增三个通用算法和一个 <code>Comparator</code> 转换器：</p><ul><li><code>frequency(Collection&lt;?&gt; c, Object o)</code> 计算指定元素在指定集合中出现的次数。</li><li><code>disjoint(Collection&lt;?&gt; c1, Collection&lt;?&gt; c2)</code> 求两个集合是否不相交。</li><li><code>addAll(Collection&lt;? super T&gt; c, T... a)</code> 将指定数组中的所有元素添加到指定集合的便捷方法。</li><li><code>Comparator&lt;T&gt; reverseOrder(Comparator&lt;T&gt; cmp)</code> 反向排序。</li></ul><p><code>Arrays</code> 工具类新增下列方法：</p><ul><li><code>hashCode</code>、<code>toString</code></li><li><code>deepEquals</code>、<code>deepHashCode</code>、<code>deepToString</code> 用于多维数组</li></ul><h1 id="Java-SE-1-4"><a href="#Java-SE-1-4" class="headerlink" title="Java SE 1.4"></a>Java SE 1.4</h1><ul><li><code>Collections</code> 工具类新增几个新方法，例如 ：<ul><li><code>replaceAll(List list, Object oldVal, Object newVal)</code> 查找替换。</li></ul></li><li>新增标记接口 <code>RandomAccess</code>。</li><li>新增集合实现类 <code>LinkedHashMap</code>、<code>LinkedHashSet</code>。内部使用散列表 + 双向链表（按插入顺序排序）。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://openjdk.java.net/jeps/180" target="_blank" rel="noopener">http://openjdk.java.net/jeps/180</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合框架系列（三）并发实现总结</title>
      <link href="2018/04/21/java-collections-framework-concurrent-impl/"/>
      <url>2018/04/21/java-collections-framework-concurrent-impl/</url>
      
        <content type="html"><![CDATA[<p>并发编程时，集合操作必须小心谨慎。Java SE 提供了两种并发编程方法：</p><ul><li>方案一：为集合通用实现添加线程同步功能。<code>Collections</code> 工具类提供了称为<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedCollection-java.util.Collection-" target="_blank" rel="noopener"><em>同步包装器（synchronization wrappers）</em></a>的静态工厂方法可用于向许多非线程同步的集合添加同步行为。</li><li>方案二：使用并发集合。Java SE 提供了各种并发友好的集合接口和实现类。这些接口和类性能优于<em>同步包装器（synchronization wrappers）</em>，提供了并发编程中经常需要的各种功能。</li></ul><h1 id="同步包装器"><a href="#同步包装器" class="headerlink" title="同步包装器"></a>同步包装器</h1><p><code>Collections</code> 工具类提供如下静态工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection</span><br><span class="line">synchronizedSet</span><br><span class="line">synchronizedSortedSet</span><br><span class="line">synchronizedNavigableSet</span><br><span class="line">synchronizedList</span><br><span class="line">synchronizedMap</span><br><span class="line">synchronizedSortedMap</span><br><span class="line">synchronizedNavigableMap</span><br></pre></td></tr></table></figure><p>以 <code>synchronizedCollection</code> 静态方法为例，源码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a synchronized (thread-safe) collection backed by the specified</span></span><br><span class="line"><span class="comment"> * collection.  In order to guarantee serial access, it is critical that</span></span><br><span class="line"><span class="comment"> * &lt;strong&gt;all&lt;/strong&gt; access to the backing collection is accomplished</span></span><br><span class="line"><span class="comment"> * through the returned collection.&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is imperative that the user manually synchronize on the returned</span></span><br><span class="line"><span class="comment"> * collection when traversing it via &#123;<span class="doctag">@link</span> Iterator&#125;, &#123;<span class="doctag">@link</span> Spliterator&#125;</span></span><br><span class="line"><span class="comment"> * or &#123;<span class="doctag">@link</span> Stream&#125;:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *  Collection c = Collections.synchronizedCollection(myCollection);</span></span><br><span class="line"><span class="comment"> *     ...</span></span><br><span class="line"><span class="comment"> *  synchronized (c) &#123;</span></span><br><span class="line"><span class="comment"> *      Iterator i = c.iterator(); // Must be in the synchronized block</span></span><br><span class="line"><span class="comment"> *      while (i.hasNext())</span></span><br><span class="line"><span class="comment"> *         foo(i.next());</span></span><br><span class="line"><span class="comment"> *  &#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * Failure to follow this advice may result in non-deterministic behavior.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The returned collection does &lt;i&gt;not&lt;/i&gt; pass the &#123;<span class="doctag">@code</span> hashCode&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@code</span> equals&#125; operations through to the backing collection, but</span></span><br><span class="line"><span class="comment"> * relies on &#123;<span class="doctag">@code</span> Object&#125;'s equals and hashCode methods.  This is</span></span><br><span class="line"><span class="comment"> * necessary to preserve the contracts of these operations in the case</span></span><br><span class="line"><span class="comment"> * that the backing collection is a set or a list.&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The returned collection will be serializable if the specified collection</span></span><br><span class="line"><span class="comment"> * is serializable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  &lt;T&gt; the class of the objects in the collection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  c the collection to be "wrapped" in a synchronized collection.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a synchronized view of the specified collection.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedCollection&lt;&gt;(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现就是一行代码，返回一个静态内部类 <code>SynchronizedCollection</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3053995032091335093L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Collection&lt;E&gt; c;  <span class="comment">// Backing Collection</span></span><br><span class="line">    <span class="keyword">final</span> Object mutex;     <span class="comment">// Object on which to synchronize</span></span><br><span class="line"></span><br><span class="line">    SynchronizedCollection(Collection&lt;E&gt; c) &#123;</span><br><span class="line">        <span class="keyword">this</span>.c = Objects.requireNonNull(c);</span><br><span class="line">        mutex = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SynchronizedCollection(Collection&lt;E&gt; c, Object mutex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.c = Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">this</span>.mutex = Objects.requireNonNull(mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.size();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.isEmpty();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.contains(o);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.toArray();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.toArray(a);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.iterator(); <span class="comment">// Must be manually synched by user!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.add(e);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.remove(o);&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; coll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.containsAll(coll);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.addAll(coll);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; coll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.removeAll(coll);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; coll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.retainAll(coll);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;c.clear();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.toString();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Override default methods in Collection</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;c.forEach(consumer);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeIf</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> E&gt; filter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> c.removeIf(filter);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.spliterator(); <span class="comment">// Must be manually synched by user!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.stream(); <span class="comment">// Must be manually synched by user!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.parallelStream(); <span class="comment">// Must be manually synched by user!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream s)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mutex) &#123;s.defaultWriteObject();&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码可见，其实就是返回一个包装类，内部实现使用了 <code>synchronized</code> 关键字加 <code>mutex</code> 对象作为互斥锁，对被包装集合的所有增删改查方法加锁，相当暴力。</p><h1 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h1><p>并发集合作为 <code>java.util.concurrent</code> 包的一部分，提供的并发集合类如下：</p><p><img src="/img/java/collection/concurrent_collections.png" alt="concurrent_collections"></p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><code>Queue</code> 的常用方法差别如下：</p><table><thead><tr><th></th><th><em>Throws exception</em></th><th><em>Returns special value</em></th></tr></thead><tbody><tr><td><strong>Insert</strong></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#add-E-" target="_blank" rel="noopener"><code>add(e)</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#offer-E-" target="_blank" rel="noopener"><code>offer(e)</code></a></td></tr><tr><td><strong>Remove</strong></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#remove--" target="_blank" rel="noopener"><code>remove()</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#poll--" target="_blank" rel="noopener"><code>poll()</code></a></td></tr><tr><td><strong>Examine</strong></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#element--" target="_blank" rel="noopener"><code>element()</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#peek--" target="_blank" rel="noopener"><code>peek()</code></a></td></tr></tbody></table><p>有两种并发队列实现，阻塞队列、并发队列（非阻塞式）：</p><p><img src="/img/java/collection/queue_impl.png" alt="Queue_implementations"></p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p><code>BlockingQueue</code> 扩展自 <code>Queue</code> 接口，主要新增了两组接口（下表后两列），其常用方法差别如下：</p><table><thead><tr><th></th><th><em>Throws exception</em></th><th><em>Returns Special value</em></th><th><em>Times out</em></th><th><em>Blocks</em></th></tr></thead><tbody><tr><td><strong>Insert</strong></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#add-E-" target="_blank" rel="noopener"><code>add(e)</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#offer-E-" target="_blank" rel="noopener"><code>offer(e)</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#offer-E-long-java.util.concurrent.TimeUnit-" target="_blank" rel="noopener"><code>offer(e, time, unit)</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#put-E-" target="_blank" rel="noopener"><code>put(e)</code></a></td></tr><tr><td><strong>Remove</strong></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#remove-java.lang.Object-" target="_blank" rel="noopener"><code>remove()</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#poll-long-java.util.concurrent.TimeUnit-" target="_blank" rel="noopener"><code>poll()</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#poll-long-java.util.concurrent.TimeUnit-" target="_blank" rel="noopener"><code>poll(time, unit)</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#take--" target="_blank" rel="noopener"><code>take()</code></a></td></tr><tr><td><strong>Examine</strong></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#element--" target="_blank" rel="noopener"><code>element()</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#peek--" target="_blank" rel="noopener"><code>peek()</code></a></td><td><em>not applicable</em></td><td><em>not applicable</em></td></tr></tbody></table><p><code>ThreadPoolExecutor</code> 目前使用了 <code>BlockingQueue</code> 的这些方法：</p><ul><li>入队 <code>offer(e)</code></li><li>出队 <code>poll(time, unit)</code> 或 <code>take()</code></li></ul><p>阻塞队列 <code>BlockingQueue</code> 的实现如下：</p><ul><li><p>有界队列（数组实现）：</p><ul><li><code>ArrayBlockingQueue</code>，基于数组实现的有界阻塞队列。</li></ul></li><li><p>无界队列（链表实现）：</p><ul><li><code>LinkedBlockingQueue</code>，基于链表实现的可选无界阻塞队列。默认用于 <code>Executors.newFixedThreadPool(...)</code> 和 <code>newSingleThreadExecutor(...)</code>。</li><li><code>LinkedTransferQueue</code></li><li><code>PriorityBlockingQueue</code>，基于堆实现（底层是数组）的具有优先级的无界阻塞队列。</li><li><code>DelayedQueue</code></li></ul></li><li><p>无容量队列：</p><ul><li><code>SynchronousQueue</code>，无容量阻塞队列，每个插入操作都必须等待另一个线程的移除操作，反之亦然。默认用于 <code>Executors.newCachedThreadPool(...)</code>。</li></ul></li></ul><p><img src="/img/java/collection/BlockingQueue_implementations.png" alt="BlockingQueue"></p><p>阻塞双端队列 <code>BlockingDeque</code> 的实现如下：</p><p><img src="/img/java/collection/BlockingDeque_implementations.png" alt="BlockingDeque_implementations"></p><h3 id="并发队列（非阻塞）"><a href="#并发队列（非阻塞）" class="headerlink" title="并发队列（非阻塞）"></a>并发队列（非阻塞）</h3><p><code>ConcurrentLinkedQueue</code></p><p><code>ConcurrentLinkedDeque</code></p><h2 id="并发散列表"><a href="#并发散列表" class="headerlink" title="并发散列表"></a>并发散列表</h2><p><code>ConcurrentMap</code></p><ul><li><code>ConcurrentHashMap</code></li></ul><p><img src="/img/java/collection/ConcurrentHashMap.png" alt="ConcurrentHashMap"></p><h2 id="并发跳表"><a href="#并发跳表" class="headerlink" title="并发跳表"></a>并发跳表</h2><p><code>ConcurrentSkipListSet</code></p><p><code>ConcurrentNavigableMap</code></p><ul><li><code>ConcurrentSkipListMap</code></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/way2016/article/details/93380850" target="_blank" rel="noopener">https://blog.csdn.net/way2016/article/details/93380850</a></p><p><a href="https://www.cnblogs.com/gujiande/p/9485493.html" target="_blank" rel="noopener">https://www.cnblogs.com/gujiande/p/9485493.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合框架系列（二）集合特性总结</title>
      <link href="2018/04/14/java-collections-framework-features/"/>
      <url>2018/04/14/java-collections-framework-features/</url>
      
        <content type="html"><![CDATA[<p>集合接口中的许多修改方法都被标记为<em>可选（optional）</em>。实现类允许按需实现，未实现的方法需抛出运行时异常 <code>UnsupportedOperationException</code>。每个实现类的文档必须指明支持哪些可选操作。集合框架引入下列术语来帮助阐述本规范：</p><h1 id="定长-变长"><a href="#定长-变长" class="headerlink" title="定长/变长"></a>定长/变长</h1><p>长度保证不变（即使元素可以更改）的列表称为 <strong><em>fixed-size</em></strong> 定长列表。反之则称为 <strong><em>variable-size</em></strong> 变长列表。</p><p>开发中接触最多的定长集合是通过 <code>Arrays.asList()</code> 创建的，该方法是一个适配器接口，将数组适配为定长列表，返回的对象是一个 <code>Arrays</code> 内部类，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a fixed-size list backed by the specified array.  (Changes to</span></span><br><span class="line"><span class="comment"> * the returned list "write through" to the array.)  This method acts</span></span><br><span class="line"><span class="comment"> * as bridge between array-based and collection-based APIs, in</span></span><br><span class="line"><span class="comment"> * combination with &#123;<span class="doctag">@link</span> Collection#toArray&#125;.  The returned list is</span></span><br><span class="line"><span class="comment"> * serializable and implements &#123;<span class="doctag">@link</span> RandomAccess&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This method also provides a convenient way to create a fixed-size</span></span><br><span class="line"><span class="comment"> * list initialized to contain several elements:</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> *     List&lt;String&gt; stooges = Arrays.asList("Larry", "Moe", "Curly");</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the class of the objects in the array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a the array by which the list will be backed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a list view of the specified array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"varargs"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2764017481108945198L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> E[] a;</span><br><span class="line"></span><br><span class="line">    ArrayList(E[] array) &#123;</span><br><span class="line">        a = Objects.requireNonNull(array);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析发现，涉及元素增删的操作（如 <code>add()、remove()、clear()</code>）该内部类并没有实现，而是使用了父类 <code>AbstractList</code> 的方法，默认抛出 <code>UnsupportedOperationException</code> 异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考手册：</p><p><img src="/img/java/collection/arrays_aslist.png" alt="arrays_aslist"></p><h1 id="可改-不可改"><a href="#可改-不可改" class="headerlink" title="可改/不可改"></a>可改/不可改</h1><p>不支持修改操作（例如 <code>add</code>、<code>remove</code> 和 <code>clear</code>）的集合称为 <strong><em>unmodifiable</em></strong> 不可修改集合。反之则称为 <strong><em>modifiable</em></strong> 可修改集合。<code>Collections</code> 工具类提供了一组静态工厂方法，用于包装并返回指定集合的不可修改视图（<em>unmodifiable view</em>），如果尝试修改，则会抛出<code>UnsupportedOperationException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.unmodifiableCollection</span><br><span class="line">Collections.unmodifiableSet</span><br><span class="line">Collections.unmodifiableSortedSet</span><br><span class="line">Collections.unmodifiableNavigableSet</span><br><span class="line">Collections.unmodifiableList</span><br><span class="line">Collections.unmodifiableMap</span><br><span class="line">Collections.unmodifiableSortedMap</span><br><span class="line">Collections.unmodifiableNavigableMap</span><br></pre></td></tr></table></figure><p>从源码分析，该包装类覆盖了所有修改方法并抛出异常 <code>UnsupportedOperationException</code>，实现非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1820017752578914078L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Collection&lt;? extends E&gt; c;</span><br><span class="line"></span><br><span class="line">    UnmodifiableCollection(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; coll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; coll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; coll)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="可变-不可变"><a href="#可变-不可变" class="headerlink" title="可变/不可变"></a>可变/不可变</h1><p>在 <em>unmodifiable</em> 的基础上，加之保证 <code>Collection</code> 实现类的底层数据为 <code>final</code> 的集合称为 <strong><em>immutable</em></strong> 不可变集合。反之则称为 <strong><em>mutable</em></strong> 可变集合。</p><p>Java 9 为 <code>List</code>、<code>Set</code> 和 <code>Map</code> 接口提供了新的静态工厂方法，可以创建这些集合的不可变实例，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"banana"</span>);</span><br><span class="line">Set&lt;String&gt; set = Set.of(<span class="string">"aggie"</span>, <span class="string">"alley"</span>, <span class="string">"steely"</span>);</span><br><span class="line">Map&lt;String, String&gt; map = Map.of(<span class="string">"A"</span>, <span class="string">"Apple"</span>, <span class="string">"B"</span>, <span class="string">"Boy"</span>, <span class="string">"C"</span>, <span class="string">"Cat"</span>);</span><br></pre></td></tr></table></figure><p>而 Java 9 之前，要实现不可变集合只能通过第三方库，例如用 Guava 实现相同效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = ImmutableList.of(<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"banana"</span>);</span><br><span class="line">Set&lt;String&gt; set = ImmutableSet.of(<span class="string">"aggie"</span>, <span class="string">"alley"</span>, <span class="string">"steely"</span>);</span><br><span class="line">Map&lt;String, String&gt; map = ImmutableMap.of(<span class="string">"A"</span>, <span class="string">"Apple"</span>, <span class="string">"B"</span>, <span class="string">"Boy"</span>, <span class="string">"C"</span>, <span class="string">"Cat"</span>);</span><br></pre></td></tr></table></figure><p>Guava 提供的不可变集合 API 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ImmutableAsList</span><br><span class="line">ImmutableBiMap</span><br><span class="line">ImmutableClassToInstanceMap</span><br><span class="line">ImmutableCollection</span><br><span class="line">ImmutableEntry</span><br><span class="line">ImmutableEnumMap</span><br><span class="line">ImmutableEnumSet</span><br><span class="line">ImmutableList</span><br><span class="line">ImmutableListMultimap</span><br><span class="line">ImmutableMap</span><br><span class="line">ImmutableMapEntry</span><br><span class="line">ImmutableMapEntrySet</span><br><span class="line">ImmutableMapKeySet</span><br><span class="line">ImmutableMapValues</span><br><span class="line">ImmutableMultimap</span><br><span class="line">ImmutableMultiset</span><br><span class="line">ImmutableRangeMap</span><br><span class="line">ImmutableRangeSet</span><br><span class="line">ImmutableSet</span><br><span class="line">ImmutableSetMultimap</span><br><span class="line">ImmutableSortedAsList</span><br><span class="line">ImmutableSortedMap</span><br><span class="line">ImmutableSortedMapFauxverideShim</span><br><span class="line">ImmutableSortedMultiset</span><br><span class="line">ImmutableSortedMultisetFauxverideShim</span><br><span class="line">ImmutableSortedSet</span><br><span class="line">ImmutableSortedSetFauxverideShim</span><br><span class="line">ImmutableTable</span><br></pre></td></tr></table></figure><p><img src="/img/java/collection/immutable_collections.PNG" alt="immutable_collections"></p><p>使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = ImmutableList.of(<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"banana"</span>);</span><br><span class="line">Set&lt;String&gt; set = ImmutableSet.of(<span class="string">"aggie"</span>, <span class="string">"alley"</span>, <span class="string">"steely"</span>);</span><br><span class="line">Map&lt;String, String&gt; map = ImmutableMap.of(<span class="string">"A"</span>, <span class="string">"Apple"</span>, <span class="string">"B"</span>, <span class="string">"Boy"</span>, <span class="string">"C"</span>, <span class="string">"Cat"</span>);</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"list=&#123;&#125;, set=&#123;&#125;, map=&#123;&#125;"</span>, fruits, marbles, map);  <span class="comment">// list=[apple, orange, banana], set=[aggie, alley, steely], map=&#123;A=Apple, B=Boy, C=Cat&#125;</span></span><br></pre></td></tr></table></figure><p>除此之外，Apache Commons Lang 也提供了两个好用的类 <code>Pair</code> 和 <code>Triple</code>，可用于存放指定个数的临时数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Triple.of(<span class="string">"left"</span>, <span class="string">"middle"</span>, <span class="string">"right"</span>)</span><br><span class="line">Pair.of(<span class="string">"left"</span>, <span class="string">"right"</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/java/collection/methods_of_Pair_and_Triple.png" alt="methods_of_Pair_and_Triple"></p><h1 id="随机-顺序访问"><a href="#随机-顺序访问" class="headerlink" title="随机/顺序访问"></a>随机/顺序访问</h1><p>支持根据下标索引快速（时间复杂度 <code>0(1)</code>）访问元素的列表称为 <strong><em>random access</em></strong> 随机访问列表。反之则称为 <strong><em>sequential access</em></strong> 顺序访问列表。</p><p>标记接口 <code>java.util.RandomAccess</code> 用于标记列表类支持随机访问，其实现类如下：</p><p><img src="/img/java/collection/RandomAccess.png" alt="RandomAccess"></p><p>该标记接口使得 <code>Collections</code> 工具类中的通用算法实现能够据此更改其行为以提升性能：</p><ul><li><code>binarySearch</code></li><li><code>reverse</code></li><li><code>shuffle</code></li><li><code>fill</code></li><li><code>copy</code></li><li><code>rotate</code></li><li><code>replaceAll</code></li><li><code>indexOfSubList</code></li><li><code>lastIndexOfSubList</code></li><li><code>checkedList</code></li></ul><p>以 <code>binarySearch</code> 为例，源码判断如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="元素限制"><a href="#元素限制" class="headerlink" title="元素限制"></a>元素限制</h1><p>某些集合实现限制了可以存储哪些元素。可能的限制包括：</p><ul><li>元素不能为 <code>null</code>。</li><li>元素必须属于特定类型。</li><li>元素必须匹配某些断言。</li></ul><p>尝试添加违反集合实现限制的元素将导致运行时异常，如 <code>ClassCastException</code>、<code>IllegalArgumentException</code> 或 <code>NullPointerException</code>。</p><h2 id="能否为-null"><a href="#能否为-null" class="headerlink" title="能否为 null"></a>能否为 null</h2><p>参考手册：</p><p><img src="/img/java/collection/map_element_of_null.png" alt="map_element_of_null"></p><h2 id="类型限制"><a href="#类型限制" class="headerlink" title="类型限制"></a>类型限制</h2><p>泛型机制虽然为集合提供了编译期类型检查，但仍然可以在运行期绕过此机制（通过反射也能绕过编译期类型检查）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; intList = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    add(intList);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环到第四个元素时，报错：java.lang.ClassCastException: java.lang.String cannot be cast to java.lang.Integer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> item : intList) &#123;</span><br><span class="line">        log.info(<span class="string">"result is &#123;&#125;"</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">    list.add(<span class="string">"4"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>集合框架提供了一组包装器实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collections.checkedCollection</span><br><span class="line">Collections.checkedQueue</span><br><span class="line">Collections.checkedSet</span><br><span class="line">Collections.checkedSortedSet</span><br><span class="line">Collections.checkedNavigableSet</span><br><span class="line">Collections.checkedList</span><br><span class="line">Collections.checkedMap</span><br><span class="line">Collections.checkedSortedMap</span><br><span class="line">Collections.checkedNavigableMap</span><br></pre></td></tr></table></figure><p>这些包装器实现用于返回指定集合的动态类型安全视图（<em>dynamically type-safe view</em>），核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckedCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1578914078182001775L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Collection&lt;E&gt; c;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;E&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">E <span class="title">typeCheck</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="keyword">null</span> &amp;&amp; !type.isInstance(o))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(badElementMsg(o));</span><br><span class="line">        <span class="keyword">return</span> (E) o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">badElementMsg</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Attempt to insert "</span> + o.getClass() +</span><br><span class="line">            <span class="string">" element into collection with element type "</span> + type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CheckedCollection(Collection&lt;E&gt; c, Class&lt;E&gt; type) &#123;</span><br><span class="line">        <span class="keyword">this</span>.c = Objects.requireNonNull(c, <span class="string">"c"</span>);</span><br><span class="line">        <span class="keyword">this</span>.type = Objects.requireNonNull(type, <span class="string">"type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> c.add(typeCheck(e));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 <code>add</code> 方法为例，每次添加元素时，都会调用 <code>typeCheck</code> 私有方法进行类型检查，如果尝试添加错误类型的元素，则会抛出 <code>ClassCastException</code>，通过 fail fast 防止后续出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; intList = Collections.checkedList(Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), Integer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    add(intList);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> item : intList) &#123;</span><br><span class="line">        log.info(<span class="string">"result is &#123;&#125;"</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(List list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// java.lang.ClassCastException: Attempt to insert class java.lang.String element into collection with element type class java.lang.Integer</span></span><br><span class="line">    list.add(<span class="string">"4"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组转-List-方法"><a href="#数组转-List-方法" class="headerlink" title="数组转 List 方法"></a>数组转 List 方法</h1><p>方法一：转两次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>))  <span class="comment">// from varargs</span></span><br></pre></td></tr></table></figure><p>方法二：Java 8 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包装类型</span></span><br><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; myList = Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 基本类型也可以实现转换（依赖 boxed 的装箱操作）</span></span><br><span class="line"><span class="keyword">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List&lt;Integer&gt; myList2 = Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>方法三：Guava</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不可变集合</span></span><br><span class="line">List&lt;String&gt; il = ImmutableList.of(<span class="string">"string"</span>, <span class="string">"elements"</span>);  <span class="comment">// from varargs</span></span><br><span class="line">List&lt;String&gt; i2 = ImmutableList.copyOf(<span class="keyword">new</span> String[]&#123;<span class="string">"string"</span>, <span class="string">"elements"</span>&#125;);  <span class="comment">// from array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变集合</span></span><br><span class="line">List&lt;String&gt; l0 = Lists.newLinkedList(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>));  <span class="comment">// from collection</span></span><br><span class="line">List&lt;String&gt; l1 = Lists.newArrayList(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>));  <span class="comment">// from collection</span></span><br><span class="line">List&lt;String&gt; l2 = Lists.newArrayList(<span class="keyword">new</span> String[]&#123;<span class="string">"string"</span>, <span class="string">"elements"</span>&#125;);  <span class="comment">// from array</span></span><br><span class="line">List&lt;String&gt; l3 = Lists.newArrayList(<span class="string">"or"</span>, <span class="string">"string"</span>, <span class="string">"elements"</span>); <span class="comment">// from varargs</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://mp.weixin.qq.com/s/-jWmAqAbc-vLV9w541NhxQ" target="_blank" rel="noopener">Arrays.asList()原来是这样用的</a>》</p><p>《<a href="https://mp.weixin.qq.com/s/7ILvz9UreVco0sq9s-zJNg" target="_blank" rel="noopener">千万不要这样使用Arrays.asList !</a>》</p><p>《<a href="https://www.cnblogs.com/peida/p/Guava_ImmutableCollections.html" target="_blank" rel="noopener">Guava学习笔记：Immutable(不可变)集合</a>》</p><p>《<a href="https://blog.csdn.net/Seriousplus/article/details/79750581" target="_blank" rel="noopener">Java 中的 Mutable 和 Immutable</a>》（<a href="http://web.mit.edu/6.031/www/sp17/classes/09-immutability/" target="_blank" rel="noopener">en_US</a>）</p><p><a href="https://stackoverflow.com/questions/7713274/java-immutable-collections" target="_blank" rel="noopener">https://stackoverflow.com/questions/7713274/java-immutable-collections</a></p><ul><li>Unmodifiable collections are usually read-only views (wrappers) of other collections. You can’t add, remove or clear them, but <strong>the underlying collection can change</strong>.</li><li>Immutable collections can’t be changed at all - they don’t wrap another collection - they have their own <code>final</code> elements.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 集合框架系列（一）框架总结</title>
      <link href="2018/04/10/java-collections-framework/"/>
      <url>2018/04/10/java-collections-framework/</url>
      
        <content type="html"><![CDATA[<p>集合（<em>collection</em>）表示一组对象。Java SE 提供了集合框架（<em>collections framework</em>），是一个用于表示和操作集合的统一框架，使集合可以独立于实现细节进行操作。集合框架的主要优点如下：</p><ul><li>通过提供数据结构和算法实现，使用户无需自行编写，<strong>减少编程工作</strong>。</li><li>通过提供数据结构和算法的高性能实现来<strong>提高性能</strong>。由于每个接口的各种实现是可互换的，因此可以通过切换实现来调整和优化程序。</li><li>通过提供一套标准接口来<strong>促进软件重用</strong>。</li><li>通过建立一种通用语言，<strong>为无关联的集合 API 之间提供互操作性</strong>。</li><li><strong>减少学习成本</strong>，只须学习一些特设的集合 API。</li></ul><p>集合框架的整体组成如下：</p><p><img src="/img/java/collection/overview.png" alt="overview"></p><p>下面分别来看下各组成部分。</p><h1 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h1><p>集合接口分为下面两组，这些接口构成了集合框架的基础：</p><ul><li><p><code>java.util.Collection</code>，表示一组对象集合</p><blockquote><p>A collection represents a group of objects, known as its <em>elements</em>. </p><ul><li><p>Some collections allow duplicate elements and others do not. </p></li><li><p>Some are ordered and others unordered. </p></li></ul><p>The JDK does not provide any <em>direct</em> implementations of this interface: it provides implementations of more specific subinterfaces like <code>Set</code> and <code>List</code>. </p><p>This interface is typically used to pass collections around and manipulate them where maximum generality is desired.</p></blockquote></li><li><p><code>java.util.Map</code>，用于存储键值对</p><blockquote><p>An object that maps keys to values.</p><ul><li><p>A map cannot contain duplicate keys; </p></li><li><p>each key can map to at most one value.</p></li></ul></blockquote></li></ul><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p>最基础的集合接口 <code>java.util.Collection</code> 及其子接口如下：</p><p><img src="/img/java/collection/Collection.png" alt="Collection"></p><p>其中，常用的五个重点接口的方法及使用要点如下：</p><p><img src="/img/java/collection/methods_of_collection.png" alt="methods_of_collection"></p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>其它集合接口基于 <code>java.util.Map</code>，不是真正的集合。但是，这些接口包含集合视图（<em>collection-view</em>）操作，使得它们可以作为集合进行操作。</p><p><img src="/img/java/collection/Map.png" alt="Map"></p><p><code>java.util.Map</code> 接口的方法如下:</p><p><img src="/img/java/collection/Map_methods.png" alt="Map methods"></p><h1 id="集合实现类"><a href="#集合实现类" class="headerlink" title="集合实现类"></a>集合实现类</h1><h2 id="抽象类实现"><a href="#抽象类实现" class="headerlink" title="抽象类实现"></a>抽象类实现</h2><p>下列抽象类为核心集合接口提供了基本功能实现，以最小化用户自定义实现的成本。这些抽象类的 API 文档精确地描述了各个方法的实现方式，实现者能够参阅并了解哪些方法需要覆盖：</p><p><img src="/img/java/collection/Collection_abstract_class.png" alt="Collection_abstract_class"></p><h2 id="通用实现"><a href="#通用实现" class="headerlink" title="通用实现"></a>通用实现</h2><p><code>java.util.Collection</code> 的通用实现如下：</p><p><img src="/img/java/collection/collection_impl.png" alt="collection_impl"></p><p><code>java.util.Map</code> 的通用实现如下：</p><p><img src="/img/java/collection/map_impl.JPG" alt="map_impl"></p><p>集合接口的主要实现，命名通常形如 &lt;<em>Implementation-style</em>&gt;&lt;<em>Interface</em>&gt;。通用实现类汇总如下（左列为接口，表头为数据结构）：</p><table><thead><tr><th></th><th><strong>Resizable Array</strong></th><th><strong>Linked List</strong></th><th><strong>Hash Table</strong></th><th><strong>Hash Table + Linked List</strong></th><th><strong>Balanced Tree</strong></th><th><strong>Heap</strong></th></tr></thead><tbody><tr><td><code>List</code></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html" target="_blank" rel="noopener"><code>ArrayList</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" target="_blank" rel="noopener"><code>LinkedList</code></a></td><td></td><td></td><td></td><td></td></tr><tr><td><code>Queue</code></td><td><code>ArrayBlockingQueue</code></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" target="_blank" rel="noopener"><code>LinkedList</code></a><br/><code>LinkedBlockingQueue</code><br/><code>LinkedTransferQueue</code><br/><code>ConcurrentLinkedQueue</code></td><td></td><td></td><td></td><td><code>PriorityBlockingQueue</code><br/><a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html" target="_blank" rel="noopener"><code>PriorityQueue</code></a></td></tr><tr><td><code>Deque</code></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html" target="_blank" rel="noopener"><code>ArrayDeque</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html" target="_blank" rel="noopener"><code>LinkedList</code></a><br/><code>LinkedBlockingDeque</code><br/><code>ConcurrentLinkedDeque</code></td><td></td><td></td><td></td><td></td></tr><tr><td><code>Set</code></td><td></td><td></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html" target="_blank" rel="noopener"><code>HashSet</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashSet.html" target="_blank" rel="noopener"><code>LinkedHashSet</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeSet.html" target="_blank" rel="noopener"><code>TreeSet</code></a></td><td></td></tr><tr><td><code>Map</code></td><td></td><td></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html" target="_blank" rel="noopener"><code>HashMap</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/LinkedHashMap.html" target="_blank" rel="noopener"><code>LinkedHashMap</code></a></td><td><a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html" target="_blank" rel="noopener"><code>TreeMap</code></a></td><td></td></tr></tbody></table><p>通用实现的特性如下：</p><ul><li>通用实现类支持集合接口中的所有可选操作，并且对包含的元素没有限制。</li><li>都是非线程同步的。<code>Collections</code> 工具类提供了称为<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#synchronizedCollection-java.util.Collection-" target="_blank" rel="noopener"><em>同步包装器（synchronization wrappers）</em></a>的静态工厂方法可用于添加同步行为。</li><li>所有集合实现都具有<em>快速失败的迭代器（fail-fast iterators）</em>，可以检测到无效的并发修改，然后快速失败，而不是表现异常。</li></ul><h2 id="遗留实现"><a href="#遗留实现" class="headerlink" title="遗留实现"></a>遗留实现</h2><p>早期版本的集合类，已被改进以实现新的集合接口：</p><ul><li><code>java.util.Vector</code> - <code>List</code> 接口的可变长数组实现，线程同步，包含其它遗留方法。</li><li><code>java.util.Hashtable</code> -  <code>Map</code> 接口的散列表实现，线程同步，键和值都不允许为 <code>null</code>，包含其它遗留方法。继承自抽象类 <code>java.util.Dictionary</code>。</li></ul><h2 id="并发实现"><a href="#并发实现" class="headerlink" title="并发实现"></a>并发实现</h2><p>为高并发使用而设计的实现。详见另一篇《Java 并发集合总结》。</p><h2 id="特殊实现"><a href="#特殊实现" class="headerlink" title="特殊实现"></a>特殊实现</h2><p>用于特殊情况的实现：</p><ul><li><code>CopyOnWriteArrayList</code> 写时复制列表</li><li><code>CopyOnWriteArraySet</code> 写时复制列表</li><li><code>WeakHashMap</code></li><li><code>IdentityHashMap</code></li><li><code>EnumSet</code></li><li><code>EnumMap</code></li></ul><h2 id="适配器实现"><a href="#适配器实现" class="headerlink" title="适配器实现"></a>适配器实现</h2><p>将某个集合接口适配成另一个：</p><ul><li><p>根据 <code>Map</code> 的通用实现创建一个 <code>Set</code> 的通用实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.newSetFromMap(Map)</span><br></pre></td></tr></table></figure></li><li><p>以后进先出（Lifo）队列的形式返回 <code>Deque</code> 的视图：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.asLifoQueue(Deque)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>将数组转换为 <code>List</code> 集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(...)</span><br></pre></td></tr></table></figure></li></ul><h2 id="包装器实现"><a href="#包装器实现" class="headerlink" title="包装器实现"></a>包装器实现</h2><p>用于其它集合实现的功能增强：</p><ul><li><p>返回指定集合的不可修改视图（<em>unmodifiable view</em>），如果尝试修改，则会抛出<code>UnsupportedOperationException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.unmodifiableCollection</span><br><span class="line">Collections.unmodifiableSet</span><br><span class="line">Collections.unmodifiableSortedSet</span><br><span class="line">Collections.unmodifiableNavigableSet</span><br><span class="line">Collections.unmodifiableList</span><br><span class="line">Collections.unmodifiableMap</span><br><span class="line">Collections.unmodifiableSortedMap</span><br><span class="line">Collections.unmodifiableNavigableMap</span><br></pre></td></tr></table></figure></li><li><p>返回由指定集合支持的 <code>synchronized</code> 线程同步集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Collections.synchronizedCollection</span><br><span class="line">Collections.synchronizedSet</span><br><span class="line">Collections.synchronizedSortedSet</span><br><span class="line">Collections.synchronizedNavigableSet</span><br><span class="line">Collections.synchronizedList</span><br><span class="line">Collections.synchronizedMap</span><br><span class="line">Collections.synchronizedSortedMap</span><br><span class="line">Collections.synchronizedNavigableMap</span><br></pre></td></tr></table></figure></li><li><p>返回指定集合的动态类型安全视图（<em>dynamically type-safe view</em>），如果尝试添加错误类型的元素，则会抛出 <code>ClassCastException</code>。泛型机制虽然提供了编译期类型检查，但可以绕过此机制。动态类型安全试图消除了这种可能性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collections.checkedCollection</span><br><span class="line">Collections.checkedQueue</span><br><span class="line">Collections.checkedSet</span><br><span class="line">Collections.checkedSortedSet</span><br><span class="line">Collections.checkedNavigableSet</span><br><span class="line">Collections.checkedList</span><br><span class="line">Collections.checkedMap</span><br><span class="line">Collections.checkedSortedMap</span><br><span class="line">Collections.checkedNavigableMap</span><br></pre></td></tr></table></figure></li></ul><h2 id="便利实现"><a href="#便利实现" class="headerlink" title="便利实现"></a>便利实现</h2><p>集合接口的高性能版“迷你实现”：</p><ul><li><p>返回一个不可变集合（<em>immutable</em>），不包含任何元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collections.emptySet</span><br><span class="line">Collections.emptySortedSet</span><br><span class="line">Collections.emptyNavigableSet</span><br><span class="line">Collections.emptyList</span><br><span class="line">Collections.emptyMap</span><br><span class="line">Collections.emptySortedMap</span><br><span class="line">Collections.emptyNavigableMap</span><br></pre></td></tr></table></figure></li><li><p>返回一个不可变集合（<em>immutable</em>），仅包含一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collections.singleton</span><br><span class="line">Collections.singletonList</span><br><span class="line">Collections.singletonMap</span><br></pre></td></tr></table></figure></li><li><p>返回一个不可变集合（<em>immutable</em>），包含指定元素的 N 个拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.nCopies</span><br></pre></td></tr></table></figure></li><li><p>返回一个由指定数组支持的定长集合（<em>fixed-size</em>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList</span><br></pre></td></tr></table></figure></li></ul><h1 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h1><p>为集合接口提供必要支持的接口。例如：</p><ul><li>迭代器 <code>Iterator</code>、<code>ListIterator</code></li><li>排序接口 <code>Comparable</code>、<code>Comparator</code></li><li>运行时异常 <code>UnsupportedOperationException</code>、<code>ConcurrentModificationException</code></li><li>标记接口 <code>RandomAccess</code></li></ul><h1 id="算法和工具实现"><a href="#算法和工具实现" class="headerlink" title="算法和工具实现"></a>算法和工具实现</h1><p><strong>算法实现</strong>。由工具类 <code>Collections</code> 提供，用于集合，提供了很多静态方法例如 <code>sort</code> 排序、<code>binarySearch</code> 查找、<code>replaceAll</code> 替换等。这些算法体现了多态性，因为相同的方法可以在相似的接口上有着不同的实现。</p><p><strong>数组工具</strong>。由工具类 <code>Arrays</code> 提供，用于基本类型和引用类型数组，提供了很多静态方法例如 <code>sort</code> 排序、<code>binarySearch</code> 查找等。严格来说，这些工具不是集合框架的一部分，此功能在集合框架引入的同时被添加到 Java 平台，并依赖于一些相同的基础设施。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html</a></p><p><a href="https://stackoverflow.com/questions/4978487/why-java-collection-framework-doesnt-contain-tree-and-graph" target="_blank" rel="noopener">Why Java Collection Framework doesn’t contain Tree and Graph ?</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 常用类型系列（六）枚举类型总结</title>
      <link href="2018/04/08/java-enum/"/>
      <url>2018/04/08/java-enum/</url>
      
        <content type="html"><![CDATA[<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Maps;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PayMethodEnum &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 卡支付</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CARDS(<span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 借记支付</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BANK_DEBITS(<span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 网银支付</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BANK_REDIRECTS(<span class="number">2</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 银行转账</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BANK_TRANSFERS(<span class="number">3</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分期付款</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PAY_LATER(<span class="number">4</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 现金支付</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    VOUCHERS(<span class="number">5</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电子钱包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WALLETS(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支付方式编码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, PayMethodEnum&gt; MAP = Maps.newHashMapWithExpectedSize(PayMethodEnum.values().length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Arrays.stream(PayMethodEnum.values()).forEach(aEnum -&gt;</span><br><span class="line">                MAP.put(aEnum.getCode(), aEnum)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PayMethodEnum <span class="title">valueOfCode</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> MAP.get(code);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 常用类型系列（五）Java 8 时区处理总结</title>
      <link href="2018/04/06/java8-time-zone/"/>
      <url>2018/04/06/java8-time-zone/</url>
      
        <content type="html"><![CDATA[<p>本文介绍时区处理的两种方式。时区涉及的接口及实现类如下：</p><p><img src="/img/java/time/classes_of_time_zone.png" alt="classes_of_time_zone"></p><p>（上图简化掉了 <code>Serializable</code> 接口、<code>Comparable</code> 接口及 <code>FunctionalInterface</code> 注解）</p><h1 id="推荐方式"><a href="#推荐方式" class="headerlink" title="推荐方式"></a>推荐方式</h1><h2 id="ZoneId"><a href="#ZoneId" class="headerlink" title="ZoneId"></a>ZoneId</h2><p>时区的处理是新版日期与时间 API 新增的重要功能，且 API 被极大简化。新的 <code>java.time.ZoneId</code> 类是老版本 <code>java.util.TimeZone</code> 类的替代品。它的设计目标就是要让用户无需为时区处理的复杂和繁琐而操心，比如处理夏令时（DST）问题。</p><p>每个特定的 <code>ZoneId</code> 对象都有一个地区 ID 标识。地区 ID 格式为“<code>{区域}/{城市}</code>”，这些地区集合的设定都由 <a href="https://www.iana.org/time-zones" target="_blank" rel="noopener">IANA  的时区数据库</a>提供。静态工厂方法构造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取服务器所在时区的 ZoneId，例如 Asia/Shanghai 为 UTC+8</span></span><br><span class="line">ZoneId currentZone = ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定城市的 ZoneId，即 UTC+1</span></span><br><span class="line">ZoneId zoneId = ZoneId.of(<span class="string">"Europe/Paris"</span>);</span><br></pre></td></tr></table></figure><p>一旦得到一个 <code>ZoneId</code> 对象，就可以与 <code>LocalDate</code>、<code>LocalDateTime</code>、<code>Instant</code> 对象整合起来，构造一个 <code>ZonedDateTime</code> 实例，它代表了<strong>相对于指定时区的时间点</strong>。</p><h2 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h2><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><code>ZonedDateTime</code> 的底层实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ZonedDateTime</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Temporal</span>, <span class="title">ChronoZonedDateTime</span>&lt;<span class="title">LocalDate</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The local date-time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LocalDateTime dateTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The offset from UTC/Greenwich.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZoneOffset offset;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The time-zone.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZoneId zone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ZonedDateTime</code> 的实例如下图：</p><p><img src="/img/java/time/instance_of_ZonedDateTime.png" alt="instance_of_ZonedDateTime"></p><p>图中可见，原本 <code>LocalDateTime</code> 对象作为一个<strong>本地</strong>日期与时间，是不包含时区信息的，即没有时区概念。而在结合了 <code>ZoneId</code> 构造成一个 <code>ZonedDateTime</code> 实例之后，才有了时区概念。它代表了<strong>相对于指定时区的时间点</strong>。</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1970-01-01</span></span><br><span class="line">LocalDate date = LocalDate.ofEpochDay(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 1970-01-01T00:00</span></span><br><span class="line">LocalDateTime dateTime = date.atStartOfDay();</span><br><span class="line"><span class="comment">// 1970-01-01T00:00:00Z</span></span><br><span class="line">Instant instant = Instant.ofEpochSecond(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1970-01-01T00:00+01:00[Europe/Paris]，底层调用 ZonedDateTime.of(this, zoneId)</span></span><br><span class="line">ZonedDateTime zonedDateTime = date.atStartOfDay(zoneId);</span><br><span class="line"><span class="comment">// 1970-01-01T00:00+01:00[Europe/Paris]，底层调用 ZonedDateTime.of(this, zoneId)</span></span><br><span class="line">ZonedDateTime zonedDateTime1 = dateTime.atZone(zoneId);</span><br><span class="line"><span class="comment">// 1970-01-01T01:00+01:00[Europe/Paris]，底层调用 ZonedDateTime.ofInstant(this, zoneId)</span></span><br><span class="line">ZonedDateTime zonedDateTime2 = instant.atZone(zoneId);</span><br><span class="line"><span class="comment">// 2015-12-03T10:15:30+08:00[Asia/Shanghai]</span></span><br><span class="line">ZonedDateTime zonedDateTime3 = ZonedDateTime.parse(<span class="string">"2015-12-03T10:15:30+05:30[Asia/Shanghai]"</span>);</span><br></pre></td></tr></table></figure><h3 id="LocalDateTime-与-Instant-互转"><a href="#LocalDateTime-与-Instant-互转" class="headerlink" title="LocalDateTime 与 Instant 互转"></a>LocalDateTime 与 Instant 互转</h3><p>通过 <code>ZoneId</code> 可以将 <code>LocalDateTime</code> 和 <code>Instant</code> 进行互转，公式为 UTC + 时区差（东正西负）= 本地时间。</p><p><code>LocalDateTime</code> &gt; <code>Instant</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 东八区的 1970-01-01T00:00，等于 UTC+0 的 1969-12-31T16:00:00Z</span></span><br><span class="line">Instant instant2 = dateTime.atZone(ZoneId.systemDefault()).toInstant();</span><br></pre></td></tr></table></figure><p><code>Instant</code> &gt; <code>LocalDateTime</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1970-01-01T00:00</span></span><br><span class="line">LocalDateTime dateTime2 = LocalDateTime.ofInstant(instant2, ZoneId.systemDefault());</span><br><span class="line"><span class="comment">// 1970-01-01T08:00</span></span><br><span class="line">LocalDateTime dateTime3 = instant.atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br></pre></td></tr></table></figure><h1 id="不推荐方式"><a href="#不推荐方式" class="headerlink" title="不推荐方式"></a>不推荐方式</h1><h2 id="ZoneOffset"><a href="#ZoneOffset" class="headerlink" title="ZoneOffset"></a>ZoneOffset</h2><p>另一种比较通用的表达时区的方式是利用当前时区和 UTC/格林尼治的固定偏差。可以使用 <code>ZoneOffset</code> 类，它是 <code>ZoneId</code> 的一个子类，表示的是当前时间和 UTC 的偏差：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneOffset newYorkOffset = ZoneOffset.of(<span class="string">"-05:00"</span>);</span><br></pre></td></tr></table></figure><h2 id="OffsetDateTime"><a href="#OffsetDateTime" class="headerlink" title="OffsetDateTime"></a>OffsetDateTime</h2><h3 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h3><p><code>ZoneOffset</code> 类可用于构造 <code>OffsetDateTime</code> 实例。<code>OffsetDateTime</code> 的底层实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OffsetDateTime</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Temporal</span>, <span class="title">TemporalAdjuster</span>, <span class="title">Comparable</span>&lt;<span class="title">OffsetDateTime</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The local date-time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LocalDateTime dateTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The offset from UTC/Greenwich.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZoneOffset offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1970-01-01T00:00-05:00</span></span><br><span class="line">OffsetDateTime dateTimeInNewYork = OffsetDateTime.of(dateTime1, newYorkOffset); </span><br><span class="line"><span class="comment">// 1970-01-01T00:00-05:00</span></span><br><span class="line">OffsetDateTime dateTimeInNewYork2 = dateTime1.atOffset(newYorkOffset);</span><br></pre></td></tr></table></figure><p>“-05:00” 的偏差实际上对应的是美国东部标准时间。注意，使用这种方式定义的 <code>ZoneOffset</code> 并未考虑任何夏令时的影响，所以在大多数情况下，不推荐使用。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="java-sql-Timestamp"><a href="#java-sql-Timestamp" class="headerlink" title="java.sql.Timestamp"></a>java.sql.Timestamp</h2><p>有时开发会使用 <code>java.sql.Timestamp</code> 作为 PO 实体类的时间字段，<code>java.sql.Timestamp</code> 底层实现使用<strong>格里历（公历）</strong>，并使用<strong>本地时区</strong>（即服务器默认时区），并受该时区影响。</p><p>这里看一段代码，以 2021-01-04 00:00:00 为例演示转换过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.parse(</span><br><span class="line">  <span class="string">"2021-01-04 00:00:00"</span>, </span><br><span class="line">  DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">);</span><br><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, ZoneId.of(<span class="string">"Asia/Jakarta"</span>));</span><br><span class="line"></span><br><span class="line">Timestamp.from(zonedDateTime.toInstant());</span><br><span class="line">Timestamp.valueOf(localDateTime);</span><br></pre></td></tr></table></figure><p>这里试验两个时区：</p><table><thead><tr><th></th><th>Europe/London (UTC)</th><th>Asia/Shanghai (UTC+8)</th></tr></thead><tbody><tr><td><code>ZoneId.systemDefault()</code></td><td>Europe/London (UTC)</td><td>Asia/Shanghai (UTC+8)</td></tr><tr><td><code>TimeZone.getDefaultRef()</code></td><td>Europe/London (UTC)</td><td>Asia/Shanghai (UTC+8)</td></tr></tbody></table><p>下面分别看下 <code>java.sql.Timestamp</code> 两个 API 会有什么问题：</p><h3 id="valueOf-LocalDateTime"><a href="#valueOf-LocalDateTime" class="headerlink" title="#valueOf(LocalDateTime)"></a>#valueOf(LocalDateTime)</h3><p>转换过程：本地时间 &gt; 系统时区的时间 &gt; UTC-0 时区的时间戳</p><table><thead><tr><th>Europe/London (UTC)</th><th>Asia/Shanghai (UTC+8)</th></tr></thead><tbody><tr><td>2021-01-04T00:00 (<code>LocalDateTime</code>) → <br/>2021-01-04T00:00:00.000Z / 1609718400000 (<code>Timestamp</code>)</td><td>2021-01-04T00:00 (<code>LocalDateTime</code>) → <br/>2021-01-04T00:00:00.000+0800 / 1609689600000 (<code>Timestamp</code>)</td></tr></tbody></table><p>可见，由于 <code>LocalDateTime</code> 本身不含时区信息，在经由 <code>Timestamp#valueOf(LocalDateTime)</code> 转换时，源码中使用了 <code>TimeZone.getDefaultRef()</code> 并<strong>受系统默认时区的影响，导致结果前后不一致</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the reference to the default TimeZone object. This</span></span><br><span class="line"><span class="comment"> * method doesn't create a clone.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TimeZone <span class="title">getDefaultRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TimeZone defaultZone = defaultTimeZone;</span><br><span class="line">    <span class="keyword">if</span> (defaultZone == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Need to initialize the default time zone.</span></span><br><span class="line">        defaultZone = setDefaultZone();</span><br><span class="line">        <span class="keyword">assert</span> defaultZone != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Don't clone here.</span></span><br><span class="line">    <span class="keyword">return</span> defaultZone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="from-Instant"><a href="#from-Instant" class="headerlink" title="#from(Instant)"></a>#from(Instant)</h3><p>转换过程：本地时间 &gt; 指定时区的时间 &gt; UTC-0 时区的时间戳</p><table><thead><tr><th>Europe/London (UTC)</th><th>Asia/Shanghai (UTC+8)</th></tr></thead><tbody><tr><td>2021-01-04T00:00 (<code>LocalDateTime</code>) → <br/>2021-01-04T00:00+07:00[Asia/Jakarta] (<code>ZonedDateTime</code>) → <br/>2021-01-03T17:00:00Z / 1609693200 (<code>Instant</code>) →<br/>2021-01-03T17:00:00.000Z / 1609693200000(<code>Timestamp</code>)</td><td>2021-01-04T00:00 (<code>LocalDateTime</code>) → <br/>2021-01-04T00:00+07:00[Asia/Jakarta] (<code>ZonedDateTime</code>) → <br/>2021-01-03T17:00:00Z / 1609693200 (<code>Instant</code>) →<br/>2021-01-04T01:00:00.000+0800 / 1609693200000 (<code>Timestamp</code>)</td></tr></tbody></table><p>这里看似结果没有问题，<code>Instant</code> 和 <code>Timestamp</code> 对象在不同时区下都是相同时间戳。</p><p>但有一种场景，就是<strong>应用服务器与数据库的时区不一致导致的问题</strong>。假如应用服务器时区为 <code>Asia/Shanghai (UTC+8)</code>，数据库时区为 <code>Europe/London (UTC)</code>，当把上表 <code>Timestamp</code> 对象保存到 MySQL 数据库的 <code>datetime</code> 字段时，如果未经时区转换，会导致错误结果。</p><p>这里参考 <a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java" target="_blank" rel="noopener">mysql-connector-java-5.1.42.jar</a> 源码如下，重点看 <code>java.sql.PreparedStatement#setTimestamp</code> 的方法实现，其使用了 <code>SimpleDateFormat</code> 将 <code>Timestamp</code> 对象格式化成字符串，<strong>如果未经时区转换，结果如下表，导致前后不一致</strong>：</p><table><thead><tr><th>格式化前</th><th>格式化后</th></tr></thead><tbody><tr><td>2021-01-03T17:00:00.000Z</td><td>2021-01-03 17:00:00</td></tr><tr><td>2021-01-04T01:00:00.000+0800</td><td>2021-01-04 01:00:00</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set a parameter to a java.sql.Timestamp value. The driver converts this</span></span><br><span class="line"><span class="comment"> * to a SQL TIMESTAMP value when it sends it to the database.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameterIndex</span></span><br><span class="line"><span class="comment"> *            the first parameter is 1, the second is 2, ...</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> *            the parameter value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tz</span></span><br><span class="line"><span class="comment"> *            the timezone to use</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> *             if a database-access error occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setTimestampInternal</span><span class="params">(<span class="keyword">int</span> parameterIndex, Timestamp x, Calendar targetCalendar, TimeZone tz, <span class="keyword">boolean</span> rollForward)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    x = TimeUtil.changeTimezone(<span class="keyword">this</span>.connection, sessionCalendar, targetCalendar, x, tz, <span class="keyword">this</span>.connection.getServerTimezoneTZ(), rollForward);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.tsdf == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.tsdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"''yyyy-MM-dd HH:mm:ss"</span>, Locale.US);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                    buf.append(<span class="keyword">this</span>.tsdf.format(x));</span><br><span class="line">                    </span><br><span class="line">                    ...</span><br><span class="line">                    </span><br><span class="line">                    setInternal(parameterIndex, buf.toString());</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法内部调用了 <code>com.mysql.jdbc.TimeUtil#changeTimezone</code> 方法，源码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Change the given timestamp from one timezone to another</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment"> *            the current connection to the MySQL server</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tstamp</span></span><br><span class="line"><span class="comment"> *            the timestamp to change</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromTz</span></span><br><span class="line"><span class="comment"> *            the timezone to change from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toTz</span></span><br><span class="line"><span class="comment"> *            the timezone to change to</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the timestamp changed to the timezone 'toTz'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Timestamp <span class="title">changeTimezone</span><span class="params">(MySQLConnection conn, Calendar sessionCalendar, Calendar targetCalendar, Timestamp tstamp, TimeZone fromTz,</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeZone toTz, <span class="keyword">boolean</span> rollForward)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((conn != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="comment">// 开启 useTimezone=true，才能进入下面的时区转换逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (conn.getUseTimezone()) &#123;</span><br><span class="line">            <span class="comment">// Convert the timestamp from GMT to the server's timezone</span></span><br><span class="line">            Calendar fromCal = Calendar.getInstance(fromTz);</span><br><span class="line">            fromCal.setTime(tstamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> fromOffset = fromCal.get(Calendar.ZONE_OFFSET) + fromCal.get(Calendar.DST_OFFSET);</span><br><span class="line">            Calendar toCal = Calendar.getInstance(toTz);</span><br><span class="line">            toCal.setTime(tstamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> toOffset = toCal.get(Calendar.ZONE_OFFSET) + toCal.get(Calendar.DST_OFFSET);</span><br><span class="line">            <span class="keyword">int</span> offsetDiff = fromOffset - toOffset;</span><br><span class="line">            <span class="keyword">long</span> toTime = toCal.getTime().getTime();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rollForward) &#123;</span><br><span class="line">                toTime += offsetDiff;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                toTime -= offsetDiff;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Timestamp changedTimestamp = <span class="keyword">new</span> Timestamp(toTime);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> changedTimestamp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (conn.getUseJDBCCompliantTimezoneShift()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (targetCalendar != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                Timestamp adjustedTimestamp = <span class="keyword">new</span> Timestamp(jdbcCompliantZoneShift(sessionCalendar, targetCalendar, tstamp));</span><br><span class="line"></span><br><span class="line">                adjustedTimestamp.setNanos(tstamp.getNanos());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> adjustedTimestamp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tstamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 JDBC 连接参数未配置 <code>useTimezone=true</code>（默认值 <code>false</code>），会导致目标时区转换失效，从而产生上述问题。<strong>而如果开启之后，不管应用服务器设置什么时区，都能保证正确转换为数据库目标时区的时间值，反之亦然（数据库 -&gt; 应用服务器）。</strong>这里给两个例子，如下表：</p><table><thead><tr><th></th><th>时区转换前</th><th>时区转换后</th></tr></thead><tbody><tr><td>UTC+2</td><td>2021-01-03T19:00:00.000+0200 / 1609693200</td><td>2021-01-03T17:00:00.000Z / 1609693200</td></tr><tr><td>UTC+8</td><td>2021-01-04T01:00:00.000+0800 / 1609693200</td><td>2021-01-03T17:00:00.000Z / 1609693200</td></tr></tbody></table><p><img src="/img/java/time/after_convert_time_zone+2.png" alt="after_convert_time_zone+2"></p><p><img src="/img/java/time/after_convert_time_zone+8.png" alt="after_convert_time_zone+8"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《Java 8 实战》</li><li>Java SE Docs</li><li><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6" target="_blank" rel="noopener">协调世界时（UTC） - 维基百科</a></li><li><a href="https://www.zeitverschiebung.net/cn/" target="_blank" rel="noopener">时区转换器：计算世界各个时区的时差</a></li><li><a href="https://time.is/UTC" target="_blank" rel="noopener">https://time.is/UTC</a></li><li><a href="http://www.timezoneconverter.com/cgi-bin/zoneinfo" target="_blank" rel="noopener">Time Zone Converter</a></li><li><a href="https://www.coder.work/article/6269420" target="_blank" rel="noopener">《Java时区数据库与IANA数据》</a></li><li><a href="https://segmentfault.com/q/1010000000262788" target="_blank" rel="noopener">《Mysql JDBC里的useTimezone参数是做什么用的？》</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 常用类型系列（四）Java 8 日期与时间总结</title>
      <link href="2018/04/05/java8-time/"/>
      <url>2018/04/05/java8-time/</url>
      
        <content type="html"><![CDATA[<h1 id="现有问题"><a href="#现有问题" class="headerlink" title="现有问题"></a>现有问题</h1><p><code>java.util.Date</code> 存在的问题：</p><ul><li>正如类名所表达的，这个类无法表示“日期”（替代方案是 <code>LocalDate</code>），只能以毫秒的精度表示“时间”（替代方案是 <code>LocalDateTime</code>）。</li><li>更糟糕的是它的易用性，比如：年份的起始选择是 1900 年，月份的起始从 0 开始。如果要表达 2014 年 3 月 18 日，需要创建以下 <code>Date</code> 实例：<code>Date date = new Date(144，2，18)</code></li><li>非线程安全，且所有的日期类都是可变的，这表示在运行期其值可以任意修改，这是 Java 日期类最大的问题之一。</li></ul><p><code>java.util.Date</code> 及 <code>java.sql.Timestamp</code> API 如下：</p><p><img src="/img/java/time/java_time_old_api.png" alt="java time old api"></p><h1 id="Java-8-日期与时间"><a href="#Java-8-日期与时间" class="headerlink" title="Java 8 日期与时间"></a>Java 8 日期与时间</h1><p>Java 8 引入了新的 <code>java.time</code> 类库，用于加强对日期与时间的操作，本文主要总结其 API 结构、具体实现和使用方式。</p><p>先看下涉及的包结构简介：</p><table><thead><tr><th>Package</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/time/package-summary.html" target="_blank" rel="noopener">java.time</a></td><td>The main API for dates, times, instants, and durations.</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/package-summary.html" target="_blank" rel="noopener">java.time.temporal</a></td><td>Access to date and time using fields and units, and date time adjusters.</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/time/chrono/package-summary.html" target="_blank" rel="noopener">java.time.chrono</a></td><td>Generic API for calendar systems other than the default ISO.</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/time/zone/package-summary.html" target="_blank" rel="noopener">java.time.zone</a></td><td>Support for time-zones and their rules.</td></tr><tr><td><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/package-summary.html" target="_blank" rel="noopener">java.time.format</a></td><td>Provides classes to print and parse dates and times.</td></tr></tbody></table><h2 id="java-time"><a href="#java-time" class="headerlink" title="java.time"></a>java.time</h2><p><code>java.time</code> 包的核心接口：</p><p><img src="/img/java/time/java-time%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3.png" alt="java-time核心接口"></p><p><code>java.time</code> 包的常用类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Year              <span class="comment">// 2007</span></span><br><span class="line">YearMonth         <span class="comment">// 2007-12</span></span><br><span class="line">MonthDay          <span class="comment">// --12-03</span></span><br><span class="line"></span><br><span class="line">LocalDate         <span class="comment">// 2007-12-03</span></span><br><span class="line">LocalTime         <span class="comment">// 10:15:30</span></span><br><span class="line">LocalDateTime     <span class="comment">// 2007-12-03T10:15:30</span></span><br><span class="line"></span><br><span class="line">OffsetTime        <span class="comment">// 10:15:30+01:00</span></span><br><span class="line">OffsetDateTime    <span class="comment">// 2007-12-03T10:15:30+01:00</span></span><br><span class="line">ZonedDateTime     <span class="comment">// 2007-12-03T10:15:30+01:00 Europe/Paris</span></span><br><span class="line"></span><br><span class="line">Instant           <span class="comment">// 以 Unix 元年时间（UTC 时区 1970-01-01T00:00:00Z，“Z” 代表 UTC 时区）开始所经历的秒数</span></span><br></pre></td></tr></table></figure><p><img src="/img/java/time/java.time%E6%A0%B8%E5%BF%83%E7%B1%BB.png" alt="java.time核心类"></p><h2 id="java-time-temporal"><a href="#java-time-temporal" class="headerlink" title="java.time.temporal"></a>java.time.temporal</h2><p><code>java.time.temporal</code> 包的核心接口：</p><table><thead><tr><th>Interface</th><th>Description</th></tr></thead><tbody><tr><td><code>TemporalAccessor</code></td><td>框架级别的根接口，定义了对 temporal 对象的只读访问。</td></tr><tr><td><code>Temporal</code></td><td>框架级别的接口，定义了对 temporal 对象的读写访问。实现类有 <code>LocalDate</code>、<code>OffsetDateTime</code>、<code>Instant</code> 等等。继承自 <code>TemporalAccessor</code>。</td></tr><tr><td><code>TemporalAmount</code></td><td>框架级别的接口，定义了一个时间段，例如”6 小时“、”8 天“、”3 个月“。实现类有 <code>Duration</code>、<code>Period</code>。可传入 temporal 对象的 <code>plus</code> 或 <code>minus</code> 方法进行时间调整。</td></tr><tr><td><code>TemporalUnit</code></td><td>日期和时间的单元，<code>ChronoUnit</code> 枚举实现了该接口。可传入 temporal 对象的 <code>plus</code> 或 <code>minus</code> 方法进行时间调整。</td></tr><tr><td><code>TemporalField</code></td><td>日期和时间的字段。<code>ChronoField</code> 枚举实现了该接口，可传入 temporal 对象的 <code>get</code> 或 <code>with</code> 方法获取或修改枚举对应的值。</td></tr><tr><td><code>TemporalAdjuster</code></td><td>函数式接口，定义了对 temporal 对象的调整策略。可以使用 <code>TemporalAdjusters</code> 工具类的静态工厂方法生成对象实例，并传入temporal 对象的 <code>with</code> 方法进行时间调整。</td></tr></tbody></table><p><img src="/img/java/time/temporal%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3.png" alt="ChronoLocalDate核心接口方法"></p><h1 id="LocalDate、LocalTime"><a href="#LocalDate、LocalTime" class="headerlink" title="LocalDate、LocalTime"></a>LocalDate、LocalTime</h1><p><code>LocalDate</code>、<code>LocalTime</code> 是人类易读的日期和时间格式，表示一个本地时间点，<strong>无时区信息</strong>。</p><h2 id="历法系统介绍"><a href="#历法系统介绍" class="headerlink" title="历法系统介绍"></a>历法系统介绍</h2><p>首先了解几个概念：</p><h3 id="历法"><a href="#历法" class="headerlink" title="历法"></a>历法</h3><p><a href="https://zh.wikipedia.org/wiki/历法" target="_blank" rel="noopener">历法</a>，或称日历，是用<a href="https://zh.wikipedia.org/wiki/年" target="_blank" rel="noopener">年</a>、<a href="https://zh.wikipedia.org/wiki/月" target="_blank" rel="noopener">月</a>、<a href="https://zh.wikipedia.org/wiki/日" target="_blank" rel="noopener">日</a>等时间单位计算时间的方法。Java 8 提供的历法实现如下：</p><table><thead><tr><th>历法</th><th>Java 8 实现</th></tr></thead><tbody><tr><td><a href="https://zh.wikipedia.org/wiki/格里曆" target="_blank" rel="noopener">格里历（公历）</a>，即 <a href="https://en.wikipedia.org/wiki/Gregorian_calendar" target="_blank" rel="noopener">Gregorian calendar</a></td><td><code>LocalDate</code></td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/和历" target="_blank" rel="noopener">和历</a></td><td><code>JapaneseDate</code></td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/民國紀年" target="_blank" rel="noopener">中华民国历</a></td><td><code>MinguoDate</code></td></tr><tr><td><a href="https://zh.wikipedia.org/wiki/泰國曆" target="_blank" rel="noopener">泰国历</a></td><td><code>ThaiBuddhistDate</code></td></tr><tr><td><a href="https://zh.wikipedia.org/zh/伊斯兰历" target="_blank" rel="noopener">伊斯兰历（回历）</a></td><td><code>HijrahDate</code></td></tr></tbody></table><p><a href="https://zh.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">ISO-8601</a> 日历系统是世界文明日历系统的事实标准，其<strong>日期表示法</strong>为：</p><blockquote><p>年由4位数字组成YYYY，或者带正负号的四或五位数字表示±YYYYY。以<strong><a href="https://zh.wikipedia.org/wiki/公历" target="_blank" rel="noopener">公历</a>公元</strong>1年为0001年，以公元前1年为0000年，公元前2年为-0001年，其他以此类推。</p><p>月、日用两位数字表示：MM、DD。</p></blockquote><p>Java 8 中 <code>LocalDate</code> 基于 ISO-8601 实现。另外还提供了四种其它的日历系统。这些日历系统中的每一个都有一个对应的类，如下图。所有这些类都实现了 <code>java.time.chrono.ChronoLocalDate</code> 接口，能够对公历的日期进行建模。</p><p><img src="/img/java/time/ChronoLocalDate%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt="ChronoLocalDate实现类"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格里历（公历）</span></span><br><span class="line">LocalDate date = LocalDate.now();</span><br><span class="line"><span class="comment">// 和历</span></span><br><span class="line">JapaneseDate japaneseDate = JapaneseDate.from(date);</span><br><span class="line"><span class="comment">// 中华民国历</span></span><br><span class="line">MinguoDate minguoDate = MinguoDate.from(date);</span><br><span class="line"><span class="comment">// 泰国历</span></span><br><span class="line">ThaiBuddhistDate thaiBuddhistDate = ThaiBuddhistDate.from(date);</span><br><span class="line"><span class="comment">// 伊斯兰历（回历）</span></span><br><span class="line">HijrahDate hijrahDate = HijrahDate.from(date);</span><br></pre></td></tr></table></figure><p>还有一些常见的历法，例如：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E4%BC%A0%E7%BB%9F%E5%8E%86%E6%B3%95" target="_blank" rel="noopener">中国传统历法</a></li><li><a href="https://zh.wikipedia.org/wiki/會計年度" target="_blank" rel="noopener">会计年度</a>：</li></ul><blockquote><p>财政年度，又称会计年度，是指公司或国家每年制定预算或计算收入的统计时间。但每个国家或其法例所辖的组织各有不同，大抵分成两类：</p><ul><li>历年制，即是由1月1日起，使用历年制有中国、德国、法国、等等。</li><li>跨年制，使用跨年制有美国、日本、香港、澳大利亚、等等。</li></ul><p>在会计上常会用 <a href="https://en.wikipedia.org/wiki/4-4-5_Calendar" target="_blank" rel="noopener">4/4/5 日历</a>，每一个月会有固定的周数，以便各月之间和各年之间的比较。</p></blockquote><h3 id="纪年"><a href="#纪年" class="headerlink" title="纪年"></a>纪年</h3><blockquote><p><a href="https://zh.wikipedia.org/wiki/纪年" target="_blank" rel="noopener">纪年</a>，或称<strong>纪元</strong>，是指<a href="https://zh.wikipedia.org/wiki/历法" target="_blank" rel="noopener">历法</a>中的<strong>年份</strong>命名体系，例如<a href="https://zh.wikipedia.org/wiki/格里曆" target="_blank" rel="noopener">格里历</a>（公历）所使用的<a href="https://zh.wikipedia.org/wiki/基督纪年" target="_blank" rel="noopener">基督纪年</a>（<a href="https://zh.wikipedia.org/wiki/公元" target="_blank" rel="noopener">公元</a>），中国<a href="https://zh.wikipedia.org/wiki/农历" target="_blank" rel="noopener">农历</a>使用的<a href="https://zh.wikipedia.org/wiki/干支纪年" target="_blank" rel="noopener">干支纪年</a>等。世界各地曾存在过各种不同的纪年方法，其中一些至今仍在使用，例如日本现在仍在使用<a href="https://zh.wikipedia.org/wiki/年号纪年" target="_blank" rel="noopener">年号纪年</a>。</p><p>这里提供了一个常见的<a href="https://zh.wikipedia.org/wiki/%E6%B0%91%E5%9C%8B%E7%B4%80%E5%B9%B4#%E7%B4%80%E5%B9%B4%E5%B0%8D%E7%85%A7" target="_blank" rel="noopener">纪年对照表</a>，可供参考。 </p></blockquote><p>-</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%B9%B4%E5%8F%B7" target="_blank" rel="noopener">年号</a>是中国历史君主时代帝王纪年所立的名号，缘起于西汉汉武帝时期，后来朝鲜新罗在6世纪、日本在7世纪后期、越南在10世纪都因为中国的影响，开始使用年号；台湾岛的郑氏王朝与台湾民主国、朝鲜半岛大韩帝国与高丽、蒙古国建国初年受到中国影响，都还使用过年号，目前唯一使用年号的是仍保持君主制的日本。</p><p>值得一提，<a href="https://zh.wikipedia.org/wiki/中華民國" target="_blank" rel="noopener">中华民国</a>所用的<a href="https://zh.wikipedia.org/wiki/民國紀年" target="_blank" rel="noopener">民国纪年</a>、以及<a href="https://zh.wikipedia.org/wiki/朝鮮民主主義人民共和國" target="_blank" rel="noopener">朝鲜民主主义人民共和国</a>使用的<a href="https://zh.wikipedia.org/wiki/主体纪年" target="_blank" rel="noopener">主体纪年</a>，常被误认为是年号，实际上仅是单纯的纪年<a href="https://zh.wikipedia.org/wiki/曆法" target="_blank" rel="noopener">历法</a>。</p></blockquote><p>-</p><blockquote><p><a href="https://zh.wikipedia.org/wiki/%E4%B8%80%E4%B8%96%E4%B8%80%E5%85%83%E5%88%B6" target="_blank" rel="noopener">一世一元制</a>，指<a href="https://zh.wikipedia.org/wiki/君主" target="_blank" rel="noopener">君主</a>(国王、大君主、可汗、天皇、皇帝)在其在位期间只使用同一个<a href="https://zh.wikipedia.org/wiki/年號" target="_blank" rel="noopener">年号</a>，不进行改元的制度。例外：如果君主后来另行称帝或是重祚，会另建新年号，以示区别。</p></blockquote><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p><code>LocalDate</code> 的底层实现包含不可变的年、月、日：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDate</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Temporal</span>, <span class="title">TemporalAdjuster</span>, <span class="title">ChronoLocalDate</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The year.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> year;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The month-of-year.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> month;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The day-of-month.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LocalTime</code> 的底层实现包含不可变的时、分、秒、纳秒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalTime</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Temporal</span>, <span class="title">TemporalAdjuster</span>, <span class="title">Comparable</span>&lt;<span class="title">LocalTime</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The hour.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> hour;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The minute.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> minute;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The second.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> second;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The nanosecond.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> nano;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>LocalDateTime</code> 的底层实现包含不可变的 <code>LocalDate</code> 和 <code>LocalTime</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalDateTime</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Temporal</span>, <span class="title">TemporalAdjuster</span>, <span class="title">ChronoLocalDateTime</span>&lt;<span class="title">LocalDate</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The date part.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LocalDate date;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The time part.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LocalTime time;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><table><thead><tr><th>方法名</th><th>是否静态方法</th><th>描述</th></tr></thead><tbody><tr><td><code>of</code></td><td>是</td><td>由 <code>Temporal</code> 对象的某个部分创建该对象。</td></tr><tr><td><code>now</code></td><td>是</td><td>依据系统时钟创建 <code>Temporal</code> 对象。</td></tr><tr><td><code>from</code></td><td>是</td><td>依据传入的 <code>Temporal</code> 对象创建对象。</td></tr><tr><td><code>parse</code></td><td>是</td><td>由字符串创建 <code>Temporal</code> 对象。</td></tr><tr><td><code>format</code></td><td>否</td><td>使用某个指定的 <code>DateTimeFormatter</code> 将 <code>Temporal</code> 对象转换为字符串。</td></tr><tr><td><code>atOffset</code></td><td>否</td><td>将 <code>Temporal</code> 对象和某个时区偏移相结合。</td></tr><tr><td><code>atZone</code></td><td>否</td><td>将 <code>Temporal</code> 对象和某个时区相结合。</td></tr><tr><td><code>get</code></td><td>否</td><td>读取 <code>Temporal</code> 对象的某一部分值。</td></tr><tr><td><code>minus</code></td><td>否</td><td>创建 <code>Temporal</code> 对象的副本，通过将当前 <code>Temporal</code> 对象的值减去一定的时长创建该副本。</td></tr><tr><td><code>plus</code></td><td>否</td><td>创建 <code>Temporal</code> 对象的副本，通过将当前 <code>Temporal</code> 对象的值加上一定的时长创建该副本。</td></tr><tr><td><code>with</code></td><td>否</td><td>以该 <code>Temporal</code> 对象为模板，对某些状态进行修改创建该对象的副本。</td></tr></tbody></table><p>例子：</p><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过静态工厂方法创建实例</span></span><br><span class="line">LocalTime time = LocalTime.of(<span class="number">12</span>, <span class="number">0</span>);</span><br><span class="line">LocalDate date = LocalDate.of(<span class="number">2007</span>, <span class="number">12</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 1970-01-01。epoch day（历元日）是一个简单的天数递增计数，其中第 0 天表示 1970-01-01。负数代表更早的日期。</span></span><br><span class="line">LocalDate date1 = LocalDate.ofEpochDay(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 通过静态方法创建实例</span></span><br><span class="line">LocalDate date2 = LocalDate.parse(<span class="string">"2007-12-03"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并日期和时间</span></span><br><span class="line">LocalDateTime dateTime = date.atTime(time);</span><br><span class="line">LocalDateTime dateTime1 = time.atDate(date);</span><br><span class="line">LocalDateTime dateTime2 = date.atStartOfDay();</span><br><span class="line">LocalDateTime dateTime3 = LocalDateTime.of(date, time);</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.time.LocalDateTime 转 java.sql.Timestamp</span></span><br><span class="line">Timestamp timestamp = Timestamp.valueOf(localDateTime);</span><br></pre></td></tr></table></figure><h3 id="读取字段信息"><a href="#读取字段信息" class="headerlink" title="读取字段信息"></a>读取字段信息</h3><p>读取信息使用 <code>TemporalAccessor</code> 接口，通过传递一个 <code>ChronoField</code> 枚举给 <code>get</code> 方法读取相关信息：</p><p><img src="/img/java/time/temporal%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3.png" alt="ChronoLocalDate核心接口方法"></p><p><code>ChronoField</code> 枚举提供的值如下图：</p><p><img src="/img/java/time/ChronoField%E6%9E%9A%E4%B8%BE.png" alt="ChronoField枚举">：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 TemporalAccessor#get(TemporalField)，传入 TemporalField 接口的实现类 ChronoField</span></span><br><span class="line"><span class="keyword">int</span> year = date.get(ChronoField.YEAR);</span><br><span class="line"><span class="keyword">int</span> month = date.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line"><span class="keyword">int</span> dayOfMonth = date.get(ChronoField.DAY_OF_MONTH);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalTime/LocalDate/LocalDateTime 各自也提供了一组 getter 快捷方法</span></span><br><span class="line"><span class="keyword">int</span> year1 = date.getYear();</span><br><span class="line"><span class="keyword">int</span> month1 = date.getMonthValue();</span><br><span class="line"><span class="keyword">int</span> dayOfMonth1 = date.getDayOfMonth();</span><br><span class="line"><span class="keyword">boolean</span> leapYear = date.isLeapYear();</span><br></pre></td></tr></table></figure><h3 id="创建副本并修改"><a href="#创建副本并修改" class="headerlink" title="创建副本并修改"></a>创建副本并修改</h3><p>创建副本使用 <code>Temporal</code> 接口，其提供了一组 <code>with</code>/<code>plus</code>/<code>minus</code> 方法：</p><p><img src="/img/java/time/temporal%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3.png" alt="ChronoLocalDate核心接口方法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Temporal#with(TemporalField, long)，传入 TemporalField 接口的实现类 ChronoField</span></span><br><span class="line">LocalDate newDate = date.with(ChronoField.YEAR, <span class="number">2019</span>);</span><br><span class="line">LocalDate newDate2 = date.with(ChronoField.MONTH_OF_YEAR, <span class="number">1</span>);</span><br><span class="line">LocalDate newDate3 = date.with(ChronoField.DAY_OF_MONTH, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalTime/LocalDate/LocalDateTime 各自也提供了一组 with 快捷方法</span></span><br><span class="line">LocalDate newDate4 = date.withYear(<span class="number">2019</span>);</span><br><span class="line">LocalDate newDate5 = date.withMonth(<span class="number">1</span>);</span><br><span class="line">LocalDate newDate6 = date.withDayOfMonth(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>如果 <code>with(TemporalField, long)</code> 方法不满足需求，可以使用更灵活的 <code>with(TemporalAdjuster)</code> 方法，配合 <code>TemporalAdjusters</code> 工具类提供的静态工厂方法，方法名非常直观：</p><p><img src="/img/java/time/TemporalAdjusters%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.png" alt="TemporalAdjusters静态工厂方法"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Temporal#with(TemporalAdjuster)</span></span><br><span class="line">LocalDate newDate7 = date.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));</span><br><span class="line">LocalDate newDate8 = date.with(TemporalAdjusters.lastDayOfMonth());</span><br></pre></td></tr></table></figure><p>如果在 <code>TemporalAdjusters</code> 工具类中没有找到符合要求的预定义静态工厂方法，可以自己实现 <code>TemporalAdjuster</code> 函数式接口，以定制一些更复杂的时间修改操作：</p><p><img src="/img/java/time/TemporalAdjuster.png" alt="TemporalAdjuster"></p><h1 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h1><p>作为人，我们习惯于以星期几、几号、几点、几分这样的方式理解日期和时间。毫无疑问，这种方式对于计算机而言并不容易理解。从计算机的角度来看，建模时间最自然的格式是表示一个持续时间段上某个点的单一大整型数。这也是新的 <code>java.time.Instant</code> 类对时间建模的方式，它是以 <strong>Unix 元年时间</strong>（UTC 时区 1970-01-01T00:00:00Z，“Z” 代表 UTC 时区）开始所经历的秒数进行计算。</p><blockquote><p>1 秒(s) =<br>1,000 毫秒(ms) =<br>1,000,000 微秒(μs) =<br>1,000,000,000 纳秒(ns) =<br>1,000,000,000,000 皮秒(ps) =<br>1,000,000,000,000,000 飞秒(fs) =<br>1,000,000,000,000,000,000 仄秒(zs) =<br>1,000,000,000,000,000,000,000 幺秒(ys) =<br>1,000,000,000,000,000,000,000,000 渺秒(as)</p></blockquote><blockquote><p>1 纳秒(ns) = 10^-9 秒（0.000,000,001，十亿分之一秒）<br>1 微秒(μs) = 10^-6 秒（0.000,001，百万分之一秒）<br>1 毫秒(ms) = 10^-3 秒（0.001，千分之一秒）</p></blockquote><h2 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h2><p>从底层实现可见，<code>Instant</code> 仅包含不可变的秒、纳秒。即支持的最高存储精度为<strong>纳秒</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Instant</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Temporal</span>, <span class="title">TemporalAdjuster</span>, <span class="title">Comparable</span>&lt;<span class="title">Instant</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of seconds from the epoch of 1970-01-01T00:00:00Z.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> seconds;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of nanoseconds, later along the time-line, from the seconds field.</span></span><br><span class="line"><span class="comment">     * This is always positive, and never exceeds 999,999,999.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> nanos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h2><p>通过静态工厂方法创建实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自 1970-01-01T00:00:00Z 之后经过的毫秒数</span></span><br><span class="line"><span class="comment">// 1970-01-01T00:00:01.000Z</span></span><br><span class="line">Instant instant = Instant.ofEpochMilli(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 自 1970-01-01T00:00:00Z 之后经过的秒数</span></span><br><span class="line"><span class="comment">// 1970-01-01T00:00:01Z</span></span><br><span class="line">Instant instant1 = Instant.ofEpochSecond(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Instant instant2 = Instant.now();</span><br></pre></td></tr></table></figure><p><code>Instant</code> 与 <code>java.util.Date</code> 互转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date date = Date.from(instant);</span><br><span class="line">Instant instant = date.toInstant();</span><br></pre></td></tr></table></figure><p><code>Instant</code> 与时间戳互转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = Instant.now(); <span class="comment">// 2019-07-07T11:07:42.814Z</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Instant 的设计初衷是为了便于机器使用，底层实现仅包含由秒和纳秒所构成的数字。</span></span><br><span class="line"><span class="keyword">long</span> seconds = instant.getEpochSecond();  <span class="comment">// 1562497662</span></span><br><span class="line"><span class="keyword">int</span> nanoSeconds = instant.getNano();  <span class="comment">// 814000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Instant 无法处理那些我们非常容易理解的时间单位，例如下述操作将抛出异常：</span></span><br><span class="line"><span class="comment">// java.time.temporal.UnsupportedTemporalTypeException: Unsupported field: DayOfMonth</span></span><br><span class="line"><span class="comment">// instant.get(ChronoField.DAY_OF_MONTH);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Instant 与时间戳互转</span></span><br><span class="line"><span class="keyword">long</span> timestamp = instant.toEpochMilli();  <span class="comment">// 1562497662814</span></span><br><span class="line">assertEquals(System.currentTimeMillis(), timestamp); <span class="comment">// true</span></span><br><span class="line">Instant instant2 = Instant.ofEpochMilli(timestamp); <span class="comment">// 2019-07-07T11:07:42.814Z</span></span><br></pre></td></tr></table></figure><p>创建副本并修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Instant newInstant = instant.with(ChronoField.INSTANT_SECONDS, <span class="number">30</span>);</span><br><span class="line">Instant newInstant2 = instant.with(ChronoField.MILLI_OF_SECOND, <span class="number">300</span>);</span><br><span class="line">Instant newInstant3 = instant.plus(<span class="number">30</span>, ChronoUnit.SECONDS);</span><br><span class="line">Instant newInstant4 = instant.plusSeconds(<span class="number">30</span>);</span><br><span class="line">Instant newInstant5 = instant.minusSeconds(<span class="number">30</span>);</span><br></pre></td></tr></table></figure><h1 id="Duration、Period"><a href="#Duration、Period" class="headerlink" title="Duration、Period"></a>Duration、Period</h1><p><code>Duration</code> 和 <code>Period</code> 类用于保存两个 <code>Temporal</code> 对象之间的时间段。</p><p><img src="/img/java/time/TemporalAmount%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt="TemporalAmount实现类"></p><h2 id="底层实现-2"><a href="#底层实现-2" class="headerlink" title="底层实现"></a>底层实现</h2><p><code>Duration</code> 的底层实现仅包含不可变的秒、纳秒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Duration</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">TemporalAmount</span>, <span class="title">Comparable</span>&lt;<span class="title">Duration</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of seconds in the duration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> seconds;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of nanoseconds in the duration, expressed as a fraction of the</span></span><br><span class="line"><span class="comment">     * number of seconds. This is always positive, and never exceeds 999,999,999.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> nanos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Period</code> 的底层实现包含不可变的年、月、日：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Period</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ChronoPeriod</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of years.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> years;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of months.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> months;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of days.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> days;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用方式-2"><a href="#使用方式-2" class="headerlink" title="使用方式"></a>使用方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Duration 类的静态工厂方法 between 仅支持两个 LocalTime 或两个 LocalDateTime、或两个 Instant 对象之间的 duration</span></span><br><span class="line">Duration duration = Duration.between(dateTime1, dateTime);</span><br><span class="line">Duration.between(time, time);</span><br><span class="line">Duration.between(instant, instant1);</span><br><span class="line"><span class="comment">// 由于 Duration 类主要用于以秒和纳秒衡量时间的长短，如果传 LocalDate 对象会抛异常：java.time.temporal.UnsupportedTemporalTypeException</span></span><br><span class="line"><span class="comment">// Duration.between(date1, date);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Period 类的静态工厂方法 between 仅支持两个 LocalDates</span></span><br><span class="line">Period period = Period.between(date1, date);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Duration 和 Period 类都提供了很多非常方便的静态工厂方法，用于直接创建对应的实例</span></span><br><span class="line">Duration threeDays = Duration.ofDays(<span class="number">3</span>);</span><br><span class="line">Duration threeHours = Duration.ofHours(<span class="number">3</span>);</span><br><span class="line">Duration threeMinutes = Duration.ofMinutes(<span class="number">3</span>);</span><br><span class="line">Duration threeMinutes2 = Duration.of(<span class="number">3</span>, ChronoUnit.MINUTES);</span><br><span class="line">Duration threeSeconds = Duration.ofSeconds(<span class="number">3</span>);</span><br><span class="line">Duration threeMillis = Duration.ofMillis(<span class="number">3</span>);</span><br><span class="line">Duration twoDaysThreeHoursFourMinutes = Duration.parse(<span class="string">"P2DT3H4M"</span>);</span><br><span class="line"></span><br><span class="line">Period tenYears = Period.ofYears(<span class="number">10</span>);</span><br><span class="line">Period tenMonths = Period.ofMonths(<span class="number">10</span>);</span><br><span class="line">Period tenWeeks = Period.ofWeeks(<span class="number">10</span>);</span><br><span class="line">Period tenDays = Period.ofDays(<span class="number">10</span>);</span><br><span class="line">Period twoYearsSixMonthsOneDay = Period.of(<span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">Period oneYearTwoMonthsThreeDays = Period.parse(<span class="string">"P1Y2M3D"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准确获取该时段的差值：日、时、分、秒、毫秒、纳秒</span></span><br><span class="line"><span class="keyword">long</span> days = duration.toDays();</span><br><span class="line"><span class="keyword">long</span> hours = duration.toHours();</span><br><span class="line"><span class="keyword">long</span> minutes = duration.toMinutes();</span><br><span class="line"><span class="keyword">long</span> seconds = duration.getSeconds();</span><br><span class="line"><span class="keyword">long</span> seconds2 = duration.get(ChronoUnit.SECONDS);</span><br><span class="line"><span class="keyword">long</span> millis = duration.toMillis();</span><br><span class="line"><span class="keyword">long</span> nanos2 = duration.toNanos();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定部分的差值</span></span><br><span class="line"><span class="keyword">int</span> years = period.getYears();</span><br><span class="line"><span class="keyword">int</span> months = period.getMonths();</span><br><span class="line"><span class="keyword">int</span> days1 = period.getDays();</span><br><span class="line"><span class="keyword">long</span> days2 = period.get(ChronoUnit.DAYS);</span><br></pre></td></tr></table></figure><p><code>ChronoUnit</code> 枚举提供的值：</p><p><img src="/img/java/time/TemporalUnit%E6%9E%9A%E4%B8%BE.png" alt="TemporalUnit枚举"></p><h1 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h1><p><code>DateTimeFormatter</code> 用于日期格式化。和老的 <code>java.util.DateFormat</code> 相比，所有的 <code>DateTimeFormatter</code> 实例都是线程安全的。所以，你能够以单例模式创建格式器实例，并在多个线程间共享。</p><p>下面介绍创建格式器的三种方式：</p><h2 id="预定义的格式器"><a href="#预定义的格式器" class="headerlink" title="预定义的格式器"></a>预定义的格式器</h2><p>创建格式器最简单的方法是通过它<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#predefined" target="_blank" rel="noopener">预定义的格式器</a>常量，定义如下：</p><table><thead><tr><th align="left">Formatter</th><th align="left">Description</th><th align="left">Example</th></tr></thead><tbody><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofLocalizedDate-java.time.format.FormatStyle-" target="_blank" rel="noopener"><code>ofLocalizedDate(dateStyle)</code></a></td><td align="left">Formatter with date style from the locale</td><td align="left">‘2011-12-03’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofLocalizedTime-java.time.format.FormatStyle-" target="_blank" rel="noopener"><code>ofLocalizedTime(timeStyle)</code></a></td><td align="left">Formatter with time style from the locale</td><td align="left">‘10:15:30’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofLocalizedDateTime-java.time.format.FormatStyle-" target="_blank" rel="noopener"><code>ofLocalizedDateTime(dateTimeStyle)</code></a></td><td align="left">Formatter with a style for date and time from the locale</td><td align="left">‘3 Jun 2008 11:05:30’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofLocalizedDateTime-java.time.format.FormatStyle-" target="_blank" rel="noopener"><code>ofLocalizedDateTime(dateStyle,timeStyle)</code></a></td><td align="left">Formatter with date and time styles from the locale</td><td align="left">‘3 Jun 2008 11:05’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#BASIC_ISO_DATE" target="_blank" rel="noopener"><code>BASIC_ISO_DATE</code></a></td><td align="left">Basic ISO date</td><td align="left">‘20111203’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE" target="_blank" rel="noopener"><code>ISO_LOCAL_DATE</code></a></td><td align="left">ISO Local Date</td><td align="left">‘2011-12-03’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE" target="_blank" rel="noopener"><code>ISO_OFFSET_DATE</code></a></td><td align="left">ISO Date with offset</td><td align="left">‘2011-12-03+01:00’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_DATE" target="_blank" rel="noopener"><code>ISO_DATE</code></a></td><td align="left">ISO Date with or without offset</td><td align="left">‘2011-12-03+01:00’; ‘2011-12-03’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME" target="_blank" rel="noopener"><code>ISO_LOCAL_TIME</code></a></td><td align="left">Time without offset</td><td align="left">‘10:15:30’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_TIME" target="_blank" rel="noopener"><code>ISO_OFFSET_TIME</code></a></td><td align="left">Time with offset</td><td align="left">‘10:15:30+01:00’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_TIME" target="_blank" rel="noopener"><code>ISO_TIME</code></a></td><td align="left">Time with or without offset</td><td align="left">‘10:15:30+01:00’; ‘10:15:30’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE_TIME" target="_blank" rel="noopener"><code>ISO_LOCAL_DATE_TIME</code></a></td><td align="left">ISO Local Date and Time</td><td align="left">‘2011-12-03T10:15:30’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_OFFSET_DATE_TIME" target="_blank" rel="noopener"><code>ISO_OFFSET_DATE_TIME</code></a></td><td align="left">Date Time with Offset</td><td align="left">2011-12-03T10:15:30+01:00’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_ZONED_DATE_TIME" target="_blank" rel="noopener"><code>ISO_ZONED_DATE_TIME</code></a></td><td align="left">Zoned Date Time</td><td align="left">‘2011-12-03T10:15:30+01:00[Europe/Paris]’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_DATE_TIME" target="_blank" rel="noopener"><code>ISO_DATE_TIME</code></a></td><td align="left">Date and time with ZoneId</td><td align="left">‘2011-12-03T10:15:30+01:00[Europe/Paris]’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_ORDINAL_DATE" target="_blank" rel="noopener"><code>ISO_ORDINAL_DATE</code></a></td><td align="left">Year and day of year</td><td align="left">‘2012-337’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_WEEK_DATE" target="_blank" rel="noopener"><code>ISO_WEEK_DATE</code></a></td><td align="left">Year and Week</td><td align="left">2012-W48-6’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_INSTANT" target="_blank" rel="noopener"><code>ISO_INSTANT</code></a></td><td align="left">Date and Time of an Instant</td><td align="left">‘2011-12-03T10:15:30Z’</td></tr><tr><td align="left"><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#RFC_1123_DATE_TIME" target="_blank" rel="noopener"><code>RFC_1123_DATE_TIME</code></a></td><td align="left">RFC 1123 / RFC 822</td><td align="left">‘Tue, 3 Jun 2008 11:05:30 GMT’</td></tr></tbody></table><p><img src="/img/java/time/DateTimeFormatter%E5%B8%B8%E9%87%8F.png" alt="DateTimeFormatter常量"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2021-02-01</span></span><br><span class="line">LocalDateTime.now().format(DateTimeFormatter.ISO_DATE);</span><br></pre></td></tr></table></figure><h2 id="自定义-Pattern"><a href="#自定义-Pattern" class="headerlink" title="自定义 Pattern"></a>自定义 Pattern</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns" target="_blank" rel="noopener">Patterns for Formatting and Parsing</a>:</p><blockquote><p>Patterns are based on a simple sequence of letters and symbols. A pattern is used to create a Formatter using the <a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofPattern-java.lang.String-" target="_blank" rel="noopener"><code>ofPattern(String)</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ofPattern-java.lang.String-java.util.Locale-" target="_blank" rel="noopener"><code>ofPattern(String, Locale)</code></a> methods.</p><p>A formatter created from a pattern can be used as many times as necessary, it is immutable and is thread-safe.</p></blockquote><p><code>DateTimeFormatter#ofPattern(String)</code> 静态工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 01/02/2021</span></span><br><span class="line">LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"dd/MM/yyyy"</span>));</span><br></pre></td></tr></table></figure><p><code>DateTimeFormatter#ofPattern(String, Locale)</code> 静态工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2021 2 1</span></span><br><span class="line">LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy M d"</span>, Locale.US));</span><br><span class="line"><span class="comment">// 2021 02 1</span></span><br><span class="line">LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy MM d"</span>, Locale.US));</span><br><span class="line"><span class="comment">// 2021 Feb 1</span></span><br><span class="line">LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy MMM d"</span>, Locale.US));</span><br><span class="line"><span class="comment">// 2021 February 1</span></span><br><span class="line">LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy MMMM d"</span>, Locale.US));</span><br><span class="line"><span class="comment">// 2021 F 1</span></span><br><span class="line">LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">"yyyy MMMMM d"</span>, Locale.US));</span><br></pre></td></tr></table></figure><p>Pattern 的字母数量决定格式，以月份为例：</p><ul><li>Exactly 1 pattern letter will use the minimum number of digits and without padding.</li><li>Exactly 2 pattern letters, the count of digits is used as the width of the output field, with the value zero-padded as necessary.</li><li>Exactly 3 pattern letters will use the <a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/TextStyle.html#SHORT" target="_blank" rel="noopener"><code>short form</code></a>.</li><li>Exactly 4 pattern letters will use the <a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/TextStyle.html#FULL" target="_blank" rel="noopener"><code>full form</code></a>. </li><li>Exactly 5 pattern letters will use the <a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/TextStyle.html#NARROW" target="_blank" rel="noopener"><code>narrow form</code></a>.</li></ul><h2 id="更灵活的构建器"><a href="#更灵活的构建器" class="headerlink" title="更灵活的构建器"></a>更灵活的构建器</h2><p>如果还需要更加细粒度的控制，<code>DateTimeFormatterBuilder</code> 类还提供了更复杂的格式器构建，你可以选择恰当的方法，一步一步地构造自己的格式器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dtf = <span class="keyword">new</span> DateTimeFormatterBuilder().appendPattern(<span class="string">"dd/MM/yyyy[ [HH][:mm][:ss][.SSS]]"</span>)</span><br><span class="line">  .parseDefaulting(ChronoField.HOUR_OF_DAY, <span class="number">0</span>)</span><br><span class="line">  .parseDefaulting(ChronoField.MINUTE_OF_HOUR, <span class="number">0</span>)</span><br><span class="line">  .parseDefaulting(ChronoField.SECOND_OF_MINUTE, <span class="number">0</span>)</span><br><span class="line">  .toFormatter(Locale.US);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1999-01-01T02:04:06</span></span><br><span class="line">LocalDateTime.parse(<span class="string">"01/01/1999 02:04:06"</span>, dtf);</span><br><span class="line"><span class="comment">// 1999-01-01T00:00</span></span><br><span class="line">LocalDateTime.parse(<span class="string">"01/01/1999"</span>, dtf);</span><br></pre></td></tr></table></figure><p>另外，<code>DateTimeFormatterBuilder</code> 类还提供了非常强大的解析功能，比如区分大小写的解析、柔性解析（允许解析器使用启发式的机制去解析输入，不精确地匹配指定的模式）、填充，以及在格式器中指定可选节。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《Java 8 实战》</li><li>Java SE Docs</li><li>《<a href="https://www.jianshu.com/p/b4629857fc6f" target="_blank" rel="noopener">LocalDate、LocalDateTime与timestamp、Date的转换</a>》</li><li>《<a href="https://docs.oracle.com/javase/tutorial/datetime/iso/format.html" target="_blank" rel="noopener">Parsing and Formatting (The Java™ Tutorials &gt; Date Time &gt; Standard Calendar)</a>》</li><li>《<a href="https://stackoverflow.com/questions/41177442/uuuu-versus-yyyy-in-datetimeformatter-formatting-pattern-codes-in-java" target="_blank" rel="noopener"><code>uuuu</code> versus <code>yyyy</code> in <code>DateTimeFormatter</code> formatting pattern codes in Java?</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 常用类型系列（三）字符串类型总结</title>
      <link href="2018/04/04/java-string/"/>
      <url>2018/04/04/java-string/</url>
      
        <content type="html"><![CDATA[<h1 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h1><p><img src="/img/java/string/methods_of_CharSequence.png" alt="methods_of_CharSequence"></p><p><img src="/img/java/string/Appendable.png" alt="Appendable"></p><p><img src="/img/java/string/CharSequence.png" alt="CharSequence"></p><h1 id="字符串的实现"><a href="#字符串的实现" class="headerlink" title="字符串的实现"></a>字符串的实现</h1><p><img src="/img/java/string/history_of_String.jpg" alt="history_of_String"></p><h1 id="字符串的创建方式"><a href="#字符串的创建方式" class="headerlink" title="字符串的创建方式"></a>字符串的创建方式</h1><h2 id="通过字符串常量创建"><a href="#通过字符串常量创建" class="headerlink" title="通过字符串常量创建"></a>通过字符串常量创建</h2><h2 id="通过构造方法创建"><a href="#通过构造方法创建" class="headerlink" title="通过构造方法创建"></a>通过构造方法创建</h2><h2 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern() 方法"></a><code>intern()</code> 方法</h2><h1 id="字符串的特性"><a href="#字符串的特性" class="headerlink" title="字符串的特性"></a>字符串的特性</h1><p>三种常用字符串类的区别如下：</p><table><thead><tr><th></th><th>since</th><th>immutable ?</th><th>thread-safe ?</th></tr></thead><tbody><tr><td><code>java.lang.String</code></td><td>Java SE 1.0</td><td>immutable</td><td>no thread-safe</td></tr><tr><td><code>java.lang.StringBuffer</code></td><td>Java SE 1.0</td><td>mutable</td><td>thread-safe</td></tr><tr><td><code>java.lang.StringBuilder</code></td><td>Java SE 1.5</td><td>mutable</td><td>no thread-safe</td></tr></tbody></table><h2 id="字符串拼接-字节码分析"><a href="#字符串拼接-字节码分析" class="headerlink" title="字符串拼接-字节码分析"></a>字符串拼接-字节码分析</h2><p><a href="https://lingcoder.github.io/OnJava8/#/book/18-Strings?id=-%e7%9a%84%e9%87%8d%e8%bd%bd%e4%b8%8e-stringbuilder" target="_blank" rel="noopener">+ 的重载与 StringBuilder</a></p><h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><h2 id="java-util-Formatter"><a href="#java-util-Formatter" class="headerlink" title="java.util.Formatter"></a>java.util.Formatter</h2><p>C 语言 <code>printf</code> 风格的字符串格式化解释器。用法参考<a href="https://blog.csdn.net/quinnnorris/article/details/54614446" target="_blank" rel="noopener">这里</a>。</p><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html</a></p><p><img src="/img/java/string/Formatter.png" alt="Formatter"></p><h2 id="java-util-StringJoiner"><a href="#java-util-StringJoiner" class="headerlink" title="java.util.StringJoiner"></a>java.util.StringJoiner</h2><p>对于字符串拼接，除了使用 <code>StringBuilder</code> 之外， Java SE 8 还提供了新的 API <code>java.util.StringJoiner</code>，它是<code>String.join</code> 和 <code>java.util.stream.Collectors#joining(...)</code> 的底层实现。结合 Stream API 使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [a,b,c,d,e,f,g]</span></span><br><span class="line">Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>).stream()</span><br><span class="line">                .collect(Collectors.joining(<span class="string">","</span>, <span class="string">"["</span>, <span class="string">"]"</span>));</span><br></pre></td></tr></table></figure><h2 id="org-apache-commons-lang3-StringUtils"><a href="#org-apache-commons-lang3-StringUtils" class="headerlink" title="org.apache.commons.lang3.StringUtils"></a>org.apache.commons.lang3.StringUtils</h2><p>Apache Commons Lang 为字符串操作提供了 <code>StringUtils</code> 工具类，使用方式参考<a href="/2017/12/25/apache-commons-lang/">这里</a>。</p><p><img src="/img/java/commons/commons-lang/StringUtils.png" alt="StringUtils"></p><h2 id="org-apache-commons-lang3-StringEscapeUtils"><a href="#org-apache-commons-lang3-StringEscapeUtils" class="headerlink" title="org.apache.commons.lang3.StringEscapeUtils"></a>org.apache.commons.lang3.StringEscapeUtils</h2><p>Apache Commons Lang 提供了字符串转义和反转义工具类 <code>StringEscapeUtils</code>，用于 Java、JavaScript、JSON、HTML、XML、CSV 等字符串：</p><p><img src="/img/java/string/StringEscapeUtils.png" alt="StringEscapeUtils"></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &amp;lt;span&amp;gt;hello world&amp;lt;/span&amp;gt;</span></span><br><span class="line">StringEscapeUtils.escapeHtml4(<span class="string">"&lt;span&gt;hello world&lt;/span&gt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;hello: "world"&#125;</span></span><br><span class="line">StringEscapeUtils.unescapeJson(<span class="string">"&#123;hello: \"world\"&#125;"</span>);</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://lingcoder.github.io/OnJava8/#/book/18-Strings" target="_blank" rel="noopener">On Java 8 - 第十八章 字符串</a>》</p><p>《<a href="https://cloud.tencent.com/developer/article/1511298" target="_blank" rel="noopener">Java String 对象，你真的了解了吗？</a>》</p><p>《<a href="https://blog.csdn.net/tyyking/article/details/82496901" target="_blank" rel="noopener">几张图轻松理解 <code>String.intern()</code></a>》</p><p>《<a href="https://blog.csdn.net/weixin_40304387/article/details/81071816" target="_blank" rel="noopener">字符串常量池深入解析</a>》</p><p>《<a href="https://www.cnblogs.com/natian-ws/p/10749164.html" target="_blank" rel="noopener">JVM 常量池、运行时常量池、字符串常量池</a>》</p><p>《<a href="https://segmentfault.com/a/1190000007835105" target="_blank" rel="noopener">Java8 对字符串连接的改进</a>》</p><p>《<a href="http://www.w3school.com.cn/html/html_entities.asp" target="_blank" rel="noopener">HTML 字符实体</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 常用类型系列（一）包装类型总结</title>
      <link href="2018/04/01/java-wrapper-types/"/>
      <url>2018/04/01/java-wrapper-types/</url>
      
        <content type="html"><![CDATA[<p>包装类型作为日常开发最常用的数据载体，使用时有一些点需要特别注意，否则容易踩坑，本文总结下。</p><h1 id="值、引用比较问题"><a href="#值、引用比较问题" class="headerlink" title="值、引用比较问题"></a>值、引用比较问题</h1><p>首先看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">1000</span>;</span><br><span class="line">Integer b = <span class="number">1000</span>;</span><br><span class="line">Integer c = <span class="number">100</span>;</span><br><span class="line">Integer d = <span class="number">100</span>;</span><br><span class="line">Integer e = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">Integer f = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值比较</span></span><br><span class="line">System.out.println((<span class="string">"a equals b is "</span> + (a.equals(b))));  <span class="comment">// a equals b is true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用比较，结果为 false</span></span><br><span class="line">System.out.println(<span class="string">"a == b is "</span> + (a == b));  <span class="comment">// a == b is false</span></span><br><span class="line"><span class="comment">// 引用比较，结果意外的为 true。这是由于 Integer 自动装箱时 [-128, 127] 使用了缓存，详见其 valueOf 方法的源码实现。</span></span><br><span class="line">System.out.println((<span class="string">"c == d is "</span> + (c == d)));  <span class="comment">// c == d is true</span></span><br><span class="line"><span class="comment">// 引用比较，结果为 false。因为 new Integer(int) 构造方法没有使用缓存。</span></span><br><span class="line">System.out.println((<span class="string">"e == f is "</span> + (e == f)));  <span class="comment">// e == f is false</span></span><br></pre></td></tr></table></figure><p>值的比较务必使用 <code>equals</code> 方法。可以遵循《阿里巴巴 Java 开发规范》这条规范：</p><p><img src="/img/java/primitive-type/notes.png" alt="notes"></p><h1 id="自动装箱的性能问题"><a href="#自动装箱的性能问题" class="headerlink" title="自动装箱的性能问题"></a>自动装箱的性能问题</h1><p>Java 语言提供了八种基本类型。其中包括：</p><ul><li>一种布尔类型</li><li>一种字符类型</li><li>六种数字类型（四种整数型，两种浮点型）</li></ul><p>这些基本类型（primitive type）都有对应的包装类型（boxed primitive type），具有类的特性。基本类型和包装类型之间的转换通过装箱和拆箱方法：</p><table><thead><tr><th>基本数据类型</th><th>对应的包装类</th><th>拆箱方法</th><th>装箱方法</th><th>存储空间</th><th>取值范围</th><th>缓存范围</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>Boolean</code></td><td><code>booleanValue()</code></td><td><code>valueOf(boolean)</code></td><td>1 bit</td><td></td><td>true &amp; false</td></tr><tr><td><code>char</code></td><td><code>Character</code></td><td><code>charValue()</code></td><td><code>valueOf(char)</code></td><td>16 bit</td><td></td><td>\u005Cu0000~\u005Cu007F</td></tr><tr><td><code>byte</code></td><td><code>Byte</code></td><td><code>byteValue()</code></td><td><code>valueOf(byte)</code></td><td>8 bit</td><td>-2^7~2^7-1</td><td>-2^7~2^7-1</td></tr><tr><td><code>short</code></td><td><code>Short</code></td><td><code>shortValue()</code></td><td><code>valueOf(short)</code></td><td>16 bit</td><td>-2^15~2^15-1</td><td>-2^7~2^7-1</td></tr><tr><td><code>int</code></td><td><code>Integer</code></td><td><code>intValue()</code></td><td><code>valueOf(int)</code></td><td>32 bit</td><td>-2^31~2^31-1</td><td>-2^7~2^7-1</td></tr><tr><td><code>long</code></td><td><code>Long</code></td><td><code>longValue()</code></td><td><code>valueOf(long)</code></td><td>64 bit</td><td>-2^63~2^63-1</td><td>-2^7~2^7-1</td></tr><tr><td><code>float</code></td><td><code>Float</code></td><td><code>floatValue()</code></td><td><code>valueOf(float)</code></td><td>32 bit</td><td></td><td></td></tr><tr><td><code>double</code></td><td><code>Double</code></td><td><code>doubleValue()</code></td><td><code>valueOf(double)</code></td><td>64 bit</td><td></td><td></td></tr></tbody></table><p>其中数字类型的拆箱方法由共同的父类 <code>java.lang.Number</code> 定义：</p><p><img src="/img/java/primitive-type/Number%E6%96%B9%E6%B3%95.png" alt="Number方法"></p><p><img src="/img/java/primitive-type/Number.png" alt="Number"></p><p>自 JDK 1.5 版本后，Java 引入了自动装箱（autoboxing）、拆箱（auto-unboxing）作为语法糖，使基本类型和包装类型可以直接转换，减少使用包装类型的繁琐性。<code>javac</code> 编译会做相应处理，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> n = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    Integer i = Integer.valueOf(<span class="number">10</span>);  <span class="comment">// 自动装箱</span></span><br><span class="line">    <span class="keyword">int</span> n = i.intValue();  <span class="comment">// 自动拆箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在进行大批量数据操作时，装箱操作会有一定的性能损耗，看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序一：包装类型</span></span><br><span class="line">Long sum = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);  <span class="comment">// 耗时 10390 ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序二：基本类型</span></span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);  <span class="comment">// 耗时 1101 ms</span></span><br></pre></td></tr></table></figure><p>程序一运行起来比程序二慢了十倍，因为变量 <code>sum</code> 的每次计算结果都被反复装箱，导致不必要的对象创建和较高的资源消耗，从而影响性能。代码反编译如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序一：包装类型</span></span><br><span class="line">Long sum = Long.valueOf(<span class="number">0L</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0L</span>; i &lt; <span class="number">2147483647L</span>; i++) &#123;</span><br><span class="line">    sum = Long.valueOf(sum.longValue() + i);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序二：基本类型</span></span><br><span class="line"><span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"><span class="keyword">long</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0L</span>; i &lt; <span class="number">2147483647L</span>; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><p>这提醒我们，在进行大批量数据操作时，要优先使用基本类型。为此 Java 8 还专门引入了：</p><ul><li><p><code>IntStream</code>、<code>LongStream</code>、<code>DoubleStream</code> 作为泛型类 <code>Stream</code> 的补充；</p></li><li><p><code>OptionalInt</code>、<code>OptionalLong</code>、<code>OptionalDouble</code> 作为泛型类 <code>Optional</code> 的补充；</p></li><li><p>以及一堆配套的基本类型特化的函数式接口。</p></li></ul><p>部分代码如下：</p><p><img src="/img/java/lambda/Stream.png" alt="Stream"></p><p><img src="/img/java/lambda/stream_methods.png" alt="stream_methods"></p><p>那么什么时候应该使用装箱类型呢？</p><ol><li>必须使用装箱基本类型作为类型参数，因为 Java 不允许使用基本类型。例如作为泛型集合中的元素、键和值，由于不能将基本类型作为类型参数，因此必须使用装箱基本类型。又例如，不能将变量声明为 <code>ThreadLocal&lt;int&gt;</code> 类型，因此必须使用 <code>ThreadLocal&lt;Integer&gt;</code>。</li><li>在进行反射的方法调用时，必须使用装箱基本类型。</li></ol><h1 id="自动拆箱的-NPE-风险"><a href="#自动拆箱的-NPE-风险" class="headerlink" title="自动拆箱的 NPE 风险"></a>自动拆箱的 NPE 风险</h1><p>要注意，当程序进行涉及装箱和拆箱基本类型的混合类型计算时，它会进行自动拆箱。当程序进行拆箱时，会有 NPE 风险：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Long sum = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">    sum += i;  <span class="comment">// java.lang.NullPointerException</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum);</span><br></pre></td></tr></table></figure><p>在日常开发中，数据库字段定义、或查询结果都可能为 <code>null</code>，因为自动拆箱，用基本类型接收会有 NPE 风险。可以遵循《阿里巴巴 Java 开发规范》这条规范：</p><p><img src="/img/java/primitive-type/notes2.png" alt="notes2"></p><h1 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h1><table><thead><tr><th></th><th>英文简写</th><th>字面量前缀</th><th>备注</th></tr></thead><tbody><tr><td>十六进制</td><td><code>HEX</code></td><td><code>0X</code>、<code>0x</code></td><td></td></tr><tr><td>十进制</td><td><code>DEC</code></td><td>无</td><td></td></tr><tr><td>八进制</td><td><code>OCT</code></td><td><code>0</code></td><td></td></tr><tr><td>二进制</td><td><code>BIN</code></td><td><code>0B</code>、<code>0b</code></td><td>参考<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/language/binary-literals.html" target="_blank" rel="noopener">官方文档</a></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 十进制转成二进制：11111111</span></span><br><span class="line">Integer.toBinaryString(<span class="number">255</span>);</span><br><span class="line"><span class="comment">// 二进制转十进制：255</span></span><br><span class="line">Integer.valueOf(<span class="string">"11111111"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制转成八进制：10</span></span><br><span class="line">Integer.toOctalString(<span class="number">8</span>);</span><br><span class="line"><span class="comment">// 八进制转成十进制：8</span></span><br><span class="line">Integer.valueOf(<span class="string">"10"</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制转成十六进制：F</span></span><br><span class="line">Integer.toHexString(<span class="number">15</span>);</span><br><span class="line"><span class="comment">// 十六进制转成十进制：15</span></span><br><span class="line">Integer.valueOf(<span class="string">"F"</span>, <span class="number">16</span>);</span><br></pre></td></tr></table></figure><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>最后，来总结下包装类型特点：</p><ul><li>所有包装类型都为 <code>final</code>，底层被包装的基本类型也都为 <code>final</code>。因此包装类型一旦初始化后，在运行期值是不可变的，非常安全。</li><li><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code> 装箱方法的某个数据段使用了缓存，因此 <code>==</code> 引用比较时可能会出现预期外的结果（<code>true</code>），详见源码。</li></ul><h2 id="java-lang-Byte"><a href="#java-lang-Byte" class="headerlink" title="java.lang.Byte"></a>java.lang.Byte</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Byte</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Byte</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of the &#123;<span class="doctag">@code</span> Byte&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@code</span> Byte&#125; instance representing the specified</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> byte&#125; value.</span></span><br><span class="line"><span class="comment">     * If a new &#123;<span class="doctag">@code</span> Byte&#125; instance is not required, this method</span></span><br><span class="line"><span class="comment">     * should generally be used in preference to the constructor</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #Byte(byte)&#125;, as this method is likely to yield</span></span><br><span class="line"><span class="comment">     * significantly better space and time performance since</span></span><br><span class="line"><span class="comment">     * all byte values are cached.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  b a byte value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> Byte&#125; instance representing &#123;<span class="doctag">@code</span> b&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Byte <span class="title">valueOf</span><span class="params">(<span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">return</span> ByteCache.cache[(<span class="keyword">int</span>)b + offset];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> Byte&#125; as a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> byte&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">byte</span> <span class="title">byteValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares this object to the specified object.  The result is</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> true&#125; if and only if the argument is not</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; and is a &#123;<span class="doctag">@code</span> Byte&#125; object that</span></span><br><span class="line"><span class="comment">     * contains the same &#123;<span class="doctag">@code</span> byte&#125; value as this object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj       the object to compare with</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>          &#123;<span class="doctag">@code</span> true&#125; if the objects are the same;</span></span><br><span class="line"><span class="comment">     *                  &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Byte) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Byte)obj).byteValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java-lang-Short"><a href="#java-lang-Short" class="headerlink" title="java.lang.Short"></a>java.lang.Short</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Short</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Short</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of the &#123;<span class="doctag">@code</span> Short&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@code</span> Short&#125; instance representing the specified</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> short&#125; value.</span></span><br><span class="line"><span class="comment">     * If a new &#123;<span class="doctag">@code</span> Short&#125; instance is not required, this method</span></span><br><span class="line"><span class="comment">     * should generally be used in preference to the constructor</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #Short(short)&#125;, as this method is likely to yield</span></span><br><span class="line"><span class="comment">     * significantly better space and time performance by caching</span></span><br><span class="line"><span class="comment">     * frequently requested values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method will always cache values in the range -128 to 127,</span></span><br><span class="line"><span class="comment">     * inclusive, and may cache other values outside of this range.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  s a short value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> Short&#125; instance representing &#123;<span class="doctag">@code</span> s&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Short <span class="title">valueOf</span><span class="params">(<span class="keyword">short</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">int</span> sAsInt = s;</span><br><span class="line">        <span class="keyword">if</span> (sAsInt &gt;= -<span class="number">128</span> &amp;&amp; sAsInt &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">            <span class="keyword">return</span> ShortCache.cache[sAsInt + offset];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Short(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> Short&#125; as a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> short&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">shortValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares this object to the specified object.  The result is</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> true&#125; if and only if the argument is not</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; and is a &#123;<span class="doctag">@code</span> Short&#125; object that</span></span><br><span class="line"><span class="comment">     * contains the same &#123;<span class="doctag">@code</span> short&#125; value as this object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj       the object to compare with</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>          &#123;<span class="doctag">@code</span> true&#125; if the objects are the same;</span></span><br><span class="line"><span class="comment">     *                  &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Short) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Short)obj).shortValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java-lang-Integer"><a href="#java-lang-Integer" class="headerlink" title="java.lang.Integer"></a>java.lang.Integer</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of the &#123;<span class="doctag">@code</span> Integer&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</span></span><br><span class="line"><span class="comment">     * required, this method should generally be used in preference to</span></span><br><span class="line"><span class="comment">     * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</span></span><br><span class="line"><span class="comment">     * to yield significantly better space and time performance by</span></span><br><span class="line"><span class="comment">     * caching frequently requested values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method will always cache values in the range -128 to 127,</span></span><br><span class="line"><span class="comment">     * inclusive, and may cache other values outside of this range.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> Integer&#125; as an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> int&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares this object to the specified object.  The result is</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> true&#125; if and only if the argument is not</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; and is an &#123;<span class="doctag">@code</span> Integer&#125; object that</span></span><br><span class="line"><span class="comment">     * contains the same &#123;<span class="doctag">@code</span> int&#125; value as this object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   obj   the object to compare with.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the objects are the same;</span></span><br><span class="line"><span class="comment">     *          &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java-lang-Long"><a href="#java-lang-Long" class="headerlink" title="java.lang.Long"></a>java.lang.Long</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Long</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of the &#123;<span class="doctag">@code</span> Long&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@code</span> Long&#125; instance representing the specified</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> long&#125; value.</span></span><br><span class="line"><span class="comment">     * If a new &#123;<span class="doctag">@code</span> Long&#125; instance is not required, this method</span></span><br><span class="line"><span class="comment">     * should generally be used in preference to the constructor</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #Long(long)&#125;, as this method is likely to yield</span></span><br><span class="line"><span class="comment">     * significantly better space and time performance by caching</span></span><br><span class="line"><span class="comment">     * frequently requested values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that unlike the &#123;<span class="doctag">@linkplain</span> valueOf(int)</span></span><br><span class="line"><span class="comment">     * corresponding method&#125; in the &#123;<span class="doctag">@code</span> Integer&#125; class, this method</span></span><br><span class="line"><span class="comment">     * is &lt;em&gt;not&lt;/em&gt; required to cache values within a particular</span></span><br><span class="line"><span class="comment">     * range.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  l a long value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> Long&#125; instance representing &#123;<span class="doctag">@code</span> l&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">            <span class="keyword">return</span> LongCache.cache[(<span class="keyword">int</span>)l + offset];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Long(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> Long&#125; as a</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> long&#125; value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares this object to the specified object.  The result is</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> true&#125; if and only if the argument is not</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; and is a &#123;<span class="doctag">@code</span> Long&#125; object that</span></span><br><span class="line"><span class="comment">     * contains the same &#123;<span class="doctag">@code</span> long&#125; value as this object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   obj   the object to compare with.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the objects are the same;</span></span><br><span class="line"><span class="comment">     *          &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Long) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Long)obj).longValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java-lang-Float"><a href="#java-lang-Float" class="headerlink" title="java.lang.Float"></a>java.lang.Float</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Float</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Float</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of the Float.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@code</span> Float&#125; instance representing the specified</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> float&#125; value.</span></span><br><span class="line"><span class="comment">     * If a new &#123;<span class="doctag">@code</span> Float&#125; instance is not required, this method</span></span><br><span class="line"><span class="comment">     * should generally be used in preference to the constructor</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #Float(float)&#125;, as this method is likely to yield</span></span><br><span class="line"><span class="comment">     * significantly better space and time performance by caching</span></span><br><span class="line"><span class="comment">     * frequently requested values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  f a float value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> Float&#125; instance representing &#123;<span class="doctag">@code</span> f&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Float <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Float(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * Compares this object against the specified object.  The result</span></span><br><span class="line"><span class="comment">     * is &#123;<span class="doctag">@code</span> true&#125; if and only if the argument is not</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; and is a &#123;<span class="doctag">@code</span> Float&#125; object that</span></span><br><span class="line"><span class="comment">     * represents a &#123;<span class="doctag">@code</span> float&#125; with the same value as the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> float&#125; represented by this object. For this</span></span><br><span class="line"><span class="comment">     * purpose, two &#123;<span class="doctag">@code</span> float&#125; values are considered to be the</span></span><br><span class="line"><span class="comment">     * same if and only if the method &#123;<span class="doctag">@link</span> #floatToIntBits(float)&#125;</span></span><br><span class="line"><span class="comment">     * returns the identical &#123;<span class="doctag">@code</span> int&#125; value when applied to</span></span><br><span class="line"><span class="comment">     * each.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that in most cases, for two instances of class</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Float&#125;, &#123;<span class="doctag">@code</span> f1&#125; and &#123;<span class="doctag">@code</span> f2&#125;, the value</span></span><br><span class="line"><span class="comment">     * of &#123;<span class="doctag">@code</span> f1.equals(f2)&#125; is &#123;<span class="doctag">@code</span> true&#125; if and only if</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;blockquote&gt;&lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *   f1.floatValue() == f2.floatValue()</span></span><br><span class="line"><span class="comment">     * &lt;/pre&gt;&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;also has the value &#123;<span class="doctag">@code</span> true&#125;. However, there are two exceptions:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;If &#123;<span class="doctag">@code</span> f1&#125; and &#123;<span class="doctag">@code</span> f2&#125; both represent</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> Float.NaN&#125;, then the &#123;<span class="doctag">@code</span> equals&#125; method returns</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> true&#125;, even though &#123;<span class="doctag">@code</span> Float.NaN==Float.NaN&#125;</span></span><br><span class="line"><span class="comment">     *     has the value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;If &#123;<span class="doctag">@code</span> f1&#125; represents &#123;<span class="doctag">@code</span> +0.0f&#125; while</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> f2&#125; represents &#123;<span class="doctag">@code</span> -0.0f&#125;, or vice</span></span><br><span class="line"><span class="comment">     *     versa, the &#123;<span class="doctag">@code</span> equal&#125; test has the value</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> false&#125;, even though &#123;<span class="doctag">@code</span> 0.0f==-0.0f&#125;</span></span><br><span class="line"><span class="comment">     *     has the value &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This definition allows hash tables to operate properly.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj the object to be compared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the objects are the same;</span></span><br><span class="line"><span class="comment">     *          &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.floatToIntBits(float)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (obj <span class="keyword">instanceof</span> Float)</span><br><span class="line">               &amp;&amp; (floatToIntBits(((Float)obj).value) == floatToIntBits(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java-lang-Double"><a href="#java-lang-Double" class="headerlink" title="java.lang.Double"></a>java.lang.Double</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Double</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of the Double.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@code</span> Double&#125; instance representing the specified</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> double&#125; value.</span></span><br><span class="line"><span class="comment">     * If a new &#123;<span class="doctag">@code</span> Double&#125; instance is not required, this method</span></span><br><span class="line"><span class="comment">     * should generally be used in preference to the constructor</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #Double(double)&#125;, as this method is likely to yield</span></span><br><span class="line"><span class="comment">     * significantly better space and time performance by caching</span></span><br><span class="line"><span class="comment">     * frequently requested values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  d a double value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> Double&#125; instance representing &#123;<span class="doctag">@code</span> d&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Double(d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares this object against the specified object.  The result</span></span><br><span class="line"><span class="comment">     * is &#123;<span class="doctag">@code</span> true&#125; if and only if the argument is not</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; and is a &#123;<span class="doctag">@code</span> Double&#125; object that</span></span><br><span class="line"><span class="comment">     * represents a &#123;<span class="doctag">@code</span> double&#125; that has the same value as the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> double&#125; represented by this object. For this</span></span><br><span class="line"><span class="comment">     * purpose, two &#123;<span class="doctag">@code</span> double&#125; values are considered to be</span></span><br><span class="line"><span class="comment">     * the same if and only if the method &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #doubleToLongBits(double)&#125; returns the identical</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> long&#125; value when applied to each.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note that in most cases, for two instances of class</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> Double&#125;, &#123;<span class="doctag">@code</span> d1&#125; and &#123;<span class="doctag">@code</span> d2&#125;, the</span></span><br><span class="line"><span class="comment">     * value of &#123;<span class="doctag">@code</span> d1.equals(d2)&#125; is &#123;<span class="doctag">@code</span> true&#125; if and</span></span><br><span class="line"><span class="comment">     * only if</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;blockquote&gt;</span></span><br><span class="line"><span class="comment">     *  &#123;<span class="doctag">@code</span> d1.doubleValue() == d2.doubleValue()&#125;</span></span><br><span class="line"><span class="comment">     * &lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;also has the value &#123;<span class="doctag">@code</span> true&#125;. However, there are two</span></span><br><span class="line"><span class="comment">     * exceptions:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;If &#123;<span class="doctag">@code</span> d1&#125; and &#123;<span class="doctag">@code</span> d2&#125; both represent</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> Double.NaN&#125;, then the &#123;<span class="doctag">@code</span> equals&#125; method</span></span><br><span class="line"><span class="comment">     *     returns &#123;<span class="doctag">@code</span> true&#125;, even though</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> Double.NaN==Double.NaN&#125; has the value</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;li&gt;If &#123;<span class="doctag">@code</span> d1&#125; represents &#123;<span class="doctag">@code</span> +0.0&#125; while</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@code</span> d2&#125; represents &#123;<span class="doctag">@code</span> -0.0&#125;, or vice versa,</span></span><br><span class="line"><span class="comment">     *     the &#123;<span class="doctag">@code</span> equal&#125; test has the value &#123;<span class="doctag">@code</span> false&#125;,</span></span><br><span class="line"><span class="comment">     *     even though &#123;<span class="doctag">@code</span> +0.0==-0.0&#125; has the value &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     * This definition allows hash tables to operate properly.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   obj   the object to compare with.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the objects are the same;</span></span><br><span class="line"><span class="comment">     *          &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> java.lang.Double#doubleToLongBits(double)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (obj <span class="keyword">instanceof</span> Double)</span><br><span class="line">               &amp;&amp; (doubleToLongBits(((Double)obj).value) ==</span><br><span class="line">                      doubleToLongBits(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java-lang-Boolean"><a href="#java-lang-Boolean" class="headerlink" title="java.lang.Boolean"></a>java.lang.Boolean</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of the Boolean.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@code</span> Boolean&#125; instance representing the specified</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> boolean&#125; value.  If the specified &#123;<span class="doctag">@code</span> boolean&#125; value</span></span><br><span class="line"><span class="comment">     * is &#123;<span class="doctag">@code</span> true&#125;, this method returns &#123;<span class="doctag">@code</span> Boolean.TRUE&#125;;</span></span><br><span class="line"><span class="comment">     * if it is &#123;<span class="doctag">@code</span> false&#125;, this method returns &#123;<span class="doctag">@code</span> Boolean.FALSE&#125;.</span></span><br><span class="line"><span class="comment">     * If a new &#123;<span class="doctag">@code</span> Boolean&#125; instance is not required, this method</span></span><br><span class="line"><span class="comment">     * should generally be used in preference to the constructor</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #Boolean(boolean)&#125;, as this method is likely to yield</span></span><br><span class="line"><span class="comment">     * significantly better space and time performance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  b a boolean value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> Boolean&#125; instance representing &#123;<span class="doctag">@code</span> b&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>  1.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> Boolean&#125; object as a boolean</span></span><br><span class="line"><span class="comment">     * primitive.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the primitive &#123;<span class="doctag">@code</span> boolean&#125; value of this object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">booleanValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if and only if the argument is not</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; and is a &#123;<span class="doctag">@code</span> Boolean&#125; object that</span></span><br><span class="line"><span class="comment">     * represents the same &#123;<span class="doctag">@code</span> boolean&#125; value as this object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   obj   the object to compare with.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the Boolean objects represent the</span></span><br><span class="line"><span class="comment">     *          same value; &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Boolean) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Boolean)obj).booleanValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java-lang-Character"><a href="#java-lang-Character" class="headerlink" title="java.lang.Character"></a>java.lang.Character</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Character</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">Character</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value of the &#123;<span class="doctag">@code</span> Character&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &lt;tt&gt;Character&lt;/tt&gt; instance representing the specified</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;char&lt;/tt&gt; value.</span></span><br><span class="line"><span class="comment">     * If a new &lt;tt&gt;Character&lt;/tt&gt; instance is not required, this method</span></span><br><span class="line"><span class="comment">     * should generally be used in preference to the constructor</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #Character(char)&#125;, as this method is likely to yield</span></span><br><span class="line"><span class="comment">     * significantly better space and time performance by caching</span></span><br><span class="line"><span class="comment">     * frequently requested values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method will always cache values in the range &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * '\u005Cu0000'&#125; to &#123;<span class="doctag">@code</span> '\u005Cu007F'&#125;, inclusive, and may</span></span><br><span class="line"><span class="comment">     * cache other values outside of this range.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c a char value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &lt;tt&gt;Character&lt;/tt&gt; instance representing &lt;tt&gt;c&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Character <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c &lt;= <span class="number">127</span>) &#123; <span class="comment">// must cache</span></span><br><span class="line">            <span class="keyword">return</span> CharacterCache.cache[(<span class="keyword">int</span>)c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Character(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value of this &#123;<span class="doctag">@code</span> Character&#125; object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the primitive &#123;<span class="doctag">@code</span> char&#125; value represented by</span></span><br><span class="line"><span class="comment">     *          this object.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Compares this object against the specified object.</span></span><br><span class="line"><span class="comment">     * The result is &#123;<span class="doctag">@code</span> true&#125; if and only if the argument is not</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125; and is a &#123;<span class="doctag">@code</span> Character&#125; object that</span></span><br><span class="line"><span class="comment">     * represents the same &#123;<span class="doctag">@code</span> char&#125; value as this object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   obj   the object to compare with.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  &#123;<span class="doctag">@code</span> true&#125; if the objects are the same;</span></span><br><span class="line"><span class="comment">     *          &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Character) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Character)obj).charValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Effective Java 第三版》</p><ul><li>第 44 条：坚持使用标准的函数接口</li><li>第 61 条：基本类型优先于装箱基本类型</li></ul><p>《Java 8 函数式编程》</p><p>《Java 8 实战》</p><p><a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650121987&idx=1&sn=70bba3f7f42a269eeada9cecb34c10a5&chksm=f36bba22c41c3334b92f184e402f2f77e2d5e0a2e0a21ec5a8229773afcab4f026a0b6f47fc4&scene=21" target="_blank" rel="noopener">一文读懂什么是Java中的自动拆装箱</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 数据持久化系列（七）MyBatis 高级结果映射</title>
      <link href="2018/03/27/mybatis-advanced-result-maps/"/>
      <url>2018/03/27/mybatis-advanced-result-maps/</url>
      
        <content type="html"><![CDATA[<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>高级结果映射常用的两种方式：</p><ul><li>嵌套结果映射，即利用表连接语法进行一次性的嵌套查询；</li><li>嵌套查询，即分开多次查询。注意 <code>association</code> 多对一关联存在 N+1 查询的性能问题，禁用。</li></ul><p>以 <code>collection</code> 一对多关联为例，两种配置区别如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一对多嵌套结果映射。注意表连接查询字段务必使用 AS 别名，避免手工映射时 column 取错列 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"ExtendResultMap"</span> <span class="attr">extends</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"...XxxQO"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"extendList"</span> <span class="attr">columnPrefix</span>=<span class="string">"sub_task_"</span> <span class="attr">resultMap</span>=<span class="string">"...XxxMapper.BaseResultMap"</span> <span class="attr">ofType</span>=<span class="string">"...XxxPO"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 一对多嵌套查询，column 为嵌套查询的参数列，即“一”方的列 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"ExtendResultMap"</span> <span class="attr">extends</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"...XxxQO"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"extendList"</span> <span class="attr">column</span>=<span class="string">"task_no"</span> <span class="attr">select</span>=<span class="string">"...XxxMapper.getByTaskNo"</span> <span class="attr">ofType</span>=<span class="string">"...XxxPO"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>下面提供一个例子，涉及的关联关系如下：学生多对一关联学校、一对多关联书本：</p><p><code>StudentMapper.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;StudentQO&gt; <span class="title">listStudents</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br></pre></td></tr></table></figure><p><code>StudentQO.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span>(callSuper = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>(callSuper = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentQO</span> <span class="keyword">extends</span> <span class="title">StudentPO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多对一关联学校</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> SchoolPO school;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一对多关联书本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;BookPO&gt; books;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StudentMapper.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Base_column_list"</span>&gt;</span></span><br><span class="line">    T.id,</span><br><span class="line">    ......</span><br><span class="line">    T.create_time,</span><br><span class="line">    T.update_time,</span><br><span class="line">    T.version</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Extend_column_list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_column_list"</span> /&gt;</span></span><br><span class="line">    ,</span><br><span class="line">    <span class="comment">&lt;!-- 见 SchoolMapper.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"com.test.school.mapper.SchoolMapper.Base_Column_List"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.test.student.po.StudentPO"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"BIGINT"</span>/&gt;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"create_time"</span> <span class="attr">property</span>=<span class="string">"createTime"</span> <span class="attr">jdbcType</span>=<span class="string">"TIMESTAMP"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"update_time"</span> <span class="attr">property</span>=<span class="string">"updateTime"</span> <span class="attr">jdbcType</span>=<span class="string">"TIMESTAMP"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"version"</span> <span class="attr">property</span>=<span class="string">"version"</span> <span class="attr">jdbcType</span>=<span class="string">"TINYINT"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"ExtendResultMap"</span> <span class="attr">extends</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.test.student.qo.StudentQO"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用嵌套结果映射，即利用表连接语法进行一次性的嵌套查询。resultMap 配置见 SchoolMapper.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"school"</span> <span class="attr">columnPrefix</span>=<span class="string">"school_"</span> <span class="attr">resultMap</span>=<span class="string">"com.test.school.mapper.SchoolMapper.BaseResultMap"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用嵌套查询，即分开多次查询。column 为嵌套查询的参数列，select 引用见 BookMapper.xml --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"books"</span> <span class="attr">column</span>=<span class="string">"student_no"</span> <span class="attr">select</span>=<span class="string">"com.test.book.mapper.BookMapper.getByStudentNo"</span> <span class="attr">ofType</span>=<span class="string">"com.test.book.po.BookPO"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用表连接嵌套查询学生、学校 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"listStudents"</span> <span class="attr">resultMap</span>=<span class="string">"ExtendResultMap"</span>&gt;</span></span><br><span class="line">    SELECT</span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Extend_column_list"</span> /&gt;</span></span><br><span class="line">    FROM t_student T</span><br><span class="line">        INNER JOIN t_school E</span><br><span class="line">        ON T.school_no = E.school_no</span><br><span class="line">    WHERE T.age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>SchoolMapper.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Base_Column_List"</span>&gt;</span></span><br><span class="line">    E.id AS school_id,</span><br><span class="line">    ......</span><br><span class="line">    E.create_time AS school_create_time,</span><br><span class="line">    E.update_time AS school_update_time</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.test.school.po.SchoolPO"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"BIGINT"</span>/&gt;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"create_time"</span> <span class="attr">property</span>=<span class="string">"createTime"</span> <span class="attr">jdbcType</span>=<span class="string">"TIMESTAMP"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"update_time"</span> <span class="attr">property</span>=<span class="string">"updateTime"</span> <span class="attr">jdbcType</span>=<span class="string">"TIMESTAMP"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 数据持久化系列（六）MyBatis 框架解析</title>
      <link href="2018/03/24/mybatis/"/>
      <url>2018/03/24/mybatis/</url>
      
        <content type="html"><![CDATA[<p>MyBatis 在 Java 业务开发领域可以说是首选的持久化框架，本文主要总结下 MyBatis 的核心配置和源码解析。</p><h1 id="MyBatis-产品组成"><a href="#MyBatis-产品组成" class="headerlink" title="MyBatis 产品组成"></a>MyBatis 产品组成</h1><p>MyBatis 常用的产品组成汇总如下：</p><p><img src="/img/mybatis/mybatis_products.png" alt="MyBatis Products"></p><h1 id="MyBatis-核心总结"><a href="#MyBatis-核心总结" class="headerlink" title="MyBatis 核心总结"></a>MyBatis 核心总结</h1><p><img src="/img/mybatis/mybatis_core.png" alt="MyBatis Core"></p><h1 id="MyBatis-核心架构"><a href="#MyBatis-核心架构" class="headerlink" title="MyBatis 核心架构"></a>MyBatis 核心架构</h1><p><img src="/img/mybatis/mybatis_core_architecture.png" alt=""></p><p><img src="/img/mybatis/mybatis_core_architecture_2.png" alt=""></p><p>MyBatis 语句执行时的层次结构：</p><p><img src="/img/mybatis/mybatis_core_architecture_3.jpg" alt=""></p><p>涉及的主要 API 如下：</p><p><img src="/img/mybatis/mybatis-api.png" alt="mybatis-api"></p><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><p><img src="/img/mybatis/mybatis_api_Executor.png" alt="mybatis_api_Executor"></p><h2 id="StatementHandler"><a href="#StatementHandler" class="headerlink" title="StatementHandler"></a>StatementHandler</h2><p><img src="/img/mybatis/mybatis_api_StatementHandler.png" alt="mybatis_api_StatementHandler"></p><h2 id="ParameterHandler"><a href="#ParameterHandler" class="headerlink" title="ParameterHandler"></a>ParameterHandler</h2><p><img src="/img/mybatis/mybatis_api_ParameterHandler.png" alt="mybatis_api_ParameterHandler"></p><h2 id="ResultSetHandler"><a href="#ResultSetHandler" class="headerlink" title="ResultSetHandler"></a>ResultSetHandler</h2><p><img src="/img/mybatis/mybatis_api_ResultSetHandler.png" alt="mybatis_api_ResultSetHandler"></p><h2 id="TypeHandler"><a href="#TypeHandler" class="headerlink" title="TypeHandler"></a>TypeHandler</h2><p><img src="/img/mybatis/mybatis_api_TypeHandler.png" alt="mybatis_api_TypeHandler"></p><h1 id="Spring-整合"><a href="#Spring-整合" class="headerlink" title="Spring 整合"></a>Spring 整合</h1><h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><p>基础依赖安装：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyBatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 整合依赖安装：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MyBatis Spring --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- MyBatis Spring Boot Starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spring-Bean-配置"><a href="#Spring-Bean-配置" class="headerlink" title="Spring Bean 配置"></a>Spring Bean 配置</h2><p>MyBatis-Spring 中，<code>SqlSessionFactoryBean</code> 用于创建 <code>SqlSessionFactory</code>。可通过 Spring 的 XML 配置文件或 Java Config 配置该工厂 bean：</p><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 MyBatis 的 sqlSessionFactory。MyBatis Plus 使用 com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- DAO接口所在包名，Spring 会自动查找其下的类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.example.dao"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Java-Config"><a href="#Java-Config" class="headerlink" title="Java Config"></a>Java Config</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.mapper.MapperScannerConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = &#123;<span class="string">"..."</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建 SqlSessionFactory，以便获取 SqlSession</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean factoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        factoryBean.setDataSource(dataSource);</span><br><span class="line">        factoryBean.setConfigLocation(configLocation);</span><br><span class="line">        factoryBean.setMapperLocations(resource);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@MapperScan</span> 或 MapperScannerConfigurer 二选一配置</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MapperScannerConfigurer <span class="title">mapperScannerConfigurer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MapperScannerConfigurer mapperScannerConfigurer = <span class="keyword">new</span> MapperScannerConfigurer();</span><br><span class="line">        mapperScannerConfigurer.setBasePackage(basePackage);</span><br><span class="line">        <span class="keyword">return</span> mapperScannerConfigurer;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/" target="_blank" rel="noopener">http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h2 id="基于-Statement-ID-的传统方式"><a href="#基于-Statement-ID-的传统方式" class="headerlink" title="基于 Statement ID 的传统方式"></a>基于 Statement ID 的传统方式</h2><p><img src="/img/mybatis/mybatis_statement_id.jpg" alt="mybatis_statement_id"></p><h2 id="基于-Mapper-接口的推荐方式"><a href="#基于-Mapper-接口的推荐方式" class="headerlink" title="基于 Mapper 接口的推荐方式"></a>基于 Mapper 接口的推荐方式</h2><p><img src="/img/mybatis/mybatis_mapper.jpg" alt="mybatis_mapper"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.mybatis.org/" target="_blank" rel="noopener">http://www.mybatis.org/</a></p><p><a href="https://github.com/mybatis" target="_blank" rel="noopener">https://github.com/mybatis</a></p><p>《MyBatis 从入门到精通》</p><p>《MyBatis 技术内幕》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 数据持久化系列（五）Spring 事务管理总结</title>
      <link href="2018/02/27/spring-transaction/"/>
      <url>2018/02/27/spring-transaction/</url>
      
        <content type="html"><![CDATA[<p>本文梳理 Spring 事务管理的方方面面，总览如下：</p><p><img src="/img/spring/transaction/transaction_management.png" alt=""></p><h1 id="Spring-框架的事务支持模型的优点"><a href="#Spring-框架的事务支持模型的优点" class="headerlink" title="Spring 框架的事务支持模型的优点"></a>Spring 框架的事务支持模型的优点</h1><p>全面的事务支持是使用 Spring 框架的最有说服力的理由之一。Spring 框架为事务管理提供了一致的抽象层，并具有以下优势：</p><ul><li>跨不同事务 API 的一致编程模型，如 JTA (Java Transaction API)、JPA (Java Persistence API)、JDBC、Hibernate、MyBatis。</li><li>支持<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#transaction-declarative" target="_blank" rel="noopener">声明式事务管理</a>，可通过 XML 或注解进行配置。</li><li>比复杂的事务 API（如 JTA）更简单的<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#transaction-programmatic" target="_blank" rel="noopener">编程式事务管理 API</a>。</li><li>与 Spring 框架的数据访问抽象层集成。</li></ul><h1 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h1><h2 id="理解声明式事务实现"><a href="#理解声明式事务实现" class="headerlink" title="理解声明式事务实现"></a>理解声明式事务实现</h2><p>关于 Spring 框架的声明式事务支持，最重要的概念是掌握其通过 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-understanding-aop-proxies" target="_blank" rel="noopener">AOP 代理</a>来启用此支持，并且事务 advice 由元数据（基于 XML 或注释 <code>@Transactional</code>）驱动。AOP 与事务元数据的组合产生 AOP 代理，该代理使用 <code>TransactionInterceptor</code> 搭配合适的 <code>PlatformTransactionManager</code> 实现来驱动围绕方法调用的事务代理。</p><p><code>TransactionInterceptor</code> 的结构如下：</p><p><img src="/img/spring/transaction/TransactionInterceptor.png" alt="TransactionInterceptor"></p><p>下图展示了调用事务代理方法的过程：</p><p><img src="/img/spring/transaction/tx.png" alt="事务代理调用"></p><h2 id="基于-XML-方式配置事务管理"><a href="#基于-XML-方式配置事务管理" class="headerlink" title="基于 XML 方式配置事务管理"></a>基于 XML 方式配置事务管理</h2><p>使用 <code>&lt;tx:advice/&gt;</code> 创建事务 advice，并创建切面通过 <code>&lt;aop:advisor/&gt;</code> 指定该事务 advice 须应用到哪些切点之上：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- the transactional advice (what 'happens'; see the &lt;aop:advisor/&gt; bean below) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"txManager"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- the transactional semantics... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- all methods starting with 'get' are read-only --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- other methods use the default transaction settings (see below) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ensure that the above transactional advice runs for any execution</span></span><br><span class="line"><span class="comment">        of an operation defined by the FooService interface --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"fooServiceOperation"</span> <span class="attr">expression</span>=<span class="string">"execution(* x.y.service.FooService.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"fooServiceOperation"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>事务配置可通过修改 <code>&lt;tx:method/&gt;</code> 的属性，详见脑图。</p><h2 id="基于注解方式配置事务管理"><a href="#基于注解方式配置事务管理" class="headerlink" title="基于注解方式配置事务管理"></a>基于注解方式配置事务管理</h2><p>除了使用基于 XML 的方式（<code>&lt;tx:advice/&gt;</code>）声明事务配置之外，您还可以使用基于注解的方式（<code>@Transactional</code> ）。直接在 Java 源代码中声明事务语义会使声明更靠近受影响的代码，易于配置和修改。这样之所以不存在过度耦合的原因是因为，无论如何，用于事务处理的代码几乎总是以事务的方式进行部署。</p><p>您可以将 <code>@Transactional</code> 注解应用于：</p><ul><li>接口定义（interface）</li><li>接口上的方法</li><li>类定义（class）</li><li>类上的公有方法（public method on class）</li></ul><p><code>@Transactional</code> 提供的配置属性如下：</p><p><img src="/img/spring/transaction/spring_annotation_transactional.png" alt="@Transactional"></p><h3 id="开启事务支持"><a href="#开启事务支持" class="headerlink" title="开启事务支持"></a>开启事务支持</h3><p>但是，仅仅使用 <code>@Transactional</code> 注解并不足以激活事务行为，还需要开启事务支持，可以使用以下方式：</p><ul><li><code>&lt;tx:annotation-driven/&gt;</code></li><li><code>@EnableTransactionManagement</code></li></ul><p>配置参数如下：</p><table><thead><tr><th>XML 属性</th><th>注解属性</th><th>默认</th><th>描述</th></tr></thead><tbody><tr><td><code>transaction-manager</code></td><td>N/A (see <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/TransactionManagementConfigurer.html" target="_blank" rel="noopener"><code>TransactionManagementConfigurer</code></a> javadoc)</td><td><code>transactionManager</code></td><td>要使用的事务管理器的名称。仅在事务管理器的名称不是  <code>transactionManager</code> 时才需要设置。</td></tr><tr><td><code>mode</code></td><td><code>mode</code></td><td><code>proxy</code></td><td>默认为代理模式（<code>proxy</code>），使用 Spring AOP 框架处理被 <code>@Transactional</code> 注解的 bean，仅适用于通过代理进入的方法调用。<br/>相反，替代模式（<code>aspectj</code>）使用Spring AspectJ 事务切面织入到受影响的类，修改目标类的字节码以应用于任何类型的方法调用（支持任意访问修饰符、支持自调用）。AspectJ 织入需要在类路径中包含 <code>spring-aspects.jar</code> 以及开启类加载期织入（load-time weaving）或编译期织入（compile-time weaving）。（参阅 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-aj-ltw-spring" target="_blank" rel="noopener">Spring 配置</a>）</td></tr><tr><td><code>proxy-target-class</code></td><td><code>proxyTargetClass</code></td><td><code>false</code></td><td>仅适用于 <code>proxy</code> 模式。控制为使用 <code>@Transactional</code> 注解的类所创建的事务代理类型。如果 <code>proxy-target-class</code> 属性设置为 <code>true</code>，则创建基于类的代理（CGLib Proxy）。如果为 <code>false</code> 或者省略该属性，则创建基于标准 JDK 接口的代理（JDK Proxy）。（参阅<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-proxying" target="_blank" rel="noopener">代理机制</a>）</td></tr><tr><td><code>order</code></td><td><code>order</code></td><td><code>Ordered.LOWEST_PRECEDENCE</code></td><td>参阅 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-ataspectj-advice-ordering" target="_blank" rel="noopener">Advice 排序</a>。</td></tr></tbody></table><p>更多注意点，详见官方文档：</p><blockquote><p>The default advice mode for processing <code>@Transactional</code> annotations is <code>proxy</code>, which allows for interception of calls through the proxy only. Local calls within the same class cannot get intercepted that way. For a more advanced mode of interception, consider switching to <code>aspectj</code> mode in combination with compile-time or load-time weaving.</p></blockquote><blockquote><p>In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation (in effect, a method within the target object calling another method of the target object) does not lead to an actual transaction at runtime even if the invoked method is marked with <code>@Transactional</code>.</p></blockquote><blockquote><p>The <code>proxy-target-class</code> attribute controls what type of transactional proxies are created for classes annotated with the <code>@Transactional</code> annotation. If <code>proxy-target-class</code> is set to <code>true</code>, class-based proxies are created. If<code>proxy-target-class</code> is <code>false</code> or if the attribute is omitted, standard JDK interface-based proxies are created. (See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#aop-proxying" target="_blank" rel="noopener">[aop-proxying]</a> for a discussion of the different proxy types.)</p></blockquote><blockquote><p>The Spring team recommends that you annotate only concrete classes (and methods of concrete classes) with the <code>@Transactional</code> annotation, as opposed to annotating interfaces. You certainly can place the <code>@Transactional</code> annotation on an interface (or an interface method), but this works only as you would expect it to if you use interface-based proxies. The fact that Java annotations are not inherited from interfaces means that, if you use class-based proxies (<code>proxy-target-class=&quot;true&quot;</code>) or the weaving-based aspect (<code>mode=&quot;aspectj&quot;</code>), the transaction settings are not recognized by the proxying and weaving infrastructure, and the object is not wrapped in a transactional proxy.</p></blockquote><blockquote><p>When you use proxies, you should apply the <code>@Transactional</code> annotation only to methods with public visibility. If you do annotate protected, private or package-visible methods with the <code>@Transactional</code> annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings. If you need to annotate non-public methods, consider using AspectJ.</p></blockquote><p><code>@EnableTransactionManagement</code> 注解主要用于导入 <code>TransactionManagementConfigurationSelector</code>，其判断 <code>mode</code> 属性：</p><ul><li><code>mode</code> 为 <code>AdviceMode.PROXY</code>，返回配置  <code>org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration</code>，该 Java Config 用于配置以下 bean：<ul><li><code>TransactionInterceptor</code> 最关键的类</li><li><code>TransactionAttributeSource</code></li><li><code>BeanFactoryTransactionAttributeSourceAdvisor</code></li></ul></li><li><code>mode</code> 为 <code>AdviceMode.ASPECTJ</code>，默认返回配置 <code>org.springframework.transaction.aspectj.AspectJTransactionManagementConfiguration</code></li></ul><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><p>其中事务的传播行为需要留意下，是 Spring 特有的概念，与数据库无关。它是为了解决业务层方法之间互相调用的事务问题而引入的。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。有以下几种方式：</p><table><thead><tr><th>传播行为</th><th>描述</th></tr></thead><tbody><tr><td><code>REQUIRED</code></td><td>支持当前事务，如果不存在，就新建一个。默认配置。</td></tr><tr><td><code>SUPPORTS</code></td><td><del>支持当前事务，如果不存在，就以非事务方式执行。</del></td></tr><tr><td><code>MANDATORY</code></td><td><del>支持当前事务，如果不存在，就抛出异常。</del></td></tr><tr><td><code>REQUIRES_NEW</code></td><td>如果当前存在事务，挂起当前事务，创建一个新事务。</td></tr><tr><td><code>NOT_SUPPORTED</code></td><td><del>以非事务方式执行，如果当前存在事务，则挂起当前事务。</del></td></tr><tr><td><code>NEVER</code></td><td><del>以非事务方式执行，如果当前存在事务，则抛出异常。</del></td></tr><tr><td><code>NESTED</code></td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 <code>REQUIRED</code> 类似的操作。</td></tr></tbody></table><p>强烈不建议使用非事务方式执行，因此上述标注删除线的传播行为不建议使用。</p><p>在 Spring 管理的事务中，请注意物理事务和逻辑事务之间的区别，以及传播行为应用于两者之上时的区别。</p><h3 id="REQUIRED"><a href="#REQUIRED" class="headerlink" title="REQUIRED"></a>REQUIRED</h3><p><img src="/img/spring/transaction/tx_prop_required.png" alt="REQUIRED"></p><h3 id="REQUIRED-NEW"><a href="#REQUIRED-NEW" class="headerlink" title="REQUIRED_NEW"></a>REQUIRED_NEW</h3><p><img src="/img/spring/transaction/tx_prop_requires_new.png" alt="REQUIRED_NEW"></p><h1 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h1><p>Spring 框架提供了两种编程式事务管理方法：</p><ul><li>直接使用 Spring 框架最底层的 <code>PlatformTransactionManager</code>  的实现类；</li><li>更建议使用 Spring 框架封装过的 <code>TransactionTemplate</code> 事务模板类。</li></ul><h2 id="使用-PlatformTransactionManager"><a href="#使用-PlatformTransactionManager" class="headerlink" title="使用 PlatformTransactionManager"></a>使用 <code>PlatformTransactionManager</code></h2><p>Spring 事务抽象的关键在于事务策略的概念。事务策略由<code>org.springframework.transaction.PlatformTransactionManager</code>接口定义 ，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>PlatformTransactionManager</code> 是一个接口，因此很容易按需 mock 或 stub。它与查找策略无关，例如JNDI。<code>PlatformTransactionManager</code> 的实现就像其它对象或 bean 一样在 Spring 框架的 IoC 容器中定义。仅此优势就让 Spring 框架事务成为一种有价值的抽象，即便是使用 JTA。与直接使用 JTA 相比，您可以更轻松地测试事务代码。</p><p>同时，为了与 Spring 的理念保持一致，<code>PlatformTransactionManager</code> 接口的所有方法抛出的  <code>TransactionException</code> 异常都是非受检的（即继承自 <code>java.lang.RuntimeException</code> 类）。事务基础设施故障几乎都是致命性的。只有极少数情况下，应用程序能够从事务故障中恢复过来。开发人员仍然可以选择 try catch <code>TransactionException</code>，但重点是开发人员不会<strong>被迫</strong>这样做。</p><p><code>getTransaction(..)</code> 方法根据 <code>TransactionDefinition</code> 参数返回一个 <code>TransactionStatus</code> 对象 。<code>TransactionStatus</code> 表示一个新事务，但如果当前调用堆栈中存在匹配事务，则表示该已有事务，即 <code>TransactionStatus</code> 是与执行的线程相关联的。</p><p><code>TransactionDefinition</code> 接口可以控制事务的传播行为、隔离级别、超时时间、只读状态，其结构如下：</p><p><img src="/img/spring/transaction/TransactionDefinition.png" alt="TransactionDefinition"></p><p><code>TransactionStatus</code> 接口为事务代码提供了一种简单的方法来控制事务执行和查询事务状态，其结构如下：</p><p><img src="/img/spring/transaction/TransactionStatus.png" alt="TransactionDefinition"></p><p>在 Spring 中无论选择使用声明式还是编程式事务管理，定义正确的 <code>PlatformTransactionManager</code> 实现都是绝对必要的。Spring 提供了下面几种实现：</p><table><thead><tr><th>实现类</th><th>包</th><th>工作环境</th></tr></thead><tbody><tr><td><code>DataSourceTransactionManager</code></td><td>spring-jdbc</td><td>JDBC、Mybatis</td></tr><tr><td><code>HibernateTransactionManager</code></td><td>spring-orm</td><td>Hibernate</td></tr><tr><td><code>JpaTransactionManager</code></td><td>spring-orm</td><td>JPA</td></tr><tr><td><code>JtaTransactionManager</code></td><td>spring-tx</td><td>JTA</td></tr></tbody></table><p>其继承关系如下：</p><p><img src="/img/spring/transaction/PlatformTransactionManager.png" alt="PlatformTransactionManager 实现"></p><p>以最常用的 <code>DataSourceTransactionManager</code> 为例，重点看下都提供了哪些方法：</p><p><img src="/img/spring/transaction/DataSourceTransactionManager.png" alt="DataSourceTransactionManager"></p><h2 id="使用-TransactionTemplate"><a href="#使用-TransactionTemplate" class="headerlink" title="使用 TransactionTemplate"></a>使用 <code>TransactionTemplate</code></h2><p>和 Spring 框架的其它模板类一样，<code>TransactionTemplate</code> 也采用了回调方法来减少样板代码。相比起直接使用 <code>PlatformTransactionManager</code> 接口，<code>TransactionTemplate</code> 可以让开发人员无须重复编写获取与释放事务资源的代码，从而更聚焦于业务代码。</p><p><img src="/img/spring/transaction/TransactionTemplate.png" alt="TransactionTemplate"></p><p>你需要编写一个 <code>TransactionCallback</code> 实现（通常为匿名内部类），其中包含需要在事务上下文中执行的代码。然后传递给 <code>TransactionTemplate</code> 的 <code>execute(..)</code> 方法去执行：</p><p><img src="/img/spring/transaction/TransactionCallback.png" alt="TransactionCallback"></p><p>由于 <code>TransactionTemplate</code> 继承自 <code>DefaultTransactionDefinition</code>，因此可以直接修改其属性进行事务配置（如传播行为、隔离级别、超时时间等）。<code>TransactionTemplate</code> 类的实例是线程安全的，实例并不维护任何会话状态，但是却会维护配置状态。因此，当多个类共享使用同一个 <code>TransactionTemplate</code> 类的实例时，如果其中一个需要使用不同的配置（例如不同的隔离级别），你需要创建两个不同的 <code>TransactionTemplate</code> 类的实例。</p><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDbService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestDAO testDAO;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要使用底层 `PlatformTransactionManager` 接口直接管理事务，请先注入所需的实现类。</span></span><br><span class="line"><span class="comment">     * 然后，通过 `TransactionDefinition` 和 `TransactionStatus` 对象启动、回滚和提交事务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultTransactionDefinition def = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">        <span class="comment">// explicitly setting the transaction name is something that can be done only programmatically</span></span><br><span class="line">        def.setName(<span class="string">"SomeTxName"</span>);</span><br><span class="line">        def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line">        </span><br><span class="line">        TransactionStatus status = transactionManager.getTransaction(def);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer result = insert();</span><br><span class="line">            transactionManager.commit(status);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage(), e);</span><br><span class="line">            transactionManager.rollback(status);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TransactionTemplate 采用了回调方法来减少样板代码。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">save1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> insert();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(e.getMessage(), e);</span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用注解方式配置事务，是最简单最推荐的方式。事务的参数配置详见脑图。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Integer</span> <span class="title">save3</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> insert();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/spring-framework-reference/data-access.html#transaction</a></p><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Transactional.html</a></p><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 数据持久化系列（四）Spring JDBC 使用总结</title>
      <link href="2018/02/20/spring-jdbc/"/>
      <url>2018/02/20/spring-jdbc/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-JDBC-简介"><a href="#Spring-JDBC-简介" class="headerlink" title="Spring JDBC 简介"></a>Spring JDBC 简介</h1><p>Spring 的 JDBC 框架承担了资源管理和异常处理的工作，从而简化了底层 JDBC API 代码，让我们只需编写从数据库读写数据所需的代码。具体特性如下：</p><ul><li><p>Spring 为读取和写入数据库的几乎所有错误提供了丰富的异常，且不与特定的持久化框架相关联（如下图）。异常都继承自的父类 <code>DataAccessException</code>，是一个非受检异常，无需捕获，因为 Spring 认为触发异常的很多问题是不能在 <code>catch</code> 代码块中修复，因此不强制开发人员编写 <code>catch</code> 代码块。这把是否要捕获异常的权利留给了开发人员。</p><p><img src="/img/spring/jdbc/data-access-exceptions.png" alt="data-access-exceptions"></p></li><li><p>Spring 将数据访问过程中固定的和可变的部分明确划分为两个不同的类：<em>模板（template）</em> 和 <em>回调（callback）</em>。模板管理过程中固定的部分（如事务控制、资源管理、异常处理），而回调处理自定义的数据访问代码（如 SQL 语句、绑定参数、整理结果集）。针对不同的持久化平台，Spring 提供了多个可选的模板：</p><p><img src="/img/spring/jdbc/data-access-templates.png" alt="data-access-templates"></p></li></ul><h1 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h1><p>要在 Spring 中使用 JDBC，需要依赖 <code>spring-jdbc</code>。如果使用 Spring Boot 的话，可以直接导入起步依赖 <code>spring-boot-starter-jdbc</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring JDBC 起步依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- MySQL JDBC 驱动程序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>mvn dependency:tree</code> 分析传递依赖如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[INFO] +- mysql:mysql-connector-java:jar:8.0.13:compile</span><br><span class="line">[INFO] \- org.springframework.boot:spring-boot-starter-jdbc:jar:2.1.2.RELEASE:compile</span><br><span class="line">[INFO]    +- org.springframework.boot:spring-boot-starter:jar:2.1.2.RELEASE:compile</span><br><span class="line">[INFO]    |  +- org.springframework.boot:spring-boot:jar:2.1.2.RELEASE:compile</span><br><span class="line">[INFO]    |  |  \- org.springframework:spring-context:jar:5.1.4.RELEASE:compile</span><br><span class="line">[INFO]    |  |     +- org.springframework:spring-aop:jar:5.1.4.RELEASE:compile</span><br><span class="line">[INFO]    |  |     \- org.springframework:spring-expression:jar:5.1.4.RELEASE:compile</span><br><span class="line">[INFO]    |  +- org.springframework.boot:spring-boot-autoconfigure:jar:2.1.2.RELEASE:compile</span><br><span class="line">[INFO]    |  +- org.springframework.boot:spring-boot-starter-logging:jar:2.1.2.RELEASE:compile</span><br><span class="line">[INFO]    |  |  +- ch.qos.logback:logback-classic:jar:1.2.3:compile</span><br><span class="line">[INFO]    |  |  |  \- ch.qos.logback:logback-core:jar:1.2.3:compile</span><br><span class="line">[INFO]    |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.11.1:compile</span><br><span class="line">[INFO]    |  |  |  \- org.apache.logging.log4j:log4j-api:jar:2.11.1:compile</span><br><span class="line">[INFO]    |  |  \- org.slf4j:jul-to-slf4j:jar:1.7.25:compile</span><br><span class="line">[INFO]    |  +- javax.annotation:javax.annotation-api:jar:1.3.2:compile</span><br><span class="line">[INFO]    |  +- org.springframework:spring-core:jar:5.1.4.RELEASE:compile</span><br><span class="line">[INFO]    |  |  \- org.springframework:spring-jcl:jar:5.1.4.RELEASE:compile</span><br><span class="line">[INFO]    |  \- org.yaml:snakeyaml:jar:1.23:runtime</span><br><span class="line">[INFO]    +- com.zaxxer:HikariCP:jar:3.2.0:compile</span><br><span class="line">[INFO]    |  \- org.slf4j:slf4j-api:jar:1.7.25:compile</span><br><span class="line">[INFO]    \- org.springframework:spring-jdbc:jar:5.1.4.RELEASE:compile</span><br><span class="line">[INFO]       +- org.springframework:spring-beans:jar:5.1.4.RELEASE:compile</span><br><span class="line">[INFO]       \- org.springframework:spring-tx:jar:5.1.4.RELEASE:compile</span><br></pre></td></tr></table></figure><p>可见，<code>spring-boot-starter-jdbc</code> 引入了如下传递依赖：</p><ul><li><code>spring-boot-starter</code><ul><li><code>spring-boot-autoconfigure</code> Spring Boot 自动配置类</li></ul></li><li><code>spring-jdbc</code> Spring JDBC 核心库</li><li><code>HikariCP</code>，Spring Boot 2 的默认数据库连接池</li><li>……</li></ul><h1 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h1><p><code>spring-boot-autoconfigure</code> 依赖内含几个关键的配置类，提供了如下外部配置：</p><ul><li><p><code>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration</code>，用于自动配置嵌入式数据源 或 连接池数据源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span></span><br><span class="line">    <span class="attr">url:</span></span><br><span class="line">    <span class="attr">username:</span></span><br><span class="line">    <span class="attr">password:</span></span><br></pre></td></tr></table></figure></li><li><p><code>org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration</code>，用于自动配置 JNDI 数据源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">jndi-name:</span></span><br></pre></td></tr></table></figure></li><li><p><code>org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration</code>，用于自动配置分布式事务的数据源</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">xa:</span></span><br><span class="line">      <span class="attr">data-source-class-name:</span></span><br><span class="line">      <span class="attr">properties:</span></span><br></pre></td></tr></table></figure></li><li><p><code>org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration</code>，用于导入配置类：<code>JdbcTemplateConfiguration</code>、<code>NamedParameterJdbcTemplateConfiguration</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jdbc:</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">fetch-size:</span> </span><br><span class="line">      <span class="attr">max-rows:</span> </span><br><span class="line">      <span class="attr">query-timeout:</span></span><br></pre></td></tr></table></figure></li><li><p><code>org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration</code> 用于自动配置 <code>DataSourceTransactionManager</code></p></li><li><p><code>org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">transaction:</span></span><br><span class="line">    <span class="attr">defaultTimeout:</span></span><br><span class="line">    <span class="attr">rollbackOnCommitFailure:</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="使用-JDBC-Template"><a href="#使用-JDBC-Template" class="headerlink" title="使用 JDBC Template"></a>使用 JDBC Template</h1><h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>为了让 <code>JdbcTemplate</code> 正常工作，只需要为其设置 <code>DataSource</code> 数据源即可。Spring Boot 下直接使用外部配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span>  <span class="comment">#使用 HikariCP，Spring Boot 2 的默认数据库连接池</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?useUnicode=true;characterEncoding=utf-8</span></span><br><span class="line">    <span class="attr">username:</span> </span><br><span class="line">    <span class="attr">password:</span></span><br></pre></td></tr></table></figure><p>如果未使用 Spring Boot，Java Config 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HikariDataSource ds = <span class="keyword">new</span> HikariDataSource();</span><br><span class="line">    ds.setDriverClassName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">    ds.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/test?useUnicode=true;characterEncoding=utf-8"</span>);</span><br><span class="line">    ds.setUsername(<span class="string">""</span>);</span><br><span class="line">    ds.setPassword(<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="API-介绍"><a href="#API-介绍" class="headerlink" title="API 介绍"></a>API 介绍</h2><p><img src="/img/spring/jdbc/JdbcOperations.png" alt="JdbcOperations"></p><ul><li><p><code>org.springframework.jdbc.core.JdbcOperations</code> 是 Spring 封装 JDBC 操作的核心接口，提供的方法如下，基于<strong>索引参数</strong>进行 SQL 参数绑定。实现类为 <code>org.springframework.jdbc.core.JdbcTemplate</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">&lt;T&gt; List&lt;T&gt; <span class="title">query</span><span class="params">(String, RowMapper&lt;T&gt;, Object...)</span>  <span class="comment">// 多列查询</span></span></span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">queryForMap</span><span class="params">(String, Object...)</span>  <span class="comment">// 单行多列查询</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">queryForObject</span><span class="params">(String, Class&lt;T&gt;, Object...)</span>  <span class="comment">// 单行单列查询</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">queryForObject</span><span class="params">(String, RowMapper&lt;T&gt;, Object...)</span>  <span class="comment">// 单行多列查询</span></span></span><br><span class="line"><span class="function">&lt;T&gt; List&lt;T&gt; <span class="title">queryForList</span><span class="params">(String, Class&lt;T&gt;, Object...)</span>  <span class="comment">// 多行单列查询</span></span></span><br><span class="line"><span class="function">List&lt;Map&lt;String, Object&gt;&gt; <span class="title">queryForList</span><span class="params">(String, Object...)</span>  <span class="comment">// 多行多列查询</span></span></span><br><span class="line"><span class="function">SqlRowSet <span class="title">queryForRowSet</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(...)</span>  <span class="comment">// 执行单个增删改</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>[] <span class="title">batchUpdate</span><span class="params">(...)</span>  <span class="comment">// 执行批量增删改</span></span></span><br><span class="line"><span class="function">Map&lt;String, Object&gt; <span class="title">call</span><span class="params">(...)</span>  <span class="comment">// 执行存储过程和函数</span></span></span><br><span class="line"><span class="function">......</span></span><br></pre></td></tr></table></figure></li><li><p><code>org.springframework.jdbc.core.namedparam.NamedParameterJdbcOperations</code> 接口支持将值以<strong>命名参数</strong>的形式绑定到 SQL，实现类为 <code>org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate</code>，其底层使用的仍然是 <code>JdbcOperations</code>，是一个二次封装的 API，推荐使用。</p></li></ul><p>如果使用 Spring Boot 的话，可以直接导入起步依赖 <code>spring-boot-starter-jdbc</code>，会引入自动配置类 <code>org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration</code>，用于导入配置类：<code>JdbcTemplateConfiguration</code>、<code>NamedParameterJdbcTemplateConfiguration</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; DataSource<span class="class">.<span class="keyword">class</span>, <span class="title">JdbcTemplate</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnSingleCandidate</span>(<span class="title">DataSource</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(<span class="title">DataSourceAutoConfiguration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">JdbcProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123; JdbcTemplateConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">NamedParameterJdbcTemplateConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JdbcTemplateAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要满足几个条件，该自动配置类就会生效：</p><ul><li>classpath 包含 <code>DataSource</code>、<code>JdbcTemplate</code> 类</li><li><code>DataSource</code> bean 有且只有一个</li></ul><h3 id="使用-JdbcOperations"><a href="#使用-JdbcOperations" class="headerlink" title="使用 JdbcOperations"></a>使用 JdbcOperations</h3><p>依赖注入 <code>JdbcTemplate</code> 实现之后，使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TestPO&gt; testPOList = jdbcOperations.query(</span><br><span class="line">        <span class="string">"SELECT id, name, city FROM test WHERE name = ? AND city = ?"</span>, </span><br><span class="line">        (rs, rowNum) -&gt; <span class="keyword">new</span> TestPO(</span><br><span class="line">            rs.getLong(<span class="string">"id"</span>),</span><br><span class="line">            rs.getString(<span class="string">"name"</span>),</span><br><span class="line">            rs.getString(<span class="string">"city"</span>)</span><br><span class="line">        ), </span><br><span class="line">        <span class="string">"李四"</span>, <span class="string">"beijing"</span></span><br><span class="line">    );</span><br><span class="line">log.info(<span class="string">"Result is &#123;&#125;"</span>, testPOList);  <span class="comment">// Result is [TestPO(id=2, name=李四, city=beijing)]</span></span><br><span class="line"></span><br><span class="line">TestPO testPO = jdbcOperations.queryForObject(</span><br><span class="line">        <span class="string">"SELECT id, name, city FROM test WHERE id = ?"</span>, </span><br><span class="line">        (rs, rowNum) -&gt; <span class="keyword">new</span> TestPO(</span><br><span class="line">            rs.getLong(<span class="string">"id"</span>),</span><br><span class="line">            rs.getString(<span class="string">"name"</span>),</span><br><span class="line">            rs.getString(<span class="string">"city"</span>)</span><br><span class="line">        ), </span><br><span class="line">        <span class="number">2</span></span><br><span class="line">    );</span><br><span class="line">log.info(<span class="string">"Result is &#123;&#125;"</span>, testPO);  <span class="comment">// Result is TestPO(id=2, name=李四, city=beijing)</span></span><br><span class="line"></span><br><span class="line">String name = jdbcOperations.queryForObject(<span class="string">"SELECT name FROM test WHERE id = ?"</span>, String<span class="class">.<span class="keyword">class</span>, 2)</span>;</span><br><span class="line">log.info(<span class="string">"Result is &#123;&#125;"</span>, name);  <span class="comment">// Result is 李四</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; names = jdbcOperations.queryForList("SELECT name FROM test WHERE city = ?", String.class, "beijing");</span><br><span class="line">log.info(<span class="string">"Result is &#123;&#125;"</span>, names);  <span class="comment">// Result is [李四, 王五]</span></span><br><span class="line"></span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; testMapList = jdbcOperations.queryForList(<span class="string">"SELECT id, name, city FROM test WHERE city = ?"</span>, <span class="string">"beijing"</span>);</span><br><span class="line">log.info(<span class="string">"Result is &#123;&#125;"</span>, testMapList);  <span class="comment">// Result is [&#123;id=2, name=李四, city=beijing&#125;, &#123;id=3, name=王五, city=beijing&#125;]</span></span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; testMap = jdbcOperations.queryForMap(<span class="string">"SELECT id, name, city FROM test WHERE id = ?"</span>, <span class="number">2</span>);</span><br><span class="line">log.info(<span class="string">"Result is &#123;&#125;"</span>, testMap);  <span class="comment">// Result is &#123;id=2, name=李四, city=beijing&#125;</span></span><br></pre></td></tr></table></figure><h3 id="使用-NamedParameterJdbcTemplate"><a href="#使用-NamedParameterJdbcTemplate" class="headerlink" title="使用 NamedParameterJdbcTemplate"></a>使用 NamedParameterJdbcTemplate</h3><p>使用 <code>JdbcOperations</code> 需要特别注意索引参数的正确顺序，如果在修改 SQL 时忘记修改参数顺序，将导致查询出错。因此更建议使用命名参数，按照名字来绑定值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; cityParamMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">paramMap.put(<span class="string">"city"</span>, <span class="string">"beijing"</span>);</span><br><span class="line">paramMap.put(<span class="string">"name"</span>, <span class="string">"李四"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;TestPO&gt; testPOList = namedParameterJdbcOperations.query(</span><br><span class="line">        <span class="string">"SELECT id, name, city FROM test WHERE name = :name AND city = :city"</span>, </span><br><span class="line">        paramMap, </span><br><span class="line">        (rs, rowNum) -&gt; <span class="keyword">new</span> TestPO(</span><br><span class="line">            rs.getLong(<span class="string">"id"</span>),</span><br><span class="line">            rs.getString(<span class="string">"name"</span>),</span><br><span class="line">            rs.getString(<span class="string">"city"</span>)</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"Result is &#123;&#125;"</span>, testPOList);  <span class="comment">// Result is [TestPO(id=2, name=李四, city=beijing)]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 数据持久化系列（三）JDBC SQL 和 Java 数据类型映射总结</title>
      <link href="2018/02/08/java-jdbc-mapping-sql-and-java-types/"/>
      <url>2018/02/08/java-jdbc-mapping-sql-and-java-types/</url>
      
        <content type="html"><![CDATA[<h1 id="映射概述"><a href="#映射概述" class="headerlink" title="映射概述"></a>映射概述</h1><p>由于 SQL 中的数据类型和 Java 编程语言中的数据类型并不相同，因此需要使用某种机制在使用 Java 类型的应用程序和使用 SQL 类型的数据库之间传输数据。</p><h1 id="SQL-类型映射成-JDBC-类型"><a href="#SQL-类型映射成-JDBC-类型" class="headerlink" title="SQL 类型映射成 JDBC 类型"></a>SQL 类型映射成 JDBC 类型</h1><p>不同数据库产品支持的 SQL 类型之间存在显着差异。即使不同的数据库支持具有相同语义的 SQL 类型，它们也可能为这些类型提供了不同的名称。例如，大多数主要数据库都支持 large binary 这种 SQL 类型，但是：</p><ul><li>MySQL 的命名为 <code>BINARY</code>、<code>VARBINARY</code>（详见：<a href="https://dev.mysql.com/doc/refman/8.0/en/binary-varbinary.html" target="_blank" rel="noopener">The BINARY and VARBINARY Types</a>）</li><li>Oracle 的命名为 <code>LONG RAW</code></li><li>Sybase 的命名为 <code>IMAGE</code></li><li>Informix 的命名为 <code>BYTE</code></li><li>DB2 的命名为 <code>LONG VARCHAR FOR BIT DATA</code></li></ul><p>幸运的是，JDBC 开发通常不需要关心目标数据库使用的实际 SQL 类型名称。大多数情况下，JDBC 开发将针对现有数据库表进行编程，并不需要关心用于创建这些表的确切 SQL 类型名称。</p><p>JDBC API 在 <code>java.sql.Types</code> 类中定义了一组通用 SQL 类型标识符，旨在表达最常用的 SQL 类型。在使用 JDBC API 进行编程时，程序员通常可以使用这些 JDBC 类型来引用通用 SQL 类型，而无需关心目标数据库使用的确切 SQL 类型名称。</p><p>下表提供了 MySQL 类型与  JDBC 类型、Java 类型的映射关系：</p><p><img src="/img/java/jdbc/mysql-types.png" alt="JDBC Types Mapped to Database-specific SQL Types"></p><h2 id="基本-JDBC-类型"><a href="#基本-JDBC-类型" class="headerlink" title="基本 JDBC 类型"></a>基本 JDBC 类型</h2><table><thead><tr><th>Java 类型</th><th>SQL 数据类型</th></tr></thead><tbody><tr><td><code>byte[]</code></td><td><code>BINARY</code>、<code>VARBINARY</code>、<code>LONGVARBINARY</code></td></tr><tr><td><code>String</code></td><td><code>CHAR</code>，<code>VARCHAR</code>、<code>LONGVARCHAR</code></td></tr><tr><td><code>boolean</code></td><td><code>BIT</code></td></tr><tr><td><code>byte</code></td><td><code>TINYINT</code></td></tr><tr><td><code>short</code></td><td><code>SMALLINT</code></td></tr><tr><td><code>int</code></td><td><code>INTEGER</code></td></tr><tr><td><code>long</code></td><td><code>BIGINT</code></td></tr><tr><td><code>float</code></td><td><code>REAL</code></td></tr><tr><td><code>double</code></td><td><code>FLOAT</code>、<code>DOUBLE</code></td></tr><tr><td><code>java.math.BigDecimal</code></td><td><code>NUMERIC</code>、<code>DECIMAL</code></td></tr><tr><td><code>java.sql.Date</code></td><td><code>DATE</code></td></tr><tr><td><code>java.sql.Time</code></td><td><code>TIME</code></td></tr><tr><td><code>java.sql.Timestamp</code></td><td><code>TIMESTAMP</code></td></tr></tbody></table><h2 id="高级-JDBC-类型"><a href="#高级-JDBC-类型" class="headerlink" title="高级 JDBC 类型"></a>高级 JDBC 类型</h2><p>SQL 标准后续引入的数据类型，包括 <code>BLOB</code>， <code>CLOB</code>，<code>ARRAY</code>，<code>REF</code> 等等：</p><table><thead><tr><th>Java 类型</th><th>SQL 数据类型</th><th>备注</th></tr></thead><tbody><tr><td><code>java.sql.Array</code></td><td><code>ARRAY</code></td><td>JDBC API 1.2 引入</td></tr><tr><td><code>java.sql.Blob</code></td><td><code>BLOB</code></td><td>JDBC API 1.2 引入</td></tr><tr><td><code>java.sql.Clob</code></td><td><code>CLOB</code></td><td>JDBC API 1.2 引入</td></tr><tr><td><code>java.sql.NClob</code></td><td><code>NCLOB</code></td><td>JDBC API 1.6 引入</td></tr><tr><td><code>java.sql.Ref</code></td><td><code>REF</code></td><td>JDBC API 1.2 引入</td></tr><tr><td><code>java.sql.RowId</code></td><td><code>ROWID</code></td><td>JDBC API 1.6 引入</td></tr><tr><td><code>java.sql.Struct</code></td><td><code>STRUCT</code></td><td>JDBC API 1.2 引入</td></tr><tr><td><code>java.sql.SQLXML</code></td><td><code>XML</code></td><td>JDBC API 1.6 引入</td></tr></tbody></table><h1 id="数据访问-API"><a href="#数据访问-API" class="headerlink" title="数据访问 API"></a>数据访问 API</h1><p>为了在数据库和 Java 应用程序之间传输数据，JDBC API 提供了三组方法：</p><ul><li><code>ResultSet</code> 类提供的用于将 <code>SELECT</code> 检索结果转换为 Java 类型的方法；</li><li><code>PreparedStatement</code> 类提供的用于将 Java 类型作为 SQL 语句参数发送的方法；</li><li><code>CallableStatement</code>类提供的用于将 <code>OUT</code> 参数转换为 Java 类型的方法。</li></ul><h2 id="静态数据访问"><a href="#静态数据访问" class="headerlink" title="静态数据访问"></a>静态数据访问</h2><h3 id="标准映射"><a href="#标准映射" class="headerlink" title="标准映射"></a>标准映射</h3><p>Java 程序从数据库中检索数据时，都必然会有某种形式的数据映射和数据转换。大多数情况下，JDBC 开发是知道目标数据库的 schema 的，例如表结构及其每列的数据类型。因此，JDBC 开发可以使用 <code>ResultSet</code>、<code>PreparedStatement</code>、<code>CallableStatement</code> 接口的强类型访问方法进行类型转换，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PreparedStatement 接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBoolean</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">boolean</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setByte</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">byte</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setShort</span><span class="params">(<span class="keyword">int</span> <span class="keyword">short</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInt</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLong</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">long</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFloat</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">float</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDouble</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBigDecimal</span><span class="params">(<span class="keyword">int</span>, BigDecimal)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setString</span><span class="params">(<span class="keyword">int</span>, String)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBytes</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">byte</span>[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDate</span><span class="params">(<span class="keyword">int</span>, Date)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">int</span>, Time)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTimestamp</span><span class="params">(<span class="keyword">int</span>, Timestamp)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBinaryStream</span><span class="params">(<span class="keyword">int</span>, InputStream)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCharacterStream</span><span class="params">(<span class="keyword">int</span>, Reader)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setRef</span><span class="params">(<span class="keyword">int</span>, Ref)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setBlob</span><span class="params">(<span class="keyword">int</span>, Blob)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setClob</span><span class="params">(<span class="keyword">int</span>, Clob)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">int</span>, Array)</span></span></span><br><span class="line"><span class="function">...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// ResultSet 接口</span></span></span><br><span class="line"><span class="function">Object <span class="title">getObject</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">getShort</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLong</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getFloat</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getDouble</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">BigDecimal <span class="title">getBigDecimal</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">String <span class="title">getString</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">byte</span>[] <span class="title">getBytes</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Date <span class="title">getDate</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Time <span class="title">getTime</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Timestamp <span class="title">getTimestamp</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">InputStream <span class="title">getBinaryStream</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Reader <span class="title">getCharacterStream</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Ref <span class="title">getRef</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Blob <span class="title">getBlob</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Clob <span class="title">getClob</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">Array <span class="title">getArray</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure><h3 id="自定义映射"><a href="#自定义映射" class="headerlink" title="自定义映射"></a>自定义映射</h3><p>自定义映射（SQL user-defined type (UDT) 到 Java 类）使用如下接口：</p><ul><li><code>java.sql.SQLData</code> 接口</li><li><code>java.sql.SQLInput</code> 接口</li><li><code>java.sql.SQLOutput</code> 接口</li></ul><h2 id="动态数据访问"><a href="#动态数据访问" class="headerlink" title="动态数据访问"></a>动态数据访问</h2><p>在大多数情况下，用户都希望访问在编译期数据类型已知的结果或参数。但是某些情况下，应用程序在编译期无法获知它们访问的目标数据库的 schema。因此，除了静态的数据类型访问之外，JDBC 还提供了对动态的数据类型访问的支持。</p><p>有三种方法可以方便地访问在编译期数据类型未知的值，使用所有 Java 对象的共同父类 <code>Object</code> 类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ResultSet.getObject</span><br><span class="line">PreparedStatement.setObject</span><br><span class="line">CallableStatement.getObject</span><br></pre></td></tr></table></figure><p><code>boolean</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code> 八种基本数据类型将返回其对应的包装类型，其它的则返回对应的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(url)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement stmt = conn.prepareStatement(<span class="string">"SELECT * FROM test WHERE name = ?;"</span>)) &#123;</span><br><span class="line">        stmt.setObject(<span class="number">1</span>, <span class="string">"李四"</span>, JDBCType.VARCHAR);</span><br><span class="line">        <span class="keyword">try</span> (ResultSet rs = stmt.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                Object id = rs.getObject(<span class="string">"id"</span>);</span><br><span class="line">                String name = rs.getObject(<span class="string">"name"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                log.info(<span class="string">"Result is &#123;&#125;, &#123;&#125;"</span>, id <span class="keyword">instanceof</span> Long, name);  <span class="comment">// Result is true, 李四</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.oracle.com/javase/6/docs/technotes/guides/jdbc/getstart/mapping.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/6/docs/technotes/guides/jdbc/getstart/mapping.html</a></p><p><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-type-conversions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-type-conversions.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 数据持久化系列（二）JDBC API 规范总结</title>
      <link href="2018/02/06/java-jdbc-api/"/>
      <url>2018/02/06/java-jdbc-api/</url>
      
        <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>首先，来总览下 JDBC API：</p><p><img src="/img/java/jdbc/jdbc-api.png" alt="JDBC"></p><h1 id="JDBC-API-规范"><a href="#JDBC-API-规范" class="headerlink" title="JDBC API 规范"></a>JDBC API 规范</h1><p>JDBC API 作为 Java SE™（Java 标准版）的一部分，由以下部分组成：</p><ul><li><p>JDBC 核心 API —— <code>java.sql</code> package。</p></li><li><p>JDBC 可选 API —— <code>javax.sql</code> package，是 Java EE™（Java 企业版）的重要组成部分。</p></li></ul><p>其中，<code>java.sql</code> package 包含下列 API：</p><ul><li><p>通过 <code>java.sql.DriverManager</code> 与数据库建立连接</p><ul><li><code>java.sql.DriverManager</code> 类 - 用于与驱动程序建立连接</li><li><code>java.sql.SQLPermission</code> 类</li><li><code>java.sql.Driver</code> 接口 - 提供用于注册和连接驱动程序的 API。</li><li><code>java.sql.DriverPropertyInfo</code> 类 - 提供 JDBC 驱动程序的属性。</li></ul></li><li><p>发送 SQL 语句到数据库</p><ul><li><code>java.sql.Connection</code> 接口 - 提供创建语句、管理连接及其属性的方法</li><li><code>java.sql.Statement</code> 接口 - 用于发送基本的 SQL 语句</li><li><code>java.sql.PreparedStatement</code> 接口 - 用于发送预编译语句或基本 SQL 语句（继承自<code>Statement</code>）</li><li><code>java.sql.CallableStatement</code> 接口 - 用于调用数据库存储过程（继承自<code>PreparedStatement</code>）</li><li><code>java.sql.Savepoint</code> 接口 - 在事务中提供保存点</li></ul></li><li><p>检索和更新查询结果</p><ul><li><code>java.sql.ResultSet</code> 接口</li></ul></li><li><p>标准映射（SQL 数据类型到 Java 类或接口）</p></li><li><p>自定义映射（SQL user-defined type (UDT) 到 Java 类）</p></li><li><p>元数据</p><ul><li><code>java.sql.DatabaseMetaData</code> 接口 - 提供有关数据库的信息</li><li><code>java.sql.ResultSetMetaData</code> 接口 - 提供有关 <code>ResultSet</code> 对象的列信息</li><li><code>java.sql.ParameterMetaData</code> 接口 - 提供有关 <code>PreparedStatement</code> 命令的参数信息</li></ul></li><li><p>异常</p><ul><li><code>java.sql.SQLException</code> 类 - 被大多数方法抛出，当数据访问出现问题或出于其它原因</li><li><code>java.sql.SQLWarning</code> 类 - 抛出表示警告</li><li><code>java.sql.DataTruncation</code> 类 - 抛出表示数据可能已被截断</li><li><code>java.sql.BatchUpdateException</code> 类 - 抛出表示批量更新中的部分命令未执行成功</li></ul></li></ul><p>下面重点看下常用的接口和类。</p><h2 id="DriverManager-类"><a href="#DriverManager-类" class="headerlink" title="DriverManager 类"></a>DriverManager 类</h2><p><code>java.sql.DriverManager</code> 类充当用户和驱动程序之间的接口。它跟踪可用的驱动程序并处理数据库与相应驱动程序之间的连接。<code>DriverManager</code> 类维护了一个通过调用 <code>DriverManager.registerDriver()</code> 方法来注册自己的 <code>java.sql.Driver</code> 类列表。</p><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(Driver driver)</span> <span class="comment">// 用于通过 `DriverManager` 注册给定的驱动程序。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deregisterDriver</span><span class="params">(Driver driver)</span>  <span class="comment">// 用于从 `DriverManager` 取消注册给定的驱动程序（从列表中删除驱动程序）。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url)</span>  <span class="comment">// 用于与指定的 URL 建立连接。</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url, String userName, String password)</span>  <span class="comment">// 用于与指定的 URL 建立连接，通过用户名和密码。</span></span></span><br></pre></td></tr></table></figure><p>关于 Driver 驱动程序注册，详见《<a href="/2019/01/23/java-jdbc-driver/">注册驱动程序</a>》。</p><h2 id="Connection-接口"><a href="#Connection-接口" class="headerlink" title="Connection 接口"></a>Connection 接口</h2><p><code>java.sql.Connection</code> 接口表示 Java 应用程序和数据库之间的会话（Session），它提供了许多事务管理方法如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">boolean</span> status)</span>  <span class="comment">// 修改当前 `Connection` 对象的事务自动提交模式。默认为 `true`。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setReadOnly</span><span class="params">(<span class="keyword">boolean</span> readOnly)</span>  <span class="comment">// 修改当前 `Connection` 对象的只读状态以提示驱动程序开启数据库优化。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTransactionIsolation</span><span class="params">(<span class="keyword">int</span> level)</span>  <span class="comment">// 修改当前 `Connection` 对象的事务隔离级别。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span>  <span class="comment">// 保存自上次提交/回滚以来所做的所有更改。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span>  <span class="comment">// 丢弃自上次提交/回滚以来所做的所有更改。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 在当前事务中设置或移除保存点。</span></span></span><br><span class="line"><span class="function">Savepoint <span class="title">setSavepoint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">Savepoint <span class="title">setSavepoint</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">releaseSavepoint</span><span class="params">(Savepoint savepoint)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>  <span class="comment">// 关闭连接并立即释放 JDBC 资源。</span></span></span><br></pre></td></tr></table></figure><p><code>Connection</code> 接口同时也是一个工厂类，用于获取 <code>Statement</code>、<code>PreparedStatement</code> 和 <code>DatabaseMetaData</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Statement <span class="title">createStatement</span><span class="params">(...)</span>  <span class="comment">// 创建一个可用于执行 SQL 查询或更新的语句对象。</span></span></span><br><span class="line"><span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(...)</span>  <span class="comment">// 创建一个可用于执行 SQL 参数化查询或更新的语句对象。</span></span></span><br><span class="line"><span class="function">CallableStatement <span class="title">prepareCall</span><span class="params">(...)</span>  <span class="comment">// 用于调用存储过程和函数。</span></span></span><br><span class="line"><span class="function">DatabaseMetaData <span class="title">getMetaData</span><span class="params">()</span>  <span class="comment">// 用于获取数据库的元数据，例如数据库产品名称，数据库产品版本，驱动程序名称，表总数名称，总视图名称等。</span></span></span><br></pre></td></tr></table></figure><h2 id="Statement-接口"><a href="#Statement-接口" class="headerlink" title="Statement 接口"></a>Statement 接口</h2><p><code>java.sql.Statement</code> 接口提供用于执行数据库查询与更新的方法。<code>Statement</code>  接口是 <code>ResultSet</code> 的工厂，即它提供工厂方法来获取 <code>ResultSet</code> 的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ResultSet <span class="title">executeQuery</span><span class="params">(String sql)</span>  <span class="comment">// 用于执行 `SELECT` 查询并返回 `ResultSet` 的对象。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">(String sql)</span>  <span class="comment">// 用于执行指定的更新，如 `create`，`drop`，`insert`，`update`，`delete` 等。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">execute</span><span class="params">(String sql)</span>  <span class="comment">// 用于执行可能返回多种结果的查询。</span></span></span><br></pre></td></tr></table></figure><p>除了通过上述方法来执行单个查询或更新，还可以通过下列方法执行批量命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addBatch</span><span class="params">(String sql)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearBatch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span>[] <span class="title">executeBatch</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>使用批量命令前，记得先使用 <code>setAutoCommit()</code> 将事务的自动提交模式设置为 <code>false</code> 。</p><p>批处理允许您将相关的 SQL 语句分组到批处理中，并通过一次调用数据库来提交它们。当您一次性向数据库发送多个 SQL 语句时，可以减少通信开销，从而提高性能。参考：<a href="https://www.tutorialspoint.com/jdbc/jdbc-batch-processing.htm" target="_blank" rel="noopener">JDBC - Batch Processing</a>。</p><h2 id="PreparedStatement-接口"><a href="#PreparedStatement-接口" class="headerlink" title="PreparedStatement 接口"></a>PreparedStatement 接口</h2><p><code>java.sql.PreparedStatement</code> 接口是 <code>java.sql.Statement</code> 的子接口。它用于执行参数化查询（parameterized query），例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement stmt = connection.prepareStatement("<span class="keyword">insert</span> <span class="keyword">into</span> emp <span class="keyword">values</span>(?, ?, ?)<span class="string">");</span></span><br></pre></td></tr></table></figure><p>为什么要使用 <code>PreparedStatement</code>？</p><ul><li><strong>提升性能</strong>：应用程序的性能会更快，因为 SQL 语句只会编译一次。</li><li><strong>提升安全</strong></li></ul><p>创建预编译的参数化查询语句后，需要通过 <code>setXxx</code> 方法设置对应参数。参数设置完毕后，就可以通过下列方法执行 SQL 语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ResultSet <span class="title">executeQuery</span><span class="params">()</span>  <span class="comment">// 用于执行 `SELECT` 查询并返回 `ResultSet` 的对象。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">executeUpdate</span><span class="params">()</span>  <span class="comment">// 用于执行指定的更新，如 `create`，`drop`，`insert`，`update`，`delete` 等。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span>  <span class="comment">// 用于执行可能返回多种结果的查询。</span></span></span><br></pre></td></tr></table></figure><p><code>PreparedStatement</code> 还提供了批处理方式，减少网络请求，提升性能，API 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a set of parameters to this &lt;code&gt;PreparedStatement&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * object's batch of commands.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@exception</span> SQLException if a database access error occurs or</span></span><br><span class="line"><span class="comment"> * this method is called on a closed &lt;code&gt;PreparedStatement&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Statement#addBatch</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addBatch</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement ps = conn.prepareStatement(<span class="string">"INSERT into employees values (?, ?, ?)"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">100</span>; n++) &#123;</span><br><span class="line">    ps.setString(name[n]);</span><br><span class="line">    ps.setLong(id[n]);</span><br><span class="line">    ps.setInt(salary[n]);</span><br><span class="line">    <span class="comment">// 多次执行PreparedStatement，多次数据库请求（网络请求）</span></span><br><span class="line">    ps.executeUpdate();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用批处理方法，一次性执行多条 SQL：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement ps = conn.prepareStatement(<span class="string">"INSERT into employees values (?, ?, ?)"</span>);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n &lt; <span class="number">100</span>; n++) &#123;</span><br><span class="line">    ps.setString(name[n]);</span><br><span class="line">    ps.setLong(id[n]);</span><br><span class="line">    ps.setInt(salary[n]);</span><br><span class="line">    <span class="comment">// 添加批次</span></span><br><span class="line">    ps.addBatch();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用父接口 Statement#executeBatch() 执行批次</span></span><br><span class="line">ps.executeBatch();</span><br></pre></td></tr></table></figure><h2 id="ResultSet-接口"><a href="#ResultSet-接口" class="headerlink" title="ResultSet 接口"></a>ResultSet 接口</h2><p><code>java.sql.ResultSet</code> 对象维护了一个指向 table 行的游标。游标初始值指向第 0 行。默认情况下，<code>ResultSet</code> 对象只能向前移动，并且不可更新。可以通过在 <code>createStatement(int, int)</code> 方法中传递指定参数修改该默认行为。</p><p>可以通过以下方法操作游标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">next</span><span class="params">()</span>  <span class="comment">// 将游标移动到当前位置的下一行。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">previous</span><span class="params">()</span>  <span class="comment">// 将游标移动到当前位置之前的一行。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">first</span><span class="params">()</span>  <span class="comment">// 将游标移动到结果集的第一行。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">last</span><span class="params">()</span>  <span class="comment">// 将游标移动到结果集的最后一行。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">absolute</span><span class="params">(<span class="keyword">int</span> row)</span>  <span class="comment">// 将游标移动到结果集的指定行号。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">relative</span><span class="params">(<span class="keyword">int</span> row)</span>  <span class="comment">// 将游标移动到结果集的相对行号，它可以是正数或负数。</span></span></span><br></pre></td></tr></table></figure><p>将游标移动到指定行之后，可以通过 <code>getXxx</code> 方法获取当前行的指定列的数据。</p><p>此外，还可以直接获取 table 的元数据，例如列的总数，列名，列类型等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ResultSetMetaData <span class="title">getMetaData</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="ResultSetMetaData-接口"><a href="#ResultSetMetaData-接口" class="headerlink" title="ResultSetMetaData 接口"></a>ResultSetMetaData 接口</h2><p><code>java.sql.ResultSetMetaData</code> 用于获取 table 的元数据，例如列的总数，列名，列类型等。</p><h2 id="DatabaseMetaData-接口"><a href="#DatabaseMetaData-接口" class="headerlink" title="DatabaseMetaData 接口"></a>DatabaseMetaData 接口</h2><p><code>java.sql.DatabaseMetaData</code> 用于获取数据库的元数据，例如数据库产品名称，数据库产品版本，驱动程序名称，表总数名称，总视图名称等。</p><h2 id="RowSet-接口"><a href="#RowSet-接口" class="headerlink" title="RowSet 接口"></a>RowSet 接口</h2><p><code>javax.sql.RowSet</code> 继承自 <code>java.sql.ResultSet</code>，是其包装器类。它包含类似 <code>ResultSet</code> 的表格数据，但使用起来非常简单灵活。其实现类如下：</p><p><img src="/img/java/jdbc/rowset.jpg" alt="RowSet"></p><p>下面是一个不含事件处理代码的 <code>JdbcRowSet</code> 的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (JdbcRowSet rowSet = RowSetProvider.newFactory().createJdbcRowSet()) &#123;</span><br><span class="line">    rowSet.setUrl(url);</span><br><span class="line">    rowSet.setCommand(<span class="string">"SELECT * FROM test"</span>);</span><br><span class="line">    rowSet.execute();</span><br><span class="line">    <span class="keyword">while</span> (rowSet.next()) &#123;</span><br><span class="line">        <span class="keyword">int</span> id = rowSet.getInt(<span class="string">"id"</span>);</span><br><span class="line">        String name = rowSet.getString(<span class="string">"name"</span>);</span><br><span class="line">        log.info(<span class="string">"Result is &#123;&#125; &#123;&#125;"</span>, id, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比下面传统的 JDBC API，代码更加直观，需要直接管理的资源也更少：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(url)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (Statement stmt = conn.createStatement()) &#123;</span><br><span class="line">        <span class="keyword">try</span> (ResultSet rs = stmt.executeQuery(<span class="string">"SELECT * FROM test"</span>)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">                log.info(<span class="string">"Result is &#123;&#125;, &#123;&#125;"</span>, id, name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要使用 <code>JdbcRowSet</code> 执行事件处理，需要在 <code>JdbcRowSet</code> 的 <code>addRowSetListener</code> 方法中添加 <code>RowSetListener</code> 的实例。<code>RowSetListener</code> 接口提供了必须实现的三个方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cursorMoved</span><span class="params">(RowSetEvent event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rowChanged</span><span class="params">(RowSetEvent event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rowSetChanged</span><span class="params">(RowSetEvent event)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="DataSource-接口"><a href="#DataSource-接口" class="headerlink" title="DataSource 接口"></a>DataSource 接口</h2><h1 id="JDBC-API-示例"><a href="#JDBC-API-示例" class="headerlink" title="JDBC API 示例"></a>JDBC API 示例</h1><p>JDBC API 的使用步骤如下：</p><p><img src="/img/java/jdbc/steps-to-connect-to-the-database-in-java.jpg" alt="JDBC 使用步骤"></p><p>其中：</p><ol><li>步骤一：JDBC API 从 4.0 开始利用 Java SPI 机制自动加载驱动程序，可以省略该步骤。</li><li>步骤二、三：如果使用如 Spring <code>JdbcTempate</code>、MyBatis 等框架，可以省略该步骤。</li><li>步骤五：使用 <code>try-with-resources</code> 语句，可以省略该步骤。</li></ol><p>下面来两个示例：</p><h2 id="存储图片"><a href="#存储图片" class="headerlink" title="存储图片"></a>存储图片</h2><p>下例通过 <code>PreparedStatement</code> 接口的 <code>setBinaryStream()</code> 方法将图片（二进制信息）存储到数据库中。为了将图片存储到数据库中，需要在表中使用 <code>BLOB</code>（Binary Large Object）数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(url)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement stmt = conn.prepareStatement(<span class="string">"INSERT INTO test(title, photo) VALUES(?, ?)"</span>)) &#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"F:\\test.jpg"</span>);</span><br><span class="line">        stmt.setString(<span class="number">1</span>, <span class="string">"pic1"</span>);</span><br><span class="line">        stmt.setBinaryStream(<span class="number">2</span>, fileInputStream);</span><br><span class="line">        assertTrue(<span class="number">1</span> == stmt.executeUpdate());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这只是一个例子，生产环境中是不会将这类二进制信息存储到数据库中的，而是存储到专门的文件系统，以提升性能，并节省宝贵的数据库资源 :)</p><h2 id="检索图片"><a href="#检索图片" class="headerlink" title="检索图片"></a>检索图片</h2><p>Using <code>try-with-resources</code> Statements to Automatically Close JDBC Resources: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection conn = DriverManager.getConnection(url)) &#123;</span><br><span class="line">    <span class="keyword">try</span> (PreparedStatement stmt = conn.prepareStatement(<span class="string">"SELECT title, photo FROM test"</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> (ResultSet rs = stmt.executeQuery()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                String title = rs.getString(<span class="number">1</span>);</span><br><span class="line">                log.info(<span class="string">"title is &#123;&#125;"</span>, title);</span><br><span class="line"></span><br><span class="line">                Blob photo = rs.getBlob(<span class="number">2</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = photo.getBytes(<span class="number">1</span>, (<span class="keyword">int</span>) photo.length());</span><br><span class="line">                String fileName = String.format(<span class="string">"F:\\%s.png"</span>, title);</span><br><span class="line">                <span class="keyword">try</span> (FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(fileName)) &#123;</span><br><span class="line">                    fileOutputStream.write(bytes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDBC 4.1 (Java SE 7) introduces the ability to use a <code>try-with-resources</code> statement to automatically close <code>java.sql.Connection</code>, <code>java.sql.Statement</code>, and <code>java.sql.ResultSet</code> objects, regardless of whether a <code>SQLException</code> or any other exception has been thrown. See <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/language/try-with-resources.html" target="_blank" rel="noopener">The try-with-resources Statement</a> for more information.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://docs.oracle.com/javase/6/docs/technotes/guides/jdbc/getstart/GettingStartedTOC.fm.html" target="_blank" rel="noopener">Getting Started with the JDBC API</a>》</p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/jdbc_41.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/jdbc_41.html</a></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/jdbc_42.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/jdbc_42.html</a></p><p><a href="https://docs.oracle.com/javase/9/docs/api/java/sql/package-summary.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/9/docs/api/java/sql/package-summary.html</a></p><p><a href="https://www.javatpoint.com/java-jdbc" target="_blank" rel="noopener">https://www.javatpoint.com/java-jdbc</a></p><p><a href="https://www.tutorialspoint.com/jdbc/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/jdbc/index.htm</a></p><p><a href="https://www.tutorialspoint.com/dbutils/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/dbutils/index.htm</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 数据持久化系列（一）JDBC Driver 驱动程序总结</title>
      <link href="2018/02/03/java-jdbc-driver/"/>
      <url>2018/02/03/java-jdbc-driver/</url>
      
        <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img src="/img/java/jdbc/jdbc-driver.png" alt="JDBC Driver"></p><h1 id="什么是-JDBC？"><a href="#什么是-JDBC？" class="headerlink" title="什么是 JDBC？"></a>什么是 JDBC？</h1><p>JDBC 表示 Java Database Connectivity，是 JavaSE（Java 标准版）的一部分，。JDBC API 用于在 Java 应用程序中执行以下活动：</p><ol><li>连接到数据库</li><li>执行查询并将语句更新到数据库</li><li>检索从数据库收到的结果</li></ol><p><img src="/img/java/jdbc/usage-of-jdbc.png" alt="JDBC API"></p><h1 id="为什么要使用-JDBC？"><a href="#为什么要使用-JDBC？" class="headerlink" title="为什么要使用 JDBC？"></a>为什么要使用 JDBC？</h1><p>在 JDBC 之前，ODBC API 是用于连接和执行命令的数据库 API 标准。但是，ODBC API 是使用 C 语言编写的驱动程序，依赖于平台。这就是为什么 Java 定义了自己的 JDBC API，它使用的 JDBC 驱动程序，是用 Java 语言编写的，具有与平台无关的特性，支持跨平台部署，性能也较好。</p><h1 id="什么是-JDBC-驱动程序？"><a href="#什么是-JDBC-驱动程序？" class="headerlink" title="什么是 JDBC 驱动程序？"></a>什么是 JDBC 驱动程序？</h1><p>由于 JDBC API 只是一套接口规范，因此要使用 JDBC API 操作数据库，首先需要选择合适的驱动程序：</p><h2 id="驱动程序四种类型"><a href="#驱动程序四种类型" class="headerlink" title="驱动程序四种类型"></a>驱动程序四种类型</h2><p>有四种类型的 JDBC 驱动程序：</p><ol><li>JDBC-ODBC bridge driver (<del>In Java 8, the JDBC-ODBC Bridge has been removed.</del>)</li><li>Native-API driver (partially java driver)</li><li>Network-Protocol driver (Middleware driver, fully java driver)</li><li><strong>Database-Protocol driver (Thin driver, fully java driver)</strong>，目前最常用的驱动类型，日常开发中使用的驱动 jar 包基本都属于这种类型，通常由数据库厂商直接提供，例如 <code>mysql-connector-java</code>。驱动程序把 JDBC 调用直接转换为数据库特定的网络协议，因此性能更好。驱动程序纯 Java 实现，支持跨平台部署。</li></ol><blockquote><p>我们知道，ODBC几乎能在所有平台上连接几乎所有的数据库。为什么 Java 不使用 ODBC？</p><p>答案是：Java 可以使用 ODBC，但最好是以JDBC-ODBC桥的形式使用（Java连接总体分为Java直连和JDBC-ODBC桥两种形式）。</p><p>那为什么还需要 JDBC？</p><p>因为ODBC 不适合直接在 Java 中使用，因为它使用 C 语言接口。从Java 调用本地 C代码在安全性、实现、坚固性和程序的自动移植性方面都有许多缺点。从 ODBC C API 到 Java API 的字面翻译是不可取的。例如，Java 没有指针，而 ODBC 却对指针用得很广泛（包括很容易出错的指针”void *”）。</p><p>另外，ODBC 比较复杂，而JDBC 尽量保证简单功能的简便性，同时在必要时允许使用高级功能。如果使用ODBC，就必须手动地将 ODBC 驱动程序管理器和驱动程序安装在每台客户机上。如果完全用 Java 编写 JDBC 驱动程序则 JDBC代码在所有 Java 平台上（从网络计算机到大型机）都可以自 动安装、移植并保证安全性。</p><p>总之，JDBC 在很大程度上是借鉴了ODBC的，从他的基础上发展而来。JDBC 保留了 ODBC 的基本设计特征，因此，熟悉 ODBC 的程序员将发现 JDBC 很容易使用。它们之间最大的区别在于：JDBC 以 Java 风格与优点为基础并进行优化，因此更加易于使用。</p></blockquote><p>各类型的优缺点详见：</p><p><a href="https://en.wikipedia.org/wiki/JDBC_driver" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/JDBC_driver</a></p><p><a href="https://www.javatpoint.com/jdbc-driver" target="_blank" rel="noopener">https://www.javatpoint.com/jdbc-driver</a></p><p><a href="https://blog.csdn.net/autfish/article/details/52170053" target="_blank" rel="noopener">https://blog.csdn.net/autfish/article/details/52170053</a></p><h2 id="驱动程序厂商实现"><a href="#驱动程序厂商实现" class="headerlink" title="驱动程序厂商实现"></a>驱动程序厂商实现</h2><p>如果选定使用推荐的第四种驱动程序类型，接下来需要下载对应厂商的驱动程序，目前提供这些<a href="https://www.oracle.com/technetwork/java/index-136695.html" target="_blank" rel="noopener">支持列表</a>。</p><p>例如最常用的 MySQL 数据库，提供了 <a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">MySQL Connector/J</a>（即 <code>mysql-connector-java</code>）。Maven 依赖配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MySQL 驱动程序的更多信息，例如：</p><ul><li>驱动程序/数据源类名</li><li>连接 URL 语法</li><li>配置属性</li><li>JDBC API 实现说明</li><li>Java，JDBC 和 MySQL 类型</li><li>使用字符集和 Unicode</li><li>各种连接方式（如 SSL 安全连接）</li><li>MySQL 错误码与 JDBC SQLState 代码的映射关系</li><li>……</li></ul><p>详见：<a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-overview.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-overview.html</a></p><h1 id="注册驱动程序源码分析"><a href="#注册驱动程序源码分析" class="headerlink" title="注册驱动程序源码分析"></a>注册驱动程序源码分析</h1><p>有几种方式可以注册驱动程序，如下：</p><h2 id="手工注册"><a href="#手工注册" class="headerlink" title="手工注册"></a>手工注册</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);  <span class="comment">// 方式一，底层实现其实就是方式二</span></span><br><span class="line">DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());  <span class="comment">// 方式二</span></span><br><span class="line">System.setProperty(<span class="string">"jdbc.drivers"</span>, <span class="string">"com.mysql.jdbc.Driver"</span>);  <span class="comment">// 方式三</span></span><br></pre></td></tr></table></figure><h2 id="自动注册"><a href="#自动注册" class="headerlink" title="自动注册"></a>自动注册</h2><p>从 JDBC API 4.0 开始，<code>java.sql.DriverManager</code> 类得到了增强，利用 <strong>Java SPI 机制</strong>从厂商驱动程序的 <code>META-INF/services/java.sql.Driver</code> 文件中自动加载 <code>java.sql.Driver</code> 实现类。 因此应用程序无需再显式调用 <code>Class.forName</code> 或 <code>DriverManager.registerDriver</code> 方法来注册或加载驱动程序。<code>java.sql.DriverManager</code> 源码分析如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Load the initial JDBC drivers by checking the System property</span></span><br><span class="line"><span class="comment">     * jdbc.properties and then use the &#123;<span class="doctag">@code</span> ServiceLoader&#125; mechanism</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        loadInitialDrivers();</span><br><span class="line">        println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadInitialDrivers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String drivers;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            drivers = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;String&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> System.getProperty(<span class="string">"jdbc.drivers"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            drivers = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If the driver is packaged as a Service Provider, load it.</span></span><br><span class="line">        <span class="comment">// Get all the drivers through the classloader</span></span><br><span class="line">        <span class="comment">// exposed as a java.sql.Driver.class service.</span></span><br><span class="line">        <span class="comment">// ServiceLoader.load() replaces the sun.misc.Providers()</span></span><br><span class="line"></span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Load these drivers, so that they can be instantiated.</span></span><br><span class="line"><span class="comment">                 * It may be the case that the driver class may not be there</span></span><br><span class="line"><span class="comment">                 * i.e. there may be a packaged driver with the service class</span></span><br><span class="line"><span class="comment">                 * as implementation of java.sql.Driver but the actual class</span></span><br><span class="line"><span class="comment">                 * may be missing. In that case a java.util.ServiceConfigurationError</span></span><br><span class="line"><span class="comment">                 * will be thrown at runtime by the VM trying to locate</span></span><br><span class="line"><span class="comment">                 * and load the service.</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * Adding a try catch block to catch those runtime errors</span></span><br><span class="line"><span class="comment">                 * if driver not available in classpath but it's</span></span><br><span class="line"><span class="comment">                 * packaged as service and that service is there in classpath.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    <span class="keyword">while</span>(driversIterator.hasNext()) &#123;</span><br><span class="line">                        driversIterator.next();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span>(Throwable t) &#123;</span><br><span class="line">                <span class="comment">// Do nothing</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"DriverManager.initialize: jdbc.drivers = "</span> + drivers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drivers == <span class="keyword">null</span> || drivers.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] driversList = drivers.split(<span class="string">":"</span>);</span><br><span class="line">        println(<span class="string">"number of Drivers:"</span> + driversList.length);</span><br><span class="line">        <span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">"DriverManager.Initialize: loading "</span> + aDriver);</span><br><span class="line">                Class.forName(aDriver, <span class="keyword">true</span>,</span><br><span class="line">                        ClassLoader.getSystemClassLoader());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                println(<span class="string">"DriverManager.Initialize: load failed: "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源码中可见，当类加载器载入 <code>java.sql.DriverManager</code> 类时，会执行其静态代码块，从而执行 <code>loadInitialDrivers()</code> 方法。该方法实现中通过 Java SPI <code>ServiceLoader</code> 查找 classpath 下所有 jar 包内的 <code>META-INF/services</code> 目录，找到 <code>java.sql.Driver</code> 文件，加载其中定义的实现类并通过反射创建实例。以 <code>mysql-connector-java</code> 8.x 为例，该类定义就是 <code>com.mysql.cj.jdbc.Driver</code>，此时由于该 <code>Driver</code> 类内含静态代码块，会用 <code>new</code> 关键字创建自身实例并反向注册到 <code>DriverManager</code>，从而达到自动注册驱动程序的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register ourselves with the DriverManager</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException E) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JDBC-URL"><a href="#JDBC-URL" class="headerlink" title="JDBC URL"></a>JDBC URL</h1><p>驱动程序注册完毕之后，接下来是通过 JDBC URL 与数据源建立连接。</p><p>JDBC URL 提供了一种标识数据源的方法，以便相应的驱动程序识别它并与之建立连接。</p><p>JDBC URL 的标准语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:&lt;subprotocol&gt;:&lt;subname&gt;</span><br></pre></td></tr></table></figure><p>它有三个部分，用冒号分隔，分解如下：</p><ul><li><code>jdbc</code> - 协议。JDBC URL 中的协议始终是 <code>jdbc</code>。</li><li><code>&lt;subprotocol&gt;</code> - 驱动程序的名称（如 <code>mysql</code>）或数据库连接机制的名称（如 <code>odbc</code>），可由一个或多个驱动程序支持。</li><li><code>&lt;subname&gt;</code> - 数据源的名称。</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true;characterEncoding&#x3D;utf-8</span><br></pre></td></tr></table></figure><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>如果有多个不同的驱动程序都被注册，调用 <code>DriverManager.getConnection</code> 方法通过 JDBC URL 获取数据源连接时，会使用第一个可用的驱动程序来创建连接。源码分析如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/test?useUnicode=true;characterEncoding=utf-8"</span>)</span><br></pre></td></tr></table></figure><p><code>DriverManager</code> 会遍历已注册的驱动程序，尝试获取连接，关键代码：<code>Connection con = aDriver.driver.connect(url, info);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DriverManager 源码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String url, java.util.Properties info, Class&lt;?&gt; caller)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">        <span class="comment">// If the caller does not have permission to load the driver then</span></span><br><span class="line">        <span class="comment">// skip it.</span></span><br><span class="line">        <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                println(<span class="string">"    trying "</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">                <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Success!</span></span><br><span class="line">                    println(<span class="string">"getConnection returning "</span> + aDriver.driver.getClass().getName());</span><br><span class="line">                    <span class="keyword">return</span> (con);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    reason = ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            println(<span class="string">"    skipping: "</span> + aDriver.getClass().getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MySQL 驱动程序实现类会判断该 JDBC URL 是否支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.mysql.cj.jdbc.NonRegisteringDriver 源码，实现 java.sql.Driver 接口</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> java.sql.<span class="function">Connection <span class="title">connect</span><span class="params">(String url, Properties info)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ConnectionUrl.acceptsUrl(url)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * According to JDBC spec:</span></span><br><span class="line"><span class="comment">             * The driver should return "null" if it realizes it is the wrong kind of driver to connect to the given URL. This will be common, as when the</span></span><br><span class="line"><span class="comment">             * JDBC driver manager is asked to connect to a given URL it passes the URL to each loaded driver in turn.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ConnectionUrl conStr = ConnectionUrl.getConnectionUrlInstance(url, info);</span><br><span class="line">        <span class="keyword">switch</span> (conStr.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> SINGLE_CONNECTION:</span><br><span class="line">                <span class="keyword">return</span> com.mysql.cj.jdbc.ConnectionImpl.getInstance(conStr.getMainHost());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> LOADBALANCE_CONNECTION:</span><br><span class="line">                <span class="keyword">return</span> LoadBalancedConnectionProxy.createProxyInstance((LoadbalanceConnectionUrl) conStr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> FAILOVER_CONNECTION:</span><br><span class="line">                <span class="keyword">return</span> FailoverConnectionProxy.createProxyInstance(conStr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> REPLICATION_CONNECTION:</span><br><span class="line">                <span class="keyword">return</span> ReplicationConnectionProxy.createProxyInstance((ReplicationConnectionUrl) conStr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedConnectionStringException e) &#123;</span><br><span class="line">        <span class="comment">// when Connector/J can't handle this connection string the Driver must return null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (CJException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.createException(UnableToConnectException<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">                  Messages.getString("NonRegisteringDriver.17", new Object[] &#123; ex.toString() &#125;), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scheme 支持列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.mysql.cj.conf.Type 枚举源码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The database URL type which is determined by the scheme section of the connection string.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Type &#123;</span><br><span class="line">    SINGLE_CONNECTION(<span class="string">"jdbc:mysql:"</span>, HostsCardinality.SINGLE), <span class="comment">//</span></span><br><span class="line">    FAILOVER_CONNECTION(<span class="string">"jdbc:mysql:"</span>, HostsCardinality.MULTIPLE), <span class="comment">//</span></span><br><span class="line">    LOADBALANCE_CONNECTION(<span class="string">"jdbc:mysql:loadbalance:"</span>, HostsCardinality.ONE_OR_MORE), <span class="comment">//</span></span><br><span class="line">    REPLICATION_CONNECTION(<span class="string">"jdbc:mysql:replication:"</span>, HostsCardinality.ONE_OR_MORE), <span class="comment">//</span></span><br><span class="line">    XDEVAPI_SESSION(<span class="string">"mysqlx:"</span>, HostsCardinality.ONE_OR_MORE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String scheme;</span><br><span class="line">    <span class="keyword">private</span> HostsCardinality cardinality;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果该 JDBC URL 没有对应可用的驱动程序，程序将抛出异常：<code>java.sql.SQLException: No suitable driver found for jdbc:...</code>。</p><h2 id="常用列表"><a href="#常用列表" class="headerlink" title="常用列表"></a>常用列表</h2><p>常见的 JDBC URL 前缀及对应 Driver Class 如下：</p><p><img src="/img/java/jdbc/jdbc-url.png" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://en.wikipedia.org/wiki/JDBC_driver" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/JDBC_driver</a></p><p><a href="https://www.javatpoint.com/jdbc-driver" target="_blank" rel="noopener">https://www.javatpoint.com/jdbc-driver</a></p><p><a href="https://blog.csdn.net/autfish/article/details/52170053" target="_blank" rel="noopener">https://blog.csdn.net/autfish/article/details/52170053</a></p><p><a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/connector/j/</a></p><p><a href="https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-overview.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/connector-j/8.0/en/connector-j-overview.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL SELECT 语法总结</title>
      <link href="2018/02/02/mysql-select-syntax/"/>
      <url>2018/02/02/mysql-select-syntax/</url>
      
        <content type="html"><![CDATA[<h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><p><code>SELECT</code> 基础语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    [ALL | DISTINCT]</span><br><span class="line">    select_expr [, select_expr ...]</span><br><span class="line">    [</span><br><span class="line">      FROM table_references</span><br><span class="line">      [WHERE where_condition]</span><br><span class="line">      [GROUP BY &#123;col_name | expr | position&#125;</span><br><span class="line">        [ASC | DESC], ... [WITH ROLLUP]]</span><br><span class="line">      [HAVING where_condition]</span><br><span class="line">      [ORDER BY &#123;col_name | expr | position&#125;</span><br><span class="line">        [ASC | DESC], ...]</span><br><span class="line">      [LIMIT &#123;[offset,] row_count | row_count OFFSET offset&#125;]</span><br><span class="line">      [</span><br><span class="line">        INTO OUTFILE &#39;file_name&#39;</span><br><span class="line">          [CHARACTER SET charset_name]</span><br><span class="line">          export_options</span><br><span class="line">        | INTO DUMPFILE &#39;file_name&#39;</span><br><span class="line">        | INTO var_name [, var_name]</span><br><span class="line">      ]</span><br><span class="line">      [FOR UPDATE | LOCK IN SHARE MODE]</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p><code>SELECT</code> 语句可用于检索单个、多个、所有列（星号 <code>*</code> 通配符）。每个 <em>select_expr</em> 表示您想要检索的列。必须至少有一个 <em>select_expr</em>。</p><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>修饰符 <code>ALL</code> 和 <code>DISTINCT</code> 用于指定<strong>重复行是否应该返回（是否去重）</strong>，作用于所有的列，而不仅仅是跟在其后的那一列。例如 <code>SELECT DISTINCT vend_id, prod_price</code> ，除非指定的两列完全相同，否则所有的行都会被检索出来。</p><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td><code>ALL</code></td><td>默认值，指定应返回所有匹配的行，包括重复项。</td></tr><tr><td><code>DISTINCT</code></td><td>指定从结果集中删除重复的行。</td></tr></tbody></table><h2 id="检索表"><a href="#检索表" class="headerlink" title="检索表"></a>检索表</h2><p><em>table_references</em> 指示检索表，其语法可参考 <a href="https://dev.mysql.com/doc/refman/5.7/en/join.html" target="_blank" rel="noopener">JOIN语法</a>。<code>SELECT</code> 也可以不使用 <code>FROM</code> 子句而用来检索计算出的行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1 + 1;</span><br><span class="line"> -&gt; 2</span><br></pre></td></tr></table></figure><p>也可以使用 <code>FROM DUAL</code> 指定虚拟表，MySQL 会忽略这个子句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1 + 1 FROM DUAL;</span><br><span class="line"> -&gt; 2</span><br></pre></td></tr></table></figure><h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><p><code>WHERE</code> 子句用于过滤数据，<em>where_condition</em> 可以使用以下表达式语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">expr:</span><br><span class="line">    expr OR expr</span><br><span class="line">  | expr || expr</span><br><span class="line">  | expr XOR expr</span><br><span class="line">  | expr AND expr</span><br><span class="line">  | expr &amp;&amp; expr</span><br><span class="line">  | NOT expr</span><br><span class="line">  | ! expr</span><br><span class="line">  | boolean_primary IS [NOT] &#123;TRUE | FALSE | UNKNOWN&#125;</span><br><span class="line">  | boolean_primary</span><br><span class="line"></span><br><span class="line">boolean_primary:</span><br><span class="line">    boolean_primary IS [NOT] NULL</span><br><span class="line">  | boolean_primary &lt;&#x3D;&gt; predicate</span><br><span class="line">  | boolean_primary comparison_operator predicate</span><br><span class="line">  | boolean_primary comparison_operator &#123;ALL | ANY&#125; (subquery)</span><br><span class="line">  | predicate</span><br><span class="line"></span><br><span class="line">comparison_operator: &#x3D; | &gt;&#x3D; | &gt; | &lt;&#x3D; | &lt; | &lt;&gt; | !&#x3D;</span><br><span class="line"></span><br><span class="line">predicate:</span><br><span class="line">    bit_expr [NOT] IN (subquery)</span><br><span class="line">  | bit_expr [NOT] IN (expr [, expr] ...)</span><br><span class="line">  | bit_expr [NOT] BETWEEN bit_expr AND predicate</span><br><span class="line">  | bit_expr SOUNDS LIKE bit_expr</span><br><span class="line">  | bit_expr [NOT] LIKE simple_expr [ESCAPE simple_expr]</span><br><span class="line">  | bit_expr [NOT] REGEXP bit_expr</span><br><span class="line">  | bit_expr</span><br><span class="line"></span><br><span class="line">bit_expr:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">simple_expr:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p><code>LIKE</code> 可使用以下通配符：</p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td><code>%</code></td><td>匹配多个字符</td></tr><tr><td><code>_</code></td><td>匹配单个字符</td></tr><tr><td><code>[]</code></td><td>匹配一个字符集</td></tr></tbody></table><h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h2><p><code>ORDER BY</code> 子句用于排序，使用以下关键字进行升序或降序排序，要注意关键字只应用于直接位于其前面的列名。如果想在多个列上进行降序排序，必须对每一列指定 <code>DESC</code> 关键字。</p><table><thead><tr><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td><code>ASC</code></td><td>升序排序（默认）</td></tr><tr><td><code>DESC</code></td><td>降序排序</td></tr></tbody></table><h2 id="限制结果集"><a href="#限制结果集" class="headerlink" title="限制结果集"></a>限制结果集</h2><p><code>LIMIT</code> 子句可用于限制 <code>SELECT</code> 语句返回的结果集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tbl LIMIT 5;     # Retrieve first 5 rows, equivalent to LIMIT 0, 5</span><br><span class="line">SELECT * FROM tbl LIMIT 5,10;  # Retrieve rows 6-15</span><br><span class="line">SELECT * FROM tbl LIMIT 5 OFFSET 10;  # Retrieve rows 11-15</span><br></pre></td></tr></table></figure><h2 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h2><p>我们经常需要汇总数据而不用把它们实际检索出来，为此 SQL 提供了五个聚集函数（aggregate function）。使用这些函数，SQL 查询可用于检索数据，以便分析和报表生成。这种类型的检索例子有：</p><ul><li>确定表中行数（或者满足某个条件或包含某个特定值的行数）；</li><li>获得表中某些行的和；</li><li>找出表列（或所有行或某些特定的行）的最大值、最小值、平均值。</li></ul><table><thead><tr><th>聚集函数</th><th>描述</th></tr></thead><tbody><tr><td><code>COUNT()</code></td><td>返回某列的行数，忽略 <code>NULL</code> 值。<code>COUNT(*)</code> 则包含 <code>NULL</code> 值。</td></tr><tr><td><code>AVG()</code></td><td>返回某列的平均值，忽略 <code>NULL</code> 值。</td></tr><tr><td><code>MAX()</code></td><td>返回某列的最大值，忽略 <code>NULL</code> 值。</td></tr><tr><td><code>MIN()</code></td><td>返回某列的最小值，忽略 <code>NULL</code> 值。</td></tr><tr><td><code>SUM()</code></td><td>返回某列值之和，忽略 <code>NULL</code> 值。</td></tr></tbody></table><p>修饰符 <code>ALL</code> 和 <code>DISTINCT</code> 可用于指定重复行是否应该返回。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 返回特定供应商所提供产品的平均价格</span><br><span class="line">SELECT AVG(prod_price) AS avg_price</span><br><span class="line">FROM Products</span><br><span class="line">WHERE vend_id &#x3D; &#39;DLL01&#39;;</span><br><span class="line"> -&gt; 3.8650</span><br><span class="line"></span><br><span class="line"># 同上，但平均值只考虑各个不同的价格</span><br><span class="line">SELECT AVG(DISTINCT prod_price) AS avg_price</span><br><span class="line">FROM Products</span><br><span class="line">WHERE vend_id &#x3D; &#39;DLL01&#39;;</span><br><span class="line"> -&gt; 4.2400</span><br></pre></td></tr></table></figure><p>可以看到，使用了 <code>DISTINCT</code> 后的 <em>avg_price</em> 会比较高，因为此例子中有多个物品具有相同的较低价格，排除它们提升了平均价格。</p><p><code>SELECT</code> 语句也可根据需要同时使用多个聚集函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) AS num_items,</span><br><span class="line">       MIN(prod_price) AS price_min,</span><br><span class="line">       MAX(prod_price) AS price_max,</span><br><span class="line">       AVG(prod_price) AS price_avg</span><br><span class="line">FROM Products;</span><br></pre></td></tr></table></figure><h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><p><code>GROUP BY</code> 子句用于分组数据，注意：</p><ul><li><code>GROUP BY</code> 子句可以包含任意数目的列，因而可以对分组进行嵌套，更细致地进行数据分组。</li><li>如果在 <code>GROUP BY</code> 子句中嵌套了分组，数据将在最后指定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。</li><li><code>GROUP BY</code> 子句中列出的每一列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在 <code>SELECT</code> 中使用表达式，则必须在 <code>GROUP BY</code> 子句中指定相同的表达式。不能使用别名。</li><li>除聚集计算语句外，<code>SELECT</code> 语句中的每一列都必须在 <code>GROUP BY</code> 子句中给出。否则，如果 <code>SELECT</code> 语句中出现了 <code>GROUP BY</code> 中没有的列，假如该分组内的条目数大于 1，这样的列显示的内容为第一个条目的值。</li><li>如果分组列中包含具有 <code>NULL</code> 值的行，则 <code>NULL</code> 将作为一个分组返回。如果列中有多行 <code>NULL</code> 值，它们将分为一组。</li></ul><p><code>GROUP BY</code> 可以搭配使用 <code>HAVING</code> 过滤分组。<code>HAVING</code> 和 <code>WHERE</code> 的差别在于，<code>WHERE</code> 对分组前的数据进行过滤， <code>HAVING</code> 对分组后的数据进行过滤。</p><h1 id="加锁读"><a href="#加锁读" class="headerlink" title="加锁读"></a>加锁读</h1><p><code>InnoDB</code> 支持两种类型的 <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_locking_read" target="_blank" rel="noopener">加锁读（Locking Reads）</a>，为事务操作提供额外的<strong>安全性</strong>：</p><ul><li><code>SELECT ... LOCK IN SHARE MODE</code> 设置<strong>共享（<em>S</em>）锁</strong></li><li><code>SELECT ... FOR UPDATE</code> 设置<strong>排它（<em>X</em>）锁</strong></li></ul><p>详情请参考《<a href="/2018/10/20/mysql-locking/">MySQL 锁机制总结</a>》。</p><h1 id="UNION-子句"><a href="#UNION-子句" class="headerlink" title="UNION 子句"></a>UNION 子句</h1><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ...</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span> | <span class="keyword">DISTINCT</span>] <span class="keyword">SELECT</span> ...</span><br><span class="line">[<span class="keyword">UNION</span> [<span class="keyword">ALL</span> | <span class="keyword">DISTINCT</span>] <span class="keyword">SELECT</span> ...]</span><br></pre></td></tr></table></figure><p><code>UNION</code> 将来自多个 <code>SELECT</code> 语句的结果合并为一个结果集，结果集列名取自第一条 <code>SELECT</code> 语句的列名。</p><p><code>UNION</code> 或 <code>UNION DISTINCT</code> 去重，而 <code>UNION ALL</code> 则不去重。</p><p>要为单独的一条 <code>SELECT</code> 语句应用 <code>ORDER BY</code> 或 <code>LIMIT</code> 子句，需要将子句放在包含 <code>SELECT</code> 的括号内，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> a <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> a=<span class="number">10</span> <span class="keyword">AND</span> B=<span class="number">1</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">10</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> a <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> a=<span class="number">11</span> <span class="keyword">AND</span> B=<span class="number">2</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>反之，如要应用到整个 <code>UNION</code> 结果集，则在单个 <code>SELECT</code> 语句后面加上括号，并在最后一个语句后面加上子句，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> a <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> a=<span class="number">10</span> <span class="keyword">AND</span> B=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> a <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> a=<span class="number">11</span> <span class="keyword">AND</span> B=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> a <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《MySQL 必知必会》</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/select.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/select.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 常用日期函数</title>
      <link href="2018/01/26/mysql-datetime/"/>
      <url>2018/01/26/mysql-datetime/</url>
      
        <content type="html"><![CDATA[<h1 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h1><h2 id="获得当前日期-时间"><a href="#获得当前日期-时间" class="headerlink" title="获得当前日期/时间"></a>获得当前日期/时间</h2><table><thead><tr><th>Name</th><th>Synonym</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_current-date" target="_blank" rel="noopener"><code>CURRENT_DATE</code>, <code>CURRENT_DATE()</code></a></td><td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_curdate" target="_blank" rel="noopener"><code>CURDATE()</code></a></td><td>Return the current date as <br/><em><code>&#39;YYYY-MM-DD&#39;</code></em> / <em><code>YYYYMMDD</code></em></td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_current-time" target="_blank" rel="noopener"><code>CURRENT_TIME</code>, <code>CURRENT_TIME([fsp])</code></a></td><td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_curtime" target="_blank" rel="noopener"><code>CURTIME([fsp])</code></a></td><td>Return the current time as <br/><em><code>&#39;hh:mm:ss&#39;</code></em> / <em><code>hhmmss</code></em><br/>The value is expressed in the session time zone.</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_current-timestamp" target="_blank" rel="noopener"><code>CURRENT_TIMESTAMP</code>, <code>CURRENT_TIMESTAMP([fsp])</code></a><br/><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_localtime" target="_blank" rel="noopener"><code>LOCALTIME</code>, <code>LOCALTIME([fsp])</code></a><br/><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_localtimestamp" target="_blank" rel="noopener"><code>LOCALTIMESTAMP</code>, <code>LOCALTIMESTAMP([fsp])</code></a></td><td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_now" target="_blank" rel="noopener"><code>NOW([fsp])</code></a></td><td>Return the current date and time as <br/><em><code>&#39;YYYY-MM-DD hh:mm:ss&#39;</code></em> / <em><code>YYYYMMDDhhmmss</code></em><br/>The value is expressed in the session time zone.</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_utc-date" target="_blank" rel="noopener"><code>UTC_DATE</code>, <code>UTC_DATE()</code></a></td><td></td><td>Return the current UTC date as <br/><em><code>&#39;YYYY-MM-DD&#39;</code></em> / <em><code>YYYYMMDD</code></em></td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_utc-time" target="_blank" rel="noopener"><code>UTC_TIME</code>, <code>UTC_TIME([fsp])</code></a></td><td></td><td>Return the current UTC time as <br/><em><code>&#39;hh:mm:ss&#39;</code></em> / <em><code>hhmmss</code></em></td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_utc-timestamp" target="_blank" rel="noopener"><code>UTC_TIMESTAMP</code>, <code>UTC_TIMESTAMP([fsp])</code></a></td><td></td><td>Return the current UTC date and time as <br/><em><code>&#39;YYYY-MM-DD hh:mm:ss&#39;</code></em> / <em><code>YYYYMMDDhhmmss</code></em></td></tr></tbody></table><p>注意，MySQL 时间支持的最高存储精度为微秒：</p><blockquote><p>1 秒(s) =<br>1,000 毫秒(ms) =<br>1,000,000 微秒(μs) =<br>1,000,000,000 纳秒(ns) =<br>1,000,000,000,000 皮秒(ps) =<br>1,000,000,000,000,000 飞秒(fs) =<br>1,000,000,000,000,000,000 仄秒(zs) =<br>1,000,000,000,000,000,000,000 幺秒(ys) =<br>1,000,000,000,000,000,000,000,000 渺秒(as)</p></blockquote><blockquote><p>1 微秒(μs) = 10^-6 秒（0.000,001，百万分之一秒）<br>1 毫秒(ms) = 10^-3 秒（0.001，千分之一秒）</p></blockquote><p>因此 <code>fsp</code> 参数范围只能为 0 ~ 6：</p><blockquote><p>If the <em><code>fsp</code></em> argument is given to specify a fractional seconds precision from 0 to 6, the return value includes a fractional seconds part of that many digits.</p></blockquote><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT CURDATE();                       -- 2018-08-08，获取当前年月日</span><br><span class="line">SELECT CURTIME();                       -- 22:41:30，获取当前时分秒</span><br><span class="line">SELECT NOW();                           -- 2018-08-08 22:20:46，获取当前年月日时分秒</span><br><span class="line">SELECT NOW(3);                          -- 2018-08-08 22:20:46.166，获取当前年月日时分秒毫秒</span><br><span class="line">SELECT NOW(6);                          -- 2018-08-08 22:20:46.166123，获取当前年月日时分秒毫秒微秒</span><br><span class="line">SELECT CURRENT_TIMESTAMP;               -- 2018-08-08 22:20:46，获取当前年月日时分秒</span><br></pre></td></tr></table></figure><h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><h3 id="查看当前时区"><a href="#查看当前时区" class="headerlink" title="查看当前时区"></a>查看当前时区</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 结果主要看 system_time_zone</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%time_zone%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询系统时区、会话时区、下一事务时区</span></span><br><span class="line"><span class="keyword">SELECT</span> @@GLOBAL.time_zone, </span><br><span class="line">       @@SESSION.time_zone, </span><br><span class="line">       @@<span class="keyword">time_zone</span>;;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.cnblogs.com/Uest/p/8259821.html" target="_blank" rel="noopener">MySQL 中几个关于时间/时区的变量</a></p><h3 id="修改时区"><a href="#修改时区" class="headerlink" title="修改时区"></a>修改时区</h3><p>通过 SQL <code>SET</code> 语法临时修改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置 Global 全局时区，重启后失效</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> <span class="keyword">time_zone</span> = <span class="string">'+8:00'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置 Session 会话时区，会话关闭后失效</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">time_zone</span> = <span class="string">'+8:00'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置 下一事务 时区，事务结束后失效</span></span><br><span class="line"><span class="keyword">set</span> @@<span class="keyword">time_zone</span> = <span class="string">'+8:00'</span>;</span><br></pre></td></tr></table></figure><p>通过修改配置文件，重启后永久生效：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/mysql/my.cnf</span><br><span class="line">default-time_zone = '+8:00'</span><br><span class="line"></span><br><span class="line">$ service mysql restart</span><br></pre></td></tr></table></figure><h3 id="时区转换"><a href="#时区转换" class="headerlink" title="时区转换"></a>时区转换</h3><p>参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/datetime.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/datetime.html</a></p><blockquote><p>MySQL converts <code>TIMESTAMP</code> values from the current time zone to UTC for storage, and back from UTC to the current time zone for retrieval. (This does not occur for other types such as <code>DATETIME</code>.) By default, the current time zone for each connection is the server’s time. The time zone can be set on a per-connection basis. As long as the time zone setting remains constant, you get back the same value you store. If you store a <code>TIMESTAMP</code> value, and then change the time zone and retrieve the value, the retrieved value is different from the value you stored. This occurs because the same time zone was not used for conversion in both directions. The current time zone is available as the value of the <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_time_zone" target="_blank" rel="noopener"><code>time_zone</code></a> system variable. For more information, see <a href="https://dev.mysql.com/doc/refman/5.7/en/time-zone-support.html" target="_blank" rel="noopener">Section 5.1.13, “MySQL Server Time Zone Support”</a>.</p></blockquote><p><code>CONVERT_TZ(dt, from_tz, to_tz)</code> 函数用于将 <code>DATETIME</code> 类型转为指定时区，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TIMESTAMP 类型（UTC±00:00） &gt; DATETIME 类型（UTC±00:00） &gt; DATETIME 类型（UTC+08:00）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONVERT_TZ</span>( FROM_UNIXTIME( <span class="keyword">UNIX_TIMESTAMP</span>() ), <span class="string">'+00:00'</span>, <span class="string">'+08:00'</span> ) <span class="keyword">AS</span> <span class="keyword">NOW</span>;</span><br></pre></td></tr></table></figure><h2 id="日期-时间转换"><a href="#日期-时间转换" class="headerlink" title="日期/时间转换"></a>日期/时间转换</h2><h3 id="日期-时间-gt-时间戳"><a href="#日期-时间-gt-时间戳" class="headerlink" title="日期/时间 &gt; 时间戳"></a>日期/时间 &gt; 时间戳</h3><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_unix-timestamp" target="_blank" rel="noopener"><code>UNIX_TIMESTAMP([date])</code></a></td><td>Return a Unix timestamp.<br/>If no <em><code>date</code></em> argument, it returns a Unix timestamp representing seconds since <code>&#39;1970-01-01 00:00:00&#39;</code> UTC.<br/>If with a <em><code>date</code></em> argument, it returns the value of the argument as seconds since <code>&#39;1970-01-01 00:00:00&#39;</code> UTC.</td></tr></tbody></table><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UNIX_TIMESTAMP</span>();                <span class="comment">-- 1218124800，获取当前时间戳</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UNIX_TIMESTAMP</span>(<span class="keyword">now</span>());           <span class="comment">-- 1218124800，将当前时间转换为时间戳，等价于上例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">UNIX_TIMESTAMP</span>(<span class="string">'2008-08-08'</span>);    <span class="comment">-- 1219125100，将指定参数转换为时间戳</span></span><br></pre></td></tr></table></figure><h3 id="时间戳-gt-日期-时间"><a href="#时间戳-gt-日期-时间" class="headerlink" title="时间戳 &gt; 日期/时间"></a>时间戳 &gt; 日期/时间</h3><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html#function_from-unixtime" target="_blank" rel="noopener"><code>FROM_UNIXTIME(unix_timestamp[,format])</code></a></td><td>Format Unix timestamp as a date</td></tr></tbody></table><p>注意，该函数只支持单位为秒的时间戳，不支持毫秒、微秒，需要先换算：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1447430881</span>);                                    <span class="comment">-- 2015-11-13 10:08:01</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1447430881123</span> / <span class="number">1000</span>);                          <span class="comment">-- 2015-11-13 16:08:01.1230</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1447430881123456</span> / <span class="number">1000000</span>, <span class="string">'%Y %D %M %r %f'</span>);  <span class="comment">-- 2015 13th November 04:08:01 PM 123456</span></span><br></pre></td></tr></table></figure><p>支持指定 <code>fomart</code> 格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">0</span>);                       <span class="comment">-- 1970-01-01 00:00:00</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">0</span>, <span class="string">'%Y %D %M %h:%i:%s'</span>);  <span class="comment">-- 1970 1st January 12:00:00</span></span><br></pre></td></tr></table></figure><h3 id="日期-时间-gt-字符串"><a href="#日期-时间-gt-字符串" class="headerlink" title="日期/时间 &gt; 字符串"></a>日期/时间 &gt; 字符串</h3><p>Date/Time to Str（日期/时间转换为字符串）函数：</p><ul><li><code>date_format(date, format)</code></li><li><code>time_format(time, format)</code></li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select date_format(now(), &#39;%Y-%m-%d&#39;);                          -- 2018-08-08</span><br><span class="line">select date_format(&#39;2018-08-08 22:23:00&#39;, &#39;%W %M %Y&#39;);          -- Friday August 2018</span><br><span class="line">select date_format(&#39;2018-08-08 22:23:01&#39;, &#39;%Y%m%d%H%i%s&#39;);      -- 20180808222301</span><br><span class="line">select time_format(&#39;22:23:01&#39;, &#39;%H.%i.%s&#39;);                     -- 22.23.01</span><br></pre></td></tr></table></figure><h3 id="字符串-gt-日期-时间"><a href="#字符串-gt-日期-时间" class="headerlink" title="字符串 &gt; 日期/时间"></a>字符串 &gt; 日期/时间</h3><p>Str to Date （字符串转换为日期）函数：</p><ul><li><code>str_to_date(str, format)</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select str_to_date(&#39;08&#x2F;09&#x2F;2008&#39;, &#39;%m&#x2F;%d&#x2F;%Y&#39;);                   -- 2008-08-09</span><br><span class="line">select str_to_date(&#39;08&#x2F;09&#x2F;08&#39;  , &#39;%m&#x2F;%d&#x2F;%y&#39;);                   -- 2008-08-09</span><br><span class="line">select str_to_date(&#39;08.09.2008&#39;, &#39;%m.%d.%Y&#39;);                   -- 2008-08-09</span><br><span class="line">select str_to_date(&#39;08:09:30&#39;, &#39;%h:%i:%s&#39;);                     -- 08:09:30</span><br><span class="line">select str_to_date(&#39;08.09.2008 08:09:30&#39;, &#39;%m.%d.%Y %h:%i:%s&#39;); -- 2008-08-09 08:09:30</span><br></pre></td></tr></table></figure><h3 id="format-参数"><a href="#format-参数" class="headerlink" title="format 参数"></a>format 参数</h3><p><code>format</code> 如下，这里只列出常用的：</p><table><thead><tr><th><code>format</code></th><th>描述</th></tr></thead><tbody><tr><td><code>%Y</code></td><td>Year, numeric, four digits</td></tr><tr><td><code>%y</code></td><td>Year, numeric (two digits)</td></tr><tr><td><code>%M</code></td><td>Month name (<code>January</code>..<code>December</code>)</td></tr><tr><td><code>%m</code></td><td>Month, numeric (<code>00</code>..<code>12</code>)</td></tr><tr><td><code>%D</code></td><td>Day of the month with English suffix (<code>0th</code>, <code>1st</code>, <code>2nd</code>, <code>3rd</code>, …)</td></tr><tr><td><code>%d</code></td><td>Day of the month, numeric (<code>00</code>..<code>31</code>)</td></tr><tr><td><code>%H</code></td><td>Hour (<code>00</code>..<code>23</code>)</td></tr><tr><td><code>%h</code></td><td>Hour (<code>01</code>..<code>12</code>)</td></tr><tr><td><code>%i</code></td><td>Minutes, numeric (<code>00</code>..<code>59</code>)</td></tr><tr><td><code>%s</code></td><td>Seconds (<code>00</code>..<code>59</code>)</td></tr><tr><td><code>%f</code></td><td>Microseconds (<code>000000</code>..<code>999999</code>)</td></tr><tr><td><code>%T</code></td><td>Time, 24-hour (<em><code>hh:mm:ss</code></em>)</td></tr><tr><td><code>%r</code></td><td>Time, 12-hour (<em><code>hh:mm:ss</code></em> followed by <code>AM</code> or <code>PM</code>)</td></tr></tbody></table><h2 id="日期-时间计算"><a href="#日期-时间计算" class="headerlink" title="日期/时间计算"></a>日期/时间计算</h2><p>为日期增加一个时间间隔：</p><ul><li><code>date_add()</code></li></ul><p>为日期减去一个时间间隔：</p><ul><li><code>date_sub()</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set @dt &#x3D; now();</span><br><span class="line"></span><br><span class="line">select date_add(@dt, interval 1 day);        -- add 1 day</span><br><span class="line">select date_add(@dt, interval 1 hour);       -- add 1 hour</span><br><span class="line">select date_add(@dt, interval 1 minute);     -- ...</span><br><span class="line">select date_add(@dt, interval 1 second);</span><br><span class="line">select date_add(@dt, interval 1 microsecond);</span><br><span class="line">select date_add(@dt, interval 1 week);</span><br><span class="line">select date_add(@dt, interval 1 month);</span><br><span class="line">select date_add(@dt, interval 1 quarter);</span><br><span class="line">select date_add(@dt, interval 1 year);</span><br><span class="line"></span><br><span class="line">select date_add(@dt, interval -1 day);       -- sub 1 day</span><br><span class="line"></span><br><span class="line">SELECT DATE_SUB(@dt, INTERVAL 7 DAY);        -- 七天前</span><br></pre></td></tr></table></figure><h2 id="日期-时间截取"><a href="#日期-时间截取" class="headerlink" title="日期/时间截取"></a>日期/时间截取</h2><p>选取日期时间的各个部分：日期、时间、年、季度、月、日、小时、分钟、秒、微秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set @dt &#x3D; now();</span><br><span class="line"></span><br><span class="line">select date(@dt);        -- 2008-09-10</span><br><span class="line">select time(@dt);        -- 07:15:30.123456</span><br><span class="line">select year(@dt);        -- 2008</span><br><span class="line">select quarter(@dt);     -- 3</span><br><span class="line">select month(@dt);       -- 9</span><br><span class="line">select week(@dt);        -- 36</span><br><span class="line">select day(@dt);         -- 10</span><br><span class="line">select hour(@dt);        -- 7</span><br><span class="line">select minute(@dt);      -- 15</span><br><span class="line">select second(@dt);      -- 30</span><br><span class="line">select microsecond(@dt); -- 123456</span><br></pre></td></tr></table></figure><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="按天统计订单量"><a href="#按天统计订单量" class="headerlink" title="按天统计订单量"></a>按天统计订单量</h2><p>按天统计订单量（同理，按小时统计：<code>DATE_FORMAT(create_time,&#39;%Y-%m-%d %H:00:00&#39;)</code>）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*), <span class="keyword">DATE_FORMAT</span>(create_time,<span class="string">'%Y-%m-%d'</span>) <span class="keyword">days</span> </span><br><span class="line"><span class="keyword">from</span> t_order </span><br><span class="line"><span class="keyword">where</span> create_time <span class="keyword">BETWEEN</span> <span class="string">'2008-9-29'</span> <span class="keyword">AND</span> <span class="string">'2008-9-30'</span> </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">days</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----------+------------+</span></span><br><span class="line">| count(*) | hours      |</span><br><span class="line">+<span class="comment">----------+------------+</span></span><br><span class="line">|   150628 | 2008-09-01 |</span><br><span class="line">|   172419 | 2008-09-02 |</span><br><span class="line">|   177021 | 2008-09-03 |</span><br><span class="line">|   178917 | 2008-09-04 |</span><br><span class="line">|   180960 | 2008-09-05 |</span><br><span class="line">|   177626 | 2008-09-06 |</span><br><span class="line">|   177504 | 2008-09-07 |</span><br><span class="line">|   166118 | 2008-09-08 |</span><br><span class="line">|   193006 | 2008-09-09 |</span><br><span class="line">|   204156 | 2008-09-10 |</span><br><span class="line">|   196598 | 2008-09-11 |</span><br><span class="line">|   200184 | 2008-09-12 |</span><br><span class="line">|   159169 | 2008-09-13 |</span><br><span class="line">|   179798 | 2008-09-14 |</span><br><span class="line">|   203586 | 2008-09-15 |</span><br><span class="line">|   217863 | 2008-09-16 |</span><br><span class="line">|   231207 | 2008-09-17 |</span><br><span class="line">|   245960 | 2008-09-18 |</span><br><span class="line">|   226578 | 2008-09-19 |</span><br><span class="line">|   211986 | 2008-09-20 |</span><br><span class="line">|   201396 | 2008-09-21 |</span><br><span class="line">|   183012 | 2008-09-22 |</span><br><span class="line">|   221780 | 2008-09-23 |</span><br><span class="line">|   228094 | 2008-09-24 |</span><br><span class="line">|   220251 | 2008-09-25 |</span><br><span class="line">|   240866 | 2008-09-26 |</span><br><span class="line">|   235670 | 2008-09-27 |</span><br><span class="line">|   244964 | 2008-09-28 |</span><br><span class="line">|    98805 | 2008-09-29 |</span><br><span class="line">+<span class="comment">----------+------------+</span></span><br><span class="line">29 rows in <span class="keyword">set</span> (<span class="number">5.83</span> sec)</span><br></pre></td></tr></table></figure><h2 id="按-N-分钟统计订单量"><a href="#按-N-分钟统计订单量" class="headerlink" title="按 N 分钟统计订单量"></a>按 N 分钟统计订单量</h2><p>做法在于将每行的分钟数 <code>(MINUTE(create_time)</code> 除以 10 得到的小数向下取整，再乘以 10 就是所属的区间。例如：</p><ul><li>1 分钟 &gt; 0</li><li>25 分钟 &gt; 20</li><li>59 分钟 &gt; 50</li></ul><p>下例按 10 分钟统计订单量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*), <span class="keyword">DATE_FORMAT</span>(</span><br><span class="line">  <span class="keyword">CONCAT</span>(</span><br><span class="line">    <span class="built_in">DATE</span>(create_time), </span><br><span class="line">    <span class="string">' '</span>, </span><br><span class="line">    <span class="keyword">HOUR</span>(create_time), </span><br><span class="line">    <span class="string">':'</span>, </span><br><span class="line">    <span class="keyword">FLOOR</span>(<span class="keyword">MINUTE</span>(create_time) / <span class="number">10</span>) * <span class="number">10</span></span><br><span class="line">  ), <span class="string">'%Y-%m-%d %H:%i'</span></span><br><span class="line">) <span class="keyword">AS</span> <span class="keyword">hours</span></span><br><span class="line"><span class="keyword">FROM</span> t_order</span><br><span class="line"><span class="keyword">WHERE</span> create_time <span class="keyword">BETWEEN</span> <span class="string">'2008-9-29'</span> <span class="keyword">AND</span> <span class="string">'2008-9-30'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">hours</span>;</span><br><span class="line"></span><br><span class="line">+<span class="comment">----------+------------------+</span></span><br><span class="line">| COUNT(*) | hours            |</span><br><span class="line">+<span class="comment">----------+------------------+</span></span><br><span class="line">|       51 | 2008-09-29 00:00 |</span><br><span class="line">|       53 | 2008-09-29 00:10 |</span><br><span class="line">|       43 | 2008-09-29 00:20 |</span><br><span class="line">|       59 | 2008-09-29 00:30 |</span><br><span class="line">|       40 | 2008-09-29 00:40 |</span><br><span class="line">|       27 | 2008-09-29 00:50 |</span><br><span class="line">|       22 | 2008-09-29 01:00 |</span><br><span class="line">|       24 | 2008-09-29 01:10 |</span><br><span class="line">|       15 | 2008-09-29 01:20 |</span><br><span class="line">|       15 | 2008-09-29 01:30 |</span><br><span class="line">|       26 | 2008-09-29 01:40 |</span><br><span class="line">|       18 | 2008-09-29 01:50 |</span><br><span class="line">|     1949 | 2008-09-29 02:00 |</span><br></pre></td></tr></table></figure><h1 id="建表自动初始化与更新时间"><a href="#建表自动初始化与更新时间" class="headerlink" title="建表自动初始化与更新时间"></a>建表自动初始化与更新时间</h1><p>假设表有 3 个字段：id、name、update_time，希望在新增记录时能自动设置 update_time 字段为当前时间，设置 <code>DEFAULT CURRENT_TIMESTAMP</code> 子句即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;test&#96; (</span><br><span class="line">&#96;id&#96; int NOT NULL,</span><br><span class="line">&#96;name&#96; varchar(255),</span><br><span class="line">&#96;update_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果希望在更新记录时还能自动更新 update_time 字段为当前时间，设置 <code>ON UPDATE CURRENT_TIMESTAMP</code> 子句即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">&#96;update_time&#96; timestamp NOT NULL ON UPDATE CURRENT_TIMESTAMP DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>设置之后，即使直接通过 Navicat 工具修改了 name 字段，那么 update_time 也会自动更新，除非手动设置了 update_time 字段。</p><p>参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/timestamp-initialization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/timestamp-initialization.html</a></p><h1 id="DATETIME-类型快速对比"><a href="#DATETIME-类型快速对比" class="headerlink" title="DATETIME 类型快速对比"></a>DATETIME 类型快速对比</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(1) </span><br><span class="line">from t_table </span><br><span class="line">where createTime between 20180215 and 20180216;</span><br></pre></td></tr></table></figure><p>datetime 会自动转为整数，查询范围从 2018-02-15 00:00:00 到 2018-02-16 00:00:00。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/functions.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/timestamp-initialization.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/timestamp-initialization.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/time-zone-support.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/time-zone-support.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 常用数据类型</title>
      <link href="2018/01/05/mysql-data-types/"/>
      <url>2018/01/05/mysql-data-types/</url>
      
        <content type="html"><![CDATA[<h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><p>MySQL 支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于作出更好的选择。</p><h2 id="更小的通常更好"><a href="#更小的通常更好" class="headerlink" title="更小的通常更好"></a>更小的通常更好</h2><p>更小的数据类型通常更快，因为占用更少的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期也更少。</p><h2 id="简单就好"><a href="#简单就好" class="headerlink" title="简单就好"></a>简单就好</h2><p>简单数据类型的操作通常需要更少的 CPU 周期、索引性能更好。例如，整型比字符操作代价更低，因为字符集和校对规则（排序规则）使得字符比整型更复杂。</p><p>有几个例子：</p><ul><li><p>使用日期与时间类型，而不是字符串来存储日期和时间，以便排序和格式转换。</p></li><li><p>使用整型，而不是字符串来存储 IP 地址。MySQL 提供了两个函数来处理 IP 地址：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 INT unsigned 类型存储（存储范围：0 ~ 2^32-1）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">inet_aton</span>(<span class="string">'0.0.0.0'</span>);  <span class="comment">--结果：0</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">inet_aton</span>(<span class="string">'192.168.1.1'</span>);  <span class="comment">--结果：3232235777</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">inet_aton</span>(<span class="string">'255.255.255.255'</span>);  <span class="comment">--结果：4294967295</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">inet_ntoa</span>(<span class="string">'3232235777'</span>);  <span class="comment">--结果：192.168.1.1</span></span><br></pre></td></tr></table></figure></li><li><p>使用定长二进制类型（如 <code>binary</code>），而不是字符串来存储散列值：</p><ul><li><code>MD5</code> 128 bit / 4 = 32 length</li><li><code>SHA-1</code> 160 bit / 4 = 40 length</li><li><code>SHA-224</code> 224 bit / 4 = 56 length</li><li><code>SHA-256</code> 256 bit / 4 = 64 length</li><li><code>SHA-384</code> 384 bit / 4 = 96 length</li><li><code>SHA-512</code> 512 bit / 4 = 128 length</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 示例表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_hash`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键 ID'</span>,</span><br><span class="line">  <span class="string">`hash`</span> varbinary(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'散列值'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_hash`</span> (<span class="string">`hash`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_hash(<span class="keyword">hash</span>) <span class="keyword">values</span>(<span class="keyword">md5</span>(<span class="string">'0.0.0.0'</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_hash(<span class="keyword">hash</span>) <span class="keyword">values</span>(<span class="keyword">sha1</span>(<span class="string">'0.0.0.0'</span>));</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_hash(<span class="keyword">hash</span>) <span class="keyword">values</span>(<span class="string">'你好吗'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 测试结果</span></span><br><span class="line"><span class="comment">-- length() 函数返回值的单位为字节。</span></span><br><span class="line"><span class="comment">-- 由于二进制类型无字符集，因此中文乱码</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">hash</span>, <span class="keyword">length</span>(<span class="keyword">hash</span>), <span class="keyword">char_length</span>(<span class="keyword">hash</span>) <span class="keyword">from</span> t_hash <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span>;</span><br><span class="line">+<span class="comment">------------------------------------------+--------------+-------------------+</span></span><br><span class="line">| hash                                     | length(hash) | char_length(hash) |</span><br><span class="line">+<span class="comment">------------------------------------------+--------------+-------------------+</span></span><br><span class="line">| f1f17934834ae2613699701054ef9684         |           32 |                32 |</span><br><span class="line">| e562f69ec36e625116376f376d991e41613e9bf3 |           40 |                40 |</span><br><span class="line">| 浣犲ソ鍚?                                 |            9 |                 9 |</span><br><span class="line">+<span class="comment">------------------------------------------+--------------+-------------------+</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="避免使用-NULL"><a href="#避免使用-NULL" class="headerlink" title="避免使用 NULL"></a>避免使用 NULL</h2><p><code>NULL</code> 列使得 MySQL 索引、索引统计和值比较都更复杂。可为 <code>NULL</code> 的列会使用更多的存储空间（例如当可为 <code>NULL</code> 的列被索引时，每个索引记录需要一个额外的字节），在 MySQL 里也需要特殊处理。如果计划在列上建索引，应该尽量避免。</p><h1 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h1><h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><h3 id="比特类型"><a href="#比特类型" class="headerlink" title="比特类型"></a>比特类型</h3><p><code>BIT[(M)]</code> 比特类型，<em>M</em> 为 1~64 位比特。</p><p><code>b&#39;value&#39;</code> 符号可用于指定比特值。<code>value</code> 是一组使用 0 和 1 编写的二进制值。例如 <code>b&#39;111&#39;</code> 和 <code>b&#39;10000000&#39;</code> 分别代表 <code>7</code> 和 <code>128</code> 。详见《<a href="https://dev.mysql.com/doc/refman/5.7/en/bit-value-literals.html" target="_blank" rel="noopener">Bit-Value Literals</a>》。</p><p>如果赋值给小于 <em>M</em> 位长的 <code>BIT(M)</code> 类型列，则该值左侧用零填充。例如，为 <code>BIT(6)</code> 列赋值 <code>b&#39;101&#39;</code> 实际上等于赋值 <code>b&#39;000101&#39;</code>。</p><p><code>BIT(1)</code> 常用来表示布尔类型，<code>b&#39;0&#39;</code> 表示 <code>false</code>，<code>b&#39;1&#39;</code> 表示 <code>true</code>。</p><p>1 byte = 8 bit。</p><h3 id="整数类型（精确值）"><a href="#整数类型（精确值）" class="headerlink" title="整数类型（精确值）"></a>整数类型（精确值）</h3><p>MySQL 可以使用以下几种整数类型，存储的值的范围从“-2^(N-1)”到“2^(N-1)-1”，其中 N 是存储空间的位数（1 byte = 8 bit）：</p><table><thead><tr><th>类型</th><th>字节长度</th><th>取值范围（有符号）</th><th>取值范围（无符号）</th><th>备注</th></tr></thead><tbody><tr><td><code>TINYINT</code></td><td>1 byte</td><td>-2^7 ~2^7-1</td><td>0~2^8-1</td><td>同义词 <code>BOOL</code>、<code>BOOLEAN</code> ，0 为 false，!0 为 true</td></tr><tr><td><code>SMALLINT</code></td><td>2 bytes</td><td>-2^15 ~2^15-1</td><td>0~2^16-1</td><td></td></tr><tr><td><code>MEDIUMINT</code></td><td>3 bytes</td><td>-2^23 ~2^23-1</td><td>0~2^24-1</td><td></td></tr><tr><td><code>INT</code></td><td>4 bytes</td><td>-2^31 ~2^31-1</td><td>0~2^32-1</td><td>同义词 <code>INTEGER</code></td></tr><tr><td><code>BIGINT</code></td><td>8 bytes</td><td>-2^63 ~2^63-1</td><td>0~2^64-1</td><td><code>SERIAL</code> 等于 <code>BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE</code> 的别名 ，适用于创建主键</td></tr></tbody></table><p><code>INT[(M)] [UNSIGNED] [ZEROFILL] [AUTO_INCREMENT]</code> 整数类型</p><ul><li><p><em><code>M</code></em> 最大显示宽度，例如 <code>INT(11)</code> ：</p><p>这个属性对于大多数应用都是没有意义的：它不会限制值的合法范围，只是规定了 MySQL 的一些交互工具用来<strong>显示字符</strong>的个数，最大值为 255，一般配合 <code>ZEROFILL</code> 使用。对于存储和计算来说，<code>INT(1)</code> 和 <code>INT(20)</code> 是相同的，并不会影响该类型的占用字节数。</p></li><li><p><code>ZEROFILL</code> 填充零：</p><p>顾名思义就是用 “0” 填充的意思，也就是在数字位数不够（&lt; <em><code>M</code></em>）的空间用字符 “0” 填满。只在一些交互工具中有效，例如 MyCli。</p></li></ul><ul><li><p><code>UNSIGNED</code> 无符号：</p><p>整数类型有可选的 <code>UNSIGNED</code> 属性，表示不允许负值，这大致可以使正数的上限提高一倍。例如 <code>tinyint UNSIGNED</code> 可以存储的范围是 0<del>255，而 <code>tinyint</code> 的存储范围是 -128</del>127。</p></li></ul><ul><li><p><code>AUTO_INCREMENT</code> 自动递增：</p><p>在需要产生唯一标识符或顺序值时，可利用此属性，这个属性只用于整数类型。<code>AUTO_INCREMENT</code> 值一般从 1 开始，每行增加 1。 一个表中最多只能有一个 <code>AUTO_INCREMENT</code> 列 。对于任何想要使用 <code>AUTO_INCREMENT</code> 的列，应该定义为 <code>NOT NULL</code>，并定义为 <code>PRIMARY KEY</code> 或定义为 <code>UNIQUE</code> 键。</p></li></ul><h3 id="定点类型（精确值）"><a href="#定点类型（精确值）" class="headerlink" title="定点类型（精确值）"></a>定点类型（精确值）</h3><p><code>DECIMAL[(M[,D])] [UNSIGNED] [ZEROFILL]</code> 定点类型（fixed-point number），用于存储高精度数值，如货币数据。</p><p><em>M</em> 是总位数（精度，precision），<em>D</em> 是小数点后的位数（标度，scale）。小数点和（对于负数） <code>-</code> 符号不计入 <em>M</em>。如果 <em>D</em> 为 0，则值不包含小数点或小数部分。如果指定 <code>UNSIGNED</code>，则不允许负值。<code>DECIMAL</code> 的所有基本运算 (+, -, *, /) 都以 65 位数的最大精度完成。</p><table><thead><tr><th>类型</th><th><em>M</em> 精度范围（总位数）</th><th><em>D</em> 标度范围（小数位数）</th><th>备注</th></tr></thead><tbody><tr><td><code>DECIMAL</code></td><td>0~65，默认 10</td><td>0~30，默认 0</td><td>同义词 <code>DEC</code>、<code>NUMERIC</code>、<code>FIXED</code></td></tr></tbody></table><p>例如 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salary DECIMAL(5,2)</span><br></pre></td></tr></table></figure><p>可以存储在 <em>salary</em> 列中的值范围从 -999.99 ~ 999.99。</p><p><code>DECIMAL</code> 以二进制格式存储值，每 4 个字节存 9 个数字。例如，<code>DECIMAL(18,9)</code> 小数点两边各存储 9 个数字，一共使用 9 个字节：小数点前的数字使用 4 个字节，小数点后的数字使用 4 个字节，小数点本身占 1 个字节。详见《<a href="https://dev.mysql.com/doc/refman/5.7/en/precision-math.html" target="_blank" rel="noopener">Precision Math</a>》。</p><p>因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用 <code>DECIMAL</code> —— 例如存储财务数据。但在数据量比较大的时候，可以考虑使用 <code>BIGINT</code> 代替 <code>DECIMAL</code> ，将需要存储的货币单位根据小数的位数乘以相应的倍数即可。假设要存储的财务数据精确到万分之一分，则可以把所有金额乘以一百万，然后将结果存储在 <code>BIGINT</code> 里，这样可以同时避免浮点存储计算不精确和 <code>DECIMAL</code> 精确计算代价高的问题。</p><h3 id="浮点类型（近似值）"><a href="#浮点类型（近似值）" class="headerlink" title="浮点类型（近似值）"></a>浮点类型（近似值）</h3><p><code>FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]</code> 单精度浮点类型（floating-point number），<em>M</em> 是总位数，<em>D</em> 是小数点后面的位数。如果 <em>M</em> 和 <em>D</em> 省略，值将存储到硬件允许的限制。单精度浮点数精确到约 7 位小数。</p><p><code>DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]</code> 双精度浮点类型（floating-point number），<em>M</em> 是总位数，<em>D</em> 是小数点后面的位数。如果 <em>M</em> 和 <em>D</em> 省略，值将存储到硬件允许的限制。双精度浮点数精确到小数点后 15 位。</p><table><thead><tr><th>类型</th><th>字节长度</th><th>取值范围</th></tr></thead><tbody><tr><td><code>FLOAT</code></td><td>4 bytes</td><td><code>-3.402823466E+38</code> to <code>-1.175494351E-38</code>, <code>0</code>, and <code>1.175494351E-38</code> to <code>3.402823466E+38</code></td></tr><tr><td><code>DOUBLE</code></td><td>8 bytes</td><td><code>-1.7976931348623157E+308</code> to <code>-2.2250738585072014E-308</code>, <code>0</code>, and<code>2.2250738585072014E-308</code> to <code>1.7976931348623157E+308</code></td></tr></tbody></table><p>因为浮点值是近似值而不是作为精确值存储的，比值时可能会导致问题。详见《<a href="https://dev.mysql.com/doc/refman/5.7/en/problems-with-float.html" target="_blank" rel="noopener">Problems with Floating-Point Values</a>》。</p><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><h3 id="CHAR-和-VARCHAR-类型"><a href="#CHAR-和-VARCHAR-类型" class="headerlink" title="CHAR 和 VARCHAR 类型"></a>CHAR 和 VARCHAR 类型</h3><p>下列表格中，<em>M</em> 表示字符长度，<em>L</em> 表示实际字节存储长度。这两种类型很相似，但它们被存储和检索的方式不同。它们的最大字节长度 <em>L</em> 和尾部空格是否保留也不同。</p><table><thead><tr><th>类型</th><th>最大字节长度</th><th>尾部空格是否保留</th><th>描述</th><th>适用情况</th></tr></thead><tbody><tr><td><code>VARCHAR(M)</code></td><td>65,535 bytes (2^16-1)</td><td>否</td><td>用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，因为它仅使用必要的空间。其有效最大长度取决于<strong>行大小限制</strong>（默认 65,535 字节，在所有列中共享） 和使用的字符集（例如， UTF-8 字符集每个字符最多可能需要三个字节，因此最多可以声明为 21,844 个字符）。参加《<a href="https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html" target="_blank" rel="noopener">表列数量和行数限制</a>》。</td><td>字符的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像 UTF-8 这样复杂的字符集，每个字符都使用不同的字节数进行存储。</td></tr><tr><td><code>CHAR(M)</code></td><td>255 bytes (2^8-1)</td><td>是</td><td>用于存储定长字符串。长度不足时会填充尾部空格到指定的长度。</td><td>存储很短的字符串，或者所有值都接近同一个长度。例如，存储密码的 MD5 值；经常变更的数据，定长的 <code>CHAR</code> 类型不容易产生碎片。</td></tr></tbody></table><p>不同于 <code>CHAR</code> 类型，<code>VARCHAR</code> 类型需要使用 1 或 2 个额外字节记录字符串的长度：如果列的最大长度小于或等于 255 字节，则只使用 1 个字节表示，否则使用 2 个字节：</p><blockquote><p><em>L</em> + 1 bytes if column values require 0 − 255 bytes, <em>L</em> + 2 bytes if values may require more than 255 bytes</p></blockquote><p>下表通过存储各种字符串值到 <code>CHAR(4)</code> 和 <code>VARCHAR(4)</code> 列说明了 <code>CHAR</code> 和 <code>VARCHAR</code> 之间的差别（假设该列使用单字节字符集，例如 latin1）：</p><table><thead><tr><th>值</th><th><code>CHAR(4)</code></th><th>需要存储</th><th><code>VARCHAR(4)</code></th><th>需要存储</th></tr></thead><tbody><tr><td><code>&#39;&#39;</code></td><td><code>&#39;    &#39;</code></td><td>4 bytes</td><td><code>&#39;&#39;</code></td><td>1 byte</td></tr><tr><td><code>&#39;ab&#39;</code></td><td><code>&#39;ab  &#39;</code></td><td>4 bytes</td><td><code>&#39;ab&#39;</code></td><td>3 bytes</td></tr><tr><td><code>&#39;abcd&#39;</code></td><td><code>&#39;abcd&#39;</code></td><td>4 bytes</td><td><code>&#39;abcd&#39;</code></td><td>5 bytes</td></tr><tr><td><code>&#39;abcdefgh&#39;</code></td><td><code>&#39;abcd&#39;</code></td><td>4 bytes</td><td><code>&#39;abcd&#39;</code></td><td>5 bytes</td></tr></tbody></table><h3 id="BLOB-和-TEXT-类型"><a href="#BLOB-和-TEXT-类型" class="headerlink" title="BLOB 和 TEXT 类型"></a>BLOB 和 TEXT 类型</h3><p><code>TEXT</code> 表示二进制字符串（字节字符串），没有排序规则或字符集。<code>BLOB</code> 表示非二进制字符串（字符串），有排序规则、字符集。与其它类型不同，MySQL 把每个 <code>BLOB</code> 和 <code>TEXT</code> 值当做一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当 <code>BLOB</code> 和 <code>TEXT</code> 值太大时，InnoDB 会使用专门的“外部”存储区域来进行存储，<strong>此时每个值在行内需要 1~4 个字节存储一个指针，然后在外部存储区域存储实际的值</strong>。它们的最大字节长度如下：</p><table><thead><tr><th>类型</th><th>指针长度</th><th>实际值的最大字节长度</th></tr></thead><tbody><tr><td><code>TINYTEXT</code>、<code>TINYBLOB</code></td><td>1 byte</td><td>256 bytes (2^8)</td></tr><tr><td><code>TEXT</code>、<code>BLOB</code></td><td>2 bytes</td><td>65,536 bytes (2^16)，64 KB</td></tr><tr><td><code>MEDIUMTEXT</code>、<code>MEDIUMBLOB</code></td><td>3 bytes</td><td>16,777,216 bytes (2^24)，16 MB</td></tr><tr><td><code>LONGTEXT</code>、<code>LONGBLOB</code></td><td>4 bytes</td><td>4,294,967,296 bytes  (2^32)，4 GB</td></tr></tbody></table><p>MySQL 不能将 <code>BLOB</code> 和 <code>TEXT</code> 列全部长度的字符串进行索引，也不能使用这些索引消除排序，因此可以使用“前缀索引”解决这个问题。</p><h2 id="日期与时间类型"><a href="#日期与时间类型" class="headerlink" title="日期与时间类型"></a>日期与时间类型</h2><ul><li>MySQL 有多种表示日期的数据类型，比如，当只记录年信息的时候，可以使用 <code>YEAR</code> 类型，而没有必要使用 <code>DATE</code> 类型。</li><li>每一个类型都有合法的取值范围，当指定确实不合法的值时系统将 “零” 值插入到数据库中。</li></ul><table><thead><tr><th>类型</th><th>字节长度</th><th>默认值（0 值）</th><th>取值范围</th><th>备注</th></tr></thead><tbody><tr><td><code>YEAR</code></td><td>1 byte</td><td>0000</td><td>1901 ~ 2155</td><td></td></tr><tr><td><code>DATE</code></td><td>3 bytes</td><td>0000-00-00</td><td>1000-01-01 ~ 9999-12-31</td><td></td></tr><tr><td><code>TIME</code></td><td>3 bytes</td><td>00:00:00</td><td>-838:59:59 ~ 838:59:59</td><td></td></tr><tr><td><code>DATETIME</code></td><td>5 bytes</td><td>0000-00-00 00:00:00</td><td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td><code>DATETIME</code> 把日期和时间封装到格式为 <code>YYYYMMDDHHMMSS</code> 的整数中，与时区无关。默认情况下，MySQL 以一种可排序的、无歧义的格式显示 <code>DATETIME</code> 值，例如“2018-01-16 22:37:08”。这是 ANSI 标准定义的日期和时间显示方法。</td></tr><tr><td><code>TIMESTAMP</code></td><td>4 bytes</td><td>1970-01-01 00:00:00 UTC</td><td>1970-01-01 00:00:00 UTC ~ 2038-01-19 03:14:07 UTC</td><td><code>TIMESTAMP</code> 显示的值依赖于时区。</td></tr></tbody></table><h3 id="存储精度"><a href="#存储精度" class="headerlink" title="存储精度"></a>存储精度</h3><p>需要注意的是，MySQL 升级到 5.6 之后对日期与时间类型做过调整，可以精确到微秒并指定其精度（最多 6 位），参考 <a href="https://dev.mysql.com/doc/refman/5.6/en/upgrading-from-previous-series.html" target="_blank" rel="noopener">Changes in MySQL 5.6</a>：</p><p><img src="/img/mysql/datatype/incompatible_change_of_date_and_time_type.png" alt="incompatible_change_of_date_and_time_type"></p><p>参考 <a href="https://dev.mysql.com/doc/refman/5.6/en/storage-requirements.html#data-types-storage-reqs-date-time" target="_blank" rel="noopener">Date and Time Type Storage Requirements</a> 下表列明了日期与时间类型在 MySQL 5.6.4 前后的变化：</p><p><img src="/img/mysql/datatype/date_and_time_type_storage_requirements.png" alt="date_and_time_type_storage_requirements"></p><p>通过分析精确到小数部分的秒（Fractional Seconds Precision）所支持的最大十进制数值，并将其转换为二进制表示，可知为什么精度越高所需的存储空间越多：</p><table><thead><tr><th>Fractional Seconds Precision</th><th>Maximum Decimal Representation</th><th>Maximum Binary Representation</th><th>Storage Required</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0 (0 bit)</td><td>0 byte</td></tr><tr><td>1, 2</td><td>99</td><td>0110 0011 (8 bits)</td><td>1 byte</td></tr><tr><td>3, 4</td><td>9,999</td><td>0010 0111 0000 1111 (16 bits)</td><td>2 bytes</td></tr><tr><td>5, 6</td><td>999,999</td><td>0000 1111 0100 0010 0011 1111 (24 bits)</td><td>3 bytes</td></tr></tbody></table><p>有关于时间值的内部表示的详细信息，参考 <a href="https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html" target="_blank" rel="noopener">MySQL Internals: Important Algorithms and Structures - Date and Time Data Type Representation</a></p><p><code>DATETIME</code> 类型非小数部分的编码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> 1 bit  sign           (1&#x3D; non-negative, 0&#x3D; negative)</span><br><span class="line">17 bits year*13+month  (year 0-9999, month 0-12)</span><br><span class="line"> 5 bits day            (0-31)</span><br><span class="line"> 5 bits hour           (0-23)</span><br><span class="line"> 6 bits minute         (0-59)</span><br><span class="line"> 6 bits second         (0-59)</span><br><span class="line">---------------------------</span><br><span class="line">40 bits &#x3D; 5 bytes</span><br></pre></td></tr></table></figure><p><code>TIMESTAMP</code> 类型的如下：</p><table><thead><tr><th>时间</th><th>时间戳</th><th>二进制字面量</th></tr></thead><tbody><tr><td>1970-01-01T00:00:00Z</td><td>0</td><td>00000000 00000000 00000000 00000000</td></tr><tr><td>2038-01-19T03:14:07Z</td><td>2^31-1, 2147483647</td><td>01111111 11111111 11111111 11111111</td></tr></tbody></table><h1 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h1><ul><li>默认值必须是常量，而不能是一个函数或表达式。举个栗子，这意味着你不能将日期列的默认值设置为诸如 <code>NOW()</code> 或 <code>CURRENT_DATE</code> 之类的函数的值。唯一例外是你可以指定 <code>CURRENT_TIMESTAMP</code> 为 <code>TIMESTAMP</code> 和 <code>DATETIME</code> 列的默认值。</li><li>隐式默认值定义如下：<ul><li>数字类型<ul><li>对于使用 <code>AUTO_INCREMENT</code> 属性声明的整数类型或浮点类型，默认值为下一个序列值。</li><li>否则默认值为 <code>0</code> 。</li></ul></li><li>字符串类型<ul><li><code>ENUM</code> 的默认值为第一个枚举值。</li><li><code>BLOB</code> 、<code>TEXT</code> 列无法指定默认值。</li><li>其它类型的默认值为空字符串。</li></ul></li><li>日期与时间类型<ul><li><code>TIMESTAMP</code><ul><li>如果系统变量 <code>explicit_defaults_for_timestamp</code> 开启，其默认值为 0 值。</li><li>否则表中第一列 <code>TIMESTAMP</code> 的默认值为当前时间。</li></ul></li><li>其它类型的默认值为相应的 0 值。</li></ul></li></ul></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/data-types.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/data-types.html</a></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html</a></p><p>《<a href="https://www.cnblogs.com/blankqdb/archive/2012/11/03/blank_qdb.html" target="_blank" rel="noopener">MySQL数据类型：UNSIGNED注意事项</a>》</p><p>《<a href="http://tech.it168.com/a2013/1013/1544/000001544067.shtml" target="_blank" rel="noopener">MySQL 5.6时间数据类型功能获得改进</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL 常用命令</title>
      <link href="2018/01/03/mysql-cli/"/>
      <url>2018/01/03/mysql-cli/</url>
      
        <content type="html"><![CDATA[<p>高安全的生产环境下只能使用命令行操作数据库，下面介绍一些常用命令。</p><h1 id="连接-DB"><a href="#连接-DB" class="headerlink" title="连接 DB"></a>连接 DB</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -h192.168.0.221 -P3306 -u账号 -p密码 [db_name]</span><br><span class="line"></span><br><span class="line">or better:</span><br><span class="line"></span><br><span class="line">$ mycli -h192.168.0.221 -P3306 -u账号 -p密码 [db_name]</span><br></pre></td></tr></table></figure><h1 id="查看库"><a href="#查看库" class="headerlink" title="查看库"></a>查看库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看所有库</span><br><span class="line">$ show databases;</span><br><span class="line"></span><br><span class="line">+------------------+</span><br><span class="line">| Database         |</span><br><span class="line">|------------------|</span><br><span class="line">| db_name_1        |</span><br><span class="line">| db_name_2        |</span><br><span class="line">+------------------+</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 进入某个库</span><br><span class="line">$ use db_name_1;</span><br></pre></td></tr></table></figure><h1 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h1><h2 id="所有表"><a href="#所有表" class="headerlink" title="所有表"></a>所有表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ show tables [from db_name];</span><br><span class="line"></span><br><span class="line">+---------------------+</span><br><span class="line">| Tables_in_db_name   |</span><br><span class="line">|---------------------|</span><br><span class="line">| table_name_1        |</span><br><span class="line">| table_name_2        |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h2 id="所有表状态"><a href="#所有表状态" class="headerlink" title="所有表状态"></a>所有表状态</h2><p>显示当前使用或者指定的 DB 中的每个表的信息。</p><p>由于字段较多，可用 <code>\G</code> 参数按列显示（行转列），起到显示美化的作用，方便查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ show table status [from db_name] \G;</span><br><span class="line"></span><br><span class="line">Name            | table_name</span><br><span class="line">Engine          | InnoDB</span><br><span class="line">Version         | 10</span><br><span class="line">Row_format      | Compact</span><br><span class="line">Rows            | 59079</span><br><span class="line">Avg_row_length  | 133</span><br><span class="line">Data_length     | 7880704</span><br><span class="line">Max_data_length | 0</span><br><span class="line">Index_length    | 21069824</span><br><span class="line">Data_free       | 5242880</span><br><span class="line">Auto_increment  | 75437</span><br><span class="line">Create_time     | 2017-04-13 20:51:55</span><br><span class="line">Update_time     | None</span><br><span class="line">Check_time      | None</span><br><span class="line">Collation       | utf8_general_ci</span><br><span class="line">Checksum        | None</span><br><span class="line">Create_options  |</span><br><span class="line">Comment         | 测试表</span><br></pre></td></tr></table></figure><p>比较重要的字段：</p><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td><code>Rows</code></td><td>行的数目。部分存储引擎，如 <code>MyISAM</code>，存储精确的数目。<br/>对于其它存储引擎，比如 <code>InnoDB</code>，是一个大约的值，与实际值相差可达40到50％。在这些情况下，使用 <code>SELECT COUNT(*)</code> 来获得准确的数目。</td></tr><tr><td><code>Avg_row_length</code></td><td>平均的行长度。</td></tr><tr><td><code>Data_length</code></td><td>对于 <code>MyISAM</code>，<code>Data_length</code> 是数据文件的长度（以字节为单位）。<br/>对于 <code>InnoDB</code>，<code>Data_length</code> 是聚簇索引 <code>clustered index</code> 大约分配的内存量（以字节为单位）。</td></tr><tr><td><code>Index_length</code></td><td>对于 <code>MyISAM</code>，<code>Index_length</code> 是索引文件的长度（以字节为单位）。<br/>对于 <code>InnoDB</code>，<code>Index_length</code> 是非聚簇索引 <code>non-clustered index</code> 大约分配的内存量（以字节为单位）。</td></tr><tr><td><code>Auto_increment</code></td><td>下一个 <code>AUTO_INCREMENT</code> 值。</td></tr></tbody></table><h2 id="表结构"><a href="#表结构" class="headerlink" title="表结构"></a>表结构</h2><p>查看列名（三者等价）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ show columns from table_name [from db_name];</span><br><span class="line">$ show columns from [db_name.]table_name;</span><br><span class="line">$ desc table_name;  &#x2F;&#x2F; 简写形式</span><br></pre></td></tr></table></figure><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show index from table_name;</span><br></pre></td></tr></table></figure><h2 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show create table table_name;</span><br></pre></td></tr></table></figure><h1 id="查看用户权限"><a href="#查看用户权限" class="headerlink" title="查看用户权限"></a>查看用户权限</h1><p>显示一个用户的权限，显示结果类似于 <code>GRANT</code> 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ show grants [for user_name@&#39;192.168.0.%&#39;];</span><br><span class="line"></span><br><span class="line">+---------------------------------------------------------------------------------------------+</span><br><span class="line">| Grants for user_name@192.168.0.%                                                            |</span><br><span class="line">+---------------------------------------------------------------------------------------------+</span><br><span class="line">| GRANT SELECT, INSERT, UPDATE, DELETE ON &#96;db_name&#96;.&#96;table_name&#96; TO &#39;user_name&#39;@&#39;192.168.0.%&#39; |</span><br><span class="line">+---------------------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h1 id="查看系统相关"><a href="#查看系统相关" class="headerlink" title="查看系统相关"></a>查看系统相关</h1><h2 id="系统状态"><a href="#系统状态" class="headerlink" title="系统状态"></a>系统状态</h2><p>显示一些系统特定资源的信息，例如，正在运行的线程数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show status;</span><br></pre></td></tr></table></figure><h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>显示系统变量的名称和值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show variables;</span><br></pre></td></tr></table></figure><h2 id="DB-进程"><a href="#DB-进程" class="headerlink" title="DB 进程"></a>DB 进程</h2><p>显示系统中正在运行的所有进程，也就是当前正在执行的查询。大多数用户可以查看他们自己的进程，但是如果他们拥有process权限，就可以查看所有人的进程，包括密码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看当前 DB 进程</span><br><span class="line">$ show processlist;</span><br><span class="line">$ show full processlist;</span><br><span class="line">+----------+-----------+--------------------+---------+---------+------+-------+------------------+</span><br><span class="line">| Id       | User      | Host               | db      | Command | Time | State | Info             |</span><br><span class="line">+----------+-----------+--------------------+---------+---------+------+-------+------------------+</span><br><span class="line">| 33702451 | user_name | 192.168.0.200:49764 | db_name | Query   |    0 | init  | show processlist |</span><br><span class="line">+----------+-----------+--------------------+---------+---------+------+-------+------------------+</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>描述</th></tr></thead><tbody><tr><td><code>Id</code></td><td>标识，用途：<code>kill 33702451</code> 杀死指定进程。</td></tr><tr><td><code>User</code></td><td>显示执行 SQL 的用户。</td></tr><tr><td><code>Host</code></td><td>显示这个账号是从哪个 IP 连过来的。</td></tr><tr><td><code>db</code></td><td>显示这个进程目前连接的是哪个数据库 。</td></tr><tr><td><code>command</code></td><td>显示当前连接的执行命令，一般就是休眠（ sleep ），查询（ query ），连接（ connect ）。</td></tr><tr><td><code>Time</code></td><td>这个状态持续的时间，单位是秒。</td></tr><tr><td><code>State</code></td><td>显示使用当前连接的 SQL 语句的状态。</td></tr><tr><td><code>Info</code></td><td>显示执行的 SQL 语句。</td></tr></tbody></table><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>显示服务器所支持的不同权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ show privileges;</span><br></pre></td></tr></table></figure><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ show engies; &#x2F;&#x2F; 显示安装以后可用的存储引擎和默认引擎。 </span><br><span class="line"></span><br><span class="line">$ show innodb status; &#x2F;&#x2F; 显示innoDB存储引擎的状态 </span><br><span class="line"></span><br><span class="line">$ show logs; &#x2F;&#x2F; 显示BDB存储引擎的日志</span><br></pre></td></tr></table></figure><h2 id="警告与错误"><a href="#警告与错误" class="headerlink" title="警告与错误"></a>警告与错误</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ show warnings; &#x2F;&#x2F; 显示最后一个执行的语句所产生的错误、警告和通知 </span><br><span class="line"></span><br><span class="line">$ show errors; &#x2F;&#x2F; 只显示最后一个执行语句所产生的错误</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端技术栈演进之路</title>
      <link href="2018/01/01/frontend-roadmap/"/>
      <url>2018/01/01/frontend-roadmap/</url>
      
        <content type="html"><![CDATA[<p>在随手科技这几年，兼任了金融前端团队的负责人，将团队从只有 1 名前端开始，扩展到了 10 多人的前端团队，推动了整个金融前端技术栈的建设及发展，是一段挑战自己未知领域的有趣之旅。</p><p>我总结了一下，这几年团队共经历了这样几个阶段：</p><ul><li>单块项目（服务端渲染） &gt; 项目分层（前后端分离） &gt; 项目拆分（按业务拆分）</li><li>前端模块化 &gt; 组件化 &gt; 工程化</li><li>事件驱动 &gt; 数据驱动</li><li>后台选型：JSP 服务端渲染 + EasyUI &gt; 前后端分离 + <a href="http://element.eleme.io/" target="_blank" rel="noopener">Element</a></li><li>浏览器 &gt; 服务端</li></ul><p>下面分几个阶段总结下。</p><h1 id="阶段1-服务端渲染"><a href="#阶段1-服务端渲染" class="headerlink" title="阶段1 服务端渲染"></a>阶段1 服务端渲染</h1><p>2016 年之前，由于团队和项目规模所限，人员构成以后端开发为主、前端开发为辅（就一个前端开发），只能通过最基础的技术栈，以后端人员最熟悉的技术着手进行业务开发并快速上线，因此技术选型都是偏向服务端的：前端只需按照设计师要求切图并输出静态页面（HTML + CSS），加上一些基础的 ES5 实现所需的动画效果和基础交互效果，后端套成 JSP （或 freemarker velocity thymeleaf）进行服务端渲染。后端开发一般会这样解决问题：</p><ul><li>通过 SiteMesh 等框架在 JSP 中将网页内容和页面结构分离，以达到页面结构共享的目的；</li><li>通过 tld 文件自定义标签，给 JSP 页面提供一些便捷工具（如货币、时间、字符串格式化）；</li><li>对于一些复杂的页面交互逻辑，在 JSP 页面上通过 <code>&lt;script&gt;</code> 标签直接引用所需的 JavaScript 文件。</li></ul><p>作为后端开发人员会觉得：这么写代码也没什么问题啊，毕竟身边的同事都是这么写的，项目也跑得好好的。但问题在于，后端开发写 JS 都是很业余的，而且随着功能越做越多，业务越做越深，前端脚本开始变得难以扩展与维护：</p><ul><li>脚本间依赖关系脆弱，加载顺序需要手工维护，一不小心顺序乱了就 JS 报错；</li><li>脚本中潜藏着各种全局变量（函数），导致命名冲突、作用域污染，没有合理的进行前端模块化；</li><li>各页面没有主入口脚本，代码不知从何看起…… </li></ul><h1 id="阶段2-前端模块化"><a href="#阶段2-前端模块化" class="headerlink" title="阶段2 前端模块化"></a>阶段2 前端模块化</h1><p>2016 年初，我着手重构前端的第一件事就是将前端模块化。</p><p>JavaScript 这门语言（或者说老版本 ES5），最为糟糕的地方就是基于全局变量的编程模型（<a href="/2016/03/10/javascript-best-practice/#避免使用全局变量">如何避免使用全局变量？</a>），并且由于不支持“类”与“模块”，使得稍具规模的应用都难以扩展。</p><p>一番对比和调研 AMD 和 CMD 规范的相关框架之后，第二阶段决定引入 Require.js（<a href="http://www.requirejs.org/" target="_blank" rel="noopener">英文</a>、<a href="http://www.requirejs.cn/" target="_blank" rel="noopener">中文</a>）这个前端框架。Require.js 以模块化的方式组织前端脚本，通过 AMD 规范定义的两个关键函数 <code>define()</code> 和 <code>require()</code> ，我们可以很轻松的在老版本 ES5 上实现模块化功能，解决模块依赖、全局变量与命名冲突的问题，并提供了统一的脚本主入口。</p><p>Require.js 入门教程参考<a href="/2016/07/05/javascript-requirejs/">此前博文</a>。</p><h1 id="阶段3-项目分层（前后端分离）"><a href="#阶段3-项目分层（前后端分离）" class="headerlink" title="阶段3  项目分层（前后端分离）"></a>阶段3  项目分层（前后端分离）</h1><p>前端模块化虽然提升了项目的可维护性，但由于此阶段前后端项目仍然强耦合，项目和团队仍存在以下问题：</p><ul><li>前端完成的 HTML 页面需交付给后端转换为 JSP 页面，多一道无谓的工序。更重要的是，后续前端任何页面修改，都需要通知后端进行同步修改，操作繁琐且易出错；</li><li>由于 JSP 页面由后端编写，后端开发如果觉悟不够或者贪图方便，在 JSP 页面中各种 JavaScript 代码信手拈来、Java 变量和 JS 变量混用，导致前后端难以解耦、代码后续难以维护；</li><li>后端开发无法专注于业务开发，大量精力浪费于编写前端样式及脚本，分工不明确、不专业。</li></ul><p>更为重要的是，当下前端领域日新月异，ES 新版本、层出不穷的新框架，SPA 单页技术、CSS 预处理语言、前端性能优化、自动化构建…… 受限于项目结构、迫于后端人员能力，新技术无法推广落地，前端人员能力也无法完全施展。</p><p>2016 年中，我开始渐进式的推动前后端分离，为了不让步子太大扯着蛋，前端主体技术栈仍采用 HTML + Require.js + Zepto，后台采用 EasyUI，并重点解决下面两类问题：</p><h2 id="引入自动化构建工具"><a href="#引入自动化构建工具" class="headerlink" title="引入自动化构建工具"></a>引入自动化构建工具</h2><p>传统的前端是无需构建的：前端开发编写的 HTML、JS、CSS 可以直接运行在浏览器中，代码所见即所得。但这种传统方式也带来了以下问题：</p><ul><li>无法根据不同环境构建代码，解决各环境间的差异。例如不同环境下资源引用路径是不同的，生产往往会使用 CDN 域名；</li><li>HTML 页面之间各种代码重复，例如一些全局 rem 设置、全局变量、事件，公共样式、脚本、页面布局，提升了维护成本；</li><li>JS 脚本没被检查（如静态语法分析），团队协作时代码规范程度无法保证；没有单元测试，潜藏缺陷容易直接流到生产环境；</li><li>CSS 样式无法扩展、浏览器兼容性问题处理复杂（如需手工添加厂商前缀）；</li><li>静态资源没被合并、压缩，体积大、数量多，导致用户请求慢；</li><li>静态资源没被 hash，带来版本管理和缓存问题，更新困难；</li><li>静态资源需手工打包上传，操作繁琐；</li></ul><p>为了解决这些问题，这个阶段我引入了自动化构建工具 <a href="https://www.gulpjs.com.cn/" target="_blank" rel="noopener">Gulp.js</a>，一些使用实践请参考<a href="/2016/12/05/javascript-gulpjs/">此前博文</a>。对于一个前端新手来说，这是一个很大的思维转变，自动化构建极大提升前端项目的工程能力，“构建”阶段能够实现很多之前无法实现的效果。</p><h2 id="引入-CSS-预处理语言"><a href="#引入-CSS-预处理语言" class="headerlink" title="引入 CSS 预处理语言"></a>引入 CSS 预处理语言</h2><p>前后端分离后，由于引入构建工具，前端开发能够自由发挥的空间更多了，这个阶段我们还引入了 less，一门 CSS 预处理语言，提升了编写前端样式的效率。</p><h2 id="API-接口设计"><a href="#API-接口设计" class="headerlink" title="API 接口设计"></a>API 接口设计</h2><p>前后端分离的另一个重点，在于数据与页面交互方式的改变——服务端渲染 &gt; 前端渲染。因此定义一套统一的 API 接口规范尤其重要。这个阶段我解决掉的问题：</p><ul><li>跨域方案选型：代理、JSONP、CORS，平衡了浏览器兼容性和开发便利性最终采用 CORS 方案；</li><li>接口规范：编写后端 API 网关层框架，大一统全公司项目的接口入参、出参规范及处理流程；</li><li>文档管理：前期手工编写 Markdown 文档 &gt; 后期使用 SwaggerUI 自动生成文档；</li><li>搭建 API Mock Server，前期 <a href="https://github.com/sanyueyu/gulp-mock-server" target="_blank" rel="noopener">gulp-mock-server</a> &gt; 后期 <a href="http://rapapi.org/org/index.do" target="_blank" rel="noopener">RAP Mock Server</a> ，大大提升前后端并行开发效率。</li></ul><h1 id="阶段4-项目拆分"><a href="#阶段4-项目拆分" class="headerlink" title="阶段4 项目拆分"></a>阶段4 项目拆分</h1><p>2017 年开始，随着业务做大（新业务越做越多，每周还搞各种运营活动）、人员增多，原来的一两个前端项目已经不能满足快速增长的需求了。这个阶段浮现出来的新问题：</p><ul><li>人员多、特性多，由于只有几个前端项目，并行开发时 git 分支难以管理，代码合版时容易发生冲突；</li><li>测试环境当时只有两套，测试时容易发生代码被覆盖的问题，特性间不好并行测试；</li><li>生产发版风险较大，出问题时只能整体回滚，粒度太大，影响前端项目内的其它正常特性。</li></ul><p>为了解决上述问题，2017 年我们按业务、活动两个维度进行了项目分拆：</p><ul><li>业务<ul><li>帐户项目</li><li>非标项目</li><li>基金项目</li><li>XX 项目 …</li></ul></li><li>活动<ul><li>首投活动</li><li>邀请活动</li><li>XX 活动 …</li></ul></li></ul><p>各业务、各项目分而治之，由专门的前端组长统筹、排期、开发、发版，满足各业务的个性化需求及节奏差异。</p><p>为了进一步提升开发效率，解决模块及组件的复用问题，这个阶段还：</p><ul><li>引入了新版 ES6 + Babel 编译器提升 JavaScript 开发效率；</li><li>引入了 MV* 库 Vue.js + 自动化构建工具 Webpack，解决之前的 DOM 节点操作 + 事件驱动机制的开发效率低的问题。</li><li>引入了 NPM 包管理器，搭建团队专属的仓库（控件库 + 组件库），提升代码复用性。</li></ul><h1 id="阶段5-重回服务端渲染"><a href="#阶段5-重回服务端渲染" class="headerlink" title="阶段5 重回服务端渲染"></a>阶段5 重回服务端渲染</h1><p>前端技术近年来日新月异，目前 Node.js 的应用已经铺天盖地，Node.js 中间层的出现改变了前后端的合作模式，各大公司前端都把 Node.js 作为前后端分离的新手段，并且在测试、监控等方面沉淀了大量内容。</p><p>2018 年起，前端团队也开始在预研 Node.js 技术、搭建各类基础库并尝试在生产中投入使用。以史为鉴，展望未来，只要我们有不断突破自我的勇气，一定能克服困难，让新技术在公司中落地开花，进一步提升团队的开发效率，为公司创造更大的价值。</p><p>待续。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://segmentfault.com/a/1190000002413526" target="_blank" rel="noopener">Web前后端分离开发思路</a></p><p><a href="http://www.cnblogs.com/whitewolf/p/4686154.html" target="_blank" rel="noopener">前后端分离后的契约</a></p><p><a href="https://segmentfault.com/q/1010000008376827/a-1020000008379228" target="_blank" rel="noopener">什么是基于数据驱动的前端框架？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 开发必备类库 Apache Commons Lang</title>
      <link href="2017/12/25/apache-commons-lang/"/>
      <url>2017/12/25/apache-commons-lang/</url>
      
        <content type="html"><![CDATA[<p>Apache Commons 是一个 Apache 项目，专注于可重用 Java 组件的方方面面。</p><p>Apache Commons 项目由三个部分组成：</p><p><img src="/img/java/commons/apache-commons.png" alt="Apache Commons">   </p><p>其中，Apache Commons Lang 是 Java 开发过程中很常用的一个类库，可以理解为它是对 Java Lang and Util Base  Libraries 的增强。</p><p>Commons Lang 安装方法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Commons Lang 总览：</p><p><img src="/img/java/commons/commons-lang/commons-lang.png" alt="Commons Lang"></p><p>Commons Lang 提供了以下 package：</p><ul><li><code>org.apache.commons.lang3</code></li><li><code>org.apache.commons.lang3.builder</code></li><li><code>org.apache.commons.lang3.concurrent</code></li><li><code>org.apache.commons.lang3.event</code></li><li><code>org.apache.commons.lang3.exception</code></li><li><code>org.apache.commons.lang3.math</code></li><li><code>org.apache.commons.lang3.mutable</code></li><li><code>org.apache.commons.lang3.reflect</code></li><li><code>org.apache.commons.lang3.text</code></li><li><code>org.apache.commons.lang3.text.translate</code></li><li><code>org.apache.commons.lang3.time</code></li><li><code>org.apache.commons.lang3.tuple</code></li></ul><p>下面重点来看下最常用的几个工具：</p><p><code>org.apache.commons.lang3</code></p><ul><li><code>StringUtils</code></li><li><code>ArrayUtils</code></li><li><code>BooleanUtils</code></li></ul><h1 id="StringUtils"><a href="#StringUtils" class="headerlink" title="StringUtils"></a>StringUtils</h1><p><img src="/img/java/commons/commons-lang/StringUtils.png" alt="StringUtils"></p><h2 id="判空函数"><a href="#判空函数" class="headerlink" title="判空函数"></a>判空函数</h2><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.isEmpty(String str)</span><br><span class="line">StringUtils.isNotEmpty(String str)</span><br><span class="line">StringUtils.isBlank(String str)</span><br><span class="line">StringUtils.isNotBlank(String str)</span><br><span class="line">StringUtils.isAnyBlank(CharSequence… css)</span><br><span class="line">StringUtils.isAnyEmpty(CharSequence… css)</span><br><span class="line">StringUtils.isNoneBlank(CharSequence… css)</span><br><span class="line">StringUtils.isNoneEmpty(CharSequence… css)</span><br><span class="line">StringUtils.isWhitespace(CharSequence cs)</span><br></pre></td></tr></table></figure><p>看下 <code>isBlank</code> 和 <code>isEmpty</code> 的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.isBlank(<span class="keyword">null</span>) <span class="comment">// true</span></span><br><span class="line">StringUtils.isEmpty(<span class="keyword">null</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">StringUtils.isBlank(<span class="string">""</span>) <span class="comment">// true</span></span><br><span class="line">StringUtils.isEmpty(<span class="string">""</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">StringUtils.isBlank(<span class="string">" "</span>) <span class="comment">// true</span></span><br><span class="line">StringUtils.isEmpty(<span class="string">" "</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">StringUtils.isBlank(<span class="string">"\n\t"</span>) <span class="comment">// true</span></span><br><span class="line">StringUtils.isEmpty(<span class="string">"\n\t"</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">isNotEmpty = !isEmpty, isBlank同理</span><br></pre></td></tr></table></figure><p>使用 <code>isAnyBlank</code> 和 <code>isAnyEmpty</code> 进行多维判空：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.isAnyBlank(<span class="string">""</span>, <span class="string">"bar"</span>, <span class="string">"foo"</span>); <span class="comment">// true</span></span><br><span class="line">StringUtils.isAnyEmpty(<span class="string">" "</span>, <span class="string">"bar"</span>, <span class="string">"foo"</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">isNoneBlank = !isAnyBlank；isNoneEmpty同理</span><br></pre></td></tr></table></figure><p>使用 <code>isWhitespace</code> 判断空白：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.isWhitespace(<span class="keyword">null</span>); <span class="comment">// false</span></span><br><span class="line">StringUtils.isWhitespace(<span class="string">""</span>); <span class="comment">// true</span></span><br><span class="line">StringUtils.isWhitespace(<span class="string">" "</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="判断是否相等函数"><a href="#判断是否相等函数" class="headerlink" title="判断是否相等函数"></a>判断是否相等函数</h2><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">equals(CharSequence cs1,CharSequence cs2)</span><br><span class="line">equalsIgnoreCase(CharSequence str1, CharSequence str2)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.equals(<span class="string">"abc"</span>, <span class="keyword">null</span>)  = <span class="keyword">false</span></span><br><span class="line">StringUtils.equals(<span class="string">"abc"</span>, <span class="string">"abc"</span>) = <span class="keyword">true</span></span><br><span class="line">StringUtils.equals(<span class="string">"abc"</span>, <span class="string">"ABC"</span>) = <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>忽略大小写判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.equalsIgnoreCase(<span class="string">"abc"</span>, <span class="keyword">null</span>)  = <span class="keyword">false</span></span><br><span class="line">StringUtils.equalsIgnoreCase(<span class="string">"abc"</span>, <span class="string">"abc"</span>) = <span class="keyword">true</span></span><br><span class="line">StringUtils.equalsIgnoreCase(<span class="string">"abc"</span>, <span class="string">"ABC"</span>) = <span class="keyword">true</span></span><br></pre></td></tr></table></figure><h2 id="是否包含函数"><a href="#是否包含函数" class="headerlink" title="是否包含函数"></a>是否包含函数</h2><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">containsOnly(CharSequence cs,<span class="keyword">char</span>… valid)</span><br><span class="line">containsNone(CharSequence cs,<span class="keyword">char</span>… searchChars)</span><br><span class="line"></span><br><span class="line">startsWith(CharSequence str,CharSequence prefix)</span><br><span class="line">startsWithIgnoreCase(CharSequence str,CharSequence prefix)</span><br><span class="line">startsWithAny(CharSequence string,CharSequence… searchStrings)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断字符串中所有字符，是否都是出自参数2中</span></span><br><span class="line">StringUtils.containsOnly(<span class="string">"ab"</span>, <span class="string">""</span>)      = <span class="keyword">false</span></span><br><span class="line">StringUtils.containsOnly(<span class="string">"abab"</span>, <span class="string">"abc"</span>) = <span class="keyword">true</span></span><br><span class="line">StringUtils.containsOnly(<span class="string">"ab1"</span>, <span class="string">"abc"</span>)  = <span class="keyword">false</span></span><br><span class="line">StringUtils.containsOnly(<span class="string">"abz"</span>, <span class="string">"abc"</span>)  = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符串中所有字符，都不在参数2中。</span></span><br><span class="line">StringUtils.containsNone(<span class="string">"abab"</span>, <span class="string">'xyz'</span>) = <span class="keyword">true</span></span><br><span class="line">StringUtils.containsNone(<span class="string">"ab1"</span>, <span class="string">'xyz'</span>)  = <span class="keyword">true</span></span><br><span class="line">StringUtils.containsNone(<span class="string">"abz"</span>, <span class="string">'xyz'</span>)  = <span class="keyword">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断字符串是否以第二个参数开始</span></span><br><span class="line">StringUtils.startsWith(<span class="string">"abcdef"</span>, <span class="string">"abc"</span>) = <span class="keyword">true</span></span><br><span class="line">StringUtils.startsWith(<span class="string">"ABCDEF"</span>, <span class="string">"abc"</span>) = <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h2 id="索引下标函数"><a href="#索引下标函数" class="headerlink" title="索引下标函数"></a>索引下标函数</h2><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">indexOf(CharSequence seq,CharSequence searchSeq)</span><br><span class="line">indexOf(CharSequence seq,CharSequence searchSeq,<span class="keyword">int</span> startPos)</span><br><span class="line">indexOfIgnoreCase/lastIndexOfIgnoreCase(CharSequence str,CharSequence searchStr)</span><br><span class="line">lastIndexOf(CharSequence seq,<span class="keyword">int</span> searchChar)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回第二个参数开始出现的索引值</span></span><br><span class="line">StringUtils.indexOf(<span class="string">"aabaabaa"</span>, <span class="string">"a"</span>)  = <span class="number">0</span></span><br><span class="line">StringUtils.indexOf(<span class="string">"aabaabaa"</span>, <span class="string">"b"</span>)  = <span class="number">2</span></span><br><span class="line">StringUtils.indexOf(<span class="string">"aabaabaa"</span>, <span class="string">"ab"</span>) = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从第三个参数索引开始找起，返回第二个参数开始出现的索引值</span></span><br><span class="line">StringUtils.indexOf(<span class="string">"aabaabaa"</span>, <span class="string">"a"</span>, <span class="number">0</span>)  = <span class="number">0</span></span><br><span class="line">StringUtils.indexOf(<span class="string">"aabaabaa"</span>, <span class="string">"b"</span>, <span class="number">0</span>)  = <span class="number">2</span></span><br><span class="line">StringUtils.indexOf(<span class="string">"aabaabaa"</span>, <span class="string">"ab"</span>, <span class="number">0</span>) = <span class="number">1</span></span><br><span class="line">StringUtils.indexOf(<span class="string">"aabaabaa"</span>, <span class="string">"b"</span>, <span class="number">3</span>)  = <span class="number">5</span></span><br><span class="line">StringUtils.indexOf(<span class="string">"aabaabaa"</span>, <span class="string">"b"</span>, <span class="number">9</span>)  = -<span class="number">1</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回第二个参数出现的最后一个索引值        </span></span><br><span class="line">StringUtils.lastIndexOf(<span class="string">"aabaabaa"</span>, <span class="string">'a'</span>) = <span class="number">7</span></span><br><span class="line">StringUtils.lastIndexOf(<span class="string">"aabaabaa"</span>, <span class="string">'b'</span>) = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">StringUtils.lastIndexOfIgnoreCase(<span class="string">"aabaabaa"</span>, <span class="string">"A"</span>, <span class="number">8</span>)  = <span class="number">7</span></span><br><span class="line">StringUtils.lastIndexOfIgnoreCase(<span class="string">"aabaabaa"</span>, <span class="string">"B"</span>, <span class="number">8</span>)  = <span class="number">5</span></span><br><span class="line">StringUtils.lastIndexOfIgnoreCase(<span class="string">"aabaabaa"</span>, <span class="string">"AB"</span>, <span class="number">8</span>) = <span class="number">4</span></span><br><span class="line">StringUtils.lastIndexOfIgnoreCase(<span class="string">"aabaabaa"</span>, <span class="string">"B"</span>, <span class="number">9</span>)  = <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="截取函数"><a href="#截取函数" class="headerlink" title="截取函数"></a>截取函数</h2><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">substring(String str,<span class="keyword">int</span> start)</span><br><span class="line">substringAfter(String str,String separator)</span><br><span class="line">substringBeforeLast(String str,String separator)</span><br><span class="line">substringAfterLast(String str,String separator)</span><br><span class="line">substringBetween(String str,String tag)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//start&gt;0表示从左向右, start&lt;0表示从右向左, start=0则从左第一位开始</span></span><br><span class="line">StringUtils.substring(<span class="string">"abcdefg"</span>, <span class="number">0</span>)  = <span class="string">"abcdefg"</span></span><br><span class="line">StringUtils.substring(<span class="string">"abcdefg"</span>, <span class="number">2</span>)  = <span class="string">"cdefg"</span></span><br><span class="line">StringUtils.substring(<span class="string">"abcdefg"</span>, <span class="number">4</span>)  = <span class="string">"efg"</span></span><br><span class="line">StringUtils.substring(<span class="string">"abcdefg"</span>, -<span class="number">2</span>) = <span class="string">"fg"</span></span><br><span class="line">StringUtils.substring(<span class="string">"abcdefg"</span>, -<span class="number">4</span>) = <span class="string">"defg"</span></span><br></pre></td></tr></table></figure><p>// start&gt;0&amp;&amp;end&gt;0从左开始(包括左)到右结束(不包括右),</p><p>//start&lt;0&amp;&amp;end&lt;0从右开始(包括右),再向左数到end结束(包括end)</p><p><img src="/img/java/commons/commons-lang/substring.png" alt="substring"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从第二个参数字符串开始截取，排除第二个字符串</span></span><br><span class="line">StringUtils.substringAfter(<span class="string">"abc"</span>, <span class="string">"a"</span>)   = <span class="string">"bc"</span></span><br><span class="line">StringUtils.substringAfter(<span class="string">"abcba"</span>, <span class="string">"b"</span>) = <span class="string">"cba"</span></span><br><span class="line">StringUtils.substringAfter(<span class="string">"abc"</span>, <span class="string">"c"</span>)   = <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从最后一个字母出现开始截取</span></span><br><span class="line">StringUtils.substringBeforeLast(<span class="string">"abcba"</span>, <span class="string">"b"</span>) = <span class="string">"abc"</span></span><br><span class="line">StringUtils.substringBeforeLast(<span class="string">"abc"</span>, <span class="string">"c"</span>)   = <span class="string">"ab"</span></span><br><span class="line">StringUtils.substringBeforeLast(<span class="string">"a"</span>, <span class="string">"a"</span>)     = <span class="string">""</span></span><br><span class="line">StringUtils.substringBeforeLast(<span class="string">"a"</span>, <span class="string">"z"</span>)     = <span class="string">"a"</span></span><br><span class="line"></span><br><span class="line">StringUtils.substringAfterLast(<span class="string">"abc"</span>, <span class="string">"a"</span>)   = <span class="string">"bc"</span></span><br><span class="line">StringUtils.substringAfterLast(<span class="string">"abcba"</span>, <span class="string">"b"</span>) = <span class="string">"a"</span></span><br><span class="line">StringUtils.substringAfterLast(<span class="string">"abc"</span>, <span class="string">"c"</span>)   = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">StringUtils.substringBetween(<span class="string">"tagabctag"</span>, <span class="keyword">null</span>)  = <span class="keyword">null</span></span><br><span class="line">StringUtils.substringBetween(<span class="string">"tagabctag"</span>, <span class="string">""</span>)    = <span class="string">""</span></span><br><span class="line">StringUtils.substringBetween(<span class="string">"tagabctag"</span>, <span class="string">"tag"</span>) = <span class="string">"abc"</span></span><br></pre></td></tr></table></figure><h2 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h2><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.remove(String str, <span class="keyword">char</span> remove)</span><br><span class="line">StringUtils.remove(String str, String remove)</span><br><span class="line">StringUtils.removeEnd(String str, String remove)</span><br><span class="line">StringUtils.removeEndIgnoreCase(String str, String remove)</span><br><span class="line">StringUtils.removePattern(String source, String regex)</span><br><span class="line">StringUtils.removeStart(String str, String remove)</span><br><span class="line">StringUtils.removeStartIgnoreCase(String str, String remove)</span><br><span class="line">StringUtils.deleteWhitespace(String str)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除字符</span></span><br><span class="line">StringUtils.remove(<span class="string">"queued"</span>, <span class="string">'u'</span>) = <span class="string">"qeed"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除字符串</span></span><br><span class="line">StringUtils.remove(<span class="string">"queued"</span>, <span class="string">"ue"</span>) = <span class="string">"qd"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结尾匹配的字符串     </span></span><br><span class="line">StringUtils.removeEnd(<span class="string">"www.domain.com"</span>, <span class="string">".com"</span>)   = <span class="string">"www.domain"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结尾匹配的字符串,找都不到返回原字符串</span></span><br><span class="line">StringUtils.removeEnd(<span class="string">"www.domain.com"</span>, <span class="string">"domain"</span>) = <span class="string">"www.domain.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//忽略大小写的</span></span><br><span class="line">StringUtils.removeEndIgnoreCase(<span class="string">"www.domain.com"</span>, <span class="string">".COM"</span>) = <span class="string">"www.domain"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有空白（好用）</span></span><br><span class="line">StringUtils.deleteWhitespace(<span class="string">"abc"</span>)        = <span class="string">"abc"</span></span><br><span class="line">StringUtils.deleteWhitespace(<span class="string">"   ab  c  "</span>) = <span class="string">"abc"</span></span><br></pre></td></tr></table></figure><h2 id="删除空白函数"><a href="#删除空白函数" class="headerlink" title="删除空白函数"></a>删除空白函数</h2><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">trim(String str)</span><br><span class="line">trimToEmpty(String str)</span><br><span class="line">trimToNull(String str)</span><br><span class="line">deleteWhitespace(String str)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.trim(<span class="string">"     "</span>)       = <span class="string">""</span></span><br><span class="line">StringUtils.trim(<span class="string">"abc"</span>)         = <span class="string">"abc"</span></span><br><span class="line">StringUtils.trim(<span class="string">"    abc    "</span>) = <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line">StringUtils.trimToNull(<span class="string">"     "</span>)       = <span class="keyword">null</span></span><br><span class="line">StringUtils.trimToNull(<span class="string">"abc"</span>)         = <span class="string">"abc"</span></span><br><span class="line">StringUtils.trimToNull(<span class="string">"    abc    "</span>) = <span class="string">"abc"</span></span><br><span class="line">StringUtils.trimToEmpty(<span class="string">"     "</span>)       = <span class="string">""</span></span><br><span class="line">StringUtils.trimToEmpty(<span class="string">"abc"</span>)         = <span class="string">"abc"</span></span><br><span class="line">StringUtils.trimToEmpty(<span class="string">"    abc    "</span>) = <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line">StringUtils.deleteWhitespace(<span class="string">""</span>)           = <span class="string">""</span></span><br><span class="line">StringUtils.deleteWhitespace(<span class="string">"abc"</span>)        = <span class="string">"abc"</span></span><br><span class="line">StringUtils.deleteWhitespace(<span class="string">"   ab  c  "</span>) = <span class="string">"abc"</span></span><br></pre></td></tr></table></figure><h2 id="替换函数"><a href="#替换函数" class="headerlink" title="替换函数"></a>替换函数</h2><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">replace(String text, String searchString, String replacement)</span><br><span class="line">replace(String text, String searchString, String replacement, <span class="keyword">int</span> max)</span><br><span class="line">replaceChars(String str, <span class="keyword">char</span> searchChar, <span class="keyword">char</span> replaceChar)</span><br><span class="line">replaceChars(String str, String searchChars, String replaceChars)</span><br><span class="line">replaceEach(String text, String[] searchList, String[] replacementList)</span><br><span class="line">replaceEachRepeatedly(String text, String[] searchList, String[] replacementList)</span><br><span class="line">replaceOnce(String text, String searchString, String replacement)</span><br><span class="line">replacePattern(String source, String regex, String replacement)</span><br><span class="line">overlay(String str,String overlay,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span><br></pre></td></tr></table></figure><p><code>replace</code> 例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.replace(<span class="string">"aba"</span>, <span class="string">"a"</span>, <span class="string">""</span>)    = <span class="string">"b"</span></span><br><span class="line">StringUtils.replace(<span class="string">"aba"</span>, <span class="string">"a"</span>, <span class="string">"z"</span>)   = <span class="string">"zbz"</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">//数字就是替换个数，0代表不替换，1代表从开始数起第一个，-1代表全部替换</span></span><br><span class="line">StringUtils.replace(<span class="string">"abaa"</span>, <span class="string">"a"</span>, <span class="string">""</span>, -<span class="number">1</span>)   = <span class="string">"b"</span></span><br><span class="line">StringUtils.replace(<span class="string">"abaa"</span>, <span class="string">"a"</span>, <span class="string">"z"</span>, <span class="number">0</span>)   = <span class="string">"abaa"</span></span><br><span class="line">StringUtils.replace(<span class="string">"abaa"</span>, <span class="string">"a"</span>, <span class="string">"z"</span>, <span class="number">1</span>)   = <span class="string">"zbaa"</span></span><br><span class="line">StringUtils.replace(<span class="string">"abaa"</span>, <span class="string">"a"</span>, <span class="string">"z"</span>, <span class="number">2</span>)   = <span class="string">"zbza"</span></span><br><span class="line">StringUtils.replace(<span class="string">"abaa"</span>, <span class="string">"a"</span>, <span class="string">"z"</span>, -<span class="number">1</span>)  = <span class="string">"zbzz"</span></span><br></pre></td></tr></table></figure><p><code>replaceEach</code> 是对 <code>replace</code> 的增强版，用于一次性替换多个字符。搜索列表和替换长度必须一致，否则报 <code>IllegalArgumentException</code> 异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.replaceEach(<span class="string">"abcde"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"ab"</span>, <span class="string">"d"</span>&#125;, <span class="keyword">new</span> String[]&#123;<span class="string">"w"</span>, <span class="string">"t"</span>&#125;)  = <span class="string">"wcte"</span></span><br><span class="line">StringUtils.replaceEach(<span class="string">"abcde"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"ab"</span>, <span class="string">"d"</span>&#125;, <span class="keyword">new</span> String[]&#123;<span class="string">"d"</span>, <span class="string">"t"</span>&#125;)  = <span class="string">"dcte"</span></span><br></pre></td></tr></table></figure><p><code>replaceChars</code> 用于对单个字符逐一替换，其操作如下：</p><p><img src="/img/java/commons/commons-lang/replaceChars.png" alt="replaceChars"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.replaceChars(<span class="string">"dabcba"</span>, <span class="string">"bcd"</span>, <span class="string">"yzx"</span>) = <span class="string">"xayzya"</span></span><br><span class="line">StringUtils.replaceChars(<span class="string">"abcba"</span>, <span class="string">"bc"</span>, <span class="string">"y"</span>)   = <span class="string">"ayya"</span></span><br></pre></td></tr></table></figure><p><code>replaceOnce</code> 例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.replaceOnce(<span class="string">"aba"</span>, <span class="string">"a"</span>, <span class="string">""</span>)    = <span class="string">"ba"</span></span><br><span class="line">StringUtils.replaceOnce(<span class="string">"aba"</span>, <span class="string">"a"</span>, <span class="string">"z"</span>)   = <span class="string">"zba"</span></span><br></pre></td></tr></table></figure><p><code>overlay</code> 例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.overlay(<span class="string">"abcdef"</span>, <span class="string">"zzzz"</span>, <span class="number">2</span>, <span class="number">4</span>)   = <span class="string">"abzzzzef"</span></span><br><span class="line">StringUtils.overlay(<span class="string">"abcdef"</span>, <span class="string">"zzzz"</span>, <span class="number">4</span>, <span class="number">2</span>)   = <span class="string">"abzzzzef"</span></span><br><span class="line">StringUtils.overlay(<span class="string">"abcdef"</span>, <span class="string">"zzzz"</span>, -<span class="number">1</span>, <span class="number">4</span>)  = <span class="string">"zzzzef"</span></span><br><span class="line">StringUtils.overlay(<span class="string">"abcdef"</span>, <span class="string">"zzzz"</span>, <span class="number">2</span>, <span class="number">8</span>)   = <span class="string">"abzzzz"</span></span><br><span class="line">StringUtils.overlay(<span class="string">"abcdef"</span>, <span class="string">"zzzz"</span>, -<span class="number">2</span>, -<span class="number">3</span>) = <span class="string">"zzzzabcdef"</span></span><br><span class="line">StringUtils.overlay(<span class="string">"abcdef"</span>, <span class="string">"zzzz"</span>, <span class="number">8</span>, <span class="number">10</span>)  = <span class="string">"abcdefzzzz"</span></span><br></pre></td></tr></table></figure><h2 id="反转函数"><a href="#反转函数" class="headerlink" title="反转函数"></a>反转函数</h2><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reverse(String str)</span><br><span class="line">reverseDelimited(String str, <span class="keyword">char</span> separatorChar)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.reverse(<span class="string">"bat"</span>) = <span class="string">"tab"</span></span><br><span class="line">StringUtils.reverseDelimited(<span class="string">"a.b.c"</span>, <span class="string">'x'</span>) = <span class="string">"a.b.c"</span></span><br><span class="line">StringUtils.reverseDelimited(<span class="string">"a.b.c"</span>, <span class="string">"."</span>) = <span class="string">"c.b.a"</span></span><br></pre></td></tr></table></figure><h2 id="分隔函数"><a href="#分隔函数" class="headerlink" title="分隔函数"></a>分隔函数</h2><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">split(String str)</span><br><span class="line">split(String str, <span class="keyword">char</span> separatorChar)</span><br><span class="line">split(String str, String separatorChars)</span><br><span class="line">split(String str, String separatorChars, <span class="keyword">int</span> max)</span><br><span class="line">splitByCharacterType(String str)</span><br><span class="line">splitByCharacterTypeCamelCase(String str)</span><br><span class="line">splitByWholeSeparator(String str, String separator)</span><br><span class="line">splitByWholeSeparator(String str, String separator, <span class="keyword">int</span> max)</span><br><span class="line">splitByWholeSeparatorPreserveAllTokens(String str, String separator)</span><br><span class="line">splitByWholeSeparatorPreserveAllTokens(String str, String separator, <span class="keyword">int</span> max)</span><br><span class="line">splitPreserveAllTokens(String str)</span><br><span class="line">splitPreserveAllTokens(String str, <span class="keyword">char</span> separatorChar)</span><br><span class="line">splitPreserveAllTokens(String str, String separatorChars)</span><br><span class="line">splitPreserveAllTokens(String str, String separatorChars, <span class="keyword">int</span> max)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用空白符做空格</span></span><br><span class="line">StringUtils.split(<span class="string">"abc def"</span>)  = [<span class="string">"abc"</span>, <span class="string">"def"</span>]</span><br><span class="line">StringUtils.split(<span class="string">"abc  def"</span>) = [<span class="string">"abc"</span>, <span class="string">"def"</span>]</span><br><span class="line">StringUtils.split(<span class="string">"a..b.c"</span>, <span class="string">'.'</span>)   = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//用字符分割</span></span><br><span class="line">StringUtils.split(<span class="string">"a:b:c"</span>, <span class="string">'.'</span>)    = [<span class="string">"a:b:c"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//0 或者负数代表没有限制</span></span><br><span class="line">StringUtils.split(<span class="string">"ab:cd:ef"</span>, <span class="string">":"</span>, <span class="number">0</span>)    = [<span class="string">"ab"</span>, <span class="string">"cd"</span>, <span class="string">"ef"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//分割字符串 ,可以设定得到数组的长度，限定为2</span></span><br><span class="line">StringUtils.split(<span class="string">"ab:cd:ef"</span>, <span class="string">":"</span>, <span class="number">2</span>)    = [<span class="string">"ab"</span>, <span class="string">"cd:ef"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//null也可以作为分隔</span></span><br><span class="line">StringUtils.splitByWholeSeparator(<span class="string">"ab de fg"</span>, <span class="keyword">null</span>)      = [<span class="string">"ab"</span>, <span class="string">"de"</span>, <span class="string">"fg"</span>]</span><br><span class="line">StringUtils.splitByWholeSeparator(<span class="string">"ab   de fg"</span>, <span class="keyword">null</span>)    = [<span class="string">"ab"</span>, <span class="string">"de"</span>, <span class="string">"fg"</span>]</span><br><span class="line">StringUtils.splitByWholeSeparator(<span class="string">"ab:cd:ef"</span>, <span class="string">":"</span>)       = [<span class="string">"ab"</span>, <span class="string">"cd"</span>, <span class="string">"ef"</span>]</span><br><span class="line">StringUtils.splitByWholeSeparator(<span class="string">"ab-!-cd-!-ef"</span>, <span class="string">"-!-"</span>) = [<span class="string">"ab"</span>, <span class="string">"cd"</span>, <span class="string">"ef"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//带有限定长度的分隔</span></span><br><span class="line">StringUtils.splitByWholeSeparator(<span class="string">"ab:cd:ef"</span>, <span class="string">":"</span>, <span class="number">2</span>)       = [<span class="string">"ab"</span>, <span class="string">"cd:ef"</span>]</span><br></pre></td></tr></table></figure><h2 id="合并函数"><a href="#合并函数" class="headerlink" title="合并函数"></a>合并函数</h2><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">join(<span class="keyword">byte</span>[] array,<span class="keyword">char</span> separator)</span><br><span class="line">join(Object[] array,<span class="keyword">char</span> separator)</span><br><span class="line">join(Object[] array,<span class="keyword">char</span> separator,<span class="keyword">int</span> startIndex,<span class="keyword">int</span> endIndex)</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只有一个参数的join，简单合并在一起</span></span><br><span class="line">StringUtils.join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]) = <span class="string">"abc"</span></span><br><span class="line">StringUtils.join([<span class="keyword">null</span>, <span class="string">""</span>, <span class="string">"a"</span>]) = <span class="string">"a"</span>    </span><br><span class="line"></span><br><span class="line"><span class="comment">//null的话，就是把字符合并在一起</span></span><br><span class="line">StringUtils.join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="keyword">null</span>) = <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从index为0到3合并，注意是排除3的</span></span><br><span class="line">StringUtils.join([<span class="keyword">null</span>, <span class="string">""</span>, <span class="string">"a"</span>], <span class="string">','</span>, <span class="number">0</span>, <span class="number">3</span>)   = <span class="string">",,a"</span></span><br><span class="line">StringUtils.join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">"--"</span>, <span class="number">0</span>, <span class="number">3</span>)  = <span class="string">"a--b--c"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从index为1到3合并，注意是排除3的</span></span><br><span class="line">StringUtils.join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">"--"</span>, <span class="number">1</span>, <span class="number">3</span>)  = <span class="string">"b--c"</span></span><br><span class="line">StringUtils.join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">"--"</span>, <span class="number">2</span>, <span class="number">3</span>)  = <span class="string">"c"</span></span><br></pre></td></tr></table></figure><h2 id="大小写转换和判断"><a href="#大小写转换和判断" class="headerlink" title="大小写转换和判断"></a>大小写转换和判断</h2><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.capitalize(String str)</span><br><span class="line">StringUtils.uncapitalize(String str)</span><br><span class="line">StringUtils.upperCase(String str)</span><br><span class="line">StringUtils.upperCase(String str,Locale locale)</span><br><span class="line">StringUtils.lowerCase(String str)</span><br><span class="line">StringUtils.lowerCase(String str,Locale locale)</span><br><span class="line">StringUtils.swapCase(String str)</span><br><span class="line"></span><br><span class="line">StringUtils.isAllUpperCase(CharSequence cs)</span><br><span class="line">StringUtils.isAllLowerCase(CharSequence cs)</span><br></pre></td></tr></table></figure><p>大小写转换：</p><ul><li><code>capitalize</code> 首字母大写</li><li><code>upperCase</code> 全部转化为大写</li><li><code>swapCase</code> 大小写互转</li></ul><p>大小写判断：</p><ul><li><code>isAllUpperCase</code> 是否全部大写</li><li><code>isAllLowerCase</code> 是否全部小写</li></ul><h2 id="缩短省略函数"><a href="#缩短省略函数" class="headerlink" title="缩短省略函数"></a>缩短省略函数</h2><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abbreviate(String str, <span class="keyword">int</span> maxWidth)</span><br><span class="line">abbreviate(String str, <span class="keyword">int</span> offset, <span class="keyword">int</span> maxWidth)</span><br><span class="line">abbreviateMiddle(String str, String middle, <span class="keyword">int</span> length)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.abbreviate(<span class="string">"abcdefg"</span>, <span class="number">6</span>) = <span class="string">"abc..."</span></span><br><span class="line">StringUtils.abbreviate(<span class="string">"abcdefg"</span>, <span class="number">7</span>) = <span class="string">"abcdefg"</span></span><br><span class="line">StringUtils.abbreviate(<span class="string">"abcdefg"</span>, <span class="number">8</span>) = <span class="string">"abcdefg"</span></span><br><span class="line">StringUtils.abbreviate(<span class="string">"abcdefg"</span>, <span class="number">4</span>) = <span class="string">"a..."</span></span><br><span class="line">StringUtils.abbreviate(<span class="string">"abcdefg"</span>, <span class="number">3</span>) = IllegalArgumentException</span><br><span class="line"></span><br><span class="line">StringUtils.abbreviate(<span class="string">"abcdefghijklmno"</span>, <span class="number">6</span>, <span class="number">10</span>)  = <span class="string">"...ghij..."</span></span><br><span class="line"></span><br><span class="line">StringUtils.abbreviateMiddle(<span class="string">"abcdef"</span>, <span class="string">"."</span>, <span class="number">4</span>)     = <span class="string">"ab.f"</span></span><br></pre></td></tr></table></figure><p>字符串的长度小于或等于最大长度，返回该字符串。</p><p>运算规律：<code>(substring(str, 0, max-3) + “…”)</code></p><p>如果最大长度小于 4，则抛出异常 <code>IllegalArgumentException</code>。</p><h2 id="相似度函数"><a href="#相似度函数" class="headerlink" title="相似度函数"></a>相似度函数</h2><p>API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">difference(String str1,String str2)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在str1中寻找str2中没有的的字符串，并返回     </span></span><br><span class="line">StringUtils.difference(<span class="string">""</span>, <span class="string">"abc"</span>) = <span class="string">"abc"</span></span><br><span class="line">StringUtils.difference(<span class="string">"abc"</span>, <span class="string">""</span>) = <span class="string">""</span></span><br><span class="line">StringUtils.difference(<span class="string">"abc"</span>, <span class="string">"abc"</span>) = <span class="string">""</span></span><br><span class="line">StringUtils.difference(<span class="string">"abc"</span>, <span class="string">"ab"</span>) = <span class="string">""</span></span><br><span class="line">StringUtils.difference(<span class="string">"ab"</span>, <span class="string">"abxyz"</span>) = <span class="string">"xyz"</span></span><br><span class="line">StringUtils.difference(<span class="string">"abcde"</span>, <span class="string">"abxyz"</span>) = <span class="string">"xyz"</span></span><br><span class="line">StringUtils.difference(<span class="string">"abcde"</span>, <span class="string">"xyz"</span>) = <span class="string">"xyz"</span></span><br></pre></td></tr></table></figure><p><img src="/img/java/commons/commons-lang/difference.png" alt="difference"></p><h1 id="BooleanUtils"><a href="#BooleanUtils" class="headerlink" title="BooleanUtils"></a>BooleanUtils</h1><p><img src="/img/java/commons/commons-lang/BooleanUtils.png" alt="BooleanUtils"></p><h1 id="ArrayUtils"><a href="#ArrayUtils" class="headerlink" title="ArrayUtils"></a>ArrayUtils</h1><h2 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h2><p>add(boolean[] array,boolean element)<br>add(T[] array,int index,T element)<br>addAll(boolean[] array1,boolean… array2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素到数组中        </span></span><br><span class="line">ArrayUtils.add([<span class="keyword">true</span>, <span class="keyword">false</span>], <span class="keyword">true</span>) = [<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>]    </span><br><span class="line"></span><br><span class="line"><span class="comment">//将元素插入到指定位置的数组中</span></span><br><span class="line">ArrayUtils.add([<span class="string">"a"</span>], <span class="number">1</span>, <span class="keyword">null</span>)     = [<span class="string">"a"</span>, <span class="keyword">null</span>]</span><br><span class="line">ArrayUtils.add([<span class="string">"a"</span>], <span class="number">1</span>, <span class="string">"b"</span>)      = [<span class="string">"a"</span>, <span class="string">"b"</span>]</span><br><span class="line">ArrayUtils.add([<span class="string">"a"</span>, <span class="string">"b"</span>], <span class="number">3</span>, <span class="string">"c"</span>) = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]</span><br><span class="line">ArrayUtils.add([<span class="string">"a"</span>, <span class="string">"b"</span>], [<span class="string">"c"</span>, <span class="string">"d"</span>]) = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>,<span class="string">"d"</span>]</span><br></pre></td></tr></table></figure><h2 id="克隆方法"><a href="#克隆方法" class="headerlink" title="克隆方法"></a>克隆方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayUtils.clone(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;); = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="包含方法"><a href="#包含方法" class="headerlink" title="包含方法"></a>包含方法</h2><p>contains(boolean[] array,boolean valueToFind)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询某个Object是否在数组中</span></span><br><span class="line">ArrayUtils.contains(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span> &#125;, <span class="number">1</span>); =  <span class="keyword">true</span></span><br></pre></td></tr></table></figure><h2 id="获取长度方法"><a href="#获取长度方法" class="headerlink" title="获取长度方法"></a>获取长度方法</h2><p>getLength(Object array)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayUtils.getLength([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]) = <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="获取索引方法"><a href="#获取索引方法" class="headerlink" title="获取索引方法"></a>获取索引方法</h2><p>indexOf(boolean[] array,boolean valueToFind)<br>indexOf(boolean[] array,boolean valueToFind,int startIndex)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查询某个Object在数组中的位置,可以指定起始搜索位置,找不到返回-1</span></span><br><span class="line"><span class="comment">//从正序开始搜索,搜到就返回当前的index否则返回-1</span></span><br><span class="line">ArrayUtils.indexOf(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span> &#125;, <span class="number">6</span>); =  <span class="number">2</span></span><br><span class="line">ArrayUtils.indexOf(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span> &#125;, <span class="number">2</span>); =  -<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从逆序开始搜索,搜到就返回当前的index,否则返回-1</span></span><br><span class="line">ArrayUtils.lastIndexOf(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span> &#125;, <span class="number">6</span>); =  <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从逆序索引为2开始搜索,,搜到就返回当前的index,否则返回-1</span></span><br><span class="line">ArrayUtils.lastIndexOf(<span class="keyword">new</span> Object[]&#123;<span class="string">"33"</span>,<span class="string">"yy"</span>,<span class="string">"uu"</span>&#125;, <span class="string">"33"</span>,<span class="number">2</span> ) = <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="判空方法"><a href="#判空方法" class="headerlink" title="判空方法"></a>判空方法</h2><p>isEmpty(boolean[] array)等等<br>isNotEmpty(T[] array)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断数组是否为空(null和length=0的时候都为空)</span></span><br><span class="line">ArrayUtils.isEmpty(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>]); =  <span class="keyword">true</span></span><br><span class="line">ArrayUtils.isEmpty(<span class="keyword">new</span> Object[] &#123; <span class="keyword">null</span> &#125;); = <span class="keyword">false</span></span><br></pre></td></tr></table></figure><h2 id="长度相等判断方法"><a href="#长度相等判断方法" class="headerlink" title="长度相等判断方法"></a>长度相等判断方法</h2><p>isSameLength(boolean[] array1,boolean[] array2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断两个数组的长度是否相等</span></span><br><span class="line">ArrayUtils.isSameLength(<span class="keyword">new</span> Integer[] &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span> &#125;, <span class="keyword">new</span> Long[] &#123; <span class="string">"1"</span>, <span class="string">"3"</span>, <span class="string">"5"</span>&#125;); = <span class="keyword">true</span></span><br></pre></td></tr></table></figure><h2 id="空数组转换"><a href="#空数组转换" class="headerlink" title="空数组转换"></a>空数组转换</h2><p>nullToEmpty(Object[] array)等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//讲null转化为相应数组</span></span><br><span class="line"><span class="keyword">int</span> [] arr1 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> [] arr2 = ArrayUtils.nullToEmpty(arr1);</span><br></pre></td></tr></table></figure><h2 id="删除元素方法"><a href="#删除元素方法" class="headerlink" title="删除元素方法"></a>删除元素方法</h2><p>remove(boolean[] array,int index)等等<br>removeElement(boolean[] array,boolean element)<br>removeAll(T[] array,int… indices)<br>removeElements(T[] array,T… values)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除指定下标的元素        </span></span><br><span class="line">ArrayUtils.remove([<span class="keyword">true</span>, <span class="keyword">false</span>], <span class="number">1</span>)       = [<span class="keyword">true</span>]</span><br><span class="line">ArrayUtils.remove([<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>], <span class="number">1</span>) = [<span class="keyword">true</span>, <span class="keyword">false</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第一次出现的元素</span></span><br><span class="line">ArrayUtils.removeElement([<span class="keyword">true</span>, <span class="keyword">false</span>], <span class="keyword">false</span>)      = [<span class="keyword">true</span>]</span><br><span class="line">ArrayUtils.removeElement([<span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>], <span class="keyword">true</span>) = [<span class="keyword">false</span>, <span class="keyword">true</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有出现的下标的元素</span></span><br><span class="line">ArrayUtils.removeAll([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="number">0</span>, <span class="number">2</span>) = [<span class="string">"b"</span>]</span><br><span class="line">ArrayUtils.removeAll([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="number">1</span>, <span class="number">2</span>) = [<span class="string">"a"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除数组出现的所有元素</span></span><br><span class="line">ArrayUtils.removeElements([<span class="string">"a"</span>, <span class="string">"b"</span>], <span class="string">"a"</span>, <span class="string">"c"</span>)      = [<span class="string">"b"</span>]</span><br><span class="line">ArrayUtils.removeElements([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>], <span class="string">"a"</span>)      = [<span class="string">"b"</span>, <span class="string">"a"</span>]</span><br><span class="line">ArrayUtils.removeElements([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>], <span class="string">"a"</span>, <span class="string">"a"</span>) = [<span class="string">"b"</span>]</span><br></pre></td></tr></table></figure><h2 id="反转方法"><a href="#反转方法" class="headerlink" title="反转方法"></a>反转方法</h2><p>reverse(boolean[] array)等等<br>reverse(boolean[] array,int startIndexInclusive,int endIndexExclusive)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反转数组</span></span><br><span class="line"><span class="keyword">int</span>[] array =<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line">ArrayUtils.reverse(array);<span class="comment">// &#123;5,2,1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定范围的反转数组，排除endIndexExclusive的</span></span><br><span class="line"><span class="keyword">int</span>[] array =<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span> ,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">ArrayUtils.reverse(array,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">System.out.println(ArrayUtils.toString(array)); = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="截取数组"><a href="#截取数组" class="headerlink" title="截取数组"></a>截取数组</h2><p>subarray(boolean[] array,int startIndexInclusive,int endIndexExclusive)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//起始index为2(即第三个数据)结束index为4的数组</span></span><br><span class="line">ArrayUtils.subarray(newint[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span> &#125;, <span class="number">2</span>, <span class="number">4</span>); =  &#123;<span class="number">1</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">//如果endIndex大于数组的长度,则取beginIndex之后的所有数据</span></span><br><span class="line">ArrayUtils.subarray(newint[] &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span> &#125;, <span class="number">2</span>, <span class="number">10</span>); =  &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="打印数组方法"><a href="#打印数组方法" class="headerlink" title="打印数组方法"></a>打印数组方法</h2><p>toString(Object array)<br>toString(Object array,String stringIfNull)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印数组</span></span><br><span class="line">ArrayUtils.toString(newint[] &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span> &#125;); =  &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">ArrayUtils.toString(<span class="keyword">new</span> Integer[] &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span> &#125;); =  &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">//如果为空，返回默认信息</span></span><br><span class="line">ArrayUtils.toString(<span class="keyword">null</span>, <span class="string">"I'm nothing!"</span>); =  I<span class="string">'m nothing!</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://commons.apache.org/" target="_blank" rel="noopener">https://commons.apache.org/</a></p><p><a href="https://www.tutorialspoint.com/commons_collections/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/commons_collections/index.htm</a></p><p><a href="https://www.tutorialspoint.com/commons_io/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/commons_io/index.htm</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo 协议小结</title>
      <link href="2017/11/24/dubbo-protocol/"/>
      <url>2017/11/24/dubbo-protocol/</url>
      
        <content type="html"><![CDATA[<h1 id="RPC-框架对比"><a href="#RPC-框架对比" class="headerlink" title="RPC 框架对比"></a>RPC 框架对比</h1><p>市面上的 RPC 框架功能比较：</p><p><img src="/img/dubbo/rpc_framework_compare.png" alt="RPC框架功能比较"></p><h1 id="协议对比"><a href="#协议对比" class="headerlink" title="协议对比"></a>协议对比</h1><table><thead><tr><th></th><th>连接个数</th><th>连接方式</th><th>传输协议</th><th>传输方式</th><th>序列化</th><th>适用范围</th><th>适用场景</th><th>参考</th></tr></thead><tbody><tr><td><code>dubbo://</code></td><td>单连接</td><td>长连接</td><td>TCP</td><td>NIO 异步传输</td><td>Hessian 二进制序列化</td><td>传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用 dubbo 协议传输大文件或超大字符串。</td><td>常规远程服务方法调用</td><td><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/dubbo.html" target="_blank" rel="noopener">dubbo</a></td></tr><tr><td><code>rmi://</code></td><td>多连接</td><td>短连接</td><td>TCP</td><td>同步传输</td><td>Java 标准二进制序列化</td><td>传入传出参数数据包大小混合，消费者与提供者个数差不多，可传文件。</td><td>常规远程服务方法调用，与原生RMI服务互操作</td><td></td></tr><tr><td><code>hessian://</code></td><td>多连接</td><td>短连接</td><td>HTTP</td><td>同步传输</td><td>Hessian二进制序列化</td><td>传入传出参数数据包较大，提供者比消费者个数多，提供者压力较大，可传文件。</td><td>页面传输，文件传输，或与原生hessian服务互操作</td><td><a href="http://hessian.caucho.com/" target="_blank" rel="noopener">hession</a></td></tr><tr><td><code>http://</code></td><td>多连接</td><td>短连接</td><td>HTTP</td><td>同步传输</td><td>表单序列化</td><td>传入传出参数数据包大小混合，提供者比消费者个数多，可用浏览器查看，可用表单或URL传入参数，暂不支持传文件。</td><td>需同时给应用程序和浏览器 JS 使用的服务。</td><td></td></tr><tr><td><code>webservice://</code></td><td>多连接</td><td>短连接</td><td>HTTP</td><td>同步传输</td><td>SOAP 文本序列化</td><td></td><td>系统集成，跨语言调用</td><td><a href="http://cxf.apache.org/" target="_blank" rel="noopener">Apache CXF</a></td></tr><tr><td><code>thrift://</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td><a href="http://thrift.apache.org/" target="_blank" rel="noopener">Thrift</a></td></tr><tr><td><code>memcached://</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>redis://</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>rest://</code></td><td>多连接</td><td>可长可短</td><td>HTTP</td><td>同步传输</td><td>JSON/XML</td><td></td><td></td><td><a href="https://github.com/jax-rs" target="_blank" rel="noopener">JAX-RS</a></td></tr></tbody></table><h1 id="REST-协议小结"><a href="#REST-协议小结" class="headerlink" title="REST 协议小结"></a>REST 协议小结</h1><p>根据 dubbox、dubbo REST 官方文档，摘录了使用上的一些注意点：</p><h2 id="配置总览"><a href="#配置总览" class="headerlink" title="配置总览"></a>配置总览</h2><h3 id="服务提供端"><a href="#服务提供端" class="headerlink" title="服务提供端"></a>服务提供端</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rest"</span> <span class="attr">server</span>=<span class="string">""</span> <span class="attr">port</span>=<span class="string">""</span> <span class="attr">contextpath</span>=<span class="string">""</span> <span class="attr">threads</span>=<span class="string">""</span> <span class="attr">iothreads</span>=<span class="string">""</span> <span class="attr">keepalive</span>=<span class="string">""</span> <span class="attr">accepts</span>=<span class="string">""</span> /&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>配置项</th><th>描述</th><th>生效范围</th></tr></thead><tbody><tr><td><code>name</code></td><td>启用 REST 协议</td><td>all</td></tr><tr><td><code>server</code></td><td>REST Server 的实现</td><td>all</td></tr><tr><td><code>port</code></td><td>端口号</td><td>all</td></tr><tr><td><code>contextpath</code></td><td>应用上下文路径</td><td>all</td></tr><tr><td><code>threads</code></td><td>线程池大小</td><td>jetty、netty、tomcat</td></tr><tr><td><code>iothreads</code></td><td>IO worker线程数</td><td>netty</td></tr><tr><td><code>keepalive</code></td><td>是否长连接，默认为 <code>true</code> 长连接</td><td>netty、tomcat</td></tr><tr><td><code>accepts</code></td><td>最大的HTTP连接数</td><td>tomcat</td></tr></tbody></table><p>目前在dubbo中支持5种嵌入式rest server的实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- rest协议默认选用jetty。jetty是非常成熟的java servlet容器，并和dubbo已经有较好的集成（目前5种嵌入式server中只有jetty、tomcat、tjws，与dubbo监控系统等完成了无缝的集成）。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rest"</span> <span class="attr">server</span>=<span class="string">"jetty"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在嵌入式tomcat上，REST的性能比jetty上要好得多（参见官网的基准测试），建议在需要高性能的场景下采用tomcat。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rest"</span> <span class="attr">server</span>=<span class="string">"tomcat"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rest"</span> <span class="attr">server</span>=<span class="string">"netty"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 轻量级嵌入式server，非常方便在集成测试中快速启动使用，当然也可以在负荷不高的生产环境中使用。注意，tjws is now deprecated --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rest"</span> <span class="attr">server</span>=<span class="string">"tjws"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rest"</span> <span class="attr">server</span>=<span class="string">"sunhttp"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>同时也支持采用外部应用服务器来做rest server的实现：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web.xml 参考官网 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rest"</span> <span class="attr">server</span>=<span class="string">"servlet"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="服务消费端"><a href="#服务消费端" class="headerlink" title="服务消费端"></a>服务消费端</h3><p>如果REST服务的消费端也是dubbo系统，可以配置每个消费端的超时时间和HTTP连接数，详情参考官方文档。</p><h2 id="REST-服务提供端"><a href="#REST-服务提供端" class="headerlink" title="REST 服务提供端"></a>REST 服务提供端</h2><h3 id="标准-Java-REST-API：JAX-RS"><a href="#标准-Java-REST-API：JAX-RS" class="headerlink" title="标准 Java REST API：JAX-RS"></a>标准 Java REST API：JAX-RS</h3><ul><li>Dubbox 基于标准的 Java REST API——JAX-RS 2.0（Java API for RESTful Web Services 的简写），提供了接近透明的REST调用支持。由于完全兼容Java标准API，所以为dubbo开发的所有REST服务，未来脱离dubbo或者任何特定的REST底层实现一般也可以正常运行。</li><li>Dubbo的REST调用和dubbo中其它某些RPC不同的是，需要在服务代码中添加JAX-RS的annotation（以及JAXB、Jackson的annotation），如果你觉得这些annotation一定程度“污染”了你的服务代码，你可以考虑编写额外的Facade和DTO类，在Facade和DTO上添加annotation，而Facade将调用转发给真正的服务实现类。当然事实上，直接在服务代码中添加annotation基本没有任何负面作用，而且这本身是Java EE的标准用法，另外JAX-RS和JAXB的annotation是属于java标准，比我们经常使用的spring、dubbo等等annotation更没有vendor lock-in的问题，所以一般没有必要因此而引入额外对象。</li><li>JAX-RS与Spring MVC的对比：<ul><li>JAX-RS 相对更适合纯粹的服务化应用，也就是传统Java EE中所说的中间层服务。</li><li>在dubbo应用中，我想很多人都比较喜欢直接将一个本地的spring service bean（或者叫manager之类的）完全透明的发布成远程服务，则这里用JAX-RS是更自然更直接的，不必额外的引入MVC概念。</li></ul></li><li>就学习 JAX-RS 来说，一般主要掌握其各种 annotation 的用法即可。参考：<ul><li><a href="http://docs.oracle.com/javaee/7/tutorial/doc/jaxrs.htm" target="_blank" rel="noopener">http://docs.oracle.com/javaee/7/tutorial/doc/jaxrs.htm</a></li><li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-jaxrs/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/java/j-lo-jaxrs/</a></li></ul></li></ul><h3 id="HTTP-POST-GET-的实现"><a href="#HTTP-POST-GET-的实现" class="headerlink" title="HTTP POST/GET 的实现"></a>HTTP POST/GET 的实现</h3><ul><li>REST服务中虽然建议使用HTTP协议中四种标准方法POST、DELETE、PUT、GET来分别实现常见的“增删改查”，但实际中，我们一般情况直接用POST来实现“增改”，GET来实现“删查”即可（DELETE和PUT甚至会被一些防火墙阻挡）。</li></ul><h3 id="JSON、XML-等多数据格式的支持"><a href="#JSON、XML-等多数据格式的支持" class="headerlink" title="JSON、XML 等多数据格式的支持"></a>JSON、XML 等多数据格式的支持</h3><ul><li>在一个REST服务同时对多种数据格式支持的情况下，根据JAX-RS标准，一般是通过HTTP中的MIME header（content-type和accept）来指定当前想用的是哪种格式的数据。</li><li>目前业界普遍使用的方式，是使用一个URL后缀（.json和.xml）来指定想用的数据格式。比用HTTP Header更简单直观。Twitter、微博等的REST API都是采用这种方式。</li></ul><h3 id="定制序列化"><a href="#定制序列化" class="headerlink" title="定制序列化"></a>定制序列化</h3><ul><li>Dubbo中的REST实现是用JAXB做XML序列化，用Jackson做JSON序列化，所以在对象上添加JAXB或Jackson的annotation即可以定制映射。更多资料请参考JAXB和Jackson的官方文档。</li><li>由于JAX-RS的实现一般都用标准的JAXB（Java API for XML Binding）来序列化和反序列化XML格式数据，所以我们需要为每一个要用XML传输的对象添加一个类级别的JAXB annotation <code>@XmlRootElement</code>，否则序列化将报错。</li></ul><h3 id="添加自定义的-Filter、Interceptor-等"><a href="#添加自定义的-Filter、Interceptor-等" class="headerlink" title="添加自定义的 Filter、Interceptor 等"></a>添加自定义的 Filter、Interceptor 等</h3><ul><li>JAX-RS标准的 <code>Filter</code> 和 <code>Interceptor</code> 可以对请求与响应过程做定制化的拦截处理。</li></ul><h3 id="添加自定义的-Exception-处理"><a href="#添加自定义的-Exception-处理" class="headerlink" title="添加自定义的 Exception 处理"></a>添加自定义的 Exception 处理</h3><ul><li>JAX-RS标准的 <code>ExceptionMapper</code>，可以用来定制特定exception发生后应该返回的HTTP响应。</li></ul><h2 id="REST-服务消费端"><a href="#REST-服务消费端" class="headerlink" title="REST 服务消费端"></a>REST 服务消费端</h2><h3 id="场景1：非-dubbo-的消费端调用-dubbo-的-REST-服务（non-dubbo-gt-dubbo）"><a href="#场景1：非-dubbo-的消费端调用-dubbo-的-REST-服务（non-dubbo-gt-dubbo）" class="headerlink" title="场景1：非 dubbo 的消费端调用 dubbo 的 REST 服务（non-dubbo &gt; dubbo）"></a>场景1：非 dubbo 的消费端调用 dubbo 的 REST 服务（non-dubbo &gt; dubbo）</h3><ul><li>使用标准的JAX-RS Client API或者特定REST实现的Client API来调用REST服务。当然，在java中也可以直接用自己熟悉的比如HttpClient，FastJson，XStream等等各种不同技术来实现REST客户端。</li></ul><h3 id="场景2：dubbo-消费端调用-dubbo-的-REST-服务（dubbo-gt-dubbo）"><a href="#场景2：dubbo-消费端调用-dubbo-的-REST-服务（dubbo-gt-dubbo）" class="headerlink" title="场景2：dubbo 消费端调用 dubbo 的 REST 服务（dubbo &gt; dubbo）"></a>场景2：dubbo 消费端调用 dubbo 的 REST 服务（dubbo &gt; dubbo）</h3><ul><li>dubbo消费端调用dubbo的REST服务，这种场景下必须把JAX-RS的annotation添加到服务接口上，这样在dubbo在消费端才能共享相应的REST配置信息，并据之做远程调用。</li><li>dubbo的REST支持采用Java标准的<a href="http://beanvalidation.org/" target="_blank" rel="noopener">bean validation annotation（JSR 303)</a>来做输入校验。为了和其他dubbo远程调用协议保持一致，在rest中作校验的annotation必须放在服务的接口上，这样至少有一个好处是，dubbo的消费端可以共享这个接口的信息，dubbo消费端甚至不需要做远程调用，在本地就可以完成输入校验。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://dubbo.apache.org/zh-cn/docs/user/references/protocol/rest.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/references/protocol/rest.html</a></p><p><a href="https://github.com/dangdangdotcom/dubbox" target="_blank" rel="noopener">https://github.com/dangdangdotcom/dubbox</a></p><p><a href="https://dangdangdotcom.github.io/dubbox/rest.html" target="_blank" rel="noopener">https://dangdangdotcom.github.io/dubbox/rest.html</a></p><p><a href="https://mvnrepository.com/artifact/com.gaosi/dubbox" target="_blank" rel="noopener">https://mvnrepository.com/artifact/com.gaosi/dubbox</a></p><p>Dubbox fork from Dubbo，目前只发布了一个版本：2.8.4</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo 配置小结</title>
      <link href="2017/11/15/dubbo-config/"/>
      <url>2017/11/15/dubbo-config/</url>
      
        <content type="html"><![CDATA[<p>本文主要总结 Dubbo 日常使用时的一些常用配置。</p><h1 id="配置之间的关系"><a href="#配置之间的关系" class="headerlink" title="配置之间的关系"></a>配置之间的关系</h1><p><img src="/img/dubbo/dubbo-config.jpg" alt="配置之间的关系"></p><table><thead><tr><th>XML 配置</th><th>Java Config 配置</th><th>配置</th><th>解释</th></tr></thead><tbody><tr><td><code>&lt;dubbo:application/&gt;</code></td><td><code>com.alibaba.dubbo.config.ApplicationConfig</code></td><td>应用配置</td><td>用于配置当前应用信息，不管该应用是提供者还是消费者</td></tr><tr><td><code>&lt;dubbo:registry/&gt;</code></td><td><code>com.alibaba.dubbo.config.RegistryConfig</code></td><td>注册中心配置</td><td>用于配置连接注册中心相关信息</td></tr><tr><td><code>&lt;dubbo:monitor/&gt;</code></td><td><code>com.alibaba.dubbo.config.MonitorConfig</code></td><td>监控中心配置</td><td>用于配置连接监控中心相关信息，可选</td></tr><tr><td><code>&lt;dubbo:protocol/&gt;</code></td><td><code>com.alibaba.dubbo.config.ProtocolConfig</code></td><td>协议配置</td><td>用于配置提供服务的协议信息，协议由提供方指定，消费方<strong>被动接受</strong></td></tr><tr><td><code>&lt;dubbo:provider/&gt;</code></td><td><code>com.alibaba.dubbo.config.ProviderConfig</code></td><td>提供方配置</td><td>当 <code>ProtocolConfig</code> 和 <code>ServiceConfig</code> 某属性没有配置时，采用此缺省值，可选</td></tr><tr><td><code>&lt;dubbo:service/&gt;</code></td><td><code>com.alibaba.dubbo.config.ServiceConfig</code></td><td>服务配置</td><td>用于暴露一个服务，定义服务的元信息，一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心。对应注解：<code>@Service</code></td></tr><tr><td><code>&lt;dubbo:consumer/&gt;</code></td><td><code>com.alibaba.dubbo.config.ConsumerConfig</code></td><td>消费方配置</td><td>当 <code>ReferenceConfig</code> 某属性没有配置时，采用此缺省值，可选</td></tr><tr><td><code>&lt;dubbo:reference/&gt;</code></td><td><code>com.alibaba.dubbo.config.ReferenceConfig</code></td><td>引用配置</td><td>用于创建一个远程服务代理，一个引用可以指向多个注册中心。对应注解：<code>@Reference</code></td></tr><tr><td><code>&lt;dubbo:method/&gt;</code></td><td><code>com.alibaba.dubbo.config.MethodConfig</code></td><td>方法配置</td><td>用于 <code>ServiceConfig</code> 和 <code>ReferenceConfig</code> 指定方法级的配置信息</td></tr><tr><td><code>&lt;dubbo:argument/&gt;</code></td><td><code>com.alibaba.dubbo.config.ArgumentConfig</code></td><td>参数配置</td><td>用于指定方法参数配置</td></tr><tr><td><code>&lt;dubbo:module/&gt;</code></td><td><code>com.alibaba.dubbo.config.ModuleConfig</code></td><td>模块配置</td><td>用于配置当前模块信息，可选</td></tr></tbody></table><p>下面是一些 dubbo 配置的总结：</p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p><img src="/img/dubbo/dubbo_protocol.png" alt=""></p><h2 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h2><p><img src="/img/dubbo/provider.png" alt=""></p><h2 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h2><p><img src="/img/dubbo/consumer.png" alt=""></p><h1 id="配置覆盖关系"><a href="#配置覆盖关系" class="headerlink" title="配置覆盖关系"></a>配置覆盖关系</h1><p>配置覆盖关系：</p><ul><li>方法级优先，接口级次之，全局配置再次之。</li><li>如果级别一样，则消费方优先，提供方次之。</li></ul><p>规则二是指，所有配置最终都将转换为 URL 表示，并由服务提供方生成，经注册中心传递给消费方。其 URL 格式如下：<code>protocol://username:password@host:port/path?key=value&amp;key=value</code></p><p><img src="/img/dubbo/dubbo-config-override.jpg" alt="dubbo 配置覆盖关系"></p><p>参考：<a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/xml.html" target="_blank" rel="noopener">XML 配置</a>。</p><h1 id="属性配置关系"><a href="#属性配置关系" class="headerlink" title="属性配置关系"></a>属性配置关系</h1><p><img src="/img/dubbo/dubbo-properties-override.jpg" alt="dubbo 属性覆盖关系"></p><p>参考：<a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/properties.html" target="_blank" rel="noopener">属性配置</a></p><h1 id="注解配置实践"><a href="#注解配置实践" class="headerlink" title="注解配置实践"></a>注解配置实践</h1><p>如果想用现代的 Java Config 替代传统的 XML 配置方式，配置如下：</p><h2 id="声明组件"><a href="#声明组件" class="headerlink" title="声明组件"></a>声明组件</h2><ul><li><p>服务提供方使用 <code>@Service</code> 注解暴露服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Service</span>(timeout = <span class="number">5000</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotateServiceImpl</span> <span class="keyword">implements</span> <span class="title">AnnotateService</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>服务消费方使用 <code>@Reference</code> 注解引用服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConsumeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">public</span> AnnotateService annotateService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="开启组件扫描"><a href="#开启组件扫描" class="headerlink" title="开启组件扫描"></a>开启组件扫描</h2><ul><li>2.5.7 (Nov, 2017) 以上版本，使用 <code>@DubboComponentScan</code> 指定 dubbo 组件扫描路径</li><li>老版本或 Dubbox，使用：<code>&lt;dubbo:annotation package=&quot;com.alibaba.dubbo.test.service&quot; /&gt;</code></li></ul><h2 id="Java-Config-配置"><a href="#Java-Config-配置" class="headerlink" title="Java Config 配置"></a>Java Config 配置</h2><ul><li>使用 <code>@Configuration</code> 注解开启 Java Config 并使用 <code>@Bean</code> 进行公共模块的 bean 配置，参考：<a href="http://dubbo.apache.org/zh-cn/docs/user/configuration/api.html" target="_blank" rel="noopener">API配置</a>。</li></ul><h2 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h2><ul><li>最后开启 <code>@EnableDubboConfig</code></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="http://dubbo.apache.org/zh-cn/blog/dubbo-annotation.html" target="_blank" rel="noopener">在 Dubbo 中使用注解</a>》</p><p><a href="https://www.oschina.net/news/92687/dubbo-spring-boot-starter-1-0-0" target="_blank" rel="noopener">https://www.oschina.net/news/92687/dubbo-spring-boot-starter-1-0-0</a></p><p><a href="https://mvnrepository.com/artifact/com.alibaba.boot/dubbo-spring-boot-starter" target="_blank" rel="noopener">https://mvnrepository.com/artifact/com.alibaba.boot/dubbo-spring-boot-starter</a></p><p><a href="https://mvnrepository.com/artifact/com.alibaba/dubbo" target="_blank" rel="noopener">https://mvnrepository.com/artifact/com.alibaba/dubbo</a></p><p><a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全专题分享</title>
      <link href="2017/10/16/security/"/>
      <url>2017/10/16/security/</url>
      
        <content type="html"><![CDATA[<p>本文总结的一些学习笔记，用于建立安全观。</p><h1 id="信任域与信任边界"><a href="#信任域与信任边界" class="headerlink" title="信任域与信任边界"></a>信任域与信任边界</h1><ul><li>首先，安全问题的本质，是<strong>信任</strong>。一旦我们作为决策依据的条件被打破、被绕过，那么就会导致安全假设的前提条件不再可靠，变成一个伪命题。因此，把握住信任条件的度，使其恰到好处，正是设计安全方案的难点所在，也是安全这门学问的艺术魅力所在。</li><li>通过一个安全检查（过滤、净化）的过程，可以梳理未知的人或物，使其变得可信任。被划分出来的具有不同信任级别的区域，我们称为<strong>信任域</strong>，划分两个不同信任域之间的边界，我们称为<strong>信任边界</strong>。</li><li>因为信任关系被破坏，从而产生了安全问题。我们可以通过信任域的划分、信任边界的确定，来发现问题是在何处产生的。</li><li>数据从高等级的信任域流向低等级的信任域，是不需要经过安全检查的；数据从低等级的信任域流向高等级的信任域，则需要经过信任边界的安全检查。</li></ul><h1 id="安全基本三要素（CIA）"><a href="#安全基本三要素（CIA）" class="headerlink" title="安全基本三要素（CIA）"></a>安全基本三要素（CIA）</h1><ul><li>机密性（Confidentiality）：要求保护数据内容不能泄露，常见手段是加密。</li><li>完整性（Integrity）：要求保护数据内容是完整、没有被篡改的。常见手段是数字签名。</li><li>可用性（Availability）：要求保护资源是“随需而得”。如拒绝服务攻击 （简称DoS，Denial of Service） 破坏的是安全的可用性。</li><li>不可抵赖性（Non-repudiation），防抵赖。常见手段是数字签名。</li><li>认证（Authentication）</li><li>授权（Authorization）</li></ul><h1 id="安全评估的四阶段"><a href="#安全评估的四阶段" class="headerlink" title="安全评估的四阶段"></a>安全评估的四阶段</h1><ol><li><p>资产等级划分：对资产进行等级划分，就是对数据做<strong>等级划分</strong>。当完成划分后，对要保护的目标数据已经有了一个大概的了解，接下来就是要划分信任域和信任边界了。</p></li><li><p>威胁分析：威胁（Threat）是指可能造成危害的来源。威胁分析即把所有的威胁都找出来。可以采用头脑风暴法。或采用 <strong>STRIDE</strong> 等模型。</p><p><img src="/img/security/STRIDE.png" alt="STRIDE"></p></li><li><p>风险分析：风险（Risk）是指可能会出现的损失。风险公式：<code>Risk = Probability * Damage Potential</code>，即影响风险高低的因素，除了造成损失的大小外，还需要考虑到发生的可能性。可以采用 <strong>DREAD</strong> 等模型。</p><p><img src="/img/security/DREAD.png" alt="DREAD"></p></li><li><p>确认解决方案</p></li></ol><h1 id="安全方案设计的四原则"><a href="#安全方案设计的四原则" class="headerlink" title="安全方案设计的四原则"></a>安全方案设计的四原则</h1><ul><li><strong>默认安全性原则（Secure by Default）</strong>，最基本也是最重要的原则。即：<ul><li>黑、白名单。随着防火墙、ACL 技术的兴起，使得直接暴露在互联网上的系统得到了保护。比如一个网站的数据库，在没有保护的情况下，数据库服务端口是允许任何人随意连接的；在有了防火墙的保护后，通过ACL可以控制只允许信任来源的访问。这些措施在很大程度上保证了系统软件处于信任边界之内，从而杜绝了大部分的攻击来源。因此如果更多地使用白名单（如防火墙、ACL），系统就会变得更安全。</li><li>最小权限原则。安全设计的基本原则之一。最小权限原则要求系统只授予主体必要的权限，而不要过度授权，这样能有效地减少系统、网络、应用、数据库出错的机会。</li></ul></li><li><strong>纵深防御原则 （Defense in Depth）</strong>，其包含两层含义：<ul><li>首先，在各个不同层面、不同方面实施安全方案，避免出现疏漏，不同安全方案之间需要相互配合，构成一个整体；</li><li>其次，在正确的地方做正确的事情，即：在解决根本问题的地方实施针对性的安全方案。</li></ul></li><li><strong>数据与代码分离原则</strong><ul><li>适用于各种由于“注入”而引发的安全问题，如 XSS、SQL 注入、CRLF 注入、X-Path 注入。</li></ul></li><li><strong>不可预测性原则（Unpredictable）</strong><ul><li>能有效地对抗基于篡改、伪造（如 CSRF）的攻击，其实现往往需用到加密算法、随机数算法、哈希算法等。</li></ul></li></ul><p>总结这几条原则：</p><ul><li>Secure By Default：是时刻要牢记的原则；</li><li>纵深防御：是要更全面、更正确地看待问题；</li><li>数据与代码分离：是从漏洞成因上看问题；</li><li>不可预测性：则是从克服攻击方法的角度看问题。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>互联网安全的核心问题，是<strong>数据安全</strong>的问题。</p><p>《白帽子讲 Web 安全》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何开好会？</title>
      <link href="2017/09/11/how-to-run-a-meeting/"/>
      <url>2017/09/11/how-to-run-a-meeting/</url>
      
        <content type="html"><![CDATA[<p>开会是一门学问，也是管理的必经之路。这里总结一点开会的小心得，目的是提升工作效率。</p><p><img src="/img/management/how_to_run_a_meeting.png" alt="如何开好会？"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 条件化注解总结</title>
      <link href="2017/09/05/spring-conditional-bean/"/>
      <url>2017/09/05/spring-conditional-bean/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-4-0-引入的条件化注解"><a href="#Spring-4-0-引入的条件化注解" class="headerlink" title="Spring 4.0 引入的条件化注解"></a>Spring 4.0 引入的条件化注解</h1><blockquote><p>假设你希望一个或多个 bean 只有在应用的类路径下包含特定的库时才创建。或者我们希望某个 bean 只有当另外某个特定的 bean 也声明了之后才会创建。我们还可能要求只有某个特定的环境变量设置之后，才会创建某个 bean。<br>在 Spring 4 之前，很难实现这种级别的条件化配置，但是 Spring 4 引入了一个新的 <code>@Conditional</code> 注解，它可以用到带有 <code>@Bean</code> 注解的方法上。如果给定的条件计算结果为 <code>true</code>，就会创建这个 bean，否则的话，这个 bean 会被忽略。</p></blockquote><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Conditional.html" target="_blank" rel="noopener">@Conditional 注解</a>的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Conditional &#123;</span><br><span class="line">    Class&lt;? extends Condition&gt;[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Condition.html" target="_blank" rel="noopener">Condition 接口</a>的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext var1, AnnotatedTypeMetadata var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，通过 <code>Condition</code> 接口的入参 <code>ConditionContext</code>，我们可以做到如下几点：</p><ul><li>借助 <code>getRegistry()</code> 返回的 <code>BeanDefinitionRegistry</code> 检查 bean 定义；</li><li>借助 <code>getBeanFactory()</code> 返回的 <code>ConfigurableListableBeanFactory</code> 检查 bean 是否存在，甚至探查 bean 的属性；</li><li>借助 <code>getEnvironment()</code> 返回的 <code>Environment</code> 检查环境变量是否存在以及它的值是什么；</li><li>读取并探查 <code>getResourceLoader()</code> 返回的 <code>ResourceLoader</code> 所加载的资源；</li><li>借助 <code>getClassLoader()</code> 返回的 <code>ClassLoader</code> 加载并检查类是否存在。</li></ul><h2 id="环境与-profile"><a href="#环境与-profile" class="headerlink" title="环境与 profile"></a>环境与 profile</h2><p>在开发软件的时候，有一个很大的挑战就是将应用程序从一个环境迁移到另外一个环境。开发阶段中，某些环境相关做法可能并不适合迁移到生产环境中，甚至即便迁移过去也无法正常工作。跨环境部署时会发生变化的几个典型例子：</p><ul><li>数据库配置</li><li>加密算法</li><li>与外部系统的集成</li></ul><p>解决办法：</p><ul><li>在单独的 Java Config（或 XML）中配置每个 bean，然后在<strong>构建时</strong>根据不同的环境分别打包，典型方法是采用 Maven profile。这种方式的问题在于要为每种环境重新构建应用。</li><li><strong>运行时</strong>指定不同的环境变量，典型方法是采用 Spring profile bean。这种方式的好处在于无需为每种环境重新构建应用。</li></ul><p>Spring profile bean 的使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Profile</span>(<span class="string">"dev"</span>) <span class="comment">// 类级别（Spring 3.1 引入）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">DevProfileConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">GlobalConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"dev"</span>) <span class="comment">// 方法级别（Spring 3.2 引入）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">embeddedDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"prod"</span>) <span class="comment">// 方法级别（Spring 3.2 引入）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">jndiDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>激活方式，使用属性：<code>spring.profiles.active</code> 和 <code>spring.profiles.default</code>。有多种方式来设置这两个属性：</p><ul><li>作为 <code>DispatcherServlet</code> 的初始化参数；</li><li>作为 Web 应用的上下文参数；</li><li>作为 JNDI 条目；</li><li>作为环境变量；</li><li>作为 JVM 的系统属性；</li><li>在集成测试类上，使用 <code>@ActiveProfiles</code> 注解设置。</li></ul><p>注意，Spring profile bean 注解 <code>@Profile</code> 底层其实也是基于 <code>@Conditional</code> 和 <code>Condition</code> 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;ProfileCondition<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">Profile</span> </span>&#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-Boot-的条件化注解"><a href="#Spring-Boot-的条件化注解" class="headerlink" title="Spring Boot 的条件化注解"></a>Spring Boot 的条件化注解</h1><p>Spring Boot 没有引入任何形式的代码生成，而是利用了 Spring 4 的条件化 bean 配置特性，以及 Maven 和 Gradle 提供的传递依赖解析，以此实现 Spring 应用上下文里的<strong>自动配置</strong>。Spring Boot 实现的条件化注解如下：</p><p><img src="/img/spring/conditional_annotation.png" alt="Spring Boot 实现的条件化注解"></p><p>Spring Boot 的 <code>@Conditional</code> 注解实现及相关支持类，详见文档：<a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/autoconfigure/condition/package-summary.html" target="_blank" rel="noopener">Package org.springframework.boot.autoconfigure.condition</a></p><p>依赖配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过运行 <code>DEBUG=true mvn spring-boot:run</code>，可以看到 DEBUG 级别的日志输出，从而观察自动配置的详情（AUTO-CONFIGURATION REPORT）：</p><ul><li>Positive matches</li><li>Negative matches</li><li>Exclusions</li><li>Unconditional classes</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">CONDITIONS EVALUATION REPORT</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">Positive matches:</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   GenericCacheConfiguration matched:</span><br><span class="line">      - Cache org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration automatic cache type (CacheCondition)</span><br><span class="line"></span><br><span class="line">   JmxAutoConfiguration matched:</span><br><span class="line">      - @ConditionalOnClass found required class &#39;org.springframework.jmx.export.MBeanExporter&#39; (OnClassCondition)</span><br><span class="line">      - @ConditionalOnProperty (spring.jmx.enabled&#x3D;true) matched (OnPropertyCondition)</span><br><span class="line"></span><br><span class="line">   PropertyPlaceholderAutoConfiguration#propertySourcesPlaceholderConfigurer matched:</span><br><span class="line">      - @ConditionalOnMissingBean (types: org.springframework.context.support.PropertySourcesPlaceholderConfigurer; SearchStrategy: current) did not find any beans (OnBeanCondition)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Negative matches:</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   ActiveMQAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - @ConditionalOnClass did not find required class &#39;javax.jms.ConnectionFactory&#39; (OnClassCondition)</span><br><span class="line"></span><br><span class="line">   AopAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - @ConditionalOnClass did not find required class &#39;org.aspectj.lang.annotation.Aspect&#39; (OnClassCondition)</span><br><span class="line"></span><br><span class="line">Exclusions:</span><br><span class="line">-----------</span><br><span class="line"></span><br><span class="line">    None</span><br><span class="line"></span><br><span class="line">Unconditional classes:</span><br><span class="line">----------------------</span><br><span class="line"></span><br><span class="line">    org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration</span><br><span class="line"></span><br><span class="line">    org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration</span><br><span class="line"></span><br><span class="line">    org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://www.manning.com/books/spring-in-action-fourth-edition" target="_blank" rel="noopener">Spring in Action, 4th</a>》</p><p>《<a href="https://www.jianshu.com/p/c4df7be75d6e" target="_blank" rel="noopener">SpringBoot源码分析之条件注解的底层实现</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm 常用命令及配置总结</title>
      <link href="2017/08/29/npm/"/>
      <url>2017/08/29/npm/</url>
      
        <content type="html"><![CDATA[<p>工作中由于前端项目打包、各类工具使用（如本博客就是基于 Node.js）经常要用到 npm，下面总结一下。</p><p>npm 是随 Node.js 自动安装的，由三个独立的部分组成：</p><ul><li><a href="https://npmjs.com/" target="_blank" rel="noopener">网址</a>：开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。</li><li><a href="https://docs.npmjs.com/misc/registry" target="_blank" rel="noopener">注册表（Registry）</a>：一个巨大的数据库，保存了每个包（package）的信息。</li><li><a href="https://docs.npmjs.com/cli/npm" target="_blank" rel="noopener">命令行工具（CLI）</a>：命令行或终端运行。开发者通过 CLI 与 npm 打交道。</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>OS X 推荐使用 HomeBrew 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install node --with-npm</span><br></pre></td></tr></table></figure><p>其它：</p><p><a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download/</a></p><h1 id="npm-命令"><a href="#npm-命令" class="headerlink" title="npm 命令"></a>npm 命令</h1><p><img src="/img/javascript/npm_cli_commands.png" alt="NPM CLI Commands"></p><p><code>npm install -g &lt;package&gt;</code> 全局安装：</p><ul><li><p>Windows：</p><ul><li>安装目录 <code>C:\Users\Admin\AppData\Roaming\npm\node_modules\&lt;package&gt;</code></li><li>生成可执行脚本：<code>C:\Users\Admin\AppData\Roaming\npm\&lt;package&gt;</code></li><li>由于目录 <code>C:\Users\Admin\AppData\Roaming\npm</code> 已加入 <code>PATH</code> 环境变量，因为可以直接执行对应命令。</li></ul></li><li><p>OS X：</p><ul><li>安装目录 <code>/usr/local/lib/node_modules/&lt;package&gt;</code></li><li>生成软链，例如：<code>/usr/local/bin/npm -&gt; /usr/local/lib/node_modules/npm/bin/npm-cli.js</code></li></ul></li></ul><p><code>npm list -g -depth=0</code> 验证是否安装到位。</p><h1 id="npm-配置"><a href="#npm-配置" class="headerlink" title="npm 配置"></a>npm 配置</h1><p>npm 配置主要有两份：</p><ul><li><a href="https://www.npmjs.com.cn/files/npmrc/" target="_blank" rel="noopener">npmrc</a>：npm 从命令行、环境变量、<code>npmrc</code> 文件中读取配置。</li><li><a href="https://www.npmjs.com.cn/files/package.json/" target="_blank" rel="noopener">package.json</a>：包（package）配置文件。</li></ul><p>重点了解下 package.json，重点属性有 <code>name</code>、<code>version</code>、<code>dependencies</code>、<code>main</code>：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>name</code></td><td>包名</td></tr><tr><td><code>version</code></td><td>包的语义版本号：X.Y.Z：如果有大变动，向下不兼容，需要更新主版本号X；如果是新增了功能，但是向下兼容，需要更新次版本号 Y；如果只是修复bug，需要更新补丁版本号 Z</td></tr><tr><td><code>description</code></td><td>包的描述</td></tr><tr><td><code>homepage</code></td><td>包的官网 url</td></tr><tr><td><code>author</code></td><td>包的作者姓名</td></tr><tr><td><code>contributors</code></td><td>包的其他贡献者姓名</td></tr><tr><td><code>dependencies</code></td><td>依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下</td></tr><tr><td><code>repository</code></td><td>包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上</td></tr><tr><td><code>main</code></td><td><code>main</code> 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后<code>require(&quot;express&quot;)</code></td></tr><tr><td><code>keywords</code></td><td>关键字</td></tr></tbody></table><h1 id="淘宝-npm-镜像"><a href="#淘宝-npm-镜像" class="headerlink" title="淘宝 npm 镜像"></a>淘宝 npm 镜像</h1><p>为了解决慢的问题，推荐使用淘宝 npm 镜像。三种使用方式：</p><ul><li><p>使用淘宝定制的 <a href="https://github.com/cnpm/cnpm" target="_blank" rel="noopener">cnpm</a> 命令行工具代替默认的 <code>npm</code>，安装方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>永久配置 <code>npm</code> 命令行工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br><span class="line">--配置后验证是否成功</span><br><span class="line">$ npm config get registry</span><br></pre></td></tr></table></figure></li><li><p><code>npm</code> 安装包时，临时使用淘宝 npm 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install vue-cli --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.npmjs.com/" target="_blank" rel="noopener">https://www.npmjs.com/</a></p><p><a href="https://www.npmjs.com.cn/" target="_blank" rel="noopener">https://www.npmjs.com.cn/</a></p><p><a href="https://npm.taobao.org/" target="_blank" rel="noopener">https://npm.taobao.org/</a></p><p><a href="http://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/nodejs/nodejs-tutorial.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 自动配置及 Factories 机制总结</title>
      <link href="2017/08/20/spring-factories/"/>
      <url>2017/08/20/spring-factories/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot 应用中的”自动配置”是通过 <code>@EnableAutoConfiguration</code> 注解进行开启的。<code>@EnableAutoConfiguration</code> 可以帮助 Spring Boot 应用将所有符合条件的 <code>@Configuration</code> 配置类的 bean 都加载到 Spring IoC 容器中。本文解析了实现这个效果的原理。</p><h1 id="自动配置的原理"><a href="#自动配置的原理" class="headerlink" title="自动配置的原理"></a>自动配置的原理</h1><p>Spring Boot 应用的自动配置流程如下：</p><p><img src="/img/spring/enable-auto-configuration.png" alt="Spring SPI"></p><h2 id="Spring-Factories-机制"><a href="#Spring-Factories-机制" class="headerlink" title="Spring Factories 机制"></a>Spring Factories 机制</h2><p>首先，注解的实现类使用了 spring-core 中的加载类 <code>SpringFactoriesLoader</code> 加载指定配置，详见<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/support/SpringFactoriesLoader.html" target="_blank" rel="noopener">文档</a>：</p><blockquote><p>SpringFactoriesLoader loads and instantiates factories of a given type from “META-INF/spring.factories” files which may be present in multiple JAR files in the classpath. The spring.factories file must be in Properties format, where the key is the fully qualified name of the interface or abstract class, and the value is a comma-separated list of implementation class names. </p></blockquote><p>该类会通过类加载器从 classpath 中搜索所有 <code>META-INF/spring.factories</code> 配置文件，然后获取 key 为 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 部分。</p><p>例如 <code>spring-boot-autoconfigure.jar/META-INF/spring.factories</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>加载结果如图：</p><p><img src="/img/spring/SpringFactoriesLoader.png" alt="SpringFactoriesLoader 解析结果"></p><p>继续加载 key 为 <code>org.springframework.boot.autoconfigure.AutoConfigurationImportFilter</code> 部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter&#x3D;\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span><br></pre></td></tr></table></figure><h2 id="执行条件注解"><a href="#执行条件注解" class="headerlink" title="执行条件注解"></a>执行条件注解</h2><p>针对这 118 个候选的 Auto Configure，执行 Import Filters 对应的条件注解：</p><ul><li><p><code>OnClassCondition</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 底层实现，加载成功则返回 true；加载失败则抛出 java.lang.ClassNotFoundException，捕获异常后返回 false</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className, ClassLoader classLoader)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> classLoader.loadClass(className);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Class.forName(className);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>OnBeanCondition</code></p><p>判断指定的 bean 类或名称是否已存在于 <code>BeanFactory</code>。</p></li></ul><p>过滤结果如下：</p><p><img src="/img/spring/condition.png" alt=""></p><p><code>TRACE</code> 日志如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Filtered 30 auto configuration class in 1000 ms</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在日常工作中，我们可能需要实现一些 Spring Boot Starter 给被人使用，这个时候我们就可以使用这个 Factories 机制，将自己的 Starter 注册到 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 命名空间下。这样用户只需要在服务中引入我们的 jar 包即可完成自动加载及配置。Factories 机制可以让 Starter 的使用只需要很少甚至不需要进行配置。</p><p>本质上，Spring Factories 机制与 Java SPI 机制原理都差不多：都是通过指定的规则，在规则定义的文件中配置接口的各种实现，通过 key-value 的方式读取，并以反射的方式实例化指定的类型。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/support/SpringFactoriesLoader.html" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/io/support/SpringFactoriesLoader.html</a></p><p><a href="https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/support/SpringFactoriesLoader.java" target="_blank" rel="noopener">https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/support/SpringFactoriesLoader.java</a></p><p>《<a href="https://stackoverflow.com/questions/42819558/spring-boot-spring-factories-vs-enable-annotations" target="_blank" rel="noopener">Spring Boot spring.factories vs @Enable annotations</a>》</p><p><a href="https://www.cnblogs.com/zheting/p/6707035.html" target="_blank" rel="noopener">https://www.cnblogs.com/zheting/p/6707035.html</a></p><p><a href="http://www.cnblogs.com/whx7762/p/7832985.html" target="_blank" rel="noopener">http://www.cnblogs.com/whx7762/p/7832985.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 入门总结</title>
      <link href="2017/08/01/spring-boot-getting-started/"/>
      <url>2017/08/01/spring-boot-getting-started/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建项目"><a href="#搭建项目" class="headerlink" title="搭建项目"></a>搭建项目</h1><p>有几种方式可以搭建基于 Spring Boot 的项目：</p><ol><li><p><a href="https://start.spring.io/" target="_blank" rel="noopener">Spring Initializr</a> 在线生成项目</p><blockquote><p>Spring Initializr 从本质上来说就是一个Web应用程序，它能为你生成 Spring Boot 项目结构。虽然不能生成应用程序代码，但它能为你提供一个基本的项目结构，以及一个用于构建代码的 Maven 或 Gradle 构建说明文件。你只需要写应用程序的代码就好了。</p></blockquote></li><li><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/cli.html" target="_blank" rel="noopener">Spring Boot CLI</a> 命令行工具，下载地址<a href="http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/" target="_blank" rel="noopener">点我</a>，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ spring init -dweb,data-jpa,h2,thymeleaf --build gradle readingList</span><br></pre></td></tr></table></figure></li><li><p><a href="https://spring.io/tools/sts" target="_blank" rel="noopener">Spring Tool Suite</a>，一个官方基于 Eclipse 定制的 IDE，用法参考：《<a href="http://blog.csdn.net/linabc123000/article/details/68954236" target="_blank" rel="noopener">STS 创建第一个 Spring Boot 项目</a>》</p></li><li><p>IntelliJ IDEA</p><ol><li>社区版：离线安装 <a href="http://plugins.jetbrains.com/plugin/10229-spring-assistant" target="_blank" rel="noopener">Spring Assistant</a> 插件（在线安装方式被墙）</li><li>收费版：直接使用 Spring Initializr 插件</li></ol></li></ol><h1 id="项目组成"><a href="#项目组成" class="headerlink" title="项目组成"></a>项目组成</h1><p>Spring Boot 的<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project" target="_blank" rel="noopener">各个子项目</a>组成及结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">spring-boot-dependencies (Parent pom)</span><br><span class="line">  spring-boot-parent (Parent pom)</span><br><span class="line">    spring-boot</span><br><span class="line">    spring-boot-autoconfigure</span><br><span class="line">    spring-boot-starters (Parent module)</span><br><span class="line">      spring-boot-starter (Core starter, including auto-configuration support, logging and YAML)</span><br><span class="line">      spring-boot-starter-parent (Parent pom providing dependency and plugin management for applications</span><br><span class="line">built with Maven)</span><br><span class="line">      spring-boot-starter-web</span><br><span class="line">      ...</span><br><span class="line">    spring-boot-test</span><br><span class="line">    spring-boot-test-autoconfigure</span><br><span class="line">    spring-boot-actuator</span><br><span class="line">    spring-boot-actuator-autoconfigure</span><br><span class="line">    spring-boot-devtools</span><br><span class="line">    spring-boot-cli</span><br><span class="line">    spring-boot-docs</span><br><span class="line">    spring-boot-tools (Parent module)</span><br><span class="line">      spring-boot-autoconfigure-processor</span><br><span class="line">      spring-boot-configuration-processor</span><br><span class="line">      spring-boot-maven-plugin</span><br><span class="line">      spring-boot-gradle-plugin</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure><h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><ul><li><code>spring-boot-dependencies</code><ul><li>用于定义和统一管理 Sprint Boot 的各个依赖版本号，继承自 <code>spring-boot-build</code>。可通过 <code>dependencyManagement</code> 引入该依赖可以解决<strong>单继承问题</strong>。</li></ul></li><li><code>spring-boot-parent</code><ul><li>Spring Boot 各个依赖的父 POM，用于构建配置。继承自 <code>spring-boot-dependencies</code>。</li></ul></li></ul><h2 id="核心依赖"><a href="#核心依赖" class="headerlink" title="核心依赖"></a>核心依赖</h2><ul><li><code>spring-boot</code> Spring Boot 的核心工程。</li><li><code>spring-boot-autoconfigure</code> 实现 Spring Boot 自动配置的关键，常用的包含：<ul><li>自动配置总开关 <code>@EnableAutoConfiguration</code></li><li>各种自动配置类 <code>*AutoConfiguration</code></li><li>各种外部化配置属性类 <code>*Properties</code></li><li>各种条件化注解类 <code>@ConditionOn*</code></li></ul></li><li><code>spring-boot-starters</code> 起步依赖的父 POM<ul><li>Spring Boot 提供的众多起步依赖，用于降低项目依赖的复杂度，清单详见：<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter" target="_blank" rel="noopener">Starters</a>，例如：<ul><li><code>spring-boot-starter</code> 核心起步依赖，包括自动配置支持、日志、YAML 依赖</li><li><code>spring-boot-starter-parent</code> 业务项目的<strong>父 POM</strong>，继承自 <code>spring-boot-dependencies</code></li><li><code>spring-boot-starter-web</code> WEB 开发相关起步依赖</li><li><code>spring-boot-starter-test</code> 测试相关起步依赖</li><li>…</li></ul></li><li>起步依赖本质上就是特殊的 Maven 依赖和 Gradle 依赖，利用了<strong>传递依赖</strong>解析，把常用库聚合在一起，组成了几个为特定功能而定制的依赖。</li><li>比起减少依赖数量，起步依赖还引入了一些微妙的变化。向项目中添加了某个起步依赖，实际上指定了应用程序所需的<strong>一类功能</strong>。</li><li>起步依赖引入的库的版本兼容性都是<strong>经过测试</strong>的，可以放心使用。</li></ul></li></ul><h2 id="工具或插件"><a href="#工具或插件" class="headerlink" title="工具或插件"></a>工具或插件</h2><ul><li><code>spring-boot-test</code>、<code>spring-boot-test-autoconfigure</code><ul><li>提供一系列测试支持，常用的如：<code>@SpringBootTest</code>、mock、web 支持。</li></ul></li><li><code>spring-boot-actuator</code>、<code>spring-boot-actuator-autoconfigure</code><ul><li>包含许多额外的特性，以帮助你通过 HTTP 或 JMX 端点来监控和管理生产环境的应用程序。包括以下特性（详见<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready" target="_blank" rel="noopener">用户手册</a>）：<ul><li><strong>Endpoints</strong> Actuator endpoints allow you to monitor and interact with your application. Spring Boot includes a number of built-in endpoints and you can also add your own. For example the <code>health</code> endpoint provides basic application health information. Run up a basic application and look at <code>/actuator/health</code>.</li><li><strong>Metrics</strong> Spring Boot Actuator provides dimensional metrics by integrating with <a href="https://micrometer.io/" target="_blank" rel="noopener">Micrometer</a>.</li><li><strong>Audit</strong> Spring Boot Actuator has a flexible audit framework that will publish events to an <code>AuditEventRepository</code>. Once Spring Security is in play it automatically publishes authentication events by default. This can be very useful for reporting, and also to implement a lock-out policy based on authentication failures.</li></ul></li></ul></li><li><code>spring-boot-devtools</code><ul><li>热部署、静态资源 livereload 等等。</li></ul></li><li><code>spring-boot-tools</code> 工具集的父 POM。为 Spring Boot 开发者提供的常用工具集。例如：<ul><li><code>spring-boot-maven-plugin</code> 插件</li><li><code>spring-boot-gradle-plugin</code> 插件</li></ul></li><li><code>spring-boot-cli</code><ul><li>命令行工具。</li></ul></li></ul><h1 id="POM-配置"><a href="#POM-配置" class="headerlink" title="POM 配置"></a>POM 配置</h1><ul><li>方式一：继承 <code>spring-boot-starter-parent</code></li><li>方式二：如果已经有父项目，组合 <code>spring-boot-dependencies</code></li></ul><p>参考：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-build-systems.html#using-boot-maven" target="_blank" rel="noopener">Build Systems - Maven</a></p><h2 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h2><p>Maven 用户可以继承 <code>spring-boot-starter-parent</code> POM 项目以获得合理的默认配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Inherit defaults from Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你只需要指定 parent 的 <code>&lt;version&gt;</code> 版本号。之后如果你需要引入其它起步依赖，你可以安全的省略起步依赖的 <code>&lt;version&gt;</code> 版本号，parent 会统一管理。</p><p>父项目还提供了以下功能：</p><ul><li>Java 1.8 作为默认的编译器级别</li><li>UTF-8 源码编码</li><li>提供统一的依赖版本管理（继承自 Maven POM <code>spring-boot-dependencies</code>），可以让你在自己的 pom 中引入依赖时省略版本号定义，保障依赖间的兼容性</li><li>An execution of the <a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/maven-plugin/repackage-mojo.html" target="_blank" rel="noopener"><code>repackage</code> goal</a> with a <code>repackage</code> execution id.</li><li>合理的 <a href="https://maven.apache.org/plugins/maven-resources-plugin/examples/filter.html" target="_blank" rel="noopener">resource filtering</a> 配置（<code>application.properties</code> and <code>application.yml</code> including profile-specific files）</li><li>合理的 plugin configuration 配置</li></ul><h2 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h2><p>不是每个人都喜欢继承 <code>spring-boot-starter-parent</code> POM 项目。每个公司可能都拥有自己的标准父项目，或者你更愿意明确声明所有 Maven 配置。</p><p>即使如此，你仍然可以通过以组合方式使用 <code>scope=import</code>  的 <code>spring-boot-dependencies</code> 依赖来享受依赖管理的好处，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Import dependency management from Spring Boot --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种组合方式能解决 Maven 单继承问题。</p><h1 id="Maven-插件"><a href="#Maven-插件" class="headerlink" title="Maven 插件"></a>Maven 插件</h1><p><code>spring-boot-maven-plugin</code> 插件内置<a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#goals" target="_blank" rel="noopener">几个 goal</a>，如下：</p><table><thead><tr><th align="left">Goal</th><th align="left">Description</th><th>备注</th></tr></thead><tbody><tr><td align="left"><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#goals-build-image" target="_blank" rel="noopener">spring-boot:build-image</a></td><td align="left">Package an application into a OCI image using a buildpack.</td><td></td></tr><tr><td align="left"><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#goals-build-info" target="_blank" rel="noopener">spring-boot:build-info</a></td><td align="left">Generate a <code>build-info.properties</code> file based on the content of the current <code>MavenProject</code>.</td><td></td></tr><tr><td align="left"><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#goals-help" target="_blank" rel="noopener">spring-boot:help</a></td><td align="left">Display help information on spring-boot-maven-plugin. Call <code>mvn spring-boot:help -Ddetail=true -Dgoal=&lt;goal-name&gt;</code> to display parameter details.</td><td></td></tr><tr><td align="left"><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#goals-repackage" target="_blank" rel="noopener">spring-boot:repackage</a></td><td align="left">Repackage existing JAR and WAR archives so that they can be executed from the command line using <code>java -jar</code>. With <code>layout=NONE</code> can also be used simply to package a JAR with nested dependencies (and no main class, so not executable).</td><td>常用</td></tr><tr><td align="left"><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#goals-run" target="_blank" rel="noopener">spring-boot:run</a></td><td align="left">Run an application in place.</td><td>常用</td></tr><tr><td align="left"><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#goals-start" target="_blank" rel="noopener">spring-boot:start</a></td><td align="left">Start a spring application. Contrary to the <code>run</code> goal, this does not block and allows other goals to operate on the application. This goal is typically used in integration test scenario where the application is started before a test suite and stopped after.</td><td></td></tr><tr><td align="left"><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#goals-stop" target="_blank" rel="noopener">spring-boot:stop</a></td><td align="left">Stop an application that has been started by the “start” goal. Typically invoked once a test suite has completed.</td><td></td></tr></tbody></table><p>参考：</p><ul><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/build-tool-plugins-maven-plugin.html" target="_blank" rel="noopener">Spring Boot Maven Plugin</a></li><li><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/maven-plugin/</a></li></ul><h2 id="项目运行方式一"><a href="#项目运行方式一" class="headerlink" title="项目运行方式一"></a>项目运行方式一</h2><p>使用 <code>spring-boot-maven-plugin</code> 插件自带的命令 <code>mvn spring-boot:run</code>，快速编译并运行。</p><h2 id="项目运行方式二"><a href="#项目运行方式二" class="headerlink" title="项目运行方式二"></a>项目运行方式二</h2><p>先将项目打包成一个可执行的 jar/war 包，使用命令：<code>mvn package spring-boot:repackage</code>。</p><p>使用插件打包好的 jar 包内会内嵌一个容器，你可以像运行任何其它应用程序一样运行它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar target/myapplication-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>也可以指定运行参数，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar -spring.profiles.active=prod target/myapplication-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><h2 id="项目运行方式三"><a href="#项目运行方式三" class="headerlink" title="项目运行方式三"></a>项目运行方式三</h2><blockquote><p>In addition to running Spring Boot applications by using <code>java -jar</code>, it is also possible to make <strong>fully executable</strong> applications for Unix systems. A fully executable jar can be executed like any other executable binary or it can be <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#deployment.installing.nix-services" target="_blank" rel="noopener">registered with <code>init.d</code> or <code>systemd</code></a>. This helps when installing and managing Spring Boot applications in common production environments.</p><p>Fully executable jars work by embedding an extra script at the front of the file. It is recommended that you make your jar or war fully executable only if you intend to execute it directly, rather than running it with <code>java -jar</code> or deploying it to a servlet container.</p><p>To create a ‘fully executable’ jar with Maven, use the following plugin configuration:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executable</span>&gt;</span>true<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>You can then run your application by typing <code>./my-application.jar</code> (where <code>my-application</code> is the name of your artifact). The directory containing the jar is used as your application’s working directory.</p></blockquote><p>更多信息参考：<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#deployment.installing" target="_blank" rel="noopener">7.3 Installing Spring Boot Applications</a></p><ul><li>Unix/Linux Services<ul><li>Installation as an <code>init.d</code> Service (System V)</li><li>Installation as a <code>systemd</code> Service (<code>systemd</code> is the successor of the System V init system and is now being used by many modern Linux distributions.)</li><li>Customizing the Startup Script</li></ul></li></ul><h3 id="在运行时自定义脚本项"><a href="#在运行时自定义脚本项" class="headerlink" title="在运行时自定义脚本项"></a>在运行时自定义脚本项</h3><blockquote><p>For items of the script that need to be customized <em>after</em> the jar has been written, you can use environment variables or a <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/deployment.html#deployment.installing.nix-services.script-customization.when-running.conf-file" target="_blank" rel="noopener">config file</a>.</p><p>The <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#deployment.installing.nix-services.script-customization.when-running" target="_blank" rel="noopener">following environment properties</a> are supported with the default script.</p></blockquote><p>更多信息参考：<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#deployment.installing.nix-services.script-customization.when-running" target="_blank" rel="noopener">7.3.2 Unix/Linux Services - Customizing a Script When It Runs</a></p><h1 id="外部配置"><a href="#外部配置" class="headerlink" title="外部配置"></a>外部配置</h1><p>更多信息参考：<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config" target="_blank" rel="noopener">5.2. Externalized Configuration</a></p><p>Spring Boot 能从多种属性源获得属性，包括如下几处：</p><ol><li>命令行参数</li><li><code>java:comp/env</code> 里的 JNDI 属性</li><li>JVM 系统属性</li><li>操作系统环境变量</li><li>随机生成的带 <code>random.*</code> 前缀的属性（在设置其他属性时，可以引用它们，比如 <code>${random.long}</code>）</li><li>应用程序以外的 <code>application.properties</code> 或者 <code>appliaction.yml</code> 文件</li><li>打包在应用程序内的 <code>application.properties</code> 或者 <code>appliaction.yml</code> 文件</li><li>通过 <code>@PropertySource</code> 标注的属性源</li><li>默认属性</li></ol><p>这个列表按照优先级排序，也就是说，任何在高优先级属性源里设置的属性都会覆盖低优先级的相同属性。例如，命令行参数会覆盖其他属性源里的属性。</p><p><code>application.properties</code> 和 <code>application.yml</code> 文件能放在以下四个位置：</p><ol><li>外置，在相对于应用程序运行目录的 <code>/config</code> 子目录里。</li><li>外置，在应用程序运行的目录里。</li><li>内置，在 <code>config</code> 包内。</li><li>内置，在 <code>Classpath</code> 根目录。</li></ol><p>同样，这个列表按照优先级排序。也就是说，<code>/config</code> 子目录里的 <code>application.properties</code> 会覆盖应用程序 <code>Classpath</code> 里的 <code>application.properties</code> 中的相同属性。</p><p>此外，如果你在同一优先级位置同时有 <code>application.properties</code> 和 <code>application.yml</code>，那么 <code>application.yml</code> 里的属性会覆盖 <code>application.properties</code> 里的属性。</p><p>如果需要为自己的 Bean 加上外部配置注入，可以使用注解 <code>@ConfigurationProperties</code>。</p><h2 id="配置嵌入式服务器"><a href="#配置嵌入式服务器" class="headerlink" title="配置嵌入式服务器"></a>配置嵌入式服务器</h2><p>Spring Boot 集成了 Tomcat、Jetty 和 Undertow，极大便利了项目部署。下面介绍一些常用配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.port</span>=<span class="string">8080 # Server HTTP port.</span></span><br><span class="line"><span class="meta">server.context-path</span>= <span class="string"># Context path</span></span><br></pre></td></tr></table></figure><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><p>URI 编码配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.tomcat.uri-encoding</span>=<span class="string">UTF-8 # Character encoding to use to decode the URI.</span></span><br></pre></td></tr></table></figure><p>代理配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.tomcat.remote-ip-header</span>= <span class="string"># Name of the http header from which the remote ip is extracted. For instance `X-FORWARDED-FOR`</span></span><br><span class="line"><span class="meta">server.tomcat.protocol-header</span>= <span class="string"># Header that holds the incoming protocol, usually named "X-Forwarded-Proto".</span></span><br><span class="line"><span class="meta">server.tomcat.port-header</span>=<span class="string">X-Forwarded-Port # Name of the HTTP header used to override the original port value.</span></span><br></pre></td></tr></table></figure><p>Socket 连接限制及等待超时时间：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.tomcat.max-connections</span>= <span class="string"># Maximum number of connections that the server will accept and process at any given time.</span></span><br><span class="line"><span class="meta">server.connection-timeout</span>= <span class="string"># Time in milliseconds that connectors will wait for another HTTP request before closing the connection. When not set, the connector's container-specific default will be used. Use a value of -1 to indicate no (i.e. infinite) timeout.</span></span><br></pre></td></tr></table></figure><p>业务线程池调优：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.tomcat.max-threads</span>=<span class="string">0 # Maximum amount of worker threads. Default 200.</span></span><br><span class="line"><span class="meta">server.tomcat.min-spare-threads</span>=<span class="string">0 # Minimum amount of worker threads.</span></span><br><span class="line"><span class="meta">server.tomcat.accept-count</span>= <span class="string"># Maximum queue length for incoming connection requests when all possible request processing threads are in use.</span></span><br></pre></td></tr></table></figure><h3 id="Undertow"><a href="#Undertow" class="headerlink" title="Undertow"></a>Undertow</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置IO线程数, 它主要执行非阻塞的任务,它们会负责多个连接, 默认设置每个CPU核心一个线程</span></span><br><span class="line"><span class="comment"># 不要设置过大，如果过大，启动项目会报错：打开文件数过多</span></span><br><span class="line"><span class="meta">server.undertow.io-threads</span>=<span class="string">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 阻塞任务线程池, 当执行类似servlet请求阻塞IO操作, undertow会从这个线程池中取得线程</span></span><br><span class="line"><span class="comment"># 它的值设置取决于系统线程执行任务的阻塞系数，默认值是IO线程数*8</span></span><br><span class="line"><span class="meta">server.undertow.worker-threads</span>=<span class="string">256</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下的配置会影响buffer,这些buffer会用于服务器连接的IO操作,有点类似netty的池化内存管理</span></span><br><span class="line"><span class="comment"># 每块buffer的空间大小,越小的空间被利用越充分，不要设置太大，以免影响其他应用，合适即可</span></span><br><span class="line"><span class="meta">server.undertow.buffer-size</span>=<span class="string">1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个区分配的buffer数量 , 所以pool的大小是buffer-size * buffers-per-region</span></span><br><span class="line"><span class="meta">server.undertow.buffers-per-region</span>=<span class="string">1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否分配的直接内存(NIO直接分配的堆外内存)</span></span><br><span class="line"><span class="meta">server.undertow.direct-buffers</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/duanxz/p/9337022.html" target="_blank" rel="noopener">https://www.cnblogs.com/duanxz/p/9337022.html</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《Spring Boot in Action》</p><p><a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot</a></p><p><a href="https://docs.spring.io/spring-boot/docs/current/" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/</a></p><ul><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-starter" target="_blank" rel="noopener">4.1.5. Using Spring Boot Starters</a></li><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.external-config" target="_blank" rel="noopener">5.2. Externalized Configuration</a></li><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#deployment.installing" target="_blank" rel="noopener">7.3 Installing Spring Boot Applications</a><ul><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#deployment.installing.nix-services.script-customization" target="_blank" rel="noopener">7.3.2 Unix/Linux Services - Customizing the Startup Script</a></li></ul></li></ul><p><a href="https://yq.aliyun.com/articles/619390" target="_blank" rel="noopener">Spring Boot Tomcat配置</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP 面向切面编程总结</title>
      <link href="2017/07/10/spring-aop/"/>
      <url>2017/07/10/spring-aop/</url>
      
        <content type="html"><![CDATA[<h1 id="AOP-概念"><a href="#AOP-概念" class="headerlink" title="AOP 概念"></a>AOP 概念</h1><p>前面我们重点关注了如何使用依赖注入（DI）管理和配置我们的应用对象，从而实现应用对象之间的解耦，而 AOP 主要实现“横切关注点（cross-cutting concern）”与它们所影响的对象之间的解耦。</p><p>在软件开发中，散布于应用中多处的功能被称为“横切关注点（cross-cutting concern）”。通常来讲，这些横切关注点从概念上是与应用的业务逻辑相分离的（但是往往会直接嵌入到应用的业务逻辑之中）。把这些横切关注点与业务逻辑相分离正是面向切面编程（AOP）所要解决的问题。</p><p>AOP 补充了 OOP 编程，通过提供另一种思考软件结构的方法。OOP 编程中的模块单元是“类（Class）”，而 AOP 编程中的模块单元是“切面（Aspect）”。</p><p>切面提供了取代继承和委托的另一种可选方案，而且在很多场景下更清晰简洁。在使用面向切面编程时，我们仍然在一个地方定义通用功能，但是可以通过<strong>声明的方式</strong>定义这个功能要以何种方式在何处应用，而无需修改受影响的类。横切关注点可以被模块化为特殊的类，这些类被称为切面（aspect）。这样做有两个好处：</p><ul><li>首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；</li><li>其次，服务模块更简洁，因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。</li></ul><p>AOP 的一些场景如下：</p><ul><li>日志</li><li>事务，如 Spring Transactional</li><li>安全，如 Spring Security</li><li>缓存，如 Spring Cache</li></ul><p>AOP 的知识点总结：</p><p><img src="/img/spring/aop/AOP.png" alt="AOP 总览"></p><h1 id="AOP-术语"><a href="#AOP-术语" class="headerlink" title="AOP 术语"></a>AOP 术语</h1><p>与大多数技术一样，AOP 已经形成了自己的术语。下图展示了这些概念是如何关联在一起的：</p><p><img src="/img/spring/aop/aop_terminology.png" alt="An aspect&#39;s functionality (advice) is woven into a program&#39;s execution at one or more join points."></p><h2 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）"></a>切面（Aspect）</h2><p>什么是切面？通俗来说就是“何时何地发生何事”，其组成如下：</p><blockquote><p>Aspect = Advice (what &amp; when) + Pointcut (where)</p></blockquote><h2 id="通知（Advice）"><a href="#通知（Advice）" class="headerlink" title="通知（Advice）"></a>通知（Advice）</h2><p>通知（Advice）定义了<strong>何时（when）</strong>发生<strong>何事（what）</strong>。</p><p>Spring AOP 的切面（Aspect）可以搭配下面五种通知（Advice）注解使用：</p><table><thead><tr><th>通知</th><th>描述</th></tr></thead><tbody><tr><td><code>@Before</code></td><td>The advice functionality takes place before the advised method is invoked.</td></tr><tr><td><code>@After</code></td><td>The advice functionality takes place after the advised method completes, regardless of the outcome.</td></tr><tr><td><code>@AfterReturning</code></td><td>The advice functionality takes place after the advised method successfully completes.</td></tr><tr><td><code>@AfterThrowing</code></td><td>The advice functionality takes place after the advised method throws an exception.</td></tr><tr><td><code>@Around</code></td><td>The advice wraps the advised method, providing some functionality before and after the advised method is invoked.</td></tr></tbody></table><h2 id="切点（Pointcut）"><a href="#切点（Pointcut）" class="headerlink" title="切点（Pointcut）"></a>切点（Pointcut）</h2><p>切点（Pointcut）定义了切面在<strong>何处（where）</strong>执行。</p><p>Spring AOP 的切点（Pointcut）使用 AspectJ 的“<strong>切点表达式语言（Pointcut Expression Language）</strong>”进行定义。但要注意的是，Spring 仅支持其中一个子集：</p><p><img src="/img/spring/aop/aop_aspectj_designator.png" alt="切面指示器（Aspectj Designator）"></p><p>切点表达式的语法如下：</p><p><img src="/img/spring/aop/aop_pointcut_expression.png" alt="切点表达式（Pointcut Expression）"></p><h2 id="连接点（Join-point）"><a href="#连接点（Join-point）" class="headerlink" title="连接点（Join point）"></a>连接点（Join point）</h2><p>连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><h2 id="织入（Weaving）"><a href="#织入（Weaving）" class="headerlink" title="织入（Weaving）"></a>织入（Weaving）</h2><p>织入是把切面应用到目标对象并创建<strong>新的代理对象</strong>的过程。切面（aspect）在指定的连接点（join point）被织入（weaving）到目标对象中。在目标对象的生命周期里有多个点可以进行织入：</p><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>编译期</td><td>切面在目标类编译时被织入。这种方式需要<strong>特殊的编译器</strong>。AspectJ Compiler 就是以这种方式织入切面的。</td></tr><tr><td>类加载期</td><td>切面在目标类加载到 JVM 时被织入。这种方式需要<strong>特殊的类加载器</strong>，它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ 5 的<a href="http://www.eclipse.org/aspectj/doc/next/devguide/ltw.html" target="_blank" rel="noopener">加载时织入（load-time weaving, LTW）</a>就支持以这种方式织入切面。</td></tr><tr><td>运行期</td><td>切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP 容器会为目标对象动态地创建一个代理对象。Spring AOP 就是以这种方式织入切面的。Spring AOP 构建在动态代理基础之上，因此，Spring 对 AOP 的支持局限于方法拦截。如果你的 AOP 需求超过了简单的方法调用（如构造器或属性拦截），那么你需要考虑使用 AspectJ 来实现切面。</td></tr></tbody></table><h1 id="Spring-AOP-与-AspectJ-AOP-对比"><a href="#Spring-AOP-与-AspectJ-AOP-对比" class="headerlink" title="Spring AOP 与 AspectJ AOP 对比"></a>Spring AOP 与 AspectJ AOP 对比</h1><p>这里总结下 Spring AOP 和 AspectJ AOP 两种织入方式的优缺点：</p><h2 id="Spring-AOP-优点"><a href="#Spring-AOP-优点" class="headerlink" title="Spring AOP 优点"></a>Spring AOP 优点</h2><ul><li><p>使用方式比 AspectJ 简单，无需特殊的 LTW 或 AspectJ Compiler，仅在运行时通知对象</p><blockquote><p>通过在代理类中包裹切面，Spring 在运行期把切面织入到 Spring 管理的 bean 中。如下图所示，代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标 bean。当代理拦截到方法调用时，在调用目标 bean 方法之前，会执行切面逻辑。</p></blockquote><p><img src="/img/java/proxy/Proxy.png" alt="Spring 的切面由包裹了目标对象的代理类实现。代理类处理方法的调用，执行额外的切面逻辑，并调用目标方法"></p><blockquote><p>直到应用需要被代理的 bean 时，Spring 才创建代理对象。如果使用的是 <code>ApplicationContext</code> 的话，在 <code>ApplicationContext</code> 从 <code>BeanFactory</code> 中<strong>加载所有 bean 的时候</strong>，Spring 才会创建被代理的对象。因为 Spring 运行时才创建代理对象，所以我们不需要特殊的编译器来织入 Spring AOP 的切面。</p></blockquote></li><li><p>Advice 使用 Java 编写，使用成本低</p><blockquote><p>Spring 所创建的通知（Advice）都是用标准的 Java 类编写的。这样的话，我们就可以使用与普通 Java 开发一样的集成开发环境（IDE）来开发切面。而且，定义通知所应用的切点通常会使用注解或在 Spring 配置文件里采用 XML 来编写，这两种语法对于Java开发者来说都是相当熟悉的。</p><p>AspectJ 与之相反。虽然 AspectJ 现在支持基于注解的切面，但 AspectJ 最初是以 Java 语言扩展的方式实现的。这种方式有优点也有缺点。通过特有的 AOP 语言，我们可以获得更强大和细粒度的控制，以及更丰富的 AOP 工具集，但是我们需要额外学习新的工具和语法。</p></blockquote></li></ul><h2 id="Spring-AOP-缺点"><a href="#Spring-AOP-缺点" class="headerlink" title="Spring AOP 缺点"></a>Spring AOP 缺点</h2><ul><li><p>只支持方法级别的 join points，局限于 public 方法拦截。</p><blockquote><p>正如前面所探讨过的，通过使用各种 AOP 方案可以支持多种连接点模型。因为 Spring 基于<strong>动态代理</strong>，所以 Spring 只支持<strong>方法连接点</strong>。这与一些其他的 AOP 框架是不同的，例如 AspectJ 和 JBoss，除了方法切点，它们还提供了字段和构造器接入点。Spring 缺少对字段连接点的支持，无法让我们创建细粒度的通知，例如拦截对象字段的修改。而且它不支持构造器连接点，我们就无法在 bean 创建时应用通知。</p><p>但是方法拦截可以满足绝大部分的需求。如果需要方法拦截之外的连接点拦截功能，那么我们可以利用 Aspect 来补充 Spring AOP 的功能。</p></blockquote></li><li><p>受限于 JDK Proxy 以及 CGLib Proxy<strong>（Spring 风格）</strong>的特点，不支持方法自调用（self-invocation），即同一个类中的方法调用无法应用切面。</p></li><li><p>无法将切面应用到非 Spring 工厂创建的 bean。</p></li><li><p>有一定的运行时开销。</p></li></ul><h2 id="AspectJ-AOP-优点"><a href="#AspectJ-AOP-优点" class="headerlink" title="AspectJ AOP 优点"></a>AspectJ AOP 优点</h2><ul><li>支持所有类型的 join points（构造器、字段、方法），可以做细粒度的控制。</li><li>支持任意访问修饰符（如 protected、private）、支持方法自调用（self-invocation）。</li></ul><h2 id="AspectJ-AOP-缺点"><a href="#AspectJ-AOP-缺点" class="headerlink" title="AspectJ AOP 缺点"></a>AspectJ AOP 缺点</h2><ul><li>使用上要小心，确保切面只织入到需要被织入的地方。</li><li>需要额外的 LTW 或 AspectJ Compiler。</li></ul><h1 id="Spring-对-AOP-的支持"><a href="#Spring-对-AOP-的支持" class="headerlink" title="Spring 对 AOP 的支持"></a>Spring 对 AOP 的支持</h1><p>Spring AOP 的设计理念和大多数其它 AOP 框架不同。目标并不是为了提供一个最完整的 AOP 实现，而是为了提供一个 AOP 实现与 Spring IoC 的紧密集成，以帮助解决企业级应用的常见问题。</p><h2 id="Spring-AOP-的两种实现方式"><a href="#Spring-AOP-的两种实现方式" class="headerlink" title="Spring AOP 的两种实现方式"></a>Spring AOP 的两种实现方式</h2><p>字节码操作库有很多，常用的例如：</p><ul><li>官方库：<a href="http://cr.openjdk.java.net/~jjg/199-269/199.api/java.compiler-summary.html" target="_blank" rel="noopener">JDK 9 - JEP 199 - Java Compiler API</a>。用于 JSP 引擎、等等。</li><li>三方库：ASM、Javassist</li></ul><p><img src="/img/spring/aop/aop_lib.png" alt="aop_lib"></p><h3 id="JDK-Proxy"><a href="#JDK-Proxy" class="headerlink" title="JDK Proxy"></a>JDK Proxy</h3><p>参考：《<a href="/2018/12/01/java-jdk-proxy/">Java 反射篇（四）JDK 动态代理总结</a>》</p><h3 id="CGLib"><a href="#CGLib" class="headerlink" title="CGLib"></a>CGLib</h3><p>基于 ASM 库。</p><p>参考：<a href="https://github.com/cglib/cglib/wiki" target="_blank" rel="noopener">https://github.com/cglib/cglib/wiki</a></p><p><img src="/img/spring/aop/cglib.png" alt="cglib"></p><h3 id="两种实现方式对比"><a href="#两种实现方式对比" class="headerlink" title="两种实现方式对比"></a>两种实现方式对比</h3><p>Spring AOP 支持两种模式的动态代理，JDK Proxy 或者 CGLib：</p><p><img src="/img/spring/aop/springaop-process.png" alt="Spring AOP process"></p><p>两种模式的优势如下：</p><ul><li><p>JDK Proxy</p><ul><li>最小化依赖关系，减少依赖意味着简化开发和维护，JDK 本身的支持，可能比 CGLib 更加可靠。</li><li>平滑进行 JDK 版本升级，而第三方字节码类库通常需要进行更新以保证在新版 Java 上能够使用。</li><li>代码实现简单，主要利用 JDK 反射机制。</li></ul></li><li><p>CGLib Proxy</p><ul><li>有的时候调用目标可能不便实现额外接口，从某种角度看，限定调用者实现接口是有些侵入性的实践，类似 CGLib 动态代理就没有这种限制。CGLib 动态代理采取的是创建目标类的子类的方式，因为是子类化，我们可以达到近似使用被调用者本身的效果。</li><li>只操作我们关心的类，而不必为其它相关类增加工作量。</li><li>性能更好，相对于低版本的 JDK Proxy。</li></ul></li></ul><h3 id="核心源码解析"><a href="#核心源码解析" class="headerlink" title="核心源码解析"></a>核心源码解析</h3><p><img src="/img/spring/aop/AopProxy.png" alt="AopProxy 实现结构"></p><p><code>org.springframework.aop.framework.DefaultAopProxyFactory</code> 工厂类负责判断创建哪个 <code>AopProxy</code> 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAopProxyFactory</span> <span class="keyword">implements</span> <span class="title">AopProxyFactory</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">            Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line">            <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">                        <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Determine whether the supplied &#123;<span class="doctag">@link</span> AdvisedSupport&#125; has only the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> org.springframework.aop.SpringProxy&#125; interface specified</span></span><br><span class="line"><span class="comment">     * (or no proxy interfaces specified at all).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNoUserSuppliedProxyInterfaces</span><span class="params">(AdvisedSupport config)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt;[] ifcs = config.getProxiedInterfaces();</span><br><span class="line">        return (ifcs.length == 0 || (ifcs.length == 1 &amp;&amp; SpringProxy.class.isAssignableFrom(ifcs[0])));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>org.springframework.aop.framework.CglibAopProxy</code></p><p><code>org.springframework.aop.framework.JdkDynamicAopProxy</code>，两个关键方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建基于接口的 JDK 动态代理</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implementation of &#123;<span class="doctag">@code</span> InvocationHandler.invoke&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// Get the interception chain for this method.</span></span><br><span class="line">        List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// We need to create a method invocation...</span></span><br><span class="line">        invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line">        <span class="comment">// Proceed to the joinpoint through the interceptor chain.</span></span><br><span class="line">        retVal = invocation.proceed();</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方文档的一些关键摘录：</p><h4 id="AOP-Proxies"><a href="#AOP-Proxies" class="headerlink" title="AOP Proxies"></a>AOP Proxies</h4><p>Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied.</p><p>Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than interfaces. By default, CGLIB is used if a business object does not implement an interface. As it is good practice to program to interfaces rather than classes, business classes normally implement one or more business interfaces. It is possible to <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-proxying" target="_blank" rel="noopener">force the use of CGLIB</a>, in those (hopefully rare) cases where you need to advise a method that is not declared on an interface or where you need to pass a proxied object to a method as a concrete type.</p><p>It is important to grasp the fact that Spring AOP is proxy-based. See <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-understanding-aop-proxies" target="_blank" rel="noopener">Understanding AOP Proxies</a> for a thorough examination of exactly what this implementation detail actually means.</p><h4 id="Proxying-Mechanisms"><a href="#Proxying-Mechanisms" class="headerlink" title="Proxying Mechanisms"></a>Proxying Mechanisms</h4><p>Spring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given target object. (JDK dynamic proxies are preferred whenever you have a choice).</p><p>If the target object to be proxied implements at least one interface, a JDK dynamic proxy is used. All of the interfaces implemented by the target type are proxied. If the target object does not implement any interfaces, a CGLIB proxy is created.</p><p>If you want to force the use of CGLIB proxying (for example, to proxy every method defined for the target object, not only those implemented by its interfaces), you can do so. However, you should consider the following issues:</p><ul><li><code>final</code> methods cannot be advised, as they cannot be overridden.</li><li>As of Spring 3.2, it is no longer necessary to add CGLIB to your project classpath, as CGLIB classes are repackaged under <code>org.springframework</code> and included directly in the spring-core JAR. This means that CGLIB-based proxy support “just works”, in the same way that JDK dynamic proxies always have.</li><li>As of Spring 4.0, the constructor of your proxied object is NOT called twice any more, since the CGLIB proxy instance is created through Objenesis. Only if your JVM does not allow for constructor bypassing, you might see double invocations and corresponding debug log entries from Spring’s AOP support.</li></ul><p>To force the use of CGLIB proxies, set the value of the <code>proxy-target-class</code> attribute of the <code>&lt;aop:config&gt;</code> element to true, as follows:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- other beans defined here... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>To force CGLIB proxying when you use the @AspectJ auto-proxy support, set the <code>proxy-target-class</code> attribute of the <code>&lt;aop:aspectj-autoproxy&gt;</code> element to <code>true</code>, as follows:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Spring-AOP-切面声明的两种方式"><a href="#Spring-AOP-切面声明的两种方式" class="headerlink" title="Spring AOP 切面声明的两种方式"></a>Spring AOP 切面声明的两种方式</h2><p>Spring 2.0 之后提供了以下两种方式，为编写自定义切面引入了一种更简单和更强大的方式：</p><h3 id="schema-based-approach"><a href="#schema-based-approach" class="headerlink" title="schema-based approach"></a>schema-based approach</h3><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-schema" target="_blank" rel="noopener">schema-based approach</a>，手工声明切面方式。下面是一个完整的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- this is the object that will be proxied by Spring's AOP infrastructure --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"personService"</span> <span class="attr">class</span>=<span class="string">"x.y.service.DefaultPersonService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- this is the actual advice itself --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">class</span>=<span class="string">"x.y.MyAspect"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- cglib 代理方式配置：proxy-target-class="true" --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"myAspect"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"theExecutionOfSomePersonServiceMethod"</span> <span class="attr">expression</span>=<span class="string">"execution(* x.y.service.PersonService.getPerson(String,int)) and args(name, age)"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">pointcut-ref</span>=<span class="string">"theExecutionOfSomePersonServiceMethod"</span> <span class="attr">method</span>=<span class="string">"process"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="AspectJ-annotation-style"><a href="#AspectJ-annotation-style" class="headerlink" title="@AspectJ annotation style"></a>@AspectJ annotation style</h3><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop-ataspectj" target="_blank" rel="noopener">@AspectJ annotation style</a></p><ul><li><code>@AspectJ</code> 注解风格作为 AspectJ 5 发行版的一部分被引入。Spring 利用了这个注解，使用了 AspectJ 提供的类库进行切点解析和匹配。然而，AOP 运行时仍然是纯 Spring AOP，并且不依赖于 AspectJ 编译器和织入器。</li><li>The <code>@AspectJ</code> support can be enabled with XML- or Java-style configuration. In either case, you also need to ensure that AspectJ’s <code>aspectjweaver.jar</code> library is on the classpath of your application (version 1.8 or later).</li></ul><p>配置如下：</p><ul><li><p>Java Config 方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 Java Config</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 开启组件扫描，将 MethodCacheInterceptor 作为 bean 注册到 Spring 容器</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="comment">// 开启自动代理</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConertConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>注解 <code>@EnableAspectJAutoProxy</code> 用于开启 AspectJ 自动代理，为使用 <code>@Aspect</code> 注解的 bean 创建一个代理。其中 <code>proxyTargetClass</code> 属性用于控制代理方式：</p><ul><li>true 表示开启 CGLIB 风格的子类继承代理（CGLIB-style ‘subclass’ proxy）</li><li>默认为 false 表示开启基于接口的 JDK 动态代理（interface-based JDK proxy）</li></ul></li><li><p>XML 配置方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"your.package"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span>  <span class="comment">&lt;!-- 代理方式配置：proxy-target-class="true" --&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>由于项目中散落着各种使用缓存的代码，这些缓存代码与业务逻辑代码交织耦合在一起既编写重复又难以维护，因此打算将这部分缓存代码抽取出来形成一个注解以便使用。</p><p>这样的需求最适合通过 AOP 来解决了，来看看如何在 Spring 框架下通过 AOP 和注解实现方法缓存：</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>首先，自定义一个方法注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> your.<span class="keyword">package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法级缓存</span></span><br><span class="line"><span class="comment"> * 标注了这个注解的方法返回值将会被缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MethodCache &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存过期时间，单位是秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expire</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写切面"><a href="#编写切面" class="headerlink" title="编写切面"></a>编写切面</h2><p>使用注解来创建切面，是 AspectJ 5 所引入的关键特性。在 AspectJ 5 之前，编写 AspectJ 切面需要学习一种 Java 语言的扩展，很不友好。在此我们使用注解来实现我们的切面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> your.<span class="keyword">package</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kingdee.finance.cache.service.centralize.CentralizeCacheService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法级缓存拦截器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodCacheInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CACHE_NAME = <span class="string">"Your unique cache name"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CentralizeCacheService centralizeCacheService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 搭配 AspectJ 指示器“<span class="doctag">@annotation</span>()”可以使本切面成为某个注解的代理实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(your.package.MethodCache)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String cacheKey = getCacheKey(joinPoint);</span><br><span class="line">        Serializable serializable = centralizeCacheService.get(CACHE_NAME, cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (serializable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"cache hit，key [&#123;&#125;]"</span>, cacheKey);</span><br><span class="line">            <span class="keyword">return</span> serializable;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"cache miss，key [&#123;&#125;]"</span>, cacheKey);</span><br><span class="line">            Object result = joinPoint.proceed(joinPoint.getArgs());</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">                log.error(<span class="string">"fail to get data from source，key [&#123;&#125;]"</span>, cacheKey);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                MethodCache methodCache = getAnnotation(joinPoint, MethodCache<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                centralizeCacheService.put(CACHE_NAME, methodCache.expire(), cacheKey, (Serializable) result);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据类名、方法名和参数值获取唯一的缓存键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 格式为 "包名.类名.方法名.参数类型.参数值"，类似 "your.package.SomeService.getById(int).123"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCacheKey</span><span class="params">(ProceedingJoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%s.%s"</span>, </span><br><span class="line">                 joinPoint.getSignature().toString().split(<span class="string">"\\s"</span>)[<span class="number">1</span>], StringUtils.join(joinPoint.getArgs(), <span class="string">","</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T extends Annotation&gt; <span class="function">T <span class="title">getAnnotation</span><span class="params">(ProceedingJoinPoint jp, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        MethodSignature sign = (MethodSignature) jp.getSignature();</span><br><span class="line">        Method method = sign.getMethod();</span><br><span class="line">        <span class="keyword">return</span> method.getAnnotation(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的是，目前该实现存在两个限制：</p><ol><li>方法入参必须为基本数据类型或者字符串类型，使用其它引用类型的参数会导致缓存键构造有误；</li><li>方法返回值必须实现  <code>Serializable</code> 接口；</li></ol><h2 id="开启动态代理"><a href="#开启动态代理" class="headerlink" title="开启动态代理"></a>开启动态代理</h2><p>最后，开启 Spring 的组件扫描、自动代理功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 Java Config</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 开启组件扫描，将 MethodCacheInterceptor 作为 bean 注册到 Spring 容器</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConertConfig</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="投入使用"><a href="#投入使用" class="headerlink" title="投入使用"></a>投入使用</h2><p>例如，使用本注解为一个“按 ID 查询列表”的方法加上五分钟的缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MethodCache</span>(expire = <span class="number">300</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">listById</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return a string list.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 AOP 技术，你可以在一个地方定义所有的通用逻辑，并通过<strong>声明式（declaratively）</strong>的方式进行使用，而不必修改各个业务类的实现。这种代码解耦技术使得我们的业务代码更纯粹、仅包含所需的业务逻辑。相比继承（inheritance）和委托（delegation），AOP 实现相同的功能，代码会更整洁。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://www.manning.com/books/spring-in-action-fourth-edition" target="_blank" rel="noopener">Spring in Action, 4th</a>》</p><p><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop</a></p><p>AspectJ</p><ul><li><p><a href="https://livebook.manning.com/book/aspectj-in-action-second-edition/chapter-8/" target="_blank" rel="noopener">https://livebook.manning.com/book/aspectj-in-action-second-edition/chapter-8/</a></p></li><li><p>《<a href="https://www.eclipse.org/aspectj/docs.php" target="_blank" rel="noopener">AspectJ Docs</a>》</p></li><li><p>《<a href="http://www.eclipse.org/aspectj/doc/released/devguide/ajc-ref.html" target="_blank" rel="noopener">AspectJ Compiler (ajc)</a>》</p></li></ul><p><a href="http://openjdk.java.net/jeps/199" target="_blank" rel="noopener">http://openjdk.java.net/jeps/199</a></p><p><a href="https://github.com/cglib/cglib/wiki" target="_blank" rel="noopener">https://github.com/cglib/cglib/wiki</a></p><p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/annotation/EnableAspectJAutoProxy.html" target="_blank" rel="noopener">@EnableAspectJAutoProxy</a></p><p><a href="https://www.cnblogs.com/xrq730/p/6661692.html" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/6661692.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>find 命令使用总结</title>
      <link href="2017/07/08/gnu-findutils/"/>
      <url>2017/07/08/gnu-findutils/</url>
      
        <content type="html"><![CDATA[<p><code>find</code> 是最常见和最强大的查找命令，直接查找磁盘，缺点耗时长。命令格式如下：</p><p><code>find [path...] [expression]</code></p><p>The  expression  is made up of :</p><ul><li><code>options</code> (which affect overall operation rather than the processing of a specific file, and always return true)</li><li><code>tests</code> (which return a true or false value)</li><li><code>actions</code> (which have side effects and return a true or false value)</li></ul><p>all separated by <code>operators</code>.</p><h1 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h1><p>常用选项：</p><ul><li><code>-maxdepth 1</code> 只查找当前目录</li></ul><h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>常用条件：</p><ul><li><p><code>-name</code> 名称查找（例如：<code>find ./ -name &#39;struts*&#39;</code>）</p></li><li><p><code>-type</code> 类型查找</p><ul><li><code>d</code> 目录类型</li><li><code>f</code> 常规文件类型</li><li><code>l</code> 软链类型</li><li>……</li></ul></li><li><p><code>-user</code> 设定所属用户的名称</p></li><li><p><code>-group</code> 设定所属用户组的名称</p></li><li><p><code>-perm</code> 设定权限</p></li><li><p><code>-regex</code> 使用正则表达式进行匹配</p></li><li><p><code>-size</code> 表示文件大小</p></li><li><p><code>-empty</code> 空文件或空目录</p></li><li><p><code>-atime / -amin</code> File was last accessed n*24 hours/n minutes ago.</p></li><li><p><code>-ctime / -cmin</code> File’s status was last changed n*24hours/n minutes ago.</p></li><li><p><code>-mtime / -mmin</code> File’s data was last modified n*24hours/n minutes ago.</p></li></ul><h1 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h1><p>常用动作：</p><ul><li><code>-print</code> 输出结果（默认动作）</li><li><code>-ls</code> 输出详情</li><li><code>-delete</code> 执行删除</li><li><code>-exec</code> 执行指定命令</li></ul><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>操作符用于提高表达式的优先级，下列操作符的优先级以倒序排列：</p><ul><li><code>( expr )</code> 强制最高优先级</li><li><code>! expr</code> 求反操作</li><li><code>expr1 expr2</code> (or <code>expr1 -a expr2</code>) 求与操作</li><li><code>expr1 -o expr2</code> 求或操作</li></ul><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="按文件名查找"><a href="#按文件名查找" class="headerlink" title="按文件名查找"></a>按文件名查找</h2><p>查找当前目录树中，名字以 <code>fileA_</code> 或 <code>fileB_</code> 开头的所有文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name <span class="string">'fileA_*'</span> -o -name <span class="string">'fileB_*'</span></span><br></pre></td></tr></table></figure><p>查找当前目录树中的 <code>foo.cpp</code> 文件，查找过程中排查掉 <code>.svn</code> 子目录树：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name <span class="string">'foo.cpp'</span> <span class="string">'!'</span> -path <span class="string">'.svn'</span></span><br></pre></td></tr></table></figure><p>查找当前目录树中，以 <code>my</code> 开头的常规文件，并输出文件详情：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name <span class="string">'my*'</span> -<span class="built_in">type</span> f -ls</span><br></pre></td></tr></table></figure><h2 id="按大小查找"><a href="#按大小查找" class="headerlink" title="按大小查找"></a>按大小查找</h2><p>查找大小在 100k~500k 的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -size +100k -a -size -500k</span><br></pre></td></tr></table></figure><p>查找空文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -size 0k</span><br></pre></td></tr></table></figure><p>查找非空文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . ! -size 0k</span><br></pre></td></tr></table></figure><h2 id="删除文件或目录"><a href="#删除文件或目录" class="headerlink" title="删除文件或目录"></a>删除文件或目录</h2><p>删除空文件或空目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> f -empty -delete</span><br><span class="line">$ find . -<span class="built_in">type</span> d -empty -delete</span><br></pre></td></tr></table></figure><p>根据 inode 号删除乱码文件：：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -inum &lt;inode-number&gt; -<span class="built_in">exec</span> rm -i &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm `find ./ -inum &lt;inode-number&gt;`</span><br></pre></td></tr></table></figure><p><img src="/img/gnu-linux/find.jpg" alt="find -exec"></p>]]></content>
      
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Factory Bean 总结</title>
      <link href="2017/06/15/spring-factory-bean/"/>
      <url>2017/06/15/spring-factory-bean/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/FactoryBean.html" target="_blank" rel="noopener">org.springframework.beans.factory.FactoryBean</a> 用于在 IoC 容器中创建其它 Bean，该接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span>  <span class="comment">// Return an instance (possibly shared or independent) of the object managed by this factory.</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt; <span class="title">getObjectType</span><span class="params">()</span>  <span class="comment">// Return the type of object that this FactoryBean creates, or null if not known in advance.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span>  <span class="comment">// Is the object managed by this factory a singleton? That is, will getObject() always return the same object (a reference that can be cached)?</span></span></span><br></pre></td></tr></table></figure><p>有哪些现存的 <code>FactoryBean</code>？例如：</p><ul><li>当需要从 JNDI 查找对象（例如 <code>DataSource</code>）时，可以使用 <code>JndiObjectFactoryBean</code>。</li><li>当使用 Spring AOP 为 bean 创建代理时，可以使用 <code>ProxyFactoryBean</code>。</li><li>当需要在 IoC 容器中创建 Hibernate 的 <code>SessionFactory</code> 时，可以使用 <code>LocalSessionFactoryBean</code>。</li><li>当需要在 IoC 容器中创建 MyBatis 的 <code>SqlSessionFactory</code> 时，可以使用 <code>SqlSessionFactoryBean</code>。</li></ul><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>这里我们举一个例子：</p><p>如果要为某个接口生成 JDK 动态代理，且将该代理对象放入 Spring IoC 容器，以便后续依赖注入使用，可以自定义实现 <code>FactoryBean</code> 实现如下效果，如图：</p><p><img src="/img/spring/HttpApiService_example.png" alt="HttpApiService_example"></p><p>实现代码如下，首先创建接口及其代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Xxx 接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpApiService</span> </span>&#123;</span><br><span class="line">    <span class="function">HttpRespDTO&lt;XxxRespDTO&gt; <span class="title">api1</span><span class="params">(XxxReqDTO reqDTO)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Xxx 接口的动态代理实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpApiServiceProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一、手工注册-1-0"><a href="#一、手工注册-1-0" class="headerlink" title="一、手工注册 1.0"></a>一、手工注册 1.0</h2><p>如果只需创建一个 <code>FactoryBean</code>，可以将其作为一个 Java Config 加上 <code>@Configuration</code> 即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Xxx 接口工厂，用于创建代理实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpApiServiceFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">HttpApiService</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt; API_INTERFACE = HttpApiService<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpApiService <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (HttpApiService) Proxy.newProxyInstance(</span><br><span class="line">            API_INTERFACE.getClassLoader(), <span class="keyword">new</span> Class[]&#123; API_INTERFACE &#125;, <span class="keyword">new</span> HttpApiServiceProxy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> API_INTERFACE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、手工注册-2-0"><a href="#二、手工注册-2-0" class="headerlink" title="二、手工注册 2.0"></a>二、手工注册 2.0</h2><p>如果需要创建多个 <code>FactoryBean</code>，可以使用泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpApiServiceFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; apiService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                apiService.getClassLoader(), <span class="keyword">new</span> Class[]&#123; apiService &#125;, <span class="keyword">new</span> HttpApiServiceProxy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> apiService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java Config 如下，手工创建多个 <code>FactoryBean</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpApiServiceConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpApiServiceFactoryBean&lt;UserHttpApiService&gt; <span class="title">userHttpApiService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpApiServiceFactoryBean(UserHttpApiService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpApiServiceFactoryBean&lt;RoleHttpApiService&gt; <span class="title">roleHttpApiService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpApiServiceFactoryBean(RoleHttpApiService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式参考了 <a href="https://mybatis.org/spring/zh/mappers.html#register" target="_blank" rel="noopener">Mybatis-Spring 注册映射器</a>。</p><h2 id="三、自动发现"><a href="#三、自动发现" class="headerlink" title="三、自动发现"></a>三、自动发现</h2><p>如果想进一步省略 Java Config，做到自动扫描并创建 <code>FactoryBean</code>，可以创建自动配置类。例如，为添加了 <code>@HttpApi</code> 注解的接口创建相应的 <code>FactoryBean</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HttpApi 动态代理自动配置类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AutoConfiguredHttpApiScannerRegistrar<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HttpApiServiceAutoConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义 ImportBeanDefinitionRegistrar</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoConfiguredHttpApiScannerRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描 Application 类所在的 classpath。也可以指定其它路径（如配合 @EnableHttpApi 注解使用）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_PKG = Application<span class="class">.<span class="keyword">class</span>.<span class="title">getPackage</span>().<span class="title">getName</span>()</span>;</span><br><span class="line">    <span class="keyword">private</span> ResourceLoader resourceLoader;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"Searching for HttpApiService annotated with @HttpApi from &#123;&#125;"</span>, BASE_PKG);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 配置自定义的 ClassPathHttpApiScanner</span></span><br><span class="line">                ClassPathHttpApiScanner scanner = <span class="keyword">new</span> ClassPathHttpApiScanner(registry);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    scanner.setResourceLoader(<span class="keyword">this</span>.resourceLoader);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 扫描指定路径</span></span><br><span class="line">                scanner.doScan(BASE_PKG);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                log.debug(<span class="string">"Could not determine auto-configuration package, automatic @HttpApi scanning disabled."</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义 ClassPathHttpApiScanner</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassPathHttpApiScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathHttpApiScanner</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(registry, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加过滤条件，这里是只要添加了 @HttpApi 注解的类或接口，就会被扫描到</span></span><br><span class="line">        addIncludeFilter(<span class="keyword">new</span> AnnotationTypeFilter(HttpApi<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 Spring 的扫描</span></span><br><span class="line">        Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">super</span>.doScan(basePackages);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">            logger.warn( <span class="string">"No @HttpApi bean was found in '"</span> + Arrays.toString(basePackages) + <span class="string">"' package. Please check your configuration."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理扫到的 BeanDefinition</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            processBeanDefinitions(beanDefinitions);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">        GenericBeanDefinition definition;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">            definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">            String beanClassName = definition.getBeanClassName();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 修改 BeanDefinition 的 BeanClass 为 FactoryBean</span></span><br><span class="line">            definition.setBeanClass(HttpApiServiceFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 为构造方法指定所需参数</span></span><br><span class="line">            <span class="comment">// definition.getPropertyValues().add("restTemplate", new RuntimeBeanReference("restTemplate"));</span></span><br><span class="line">            definition.getPropertyValues().add(<span class="string">"apiService"</span>, getClass(beanClassName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; getClass(String beanClassName)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Class.forName(beanClassName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖原有策略，限定只需要接口类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCandidateComponent</span><span class="params">(AnnotatedBeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanDefinition.getMetadata().isInterface() &amp;&amp; beanDefinition.getMetadata().isIndependent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式参考了 <a href="https://mybatis.org/spring/zh/mappers.html#scan" target="_blank" rel="noopener">Mybatis-Spring 发现映射器</a>。</p><p>需要用到 Spring 的几个类，待补充：</p><ul><li><code>ImportBeanDefinitionRegistrar</code></li><li><code>ClassPathBeanDefinitionScanner</code><ul><li><code>BeanDefinitionHolder</code></li><li><code>GenericBeanDefinition</code></li><li><code>AnnotatedBeanDefinition</code></li></ul></li></ul><p><img src="/img/spring/BeanDefinition.png" alt="BeanDefinition"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://www.jianshu.com/p/05c909c9beb0" target="_blank" rel="noopener">Spring BeanFactory和FactoryBean的区别</a>》</p><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/FactoryBean.html" target="_blank" rel="noopener">org.springframework.beans.factory.FactoryBean</a></p><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolExecutorFactoryBean.html" target="_blank" rel="noopener">ThreadPoolExecutorFactoryBean</a></p><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/orm/hibernate5/LocalSessionFactoryBean.html" target="_blank" rel="noopener">LocalSessionFactoryBean</a></p><p><a href="https://github.com/mybatis/spring/blob/master/src/main/java/org/mybatis/spring/SqlSessionFactoryBean.java" target="_blank" rel="noopener">SqlSessionFactoryBean</a></p><p><a href="https://mybatis.org/spring/zh/mappers.html#" target="_blank" rel="noopener">MyBatis-Spring 注入映射器</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean 几种配置方式总结</title>
      <link href="2017/06/04/spring-bean-wiring/"/>
      <url>2017/06/04/spring-bean-wiring/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/spring/spring-bean.png" alt="spring-bean"></p><p>Spring 组件引入的两种推荐方式：</p><ul><li>非 Spring Boot 项目，显示引入  Java Config：<code>@Enable*</code> + <code>@Import</code></li><li>Spring Boot 项目，隐式引入  Java Config：<code>@EnableAutoConfiguration</code> + <code>META-INF/spring.factories</code></li></ul><p>Spring bean 的声明及装配的几种配置方式：</p><ul><li><del>基于 XML Config 的显式配置，不推荐</del></li><li>基于 Java Config 的显式配置，推荐用于声明第三方编写的组件</li><li>自动化配置，即组件扫描（隐式的 bean 发现机制） + 自动装配，推荐用于自己编写的组件</li></ul><p>用户可以选择其中一种方式使用，也可以混搭使用。使用时的最佳实践如下：</p><ul><li>建议尽可能地使用自动化配置的机制。显式配置越少越好，以避免显式配置所带来的维护成本。</li><li>当你必须要显式配置 bean 的时候（比如，有些源码不是由你来维护的，而当你需要为这些代码配置 bean 的时候），推荐使用类型安全并且比 XML Config 更加强大的 Java Config。</li><li>最后，只有当你想要使用便利的 XML 命名空间，并且在 JavaConfig 中没有同样的实现时，才应该使用 XML Config。</li></ul><p>这里提供一个例子，其接口和实现类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompactDisc</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SgtPeppers</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h1><p>Spring 从两个角度来实现 bean 的自动化配置：</p><ul><li>组件扫描（component scanning）：Spring 会自动发现应用上下文中要创建的 bean。</li><li>自动装配（autowiring）：Spring 自动满足 bean 之间的依赖。</li></ul><p>组件扫描（隐式的 bean 发现机制）和自动装配组合在一起能够发挥出强大的威力，它们能够将你的显式配置降低到最少。</p><h2 id="声明组件"><a href="#声明组件" class="headerlink" title="声明组件"></a>声明组件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Component 注解表明该类会作为组件类，并告知 Spring 要为这个类创建 bean。因此没有必要在 XML 或 Java Config 中显式配置该 bean。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SgtPeppers</span> <span class="keyword">implements</span> <span class="title">CompactDisc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式声明 Java Config 配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 组件扫描默认是不启用的。我们还需要显式配置一下 Spring，从而命令它去寻找带有 @Component 注解的类，并为其创建 bean。</span></span><br><span class="line"><span class="comment">// @ComponentScan 默认会扫描与配置类相同的包及其子包。有一个原因会促使我们明确地设置基础包，那就是我们想要将配置类放在单独的包中，使其与其他的应用代码区分开来。</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有显式地声明任何 bean，但由于开启了组件扫描，会在 Spring 容器中自动创建一个 SgtPeppers 类的 bean。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>为了测试组件扫描的功能，我们创建一个简单的 JUnit 单元测试。它会创建 Spring 上下文，并判断 bean 是否真的创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="class">.<span class="keyword">class</span>) // 用于自动创建 <span class="title">Spring</span> 的应用上下文</span></span><br><span class="line"><span class="class">@<span class="title">ContextConfiguration</span>(<span class="title">classes</span></span>=CDPlayerConfig<span class="class">.<span class="keyword">class</span>) // 指定要加载的配置</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">CDPlayerTest</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// @Autowired 是 Spring 特有的注解，也可以使用 Java 依赖注入规范的 @Inject</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CompactDisc cd;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cdShouldNotBeNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertNotNull(cd); <span class="comment">// 测试通过</span></span><br><span class="line">        cd.play(); <span class="comment">// 输出 Hello world!</span></span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何处理自动装配的歧义性问题？有两种方案：</p><ul><li>使用 <code>@Primary</code> 注解将可选 bean 中的某一个设为首选的 bean。<code>@Primary</code> 能够与 <code>@Component</code> 组合用在组件扫描的 bean 上，也可以与 <code>@Bean</code> 组合用在 Java 配置的 bean 声明中。 </li><li>使用限定符注解 <code>@Qualifier</code> 来帮助 Spring 将可选的 bean 的范围缩小到只有一个 bean。</li></ul><h1 id="基于-Java-Config-的显式配置"><a href="#基于-Java-Config-的显式配置" class="headerlink" title="基于 Java Config 的显式配置"></a>基于 Java Config 的显式配置</h1><p>尽管在很多场景下通过组件扫描和自动装配实现 Spring 的自动化配置是更为推荐的方式，但有时候自动化配置的方案行不通，因此需要显式配置 Spring。比如说，你想要将第三方库中的组件装配到你的应用中，在这种情况下，是没有办法在它的类上添加 <code>@Component</code> 和 <code>@Autowired</code> 注解的，因此就不能使用自动化装配的方案了。</p><p>在这种情况下，就必须要采用显式装配的方式。在进行显式配置的时候，有两种可选方案：Java 和 XML。Java Config 的优缺点如下：</p><ul><li>优点：类型安全，对重构友好且不易出错。因为它就是 Java 代码，就像应用程序中的其它 Java 代码一样。</li><li>缺点：如果修改了 Java Config 类中的配置，就必须重新编译应用程序。</li></ul><p>同时，Java Config 与其它的 Java 代码又有所区别，在概念上，它与应用程序中的业务逻辑和领域代码是不同的。尽管它与其它的组件一样都使用相同的语言进行表述，但 Java Config 是配置代码。这意味着它不应该包含任何业务逻辑，Java Config 也不应该侵入到业务逻辑代码之中。尽管不是必须的，但通常会将 Java Config <strong>放到单独的包中</strong>，使它与其他的应用程序逻辑分离开来，这样对于它的意图就不会产生困惑了。</p><p>下面是一个 Java Config 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式声明 Java Config 配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDPlayerConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式地声明 bean。@Bean 注解会告诉 Spring 这个方法将会返回一个对象，该对象要注册为 Spring 应用上下文中的 bean。方法体中包含了最终产生 bean 实例的逻辑。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompactDisc <span class="title">getCompactDisc</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> SgtPeppers(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 装配方式一：Spring 将会拦截所有对 getCompactDisc() 的调用，并确保直接返回该方法所创建的 bean，而不是每次都对其进行实际的调用。且默认情况下，Spring 中的 bean 都是单例的，因此多次调用只会返回同一个实例。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CDPlayer <span class="title">getCDPlayer1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(getCompactDisc())；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 装配方式二：上述通过调用方法来引用 bean 的方式有点令人困惑。而下面这种方式的好处是：</span></span><br><span class="line">    <span class="comment">// 1.不要求将 CompactDisc 声明到同一个配置类之中。</span></span><br><span class="line">    <span class="comment">// 2.不关注 Bean 的配置方式，你可以将配置分散到多个配置类、XML 文件以及自动扫描和装配 bean 之中，只要功能完整健全即可。</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CDPlayer <span class="title">getCDPlayer2</span><span class="params">(CompactDisc cd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CDPlayer(cd)；</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这个 Java Config 需要放在 <code>@ComponentScan</code> 能够扫描到的路径之下，否则配置中所声明的 bean 将无法被 Spring 容器所注册。</p><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>有时候我们需要引入一些外部的 Java Config 配置，这些配置往往是在其它 package 下。此时可以通过 <code>@Import</code> 注解导入这些外部 Java Config。</p><h2 id="Enable"><a href="#Enable" class="headerlink" title="@Enable*"></a>@Enable*</h2><p><code>@Import</code> 注解导入 Java Config 的方式有时不够直观，主流的做法是为其包装一层 <code>@Enable*</code> 注解，其字面意思是“开启某个功能”，非常直观。Spring 框架中提供了大量这类注解：</p><p>Spring Framework：</p><ul><li>spring-context<ul><li><code>@EnableAsync</code> 开启对 <code>@Async</code> 注解的支持</li><li><code>@EnableScheduling</code> 开启对 <code>@Scheduled</code> 注解的支持</li><li><code>@EnableCaching</code> 开启对 <code>@Cacheable</code> 注解的支持</li><li><code>@EnableAspectJAutoProxy</code> 开启对 <code>@Aspect</code> 注解的支持</li><li><code>@EnableLoadTimeWeaving</code></li><li><code>@EnableMBeanExport</code></li></ul></li><li>spring-tx<ul><li><code>@EnableTransactionManagement</code> 开启对 <code>@Transactional</code> 注解的支持</li></ul></li><li>spring-webmvc<ul><li><code>@EnableWebMvc</code> 开启对 <code>@Controller</code> 注解的支持</li></ul></li><li>spring-webflux<ul><li><code>@EnableWebFlux</code></li></ul></li><li>spring-websocket<ul><li><code>@EnableWebSocket</code></li><li><code>@EnableWebSocketMessageBroker</code></li></ul></li><li>spring-jms<ul><li><code>@EnableJms</code></li></ul></li></ul><p>其它组件：</p><ul><li>spring-security<ul><li><code>@EnableWebSecurity</code></li></ul></li><li>spring-data-jpa<ul><li><code>@EnableJpaRepositories</code></li></ul></li><li>spring-boot-autoconfigure<ul><li><code>@EnableAutoConfiguration</code></li></ul></li></ul><p>通过简单的 <code>@Enable*</code> 即可开启一项功能的支持，从而避免大量配置，大大降低使用难度。通过观察这些 <code>@Enable*</code> 注解的源码，可以发现所有的注解都有一个 <code>@Import</code> 注解，<code>@Import</code> 是用来导入配置类的，这也就意味着这些自动开启的实现其实就是导入了一些自动配置的 Bean。这些导入的配置主要分为以下三类：</p><ol><li>直接导入配置类</li><li>依据条件选择配置类</li><li>动态注册 Bean</li></ol><h2 id="条件化的-bean"><a href="#条件化的-bean" class="headerlink" title="条件化的 bean"></a>条件化的 bean</h2><p>假设你希望一个或多个 bean 只有在应用的类路径下包含特定的库时才创建。或者我们希望某个 bean 只有当另外某个特定的 bean 也声明了之后才会创建。我们还可能要求只有某个特定的环境变量设置之后，才会创建某个 bean。<br>在 Spring 4 之前，很难实现这种级别的条件化配置，但是 Spring 4 引入了一个新的 <code>@Conditional</code> 注解，它可以用到带有 <code>@Bean</code>注解的方法上。如果给定的条件计算结果为 <code>true</code>，就会创建这个 bean，否则的话，这个 bean 会被忽略。</p><p>详情参考另一篇博文：《<a href="/2017/09/05/spring-conditional-bean/">Spring Bean 条件化配置总结</a>》</p><h1 id="基于-XML-的显式配置"><a href="#基于-XML-的显式配置" class="headerlink" title="基于 XML 的显式配置"></a>基于 XML 的显式配置</h1><p>XML 配置的缺点是比较复杂，且无法从编译期的类型检查中受益。除非是老项目维护，否则在新项目中已不再建议使用，此处不作过多介绍。</p><h1 id="混合配置"><a href="#混合配置" class="headerlink" title="混合配置"></a>混合配置</h1><p>在典型的 Spring 应用中，我们可能会同时使用自动化和显式配置。这些配置方案不是互斥的，可以将 Java Config 的组件扫描和自动装配和/或 XML 配置混合在一起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个全局的根配置，并组合各种配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">// 通常会在根配置中启用组件扫描</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="comment">// 导入 Java Config</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;FirstConfig<span class="class">.<span class="keyword">class</span>, <span class="title">SecondConfig</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">// 导入 <span class="title">XML</span> 配置</span></span><br><span class="line">@ImportResource("classpath:applicationContext.xml")</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">GlobalConfig</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://www.manning.com/books/spring-in-action-fourth-edition" target="_blank" rel="noopener">Spring in Action, 4th</a>》</p><p>《<a href="https://www.ibm.com/developerworks/cn/webservices/ws-springjava/" target="_blank" rel="noopener">使用 Java 配置进行 Spring bean 管理</a>》</p><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/package-summary.html" target="_blank" rel="noopener">Package org.springframework.context.annotation</a></p><blockquote><p>Annotation support for the Application Context, including JSR-250 “common” annotations, component-scanning, and Java-based metadata for creating Spring-managed objects.</p></blockquote><p>《<a href="http://blog.longjiazuo.com/archives/1366" target="_blank" rel="noopener">Spring4.x高级话题(六):@Enable*注解的工作原理</a>》</p><p>《<a href="http://blog.fawnanddoug.com/2012/08/how-those-spring-enable-annotations-work.html" target="_blank" rel="noopener">How those Spring @Enable* Annotations work</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Bean 生命周期与作用域总结</title>
      <link href="2017/06/03/spring-bean-lifecycle/"/>
      <url>2017/06/03/spring-bean-lifecycle/</url>
      
        <content type="html"><![CDATA[<h1 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h1><p>Spring Bean Factory 负责管理 bean 的生命周期，可以分为三个阶段：</p><p><img src="/img/spring/spring-bean-life-cycle.png" alt="Spring Bean Life Cycle"></p><p>一、初始化阶段：</p><ul><li>Instantiation：Spring 启动，查找并加载需要被 Spring 管理的bean，进行 Bean 的实例化，调用构造方法。</li><li>Populate Properties：属性注入，包括引用的 Bean 和值，调用 setter 方法。</li><li>调用该 Bean 实现的各种生命周期回调接口。</li></ul><p>二、就绪阶段：</p><ul><li>此时，Bean 已经准备就绪，可以被应用程序使用了。它们将一直驻留在应用上下文中，直到应用上下文被销毁。</li></ul><p>三、销毁阶段：</p><ul><li>调用该 Bean 实现的各种生命周期回调接口。</li></ul><h2 id="初始化和销毁方法"><a href="#初始化和销毁方法" class="headerlink" title="初始化和销毁方法"></a>初始化和销毁方法</h2><p>Spring 框架提供了以下几种方式指定 bean 生命周期的初始化和销毁回调方法：</p><table><thead><tr><th></th><th>初始化</th><th>销毁</th></tr></thead><tbody><tr><td>实现 Spring Boot 的接口</td><td><a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/ApplicationRunner.html" target="_blank" rel="noopener"><code>ApplicationRunner</code></a></td><td></td></tr><tr><td>实现 Spring Framework 的接口</td><td><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/InitializingBean.html" target="_blank" rel="noopener"><code>InitializingBean</code></a></td><td><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/DisposableBean.html" target="_blank" rel="noopener"><code>DisposableBean</code></a></td></tr><tr><td>在 Spring <code>@Bean</code> 注解中指定属性</td><td><code>@Bean(initMethod=&quot;xxx&quot;)</code></td><td><code>@Bean(destroyMethod=&quot;xxx&quot;)</code></td></tr><tr><td>在 Spring bean 配置文件指定属性</td><td><code>&lt;bean init-method=&quot;xxx&quot; /&gt;</code></td><td><code>&lt;bean destroy-method=&quot;xxx&quot; /&gt;</code></td></tr><tr><td>使用 JavaEE 规范 <code>javax.annotation</code> 包中提供的注解</td><td><code>@PostConstruct</code></td><td><code>@PreDestroy</code></td></tr></tbody></table><p>在 Spring 容器启动后执行一些初始化逻辑是一个很常见的场景，注意使用不同的方式，顺序不同：</p><p><img src="/img/spring/spring-bean-lifecycle-3.png" alt=""></p><p>参考：<a href="https://zhuanlan.zhihu.com/p/44786291" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44786291</a></p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OssUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;oss.endpoint&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;oss.access-key-id&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;oss.access-key-secret&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;oss.bucket-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bucketName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OSS ossClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ossClient = <span class="keyword">new</span> OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Aware-接口"><a href="#Aware-接口" class="headerlink" title="Aware 接口"></a>Aware 接口</h2><p>在日常的开发中，我们经常需要用到 Spring 容器本身的功能资源，可以通过 Spring 提供的一系列 <code>Aware (org.springframework.beans.factory)</code> 子接口来实现具体的功能。<code>Aware</code> 是一个具有标识作用的超级接口，实现该接口的 bean 具有被 Spring 容器通知的能力，而被通知的方式就是通过回调，以依赖注入的方式为 bean 设置相应属性，这是一个典型的依赖注入的使用场景。<code>Aware</code> 接口的继承关系如下：</p><p><img src="/img/spring/aware_interface.png" alt="Aware 接口"></p><p>这些 <code>*Aware</code> 子接口在 Spring Bean  的生命周期中被回调的顺序如下：</p><ol><li><code>BeanNameAware (org.springframework.beans.factory)</code></li><li><code>BeanClassLoaderAware (org.springframework.beans.factory)</code></li><li><code>BeanFactoryAware (org.springframework.beans.factory)</code></li><li><code>EnvironmentAware (org.springframework.context)</code></li><li><code>EmbeddedValueResolverAware (org.springframework.context)</code></li><li><code>ResourceLoaderAware (org.springframework.context)</code></li><li><code>ApplicationEventPublisherAware (org.springframework.context)</code></li><li><code>MessageSourceAware (org.springframework.context)</code></li><li><code>ApplicationContextAware (org.springframework.context)</code></li></ol><p><img src="/img/spring/spring-bean-lifecycle-2.jpg" alt=""></p><h1 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h1><p>使用 <code>@Scope</code> 注解定义 bean 的作用域，它可以与 <code>@Component</code> 或 <code>@Bean</code> 一起使用：</p><ul><li><p>单例(Singleton):在整个应用中，只创建bean的一个实例。</p></li><li><p>原型(Prototype):每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。注意，此时目标 bean 要使用代理模式，否则无法达到效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 目标 bean 为类</span><br><span class="line">@Scope(value &#x3D; ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode &#x3D; ScopedProxyMode.TARGET_CLASS)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 目标 bean 为接口</span><br><span class="line">@Scope(value &#x3D; ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode &#x3D; ScopedProxyMode.INTERFACES)</span><br></pre></td></tr></table></figure></li><li><p>会话(Session):在Web应用中，为每个会话创建一个bean实例。</p></li><li><p>请求(Rquest):在Web应用中，为每个请求创建一个bean实例。</p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/Aware.html" target="_blank" rel="noopener">org.springframework.beans.factory.Aware</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 应用上下文总结</title>
      <link href="2017/06/01/spring-application-context/"/>
      <url>2017/06/01/spring-application-context/</url>
      
        <content type="html"><![CDATA[<p><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包为 Spring 框架 IoC 容器的提供基础。有两种形式的 Spring 容器：</p><ul><li>Bean Factory</li><li>Application Context<ul><li>spring-context 核心模块<ul><li><code>FileSystemXmlapplicationcontext</code></li><li><code>ClassPathXmlApplicationContext</code></li><li><code>AnnotationConfigApplicationContext</code></li></ul></li><li>spring-web 模块<ul><li><code>XmlWebApplicationContext</code></li><li><code>AnnotationConfigWebApplicationContext</code></li></ul></li></ul></li></ul><p>继承结构如下：</p><p><img src="/img/spring/BeanFactory.png" alt="BeanFactory"></p><h1 id="Application-Context"><a href="#Application-Context" class="headerlink" title="Application Context"></a>Application Context</h1><p>Spring 通过应用上下文（Application Context）装载 bean 的定义并将它们装配起来。Spring 应用上下文全权负责对象的创建、装配、配置它们并管理它们的整个生命周期。Spring 自带了多种应用上下文的实现，它们之间主要的区别仅仅在于如何加载配置：</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><ul><li><p><code>FileSystemXmlapplicationcontext</code> 从文件系统下的一个或多个 XML 配置文件中加载上下文定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"c:/applicationContext.xml"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>ClassPathXmlApplicationContext</code> 从类路径下的一个或多个 XML 配置文件中加载上下文定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"META-INF/spring/applicationContext.xml"</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>XmlWebApplicationContext</code> 从 Web 应用下的一个或多个 XML 配置文件中加载上下文定义，是 Web 应用程序使用的默认上下文类，因此不必在 <code>web.xml</code> 文件中显式指定这个上下文类。以下代码描述了 <code>web.xml</code> 中指向将由 <code>ContextLoaderListener</code> 监听器类载入的外部 XML 上下文文件的元素：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.ContextLoaderListener</span><br><span class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>sampleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">        <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h2><ul><li><p><code>AnnotationConfigApplicationContext</code> 从一个或多个基于 Java 的配置类中加载 Spring 应用上下文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用构造函数来注册配置类 DubboApplication</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(org.apache.dubbo.config.DubboApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此外，还可以使用 register 方法来注册配置类 OtherApplication</span></span><br><span class="line">ctx.register(OtherApplication<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.dubbo.config；</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册配置类将自动注册 @Bean 注解的方法名称返回的 bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"dubbo-annotation-provider"</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>AnnotationConfigWebApplicationContext</code> 从一个或多个基于 Java 的配置类中加载 Spring Web 应用上下文，需要显示配置该类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">            demo.AppContext</span><br><span class="line">        <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.context.ContextLoaderListener</span><br><span class="line">        <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>sampleServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">            org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">        <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span></span><br><span class="line">                org.springframework.web.context.support.AnnotationConfigWebApplicationContext</span><br><span class="line">            <span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Bean-Factory"><a href="#Bean-Factory" class="headerlink" title="Bean Factory"></a>Bean Factory</h1><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener">org.springframework.beans.factory.BeanFactory</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://www.manning.com/books/spring-in-action-fourth-edition" target="_blank" rel="noopener">Spring in Action, 4th</a>》</p><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/BeanFactory.html" target="_blank" rel="noopener">org.springframework.beans.factory.BeanFactory</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 依赖注入总结</title>
      <link href="2017/05/29/spring-dependency-injection/"/>
      <url>2017/05/29/spring-dependency-injection/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是依赖注入？"><a href="#什么是依赖注入？" class="headerlink" title="什么是依赖注入？"></a>什么是依赖注入？</h1><p>按照传统的做法，每个对象负责管理与自己相互协作的对象（即它所依赖的对象）的引用，这将会导致高度耦合和难以测试的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">            +---+</span><br><span class="line">  +---new---&gt;Bar|</span><br><span class="line">  |         +---+</span><br><span class="line">+-+-+</span><br><span class="line">|Foo|</span><br><span class="line">+-+-+</span><br><span class="line">  |         +---+</span><br><span class="line">  +---new---&gt;Baz|</span><br><span class="line">            +---+</span><br></pre></td></tr></table></figure><p>通过依赖注入（Dependency Injection），对象的依赖关系将由系统中负责协调各对象的<strong>第三方组件</strong>在创建对象的时候进行设定。对象无需自行创建或管理它们的依赖关系，依赖关系将被自动注入到需要它们的对象当中去，即做到“控制反转（IoC）”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">             +---+</span><br><span class="line">  +--inject--+Bar|</span><br><span class="line">  |          +---+</span><br><span class="line">+-v-+</span><br><span class="line">|Foo|</span><br><span class="line">+-^-+</span><br><span class="line">  |          +---+</span><br><span class="line">  +--inject--+Baz|</span><br><span class="line">             +---+</span><br></pre></td></tr></table></figure><p>如果一个对象只通过接口（而不是具体实现或初始化过程）来表明依赖关系，那么这种依赖就能够在对象本身毫不知情的情况下，用不同的具体实现进行替换。这就是依赖注入所带来的最大收益——松耦合。</p><p>对依赖进行替换的一个最常用方法就是在测试的时候使用 mock 实现。</p><h1 id="如何实现？"><a href="#如何实现？" class="headerlink" title="如何实现？"></a>如何实现？</h1><p>在面向对象的编程中，有几种实现控制反转的基本技术：</p><ul><li>使用工厂模式（factory pattern）</li><li>使用服务定位模式（service locator pattern）</li><li>使用以下任何给定类型的<strong>依赖注入（DI）</strong>：<ul><li>构造方法注入（a constructor injection）</li><li>setter 方法注入（a setter injection）</li><li>接口注入（an interface injection）</li></ul></li></ul><h1 id="装配-Bean"><a href="#装配-Bean" class="headerlink" title="装配 Bean"></a>装配 Bean</h1><p>创建应用对象之间协作关系的行为通常称为装配（wiring），这也是依赖注入（DI）的本质。</p><p>Spring 通过它的配置，能够了解这些组成部分是如何装配起来的。这样的话，就可以在不改变所依赖的类的情况下，修改依赖关系。</p><p>Spring 提供几种配置方式，用于 bean 的声明及装配，详见《<a href="/2017/06/04/spring-bean-wiring/">Spring Bean 几种配置方式总结</a>》。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h2><p>通过依赖注入获取 Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Spring 会将 service 对象作为集合注入到 list</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> List&lt;DemoService&gt; demoServices;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Spring 会将 service 的名字作为 key，service 对象作为 value 注入到 Map</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, DemoService&gt; demoServiceMap;</span><br></pre></td></tr></table></figure><h2 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h2><p>通过 <code>BeanFactory</code> 主动获取 Bean：</p><p><img src="/img/spring/getBean.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxHandlerFactoryBean</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="comment">// 通过注解获取 Beans</span></span><br><span class="line">        Map&lt;String, Object&gt; beans = applicationContext.getBeansWithAnnotation(PayMethod<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        beans.forEach((beanName, bean) -&gt; &#123;</span><br><span class="line">            Class&lt;?&gt; beanClass = bean.getClass();</span><br><span class="line">            PayMethod payMethod = beanClass.getAnnotation(PayMethod<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            map.put(payMethod.code(), beanClass);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getBeanClass(String code) &#123;</span><br><span class="line">        Class&lt;?&gt; aClass = map.get(code);</span><br><span class="line">        <span class="keyword">if</span> (aClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(<span class="string">"Not Implemented"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例子三"><a href="#例子三" class="headerlink" title="例子三"></a>例子三</h2><p>下例通过 Collection Injection 实现自定义策略模式。</p><p>首先，创建策略注解。注意，此处还使用了 <code>@Service</code>，表示标注了 <code>@PayMethod</code> 注解的类都由 Spring Bean Factory 来创建对象并管理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PayMethod &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function">PayMethodEnum <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiredArgsConstructor</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">enum</span> PayMethodEnum &#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，创建策略类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">XxxHandler</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 策略实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PayMethod</span>(code = PayMethod.PayMethodEnum.Aaa)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AaaHandler</span> <span class="keyword">implements</span> <span class="title">XxxHandler</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，创建工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.NotImplementedException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XxxHandlerFactoryBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;PayMethod.PayMethodEnum, XxxHandler&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过构造方法注入策略实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XxxHandlerFactory</span><span class="params">(List&lt;XxxHandler&gt; handlers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.map = handlers.stream()</span><br><span class="line">                .filter(handler -&gt; getAnnotation(handler) != <span class="keyword">null</span>)</span><br><span class="line">                .collect(Collectors.toMap(handler -&gt; getAnnotation(handler).code(), Function.identity()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> PayMethod <span class="title">getAnnotation</span><span class="params">(XxxHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> handler.getClass().getAnnotation(PayMethod<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> XxxHandler <span class="title">getHandler</span><span class="params">(String code)</span> </span>&#123;</span><br><span class="line">        PayMethod.PayMethodEnum payMethodEnum = PayMethod.PayMethodEnum.valueOfCode(code);</span><br><span class="line">        XxxHandler handler = map.get(payMethodEnum);</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NotImplementedException(<span class="string">"Not Implemented"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://www.manning.com/books/spring-in-action-fourth-edition" target="_blank" rel="noopener">Spring in Action, 4th</a>》</p><p>《<a href="https://www.manning.com/books/dependency-injection" target="_blank" rel="noopener">Dependency Injection, Design patterns using Spring and Guice</a>》</p><p>《<a href="https://www.cnblogs.com/fuchongjundream/p/3873073.html" target="_blank" rel="noopener">IoC模式（依赖、依赖倒置、依赖注入、控制反转）</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 实战系列（七）骨架快速搭建项目</title>
      <link href="2017/05/28/maven-archetype/"/>
      <url>2017/05/28/maven-archetype/</url>
      
        <content type="html"><![CDATA[<p>工作中经常需要为新开展的业务创建新工程，如果每次都重新搭建、或者拷贝老项目，这些重复工作会影响开发效率，也不利于维护（例如为新工程统一引入新组件、或升级配置文件等）。Maven 提供了 archetype 骨架插件，用于抽取这些重复的配置和代码，以模板的方式创建新项目。</p><p>Maven Archetype Plugin（骨架插件）能够让用户从现有的模板（即骨架）中创建 Maven 项目，也能够从现有的项目中创建骨架。其流程如下：</p><p><img src="/img/java/maven/archetype-overview.png" alt="Maven Archetype Plugin"></p><p>从上图可见，该插件提供了如下目标（即命令）：</p><ul><li><a href="http://maven.apache.org/archetype/maven-archetype-plugin/generate-mojo.html" target="_blank" rel="noopener"><code>archetype:generate</code></a> creates a Maven project from an archetype: asks the user to choose an archetype from the archetype catalog, and retrieves it from the remote repository. Once retrieved, it is processed to create a working Maven project.</li><li><a href="http://maven.apache.org/archetype/maven-archetype-plugin/create-from-project-mojo.html" target="_blank" rel="noopener"><code>archetype:create-from-project</code></a> creates an archetype from an existing project.（注意如果需要包含 yml 配置文件，需要加上参数 <code>-Darchetype.filteredExtentions=yml</code>）</li><li><a href="http://maven.apache.org/archetype/maven-archetype-plugin/crawl-mojo.html" target="_blank" rel="noopener"><code>archetype:crawl</code></a> search a repository for archetypes and updates a catalog.</li></ul><p>下面具体演示如何使用。</p><h1 id="创建-archetype-工程样例"><a href="#创建-archetype-工程样例" class="headerlink" title="创建 archetype 工程样例"></a>创建 archetype 工程样例</h1><h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><p>利用 Maven 内置的 <code>maven-archetype-archetype</code> 构件创建一个骨架工程样例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate</span><br><span class="line">  -DgroupId&#x3D;[your project&#39;s group id]</span><br><span class="line">  -DartifactId&#x3D;[your project&#39;s artifact id]</span><br><span class="line">  -DarchetypeArtifactId&#x3D;maven-archetype-archetype</span><br></pre></td></tr></table></figure><p>创建成功后，其目录结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">archetype</span><br><span class="line">|-- pom.xml  <span class="comment">// archetype pom</span></span><br><span class="line">`-- src</span><br><span class="line">    `-- main</span><br><span class="line">        `-- resources</span><br><span class="line">            |-- META-INF</span><br><span class="line">            |   `-- maven</span><br><span class="line">            |       `--archetype.xml  <span class="comment">// archetype descriptor</span></span><br><span class="line">            `-- archetype-resources  <span class="comment">// prototype files</span></span><br><span class="line">                |-- pom.xml  <span class="comment">// prototype pom</span></span><br><span class="line">                `-- src</span><br><span class="line">                    |-- main</span><br><span class="line">                    |   `-- java</span><br><span class="line">                    |       `-- App.java</span><br><span class="line">                    `-- test</span><br><span class="line">                        `-- java</span><br><span class="line">                            `-- AppTest.java</span><br></pre></td></tr></table></figure><p>骨架由以下四个部分组成，各文件作用如下：</p><table><thead><tr><th>组成部分</th><th>组成部分</th><th>路径</th><th>描述</th></tr></thead><tbody><tr><td>archetype pom</td><td>骨架的 POM</td><td>根目录下的 <code>pom.xml</code></td><td></td></tr><tr><td>archetype descriptor</td><td>骨架描述符文件</td><td><code>src/main/resources/META-INF/maven/archetype.xml</code></td><td>这个文件列出了包含在 archetype 中的所有文件并将这些文件分类，因此 archetype 生成机制才能正确的处理。</td></tr><tr><td>prototype pom</td><td>新工程的原型 POM</td><td><code>src/main/resources/archetype-resources/pom.xml</code></td><td>archetype 插件会直接复制这个 <code>pom.xml</code>，然后替换其中的占位符 <code>${artifactId}</code>、<code>${groupId}</code>、<code>${version}</code></td></tr><tr><td>prototype files</td><td>新工程的原型文件</td><td><code>src/main/resources/archetype-resources/</code></td><td>archetype 插件会直接复制这些文件</td></tr></tbody></table><h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><p>利用公司现有模板项目创建骨架：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:create-from-project -Darchetype.filteredExtentions&#x3D;yml,xml,java,jsp</span><br></pre></td></tr></table></figure><p>创建成功后，其目录结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">youproject</span><br><span class="line">|-- pom.xml<span class="comment">// 项目源文件</span></span><br><span class="line">`-- src<span class="comment">// 项目源文件</span></span><br><span class="line">    `-- main</span><br><span class="line">    `-- test</span><br><span class="line">`-- target  <span class="comment">// 创建结果</span></span><br><span class="line">    `-- generated-sources</span><br><span class="line">        `-- archetype</span><br><span class="line">            <span class="comment">// 目录结构同方式一。后续安装 archetype 到本地仓库时，需要 cd 到本目录，执行 mvn install；如果是发布到远程仓库，则 mvn deploy</span></span><br></pre></td></tr></table></figure><p><code>-Darchetype.filteredExtentions</code> 用于指定要过滤的文件后缀名，被过滤的文件将会替换文件里面用到的占位符。在生成的 archetype.xml 文件时，命令将会扫描模板项目中所有的文件类型，为上述指定的文件类型添加 <code>filtered=&quot;true&quot;</code> 属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">packaged</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/webapp<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.jsp<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fileSet</span> <span class="attr">filtered</span>=<span class="string">"true"</span> <span class="attr">packaged</span>=<span class="string">"true"</span> <span class="attr">encoding</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/test/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="配置骨架"><a href="#配置骨架" class="headerlink" title="配置骨架"></a>配置骨架</h1><h2 id="配置描述符-archetype-xml"><a href="#配置描述符-archetype-xml" class="headerlink" title="配置描述符 archetype.xml"></a>配置描述符 archetype.xml</h2><p>然后，配置 archetype.xml，详见：<a href="http://maven.apache.org/archetype/archetype-models/archetype-descriptor/archetype-descriptor.html" target="_blank" rel="noopener">archetype descriptor</a></p><h2 id="配置新工程的-pom-xml"><a href="#配置新工程的-pom-xml" class="headerlink" title="配置新工程的 pom.xml"></a>配置新工程的 pom.xml</h2><p>使用占位符 <code>${artifactId}</code>、<code>${groupId}</code>、<code>${version}</code>，这些变量都将在 <code>archetype:generate</code> 命令运行时被初始化：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>$&#123;groupId&#125;<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>$&#123;artifactId&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>A custom project<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.myorganization.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置新工程的相关文件"><a href="#配置新工程的相关文件" class="headerlink" title="配置新工程的相关文件"></a>配置新工程的相关文件</h2><p>将新工程所需文件，全部拷贝到 <code>src/main/resources/archetype-resources/</code> 目录下。</p><h1 id="安装本地仓库"><a href="#安装本地仓库" class="headerlink" title="安装本地仓库"></a>安装本地仓库</h1><p>创建骨架并配置完毕，首先安装到本地仓库：</p><ul><li>如果是使用 Maven 内置的 <code>maven-archetype-archetype</code> 构件创建的骨架工程样例，直接在该目录下执行安装命令即可。</li><li>如果是使用命令 <code>mvn archetype:create-from-project</code> 从现有的项目中创建骨架，需要先 <code>cd</code> 进入到 <code>target/generated-sources/archetype/</code> 目录，再运行 <code>mvn install</code>。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure><p>执行如下插件 goal：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">maven-resources-plugin:resources  &#x2F;&#x2F; 拷贝资源文件</span><br><span class="line">maven-resources-plugin:testResources  &#x2F;&#x2F; 拷贝测试资源文件</span><br><span class="line">maven-archetype-plugin:jar  &#x2F;&#x2F; 在 target 目录下构建出 archetype jar</span><br><span class="line">maven-archetype-plugin:integration-test</span><br><span class="line">maven-install-plugin:install  &#x2F;&#x2F; 将构建出来的 jar 和 pom 安装到本地仓库</span><br><span class="line">maven-archetype-plugin:update-local-catalog  &#x2F;&#x2F; 更新本地仓库根目录下的 archetype-catalog.xml</span><br></pre></td></tr></table></figure><p>安装完毕，构建出来的 archetype jar <code>artifactId-archetype-version.jar</code> 将会安装到本地仓库。此时需要更新本地仓库根目录下的 <code>archetype-catalog.xml</code> ，插入一段骨架配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">archetype-catalog</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/plugins/maven-archetype-plugin/archetype-catalog/1.0.0 http://maven.apache.org/xsd/archetype-catalog-1.0.0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/plugins/maven-archetype-plugin/archetype-catalog/1.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">archetypes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 新插入的骨架 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">archetype</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>[your project's group id]<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>[your project's artifact id]<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">description</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">archetype</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">archetypes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">archetype-catalog</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以使用命令：<code>mvn archetype:crawl</code>，将自动搜索仓库中的骨架并更新骨架配置。</p><h1 id="发布到远程仓库"><a href="#发布到远程仓库" class="headerlink" title="发布到远程仓库"></a>发布到远程仓库</h1><p>骨架生成成功，并且一切符合预期之后，可以发布到远程仓库供他人使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn deploy</span><br></pre></td></tr></table></figure><h1 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h1><h2 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h2><p>尝试创建项目，选择想要使用的骨架，并为新工程指定 <code>groupId</code> 和 <code>artifactId</code>，以及包名 <code>package</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate                                  \</span><br><span class="line">  -DarchetypeGroupId&#x3D;&lt;archetype-groupId&gt;                \</span><br><span class="line">  -DarchetypeArtifactId&#x3D;&lt;archetype-artifactId&gt;          \</span><br><span class="line">  -DarchetypeVersion&#x3D;&lt;archetype-version&gt;                \</span><br><span class="line">  -DgroupId&#x3D;&lt;my.groupid&gt;                                \</span><br><span class="line">  -DartifactId&#x3D;&lt;my-artifactId&gt;                          \</span><br><span class="line">  -Dversion&#x3D;&lt;my.version&gt;                                \</span><br><span class="line">  -Dpackage&#x3D;my.package</span><br></pre></td></tr></table></figure><p>输出日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[INFO] Using property: groupId &#x3D; &lt;my.groupid&gt;</span><br><span class="line">[INFO] Using property: artifactId &#x3D; &lt;my-artifactId&gt;</span><br><span class="line">[INFO] Using property: version &#x3D; &lt;my.version&gt;</span><br><span class="line">[INFO] Using property: package &#x3D; my.package</span><br><span class="line">Confirm properties configuration:</span><br><span class="line">groupId: &lt;my.groupid&gt;</span><br><span class="line">artifactId: &lt;my-artifactId&gt;</span><br><span class="line">version: &lt;my.version&gt;</span><br><span class="line">package: my.package</span><br><span class="line"> Y:</span><br></pre></td></tr></table></figure><p>回复 <code>Y</code> 确认即可。</p><h2 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h2><p>File &gt; New Module &gt; Maven，勾选 Create from archetype，点击 Add Archetype，配置如下：</p><p><img src="/img/java/maven/idea_add_archetype.png" alt="IDEA 中添加 archetype"></p><p>输入创建 archetype 工程时，定义的 GroupId、ArtifactId、Version，并选择你远程仓库的地址即可，例如：<a href="http://xxx/nexus/content/repositories/snapshots。" target="_blank" rel="noopener">http://xxx/nexus/content/repositories/snapshots。</a></p><p>配置完毕，创建新工程时，将会执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-DinteractiveMode&#x3D;false</span><br><span class="line">-DarchetypeGroupId&#x3D;</span><br><span class="line">-DarchetypeArtifactId&#x3D;</span><br><span class="line">-DarchetypeVersion&#x3D;</span><br><span class="line">-DarchetypeRepository&#x3D;http:&#x2F;&#x2F;xxx&#x2F;nexus&#x2F;content&#x2F;repositories&#x2F;snapshots </span><br><span class="line">-DgroupId&#x3D;</span><br><span class="line">-DartifactId&#x3D; </span><br><span class="line">-Dversion&#x3D;</span><br><span class="line">org.apache.maven.plugins:maven-archetype-plugin:RELEASE:generate</span><br></pre></td></tr></table></figure><p>goal <code>generate</code> 执行过程中会下载指定的 archetype jar，并根据指定参数创建新工程。</p><p>注意，由于这种方式只会下载指定的 archetype jar 到本地仓库，但不会将骨架添加到本地仓库根目录下的骨架目录文件  <code>archetype-catalog.xml</code> 之中。这将会导致在 IDEA 之外以命令行方式执行 <code>mvn archetype:generate</code> 生成新工程时，由于在骨架目录文件中找不到指定 archetype 而报错，因此需要将该 archetype 添加到骨架目录文件下。解决方法是执行命令：<code>mvn archetype:crawl</code> 遍历本地仓库搜索骨架并更新目录文件。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://maven.apache.org/guides/introduction/introduction-to-archetypes.html" target="_blank" rel="noopener">https://maven.apache.org/guides/introduction/introduction-to-archetypes.html</a></p><p><a href="https://maven.apache.org/guides/mini/guide-creating-archetypes.html" target="_blank" rel="noopener">https://maven.apache.org/guides/mini/guide-creating-archetypes.html</a></p><p><a href="http://maven.apache.org/archetype/maven-archetype-plugin/" target="_blank" rel="noopener">http://maven.apache.org/archetype/maven-archetype-plugin/</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 实战系列（六）插件总结</title>
      <link href="2017/05/19/maven-plugins/"/>
      <url>2017/05/19/maven-plugins/</url>
      
        <content type="html"><![CDATA[<p>Maven 本质上是一个插件框架，它的核心并不执行任何具体的构建任务，所有这些任务都交给插件来完成，例如编译源代码是由 <code>maven-compiler-plugin</code> 完成的。每个插件会有一个或者多个目标（goal），例如 <code>maven-compiler-plugin</code> 插件的 <code>compile</code> 目标用来编译位于 <code>src/main/java/</code> 目录下的主源码，<code>testCompile</code> 目标用来编译位于 <code>src/test/java/</code> 目录下的测试源码。</p><p>用户可以通过两种方式调用 Maven 插件目标：</p><ol><li>将插件目标与生命周期阶段（lifecycle phase）绑定，这样用户在命令行只是输入生命周期阶段而已，例如 Maven 默认将 <code>maven-compiler-plugin</code> 的 <code>compile</code> 目标与 <code>compile</code> 生命周期阶段绑定，因此命令 <code>mvn compile</code> 实际上是先定位到 <code>compile</code> 这一生命周期阶段，然后再根据绑定关系调用 <code>maven-compiler-plugin</code> 的 <code>compile</code> 目标。</li><li>直接在命令行指定要执行的插件目标（goal），例如 <code>mvn archetype:generate</code> 就表示调用 <code>maven-archetype-plugin</code> 的 <code>generate</code> 目标，<strong>这种带冒号的调用方式与生命周期无关</strong>。</li></ol><p>常用插件整理如下：</p><p><img src="/img/java/maven/plugins.png" alt="Maven 常用插件"></p><h1 id="核心插件"><a href="#核心插件" class="headerlink" title="核心插件"></a>核心插件</h1><h2 id="maven-clean-plugin"><a href="#maven-clean-plugin" class="headerlink" title="maven-clean-plugin"></a>maven-clean-plugin</h2><h2 id="maven-resources-plugin"><a href="#maven-resources-plugin" class="headerlink" title="maven-resources-plugin"></a>maven-resources-plugin</h2><h2 id="maven-compiler-plugin"><a href="#maven-compiler-plugin" class="headerlink" title="maven-compiler-plugin"></a>maven-compiler-plugin</h2><p>指定编译版本。</p><p>方式一</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="maven-surefire-plugin"><a href="#maven-surefire-plugin" class="headerlink" title="maven-surefire-plugin"></a>maven-surefire-plugin</h2><h2 id="maven-install-plugin"><a href="#maven-install-plugin" class="headerlink" title="maven-install-plugin"></a>maven-install-plugin</h2><h2 id="maven-deploy-plugin"><a href="#maven-deploy-plugin" class="headerlink" title="maven-deploy-plugin"></a>maven-deploy-plugin</h2><h1 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h1><h2 id="maven-jar-plugin"><a href="#maven-jar-plugin" class="headerlink" title="maven-jar-plugin"></a>maven-jar-plugin</h2><h2 id="maven-war-plugin"><a href="#maven-war-plugin" class="headerlink" title="maven-war-plugin"></a>maven-war-plugin</h2><h1 id="其它工具"><a href="#其它工具" class="headerlink" title="其它工具"></a>其它工具</h1><h2 id="maven-archetype-plugin"><a href="#maven-archetype-plugin" class="headerlink" title="maven-archetype-plugin"></a>maven-archetype-plugin</h2><p>用于生成骨架，详见：<a href="/2018/12/08/maven-archetype/">Maven 骨架快速搭建项目</a>。</p><h2 id="maven-assembly-plugin"><a href="#maven-assembly-plugin" class="headerlink" title="maven-assembly-plugin"></a>maven-assembly-plugin</h2><p>用于将项目输出及其依赖项、模块、站点文档和其它文件聚合构建成一个可执行的分发包。</p><p>项目简单配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.github.testproject.Main<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                        jar-with-dependencies</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>执行 Goal <code>assembly:single</code>，将在 target 目录中生成一个 <code>artifactId-version-jar-with-dependencies.jar</code> 文件，内含所需的所有依赖，执行 <code>java -jar</code> 即可运行。</p><h2 id="maven-dependency-plugin"><a href="#maven-dependency-plugin" class="headerlink" title="maven-dependency-plugin"></a>maven-dependency-plugin</h2><p>用于分析项目依赖，例如通过 <code>mvn dependency:tree</code> 命令分析 Dubbo 默认依赖的第三方库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[INFO] +- com.alibaba:dubbo:jar:2.5.9-SNAPSHOT:compile</span><br><span class="line">[INFO] |  +- org.springframework:spring-context:jar:4.3.10.RELEASE:compile</span><br><span class="line">[INFO] |  +- org.javassist:javassist:jar:3.21.0-GA:compile</span><br><span class="line">[INFO] |  \- org.jboss.netty:netty:jar:3.2.5.Final:compile</span><br></pre></td></tr></table></figure><h1 id="Spring-Boot-插件"><a href="#Spring-Boot-插件" class="headerlink" title="Spring Boot 插件"></a>Spring Boot 插件</h1><p>Spring Boot 提供了 <code>spring-boot-maven-plugin</code> 插件，可用于本地快速编译并运行、及项目打包。参考：<a href="/2017/08/01/spring-boot-getting-started/">Maven 插件</a>。</p><h1 id="IDEA-Maven-插件"><a href="#IDEA-Maven-插件" class="headerlink" title="IDEA Maven 插件"></a>IDEA Maven 插件</h1><p>最后来看下 IDEA Maven 插件提供的 Maven Projects tool window 功能：</p><p><img src="/img/java/idea/maven_projects.png" alt="IDEA Maven Projects"></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://maven.apache.org/plugins/index.html" target="_blank" rel="noopener">http://maven.apache.org/plugins/index.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 负载均衡</title>
      <link href="2017/05/13/nginx-upstream/"/>
      <url>2017/05/13/nginx-upstream/</url>
      
        <content type="html"><![CDATA[<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><p>Nginx 标准 HTTP 模块 <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html" target="_blank" rel="noopener">ngx_http_upstream_module</a> 内置了集群和负载均衡功能，使用其中的 <code>upstream</code> 配合 <code>proxy_pass</code> 指令即可快速实现一个集群：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server backend1.example.com       weight&#x3D;5;</span><br><span class="line">        server 127.0.0.1:8080             max_fails&#x3D;3 fail_timeout&#x3D;30s;</span><br><span class="line">        server unix:&#x2F;tmp&#x2F;backend3;</span><br><span class="line"></span><br><span class="line">        server backup1.example.com:8080   backup;</span><br><span class="line">        server backup2.example.com:8080   down;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>server</code> 指令的常用参数描述如下：</p><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>weight=number</code></td><td>设置服务器的轮询权重，默认为 1。用于后端服务器性能不均的情况。</td></tr><tr><td><code>max_conns=number</code></td><td>设置被代理服务器的最大可用并发连接数限制，默认为 0，表示没有限制。</td></tr><tr><td><code>max_fails=number</code></td><td>设置最大失败重试次数，默认为 1。设置为 0 表示禁用重试。</td></tr><tr><td><code>fail_timeout=time</code></td><td>设置失败时间，默认 10 秒。</td></tr><tr><td><code>backup</code></td><td>将服务器标记为备份服务器。当主服务器不可用时，它将被传递请求。</td></tr><tr><td><code>down</code></td><td>将服务器标记为永久不可用。</td></tr></tbody></table><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡（Load Balance），其意思就是将运算或存储负载按一定的算法分摊到多个运算或存储单元上，下面介绍 Nginx 几种常见的负载均衡方法：</p><ul><li>默认策略：加权轮询策略（weighted round-robin）。</li><li><code>random</code>，加权随机策略。</li><li><code>ip_hash</code>，基于客户端 IP 计算出哈希值，再根据服务器数量取模选取服务器（ip_hash % server_size = server_no）。</li><li><code>hash key [consistent]</code>，基于指定 key 计算出哈希值，再根据服务器数量取模选取服务器。可选一致性哈希算法缓解重映射问题。</li><li><code>least_conn</code>，基于最小活跃连接数（加权）。如果有多个服务器符合条件，则使用加权轮询策略依次响应。</li><li><code>least_time</code>，基于最小平均响应时间和最小活跃连接数（加权）。如果有多个服务器符合条件，则使用加权轮询策略依次响应。</li></ul><h2 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip hash"></a>ip hash</h2><p>使用 Nginx <code>ip_hash</code> 指令，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line"></span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">    server backend3.example.com down;</span><br><span class="line">    server backend4.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ip_hash</code> 指令指定集群使用基于<strong>客户端 IP 地址</strong>的负载均衡方法。 客户端 IPv4 地址的前三个八位字节或整个 IPv6 地址用作哈希键。 该方法确保来自同一客户端的请求将始终传递到同一台服务器，除非此服务器不可用，客户端请求则将被<strong>转发</strong>到另一台服务器（多数情况下，始终是同一台服务器）。<br>如果其中一台服务器需要临时删除，则应使用 <code>down</code> 参数标记，以便保留当前客户端 IP 地址的哈希值。</p><h2 id="一致性-hash"><a href="#一致性-hash" class="headerlink" title="一致性 hash"></a>一致性 hash</h2><p>使用 Nginx <code>hash</code> 指令，常用的例如基于来源 IP 进行哈希，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    hash $remote_addr consistent;</span><br><span class="line"></span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hash</code> 指令指定集群使用基于<strong>指定 hash 散列键</strong>的负载均衡方法。散列键可以包含文本，变量及其组合。请注意，从集群中添加或删除服务器可能会导致大量键被重新映射到不同的服务器。</p><p>解决办法是使用 <code>consistent</code> 参数启用  <a href="http://www.last.fm/user/RJ/journal/2007/04/10/392555/" target="_blank" rel="noopener">ketama</a> 一致性 hash 算法。 该算法将每个 server 虚拟成 n 个节点，均匀分布到 hash 环上。每次请求，根据配置的参数计算出一个 hash 值，在 hash 环上查找离这个 hash 最近的虚拟节点，对应的 server 作为该次请求的后端服务器。该算法确保在添加或删除服务器时，只会有少量键被重新映射到不同的服务器。这有助于为缓存服务器实现更高的缓存命中率。</p><h1 id="会话保持"><a href="#会话保持" class="headerlink" title="会话保持"></a>会话保持</h1><p>sticky cookie 粘滞会话（也称会话保持\会话绑定）是负载均衡的一个基本功能，为了确保与某个客户相关的所有应用请求能够由同一台服务器进行处理，我们需要在负载均衡上启用会话保持功能，以确保负载均衡的部署不会影响到正常的业务处理。</p><p>基于源地址的 ip_hash 进行会话保持的问题在于，当多个客户是通过代理或地址转换的方式来访问服务器时，由于都分配到同一台服务器上，会导致服务器之间的负载失衡。</p><p>通过 cookie 实现客户端与后端服务器的会话保持，在一定条件下可以保证同一个客户端访问的都是同一个后端服务器。使用 Nginx <code>sticky</code> 指令，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com;</span><br><span class="line">    server backend2.example.com;</span><br><span class="line"></span><br><span class="line">    sticky cookie srv_id expires&#x3D;1h domain&#x3D;.example.com path&#x3D;&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这份配置在同一域名下有两个 location，分别对应了两组集群服务。为了分别实现会话保持，将 cookie 写入了对应的 path 下，避免 cookie 互相干扰，也减少了数据传输量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream backend1 &#123;</span><br><span class="line">        server backup1.example.com:8080;</span><br><span class="line">        server backup1.example.com:8081;</span><br><span class="line">    sticky cookie srv_backend1 path&#x3D;&#x2F;backend1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    upstream backend2 &#123;</span><br><span class="line">        server backup2.example.com:8080;</span><br><span class="line">        server backup2.example.com:8081;</span><br><span class="line">    sticky cookie srv_backend2 path&#x3D;&#x2F;backend2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        server_name example.com;</span><br><span class="line">        listen 80;</span><br><span class="line">    </span><br><span class="line">        location &#x2F;backend1&#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location &#x2F;backend2&#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h1><p>健康检查（Health Check）是保障集群可用性的重要手段，有三种常见的健康检查方法：</p><ul><li>使用社区版 Nginx 的 <code>max_fails</code> 和 <code>fail_timeout</code> 指令进行被动式检查，不推荐使用，详见：《<a href="https://segmentfault.com/a/1190000002446630" target="_blank" rel="noopener">nginx中健康检查(health_check)机制深入分析</a>》；</li><li>使用<a href="http://nginx.com/products/" target="_blank" rel="noopener">商业版 Nginx Plus</a> 进行主动式检查，缺点是要收费；</li><li>使用 Nginx 第三方模块编译，例如：<a href="https://github.com/yaoweibin/nginx_upstream_check_module" target="_blank" rel="noopener">nginx_upstream_check_module</a> ；</li><li>使用 <a href="http://tengine.taobao.org/" target="_blank" rel="noopener">Tengine</a> 内置的<a href="http://tengine.taobao.org/document_cn/http_upstream_check_cn.html" target="_blank" rel="noopener">主动式健康检查</a>功能（该内置模块等同于第 3 点）。</li></ul><h2 id="主动式健康检查"><a href="#主动式健康检查" class="headerlink" title="主动式健康检查"></a>主动式健康检查</h2><p>以 <code>nginx_upstream_check_module</code> 第三方模块为例，演示配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend1 &#123;</span><br><span class="line">    check interval&#x3D;3000 rise&#x3D;2 fall&#x3D;5 timeout&#x3D;1000 type&#x3D;http;</span><br><span class="line">    check_keepalive_requests 100;</span><br><span class="line">    check_http_send &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1\r\nConnection: keep-alive\r\nHost: check.com\r\n\r\n&quot;;</span><br><span class="line">    check_http_expect_alive http_2xx http_3xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段配置表示：</p><ol><li><code>check</code> 指令配置：每隔 <code>interval</code> 毫秒主动发送一个 <code>http</code> 健康检查包给后端服务器。请求超时时间为 <code>timeout</code> 毫秒。如果连续失败次数达到 <code>fall_count</code>，服务器就被认为是 down；如果连续成功次数达到 <code>rise_count</code>，服务器就被认为是 up。</li><li><code>check_keepalive_requests</code> 指令配置：一个连接发送的请求数。</li><li><code>check_http_send</code> 指令配置：请求包的内容（注意，这里必须<a href="https://my.oschina.net/liuleidefeng/blog/786739" target="_blank" rel="noopener">配置 <code>Host</code> 请求头否则可能报错</a>）。</li><li><code>check_http_expect_alive</code> 指令配置：响应状态码为 <code>2XX</code> 和 <code>3XX</code> 表示请求成功、服务健康。</li></ol><p>查看 Tomcat access.log 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:30 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:33 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:36 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:39 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:42 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br><span class="line">127.0.0.1 - - [06&#x2F;Jun&#x2F;2017:21:03:45 +0800] &quot;HEAD &#x2F;m&#x2F;monitor.html HTTP&#x2F;1.1&quot; 200 -</span><br></pre></td></tr></table></figure><p>此时关闭某台后端服务器，一段时间后再访问，请求会被路由到其它服务器；重启后，该服务器自动加入集群。通过健康状态页面 <code>/status</code> 可见：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Nginx http upstream check status</span><br><span class="line"></span><br><span class="line">Check upstream server number: 2, generation: 2</span><br><span class="line"></span><br><span class="line">IndexUpstreamNameStatusRise countsFall countsCheck typeCheck port</span><br><span class="line">0backend1127.0.0.1:8080up47410http0</span><br><span class="line">1backend1127.0.0.1:8081down02340http0</span><br></pre></td></tr></table></figure><h1 id="常用变量"><a href="#常用变量" class="headerlink" title="常用变量"></a>常用变量</h1><h2 id="upstream-addr"><a href="#upstream-addr" class="headerlink" title="$upstream_addr"></a>$upstream_addr</h2><p>该模块中很常用的一个变量，用于标识集群中服务器的 IP 和端口。一般会加入到 Nginx 日志、同时脱敏后加入到响应头中，用于排查问题来源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    log_format  main  &#39;&quot;$http_x_forwarded_for&quot; - &quot;$upstream_addr&quot; - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">                  &#39;&quot;$http_user_agent&quot; $remote_addr $request_time_msec&#39;</span><br><span class="line">    access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    map $upstream_addr $short_address &#123;</span><br><span class="line">        ~^\d+\.\d+\.\d+\.(.*) &#39;&#39;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        server_name example.com;</span><br><span class="line">        listen 80;</span><br><span class="line">        </span><br><span class="line">        upstream backend &#123;</span><br><span class="line">            server 127.0.0.1:81;</span><br><span class="line">            server 127.0.0.1:82;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            add_header X-From $short_address$1;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend&#x2F;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 加密通信（HTTPS）</title>
      <link href="2017/05/07/nginx-ssl/"/>
      <url>2017/05/07/nginx-ssl/</url>
      
        <content type="html"><![CDATA[<p>Nginx 中配置 HTTPS/SSL 加密是非常简单的，只需要将可选 HTTP 模块中的 <code>ngx_http_ssl_module</code> 编译进去即可。然后有两种方式开启 SSL 模式：</p><ul><li><code>ssl on</code> </li><li><code>listen 443 ssl</code> 此端口上接收的所有连接都工作在 SSL 模式。</li></ul><p>建议使用 <code>listen</code> 指令的 <code>ssl</code> 参数替代 <code>ssl on</code> 指令，这样可以为同时处理 HTTP 和 HTTPS 请求的服务器提供更加紧凑的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># http 和 https(ssl) 并存配置：</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        server_name example.com;</span><br><span class="line">        listen 80;</span><br><span class="line">        listen 443 ssl;</span><br><span class="line">        </span><br><span class="line">        ssl_certificate      example.com.crt;</span><br><span class="line">        ssl_certificate_key  example.com.key;</span><br><span class="line">        </span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:81&#x2F;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果两个配置同时启用，HTTP 访问可能会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">400 Bad Request</span><br><span class="line">The plain HTTP request was sent to HTTPS port</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 反向代理</title>
      <link href="2017/05/06/nginx-proxy/"/>
      <url>2017/05/06/nginx-proxy/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是代理？"><a href="#什么是代理？" class="headerlink" title="什么是代理？"></a>什么是代理？</h1><p>一张图了解两种代理模式的区别：</p><p><img src="/img/nginx/proxy.jpg" alt="两种代理模式"></p><p>常见应用场景：</p><ul><li>正向代理：VPN 翻墙</li><li>反向代理：Web 站点服务</li></ul><h1 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h1><p>Nginx 代理功能由标准 HTTP 模块中内置的 <a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="noopener">ngx_http_proxy_module</a> 提供，因此无需额外编译，常见配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        server_name example.com;</span><br><span class="line">        listen 80;</span><br><span class="line">        </span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;127.0.0.1:81&#x2F;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>proxy_pass</code> 指令用于配置被代理服务器的协议和地址。除了配置单机，还可以配置集群，详见 <a href="/2017/05/13/nginx-upstream/">Nginx 负载均衡</a> 。</p><h1 id="解决代理后的问题"><a href="#解决代理后的问题" class="headerlink" title="解决代理后的问题"></a>解决代理后的问题</h1><h2 id="上游无法获取真实的访问来源信息"><a href="#上游无法获取真实的访问来源信息" class="headerlink" title="上游无法获取真实的访问来源信息"></a>上游无法获取真实的访问来源信息</h2><p>使用反向代理之后，上游服务器（如 Tomcat）无法获取真实的访问来源信息（如协议、域名、访问 IP），例如下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request.getScheme() <span class="comment">// 总是 http，而不是实际的 http 或 https</span></span><br><span class="line">request.isSecure() <span class="comment">// 总是 false</span></span><br><span class="line">request.getRemoteAddr() <span class="comment">// Nginx IP</span></span><br><span class="line">request.getServerName() <span class="comment">// 127.0.0.1</span></span><br><span class="line">request.getRequestURL() <span class="comment">// http://127.0.0.1:81/index</span></span><br><span class="line">response.sendRedirect(...) <span class="comment">// 总是重定向到 http</span></span><br></pre></td></tr></table></figure><p>这个问题需要在 Nginx 和 Tomcat 中做一些配置以解决问题。</p><p>Nginx 配置：</p><p>使用 <code>proxy_set_header</code> 指令为上游服务器添加请求头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    proxy_set_header Host              $host;</span><br><span class="line">    proxy_set_header X-Real-IP         $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tomcat 配置：</p><p>在 Tomcat 的 <code>server.xml</code> 中配置 <a href="http://tomcat.apache.org/tomcat-7.0-doc/api/org/apache/catalina/valves/RemoteIpValve.html" target="_blank" rel="noopener">RemoteIpValve</a> 让代码能够获取真实 IP 和协议：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Valve className&#x3D;&quot;org.apache.catalina.valves.RemoteIpValve&quot; </span><br><span class="line">    remoteIpHeader&#x3D;&quot;X-Forwarded-For&quot; </span><br><span class="line">    protocolHeader&#x3D;&quot;X-Forwarded-Proto&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>解决结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request.getScheme() <span class="comment">// 实际的 http 或 https</span></span><br><span class="line">request.isSecure() <span class="comment">// 对应的 false 或 true</span></span><br><span class="line">request.getRemoteAddr() <span class="comment">// 用户 IP</span></span><br><span class="line">request.getHeader(<span class="string">"X-Real-IP"</span>) <span class="comment">// 用户 IP</span></span><br><span class="line">request.getServerName() <span class="comment">// example.com</span></span><br><span class="line">request.getRequestURL() <span class="comment">// 对应的 http://example.com/index 或 https://example.com/index</span></span><br><span class="line">response.sendRedirect(...) <span class="comment">// 实际的 http 或 https</span></span><br></pre></td></tr></table></figure><h2 id="全局-proxy-set-header-失效"><a href="#全局-proxy-set-header-失效" class="headerlink" title="全局 proxy_set_header 失效"></a>全局 proxy_set_header 失效</h2><p>先来看下 <code>proxy_set_header</code> 的语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法:proxy_set_header field value;</span><br><span class="line">默认值: proxy_set_header Host $proxy_host;</span><br><span class="line">        proxy_set_header Connection close;</span><br><span class="line">上下文: http, server, location</span><br><span class="line"></span><br><span class="line">允许重新定义或者添加发往后端服务器的请求头。value 可以包含文本、变量或者它们的组合。当且仅当当前配置级别中没有定义 proxy_set_header 指令时，会从上面的级别继承配置。 默认情况下，只有两个请求头会被重新定义：</span><br><span class="line"></span><br><span class="line">proxy_set_header Host       $proxy_host;</span><br><span class="line">proxy_set_header Connection close;</span><br></pre></td></tr></table></figure><p>这里隐含一个坑：<strong>如果当前配置级别中定义了 <code>proxy_set_header</code> 指令，哪怕只配置了一个，都会导致无法从上面的级别继承配置</strong>，即导致全局级别的 <code>proxy_set_header</code> 配置失效。例如下述 HTTP <a href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive" target="_blank" rel="noopener">长连接配置</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    proxy_set_header Host              $host;</span><br><span class="line">    proxy_set_header X-Real-IP         $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line"></span><br><span class="line">    upstream backend &#123;</span><br><span class="line">        server 127.0.0.1:8080;</span><br><span class="line">        keepalive 16;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            proxy_pass http:&#x2F;&#x2F;backend;</span><br><span class="line">            proxy_http_version 1.1;</span><br><span class="line">            proxy_set_header Connection &quot;&quot;;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导致全局级别的 <code>proxy_set_header</code> 配置失效：</p><p><img src="/img/nginx/problem_of_proxy_set_header.png" alt="proxy_set_header 失效"></p><p>解决办法是在 <code>location</code> 中重新配置这四个请求头。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 实战系列（五）构建生命周期</title>
      <link href="2017/05/01/maven-build-lifecycle/"/>
      <url>2017/05/01/maven-build-lifecycle/</url>
      
        <content type="html"><![CDATA[<p>本文用于理顺 Maven 构建的生命周期（Build Lifecycle）概念，掌握执行 Maven 命令时其背后的原理。</p><h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><h2 id="生命周期（Lifecycle）"><a href="#生命周期（Lifecycle）" class="headerlink" title="生命周期（Lifecycle）"></a>生命周期（Lifecycle）</h2><p>生命周期（Lifecycle）是一个抽象的概念，意味着它并不做任何实质性的事情，也就是说它像接口，只定义规范，具体细节不管。具体的实现细节则交给了 Maven 各个插件（Plugin）。</p><p>生命周期（Lifecycle）是一系列有序的阶段（Phase），而插件的目标（Goal）是跟某个生命周期的阶段绑定在一起的，如果一个阶段没有绑定任何目标，则运行该阶段没有任何实质意义。</p><p>摘录一段官方的描述：</p><blockquote><p>A Build lifecycle is Made Up of build Phases.</p><p>A build phase represents a stage in the lifecycle.</p><p>A Build Phase is Made Up of Goals.</p></blockquote><p>Maven 内置三种生命周期：</p><table><thead><tr><th>内置 Lifecycle</th><th>描述</th><th>内置 Phase 数量</th></tr></thead><tbody><tr><td><code>clean</code></td><td>Project cleaning</td><td>3 个</td></tr><tr><td><code>default</code></td><td>Project deployment</td><td>23 个</td></tr><tr><td><code>site</code></td><td>Creation of project’s site documentation</td><td>4 个</td></tr></tbody></table><h2 id="阶段（Phase）"><a href="#阶段（Phase）" class="headerlink" title="阶段（Phase）"></a>阶段（Phase）</h2><p>Phase 虽然很多，但其中带连字符 (<code>pre-*</code>, <code>post-*</code>, or <code>process-*</code>) 的 Phase 通常不会在命令行中直接使用。</p><p>那么有哪些常用的 Phase？</p><table><thead><tr><th>Phase</th><th>描述</th></tr></thead><tbody><tr><td><code>clean</code></td><td>remove all files generated by the previous build.</td></tr><tr><td><code>complie</code></td><td>compile the source code of the project</td></tr><tr><td><code>test</code></td><td>test the compiled source code using a suitable unit testing framework. These tests should not require the code be packaged or deployed.</td></tr><tr><td><code>package</code></td><td>take the compiled code and package it in its distributable format, such as a JAR.</td></tr><tr><td><code>install</code></td><td>install the package into the local repository, for use as a dependency in other projects locally</td></tr><tr><td><code>deploy</code></td><td>done in the build environment, copies the final package to the remote repository for sharing with other developers and projects.</td></tr></tbody></table><p>如何运行一个 Phase？使用命令 <code>mvn phase</code>。运行时，首先由该 phase 确定对应的生命周期。然后从生命周期的第一个 Phase 开始，<strong>按顺序</strong>运行到该 phase。</p><h2 id="目标（Goal）"><a href="#目标（Goal）" class="headerlink" title="目标（Goal）"></a>目标（Goal）</h2><p>Phase 是一个逻辑概念，本身并不包含任何构建信息，运行 Phase 时，只是运行绑定到该 Phase 的 Goal。</p><p>Plugin 是一个物理概念，安装了 Plugin 才会有相应的一些 Goal。而每个 Goal 代表了该 Plugin 的一种能力。如果要直接运行一个 Goal，可以使用 <code>mvn &lt;plugin-prefix&gt;:&lt;goal&gt;</code>。其中 plugin-prefix 的<a href="http://maven.apache.org/guides/introduction/introduction-to-plugin-prefix-mapping.html" target="_blank" rel="noopener">约定格式</a>如下：</p><table><thead><tr><th>约定格式</th><th>描述</th></tr></thead><tbody><tr><td><code>maven-${prefix}-plugin</code></td><td>Apache Maven 团队维护的官方插件。例如 <code>maven-compiler-plugin</code>，命令：<code>mvn dependency:list</code></td></tr><tr><td><code>${prefix}-maven-plugin</code></td><td>其它插件。例如 <code>spring-boot-maven-plugin</code>，命令：<code>mvn spring-boot:run</code></td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html" target="_blank" rel="noopener">http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 实战系列（四）BOM 依赖管理（组合关系）</title>
      <link href="2017/04/26/maven-bom/"/>
      <url>2017/04/26/maven-bom/</url>
      
        <content type="html"><![CDATA[<p>在大型项目中，BOM 用于将一组相关的、可以良好协作的构建（Maven Artifact）组合在一起，提供版本管理，避免构件间潜在的版本不兼容风险。</p><p>BOM 如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project-n-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  <span class="comment">&lt;!-- 必须是 pom --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 属性配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 依赖管理配置，声明该 BOM 管理的依赖 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例如常用的 Reactor、Spring Boot、Spring Cloud：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Import dependency management from Reactor --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;reactor.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- Import dependency management from Spring Boot --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- Import dependency management from Spring Cloud --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="实践例子（一）"><a href="#实践例子（一）" class="headerlink" title="实践例子（一）"></a>实践例子（一）</h1><p>每个公司可能都拥有自己的标准父项目，为了解决 Maven 单继承问题，可以通过组合方式使用 <code>&lt;dependencyManagement&gt;</code> 依赖管理来享受其提供的版本管理的好处。</p><h1 id="实践例子（二）"><a href="#实践例子（二）" class="headerlink" title="实践例子（二）"></a>实践例子（二）</h1><p><code>&lt;dependencyManagement&gt;</code> 用于在具有层级关系的项目间统一管理依赖的版本，一般用在父项目中，通过它来管理 jar 包的版本，让子项目中引用一个依赖而不用显式的指定版本号，以达到<strong>依赖版本统一管理</strong>的目的。</p><p>这种方法的好处是显而易见的。依赖的细节（如版本号）可以在一个中心位置集中设置，并传播到所有继承的 POM。</p><p>但由于现实中有可能是 N 个项目都继承同一个父项目，如果把它们的依赖全部放到父项目的 <code>&lt;DependencyManagement&gt;</code> 中管理，势必会导致父项目的依赖配置急剧膨胀，形成一个巨型 POM。更为关键的是，后续各项目组都有升级各自提供的依赖版本的需要，如果大家都去改这个公共的父项目，版本管理会变得很混乱。</p><p>解决办法是按项目组粒度对依赖进行分组管理，分而治之。将每组依赖抽取成像 <code>spring-boot-dependencies</code> 一样的 BOM，并在父项目中 <code>&lt;dependencyManagement&gt;</code> 使用 <code>scope=import</code> 方式将这些 BOM 组合起来，这样父项目的 POM 就会十分干净且稳定，各组依赖的版本管理也能转由各自项目组的 BOM 专门负责，类似一个金字塔模型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                   +------------+</span><br><span class="line">                   | parent-pom |</span><br><span class="line">                   +------+-----+</span><br><span class="line">                          |</span><br><span class="line">        +-----------------|-----------------+</span><br><span class="line">        |                 |                 |</span><br><span class="line">+-------v-------+ +-------+-------+ +-------v-------+</span><br><span class="line">| Project-A-BOM | | Project-B-BOM | | Project-N-BOM |</span><br><span class="line">+---------------+ +-------+-------+ +---------------+</span><br><span class="line">                          |</span><br><span class="line">           +--------------|---------------+</span><br><span class="line">           |              |               |</span><br><span class="line">     +-----v------+ +-----v------+ +------v-----+</span><br><span class="line">     | Artifact-A | | Artifact-B | | Artifact-N |</span><br><span class="line">     +------------+ +------------+ +------------+</span><br></pre></td></tr></table></figure><p>例如某个公司的标准父项目 POM 如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  <span class="comment">&lt;!-- 必须是 pom --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- Import dependency management from Spring Boot 1 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!-- 此处省略 N 组依赖 --&gt;</span></span><br><span class="line">            ......</span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>开发阶段为了测试 Spring Boot 2 的兼容性，该公司 child 项目新开 git 分支，修改 POM 如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>child<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- Import dependency management from Spring Boot 2 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上例 child 项目覆盖了父项目 <code>&lt;dependencyManagement&gt;</code> 的 Spring Boot 版本，当兼容性测试通过后，子项目 <code>&lt;dependencyManagement&gt;</code> 即可去掉，转而升级父项目 Spring Boot 的版本号即可，这样所有子项目都会统一升级版本。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-build-systems.html" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-build-systems.html</a></p><p><a href="https://projectreactor.io/docs/core/release/reference/#getting-started-understanding-bom" target="_blank" rel="noopener">https://projectreactor.io/docs/core/release/reference/#getting-started-understanding-bom</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 实战系列（三）继承与聚合关系</title>
      <link href="2017/04/21/maven-inheritance/"/>
      <url>2017/04/21/maven-inheritance/</url>
      
        <content type="html"><![CDATA[<p>除了依赖关系，继承和聚合关系也是 Maven 项目中很常用的两种关系。</p><h1 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h1><ul><li>在子项目中，使用 <code>&lt;parent&gt;</code> 指定父项目；</li><li>项目能继承父项目的一些配置（属性，依赖等）；</li><li>一般用于多项目共享父配置。</li><li>特别注意 <code>relativePath</code> 元素。虽非必填，但可以用作 Maven 的一个指示符，以在搜索本地和远程仓库之前首先搜索此路径，以达到优先使用本地父项目的目的（本地开发过程中有时我们会修改本地父项目的配置，例如修改依赖版本号）。</li></ul><p>父项目配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  <span class="comment">&lt;!-- 必须是 pom --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 以下配置都可以被子项目继承 --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 属性配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 依赖管理配置，如 spring-cloud、spring-boot、reactor --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 依赖配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 构建配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Nexus 分发包地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Nexus 仓库地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories...</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Nexus 插件地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子项目配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../parent<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="comment">&lt;!-- 可继承自父项目 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>child-a<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="comment">&lt;!-- 可继承自父项目 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h1><ul><li>在父项目中，使用 <code>&lt;modules&gt;</code> 指定子项目；</li><li>在父项目中进行构建，会同时构建全部子项目；</li><li>一般用于批量管理一个项目的多个模块；</li></ul><p>父项目配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  <span class="comment">&lt;!-- 必须是 pom --&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 子模块相对于父项目的路径，一般为 artifactId --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>child-a<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>child-a<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 实战系列（二）依赖关系总结</title>
      <link href="2017/04/15/maven-dependencies/"/>
      <url>2017/04/15/maven-dependencies/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h1><p>依赖关系是 Maven 项目之间最常见的关系。Maven 会自动解析所有项目的<strong>直接依赖</strong>和<strong>传递性依赖</strong>，并且根据规则正确判断<strong>每个依赖范围（Dependency Scope）</strong>。对于一些依赖冲突，自动进行<strong>依赖调解（Dependency Mediation）</strong>，或开发者<strong>手动排除依赖（exclusions）</strong>，以确保任何一个构件只有唯一的版本在依赖中存在。经过这些工作之后，得到的那些依赖被称为<strong>已解析依赖（Resolved Dependency）</strong>，从而产生一个 Effective POM。</p><h2 id="依赖配置"><a href="#依赖配置" class="headerlink" title="依赖配置"></a>依赖配置</h2><p>下面是一段依赖配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>…<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>        <span class="comment">&lt;!-- 依赖的构件属组 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>…<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="comment">&lt;!-- 依赖的构件ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>…<span class="tag">&lt;/<span class="name">version</span>&gt;</span>        <span class="comment">&lt;!-- 依赖的构件版本 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>…<span class="tag">&lt;/<span class="name">type</span>&gt;</span>              <span class="comment">&lt;!-- 依赖类型，默认值为 jar --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>…<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>            <span class="comment">&lt;!-- 依赖范围 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>…<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>      <span class="comment">&lt;!-- 可选依赖，默认情况下不会被继承，只有声明了该依赖才会继承 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>                <span class="comment">&lt;!-- 排除(传递性)依赖 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>…<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                …</span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        …</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="依赖传递"><a href="#依赖传递" class="headerlink" title="依赖传递"></a>依赖传递</h2><p>Maven 会解析各个直接依赖的 POM，将那些必要的间接依赖，以<strong>传递性依赖</strong>的方式引入到当前项目中，而开发者不用再考虑该直接依赖还依赖了什么，或手动引入导致多余依赖：</p><p><img src="/img/java/maven/transitive_dependencies.png" alt="传递性依赖"></p><h2 id="依赖调解"><a href="#依赖调解" class="headerlink" title="依赖调解"></a>依赖调解</h2><p>Maven 调解依赖有两个基本原则：</p><ol><li>第一原则：<strong>路径最短者优先</strong>。<br>假设 X 是 A 的传递性依赖：A-&gt;B-&gt;C-&gt;X(1.0) 依赖路径长度为 3，A-&gt;D-&gt;X(2.0) 长度为 2，则 X(2.0) 会先被解析使用。</li><li>第二原则：<strong>第一声明者优先</strong>。<br>在依赖路径长度相等的前提下，在 POM 中，依赖声明的顺序决定了谁会先被解析使用。</li></ol><h2 id="依赖范围-scope"><a href="#依赖范围-scope" class="headerlink" title="依赖范围 scope"></a>依赖范围 scope</h2><p>依赖范围 <code>scope</code> 用于控制依赖与这三种 classpath（编译、测试、运行）的关系，即是否有效：</p><table><thead><tr><th>依赖范围（Scope）</th><th>编译classpath</th><th>测试classpath</th><th>运行classpath</th><th>例子</th></tr></thead><tbody><tr><td><code>compile</code></td><td>√</td><td>√</td><td>√</td><td>spring-core</td></tr><tr><td><code>test</code></td><td>×</td><td>√</td><td>×</td><td>spring-test、junit、mockito</td></tr><tr><td><code>provided</code></td><td>√</td><td>√</td><td>×</td><td>servlet-api（运行时，由于容器如tomcat已经提供，无须重复引入）</td></tr><tr><td><code>runtime</code></td><td>×</td><td>√</td><td>√</td><td>JDBC 驱动实现（编译时，只需 JDK 提供的 JDBC 接口；运行时，才需要接口的具体实现）</td></tr><tr><td><code>system</code></td><td>√</td><td>√</td><td>×</td><td>本地的，Maven 仓库之外的类库文件</td></tr><tr><td><code>import</code></td><td>/</td><td>/</td><td>/</td><td>Maven 2.0.9 版本后出的属性，<code>import</code> 只能在 <code>dependencyManagement</code> 的中使用，能解决 Maven 单继承问题，<code>import</code> 依赖关系实际上并不参与限制依赖关系的传递性。</td></tr></tbody></table><h2 id="可选依赖-optional"><a href="#可选依赖-optional" class="headerlink" title="可选依赖 optional"></a>可选依赖 optional</h2><p>可选依赖 <code>optional</code> 为 <code>true</code> 时，该依赖不会被传递进来。</p><h2 id="依赖排除-exclusions"><a href="#依赖排除-exclusions" class="headerlink" title="依赖排除 exclusions"></a>依赖排除 exclusions</h2><p>当传递性依赖的结果不是自己预期的构件版本，可以排除依赖重新自定义。下例展示了使用 <code>&lt;exclusions&gt;</code> 排除 A 的传递性依赖 C，并显式声明依赖 C(1.10)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>…<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>  <span class="comment">&lt;!-- 排除 A 的传递性依赖 C --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>…<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                …</span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 显式声明依赖 C(1.10) --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>…<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        …</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果如图：</p><p><img src="/img/java/maven/exclusion_dependencies.png" alt="依赖排除"></p><h2 id="依赖归类"><a href="#依赖归类" class="headerlink" title="依赖归类"></a>依赖归类</h2><p>当多个构件使用同一版本号时，为了便于后期统一升级维护，可以使用 <code>&lt;properties&gt;</code> 属性统一定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.0.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    …</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="解决依赖冲突"><a href="#解决依赖冲突" class="headerlink" title="解决依赖冲突"></a>解决依赖冲突</h2><p>例如在使用 Spring Boot 时，其依赖引入了一个有缺陷的 Jackson 框架版本 1.9.X，此时需要覆盖起步依赖引入的传递依赖：</p><p>方式一，如果项目未使用 Jackson 相关功能，可以使用 <code>&lt;exclusions&gt;</code> 排除依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式二，如果项目使用了，可以利用“就近原则”，覆盖传递依赖的版本号，修复缺陷：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="依赖下载问题"><a href="#依赖下载问题" class="headerlink" title="依赖下载问题"></a>依赖下载问题</h2><p>有时候某个依赖下载有问题时，会导致本地环境找不到相关类。此时可以找到本地仓库下的相关 jar 包目录，排查下是否只有 <code>*.lastupdated</code> 文件而没有相应 jar 包。如果是，则删掉该目录重新下载依赖即可。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html" target="_blank" rel="noopener">http://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html</a></p><p><a href="https://juejin.im/post/6844903987322290189" target="_blank" rel="noopener">Maven optional关键字透彻图解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 实战系列（一）POM 基础知识</title>
      <link href="2017/04/08/maven-pom-basics/"/>
      <url>2017/04/08/maven-pom-basics/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven-坐标"><a href="#Maven-坐标" class="headerlink" title="Maven 坐标"></a>Maven 坐标</h1><p>Maven 定义了这样一组规则：世界上任何一个<em>构件</em>都可以使用 Maven 坐标唯一标识，Maven 坐标的元素包括：</p><table><thead><tr><th>坐标元素</th><th>描述</th></tr></thead><tbody><tr><td>groupId</td><td>必选。定义当前 Maven 项目隶属的实际项目。</td></tr><tr><td>artifactId</td><td>必选。定义实际项目中的一个 Maven 项目（模块），推荐使用实际项目名称作为前缀。</td></tr><tr><td>version</td><td>必选。定义当前 Maven 项目所处版本。</td></tr><tr><td>packaging</td><td>可选。定义 Maven 项目的打包方式，默认为 <code>jar</code>。</td></tr><tr><td>classifier</td><td>不能直接定义。用来帮助定义构建输出的一些附属构件。如 javadoc、sources。</td></tr></tbody></table><h1 id="POM-关系类型"><a href="#POM-关系类型" class="headerlink" title="POM 关系类型"></a>POM 关系类型</h1><p>Maven 一个强大的地方在于处理项目之间的关系。其中包括<strong>依赖关系</strong>（包括传递性依赖关系）、<strong>继承关系</strong>和<strong>聚合关系</strong>（多模块项目）。 </p><p>详见：《<a href="/2018/04/20/maven-dependencies/">Maven 依赖关系</a>》、《<a href="/2018/04/21/maven-inheritance/">Maven 继承关系与聚合关系</a>》</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>Maven 属性是类似于 Ant 属性一样的值占位符。可以通过符号  <code>${X}</code>（其中 <code>X</code> 是属性）在 POM 中的任意位置访问它们的值。它们也可以被插件用作默认值使用，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>共有五种风格的占位符：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>${env.X}</code></td><td>返回 shell 的环境变量。例如 <code>${env.PATH}</code> 返回 PATH 环境变量。为了可靠性，Maven 2.1.0 开始将环境变量的名称归一化为全部大写。</td></tr><tr><td><code>${project.x}</code></td><td>返回 pom.xml 文件中对应元素的值。 例如可通过 <code>${project.version}</code> 访问 <code>&lt;project&gt;&lt;version&gt;1.0&lt;/version&gt;&lt;/project&gt;</code>。</td></tr><tr><td><code>${settings.x}</code></td><td>返回 settings.xml 文件中对应元素的值。例如 <code>&lt;settings&gt;&lt;offline&gt;false&lt;/offline&gt;&lt;/settings&gt;</code> 可通过 <code>${settings.offline}</code> 访问。</td></tr><tr><td><code>${java.x}</code></td><td>返回 Java 系统属性。 通过 <code>java.lang.System.getProperties()</code> 可访问的所有属性都可用作 POM 属性，例如<code>${java.home}</code>。</td></tr><tr><td><code>${x}</code></td><td>返回 pom.xml 文件中 <code>&lt;properties/&gt;</code> 元素内的值。例如 <code>&lt;spring.version&gt;1.0.1-SNAPSHOT&lt;/spring.version&gt;</code> 可通过 <code>${spring.version}</code> 访问。</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://maven.apache.org/pom.html" target="_blank" rel="noopener">http://maven.apache.org/pom.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（十五）Git 学习之路</title>
      <link href="2017/03/21/git-startup/"/>
      <url>2017/03/21/git-startup/</url>
      
        <content type="html"><![CDATA[<p>学习 Git 快一年了，感受良多，总结如下。</p><h1 id="如何开始？"><a href="#如何开始？" class="headerlink" title="如何开始？"></a>如何开始？</h1><p>早年的时候，为了获取优质的项目和资源，注册了 GitHub 的账号，但仅仅简单用了 Star 和 Clone 功能。后来开始想在 GitHub 上面托管一些资源，陆续做了一些功课：</p><ul><li>LinuxCast Git 视频教程，手把手指导，可惜教程不再维护了。</li><li><a href="http://git-scm.com/book/" target="_blank" rel="noopener">Git 官方文档</a>，第一手官方材料，由浅入深，涉及 Git 各方面的内容，建议有实操经验的同学深入阅读。</li><li><a href="https://help.github.com" target="_blank" rel="noopener">GitHub 帮助文档</a>，偏向实操，建议初学者阅读。而且里面涉及到一些 GitHub 特性（图形化操作、Social、Pages）可以与 Git 互补。</li><li>廖雪峰的博客</li></ul><p>其实网上相关教程、博客、书籍很多，但建议初学者重心先放在：</p><ul><li>基础命令的实操（推荐 <a href="https://training.github.com/kit/downloads/github-git-cheat-sheet.pdf" target="_blank" rel="noopener">Git cheatsheet</a>，按功能分组命令，便于记忆）</li><li>简单概念的理解（例如重点关注 Git 文件流转的三个工作区域及远程仓库，至于配置、分支（我知道分支是 Git 的杀手锏功能，但事实上很多人只用到一个 master 分支）、工作流等先统统忽略）</li></ul><p>然后安装好 Git，选择好一个代码托管商（如国外 <a href="https://www.github.com" target="_blank" rel="noopener">GitHub</a>，国内 <a href="https://gitcafe.com" target="_blank" rel="noopener">GitCafe</a>），赶紧先跑起来，再好起来！如果你曾大致了解过 Git 这一门技术，你会发现这是属于“记忆型”的技术，需要多用才熟能生巧。</p><h1 id="我的学习轨迹"><a href="#我的学习轨迹" class="headerlink" title="我的学习轨迹"></a>我的学习轨迹</h1><h2 id="第一轮"><a href="#第一轮" class="headerlink" title="第一轮"></a>第一轮</h2><p>第一轮学习从零开始，大致如下：</p><ul><li>简单阅读了一些文档，用思维导图做成笔记。</li><li>安装客户端，实操命令。</li><li>把所做所得整理成 PPT，用自己的理解在团队内部做了一次技术分享，反响不错，还加深了自己的理解。</li></ul><h2 id="第二轮"><a href="#第二轮" class="headerlink" title="第二轮"></a>第二轮</h2><p>第二轮的起因是因为想用 GitHub Pages 服务搭建一个静态博客写写文章。由于已经有了第一轮的沉淀，这回学习速度就很快了。还顺便学会了 Markdown 语法和 Hexo 博客搭建。</p><h2 id="第三轮"><a href="#第三轮" class="headerlink" title="第三轮"></a>第三轮</h2><p>第三轮是因为跳槽后新公司正好使用的是 Git，但由于团队成员用得都不熟练，因此利用空余时间进一步研究了 Git 的进阶内容：</p><ul><li>分支管理与团队工作流程</li><li>冲突解决方案</li><li><code>pull</code>、<code>merge</code>、<code>log</code>、<code>reset</code>、<code>checkout</code> 等实用命令</li><li><code>rebase</code>、<code>cherry-pick</code> 等高级命令</li></ul><p>整个过程使用的是“INK 学习法”，并再次将理解的内容整理成 PPT 与团队分享。这轮学习的不同之处在于：</p><ul><li>以往都是个人使用 Git，使用的命令都很简单。当与团队一起使用时，问题规模不同，对工具的理解也会进一步加深。</li><li>与第一次纯粹分享不同，这次侧重于推广我的方案，规范团队的工作流程，将知识转化为生产力。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学习的轨迹应当是螺旋向上，难易度逐轮递增。每一轮的学习主题还应有所侧重，意图一口一个大胖子的行为会噎死自己 :)</p><p>如今 Git 对我来说不止是门技术，更是一种生活方式。除了工作中每天都要用到，通过它还“连接”了我与开源世界。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（十四）Git 远程仓库迁移</title>
      <link href="2017/03/15/git-transfer-project/"/>
      <url>2017/03/15/git-transfer-project/</url>
      
        <content type="html"><![CDATA[<h1 id="1-获取权限"><a href="#1-获取权限" class="headerlink" title="1.获取权限"></a>1.获取权限</h1><p>首先获取相关 Group 的 Owner 权限。</p><h1 id="2-在线迁移"><a href="#2-在线迁移" class="headerlink" title="2.在线迁移"></a>2.在线迁移</h1><p><img src="/img/git/git_transfer_project.png" alt="Git 迁移项目"></p><h1 id="3-更新本地仓库"><a href="#3-更新本地仓库" class="headerlink" title="3.更新本地仓库"></a>3.更新本地仓库</h1><p>更新本地仓库，首先查看当前 remote url：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@git.kd.ssj:finance-ssjmarket/finance-market.git (fetch)</span><br><span class="line">origin  git@git.kd.ssj:finance-ssjmarket/finance-market.git (push)</span><br></pre></td></tr></table></figure><p>使用 <code>git remote set-url</code>  重置 remote url：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote <span class="built_in">set</span>-url origin git@git.kd.ssj:finance-web/finance-market.git</span><br></pre></td></tr></table></figure><p>检查重置是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@git.kd.ssj:finance-web/finance-market.git (fetch)</span><br><span class="line">origin  git@git.kd.ssj:finance-web/finance-market.git (push)</span><br></pre></td></tr></table></figure><h1 id="4-批量更新本地仓库"><a href="#4-批量更新本地仓库" class="headerlink" title="4 批量更新本地仓库"></a>4 批量更新本地仓库</h1><p>适用于一堆 git 仓库放在同一个目录下，可以用这个方法进行批量替换：</p><ol><li>检查一下现在的 url：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat .&#x2F;finance-*&#x2F;.git&#x2F;config | grep &#39;git@&#39;</span><br></pre></td></tr></table></figure><ol start="2"><li>批量替换：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -1 .&#x2F;仓库名-*&#x2F;.git&#x2F;config | xargs  sed -i &#39;s&#x2F;git@.*\:&#x2F;git@github.com:&#x2F;g&#39;</span><br></pre></td></tr></table></figure><ol start="3"><li>再次检查一下结果：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat .&#x2F;finance-*&#x2F;.git&#x2F;config | grep &#39;git@&#39;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyCli：支持自动补全和语法高亮的 MySQL 客户端</title>
      <link href="2017/03/02/mycli/"/>
      <url>2017/03/02/mycli/</url>
      
        <content type="html"><![CDATA[<p>工作中常用到 mysql 自带的命令行工具，但实在难用。推荐一款 MySQL 命令行工具——<a href="http://mycli.net/" target="_blank" rel="noopener">MyCli</a>，支持<strong>自动补全</strong>和<strong>语法高亮</strong>。也可用于 MariaDB 和 Percona。</p><p>功能如下：</p><p><img src="/img/mysql/mycli.gif" alt="MyCLI"></p><p>MyCLI 的兼容性爆表，支持 Windows、MacOS、Linux，运行在 Python 2.7, 3.3, 3.4, 3.5, 3.6。安装简易，例如 Windows 只要安装了 <a href="https://www.python.org/downloads/" target="_blank" rel="noopener">Python 环境</a>及其包管理工具 <code>pip</code> ，就能一键安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ pip install mycli</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">$ easy_install mycli</span><br></pre></td></tr></table></figure><p>其它系统的安装方式，请参考：<a href="http://mycli.net/install" target="_blank" rel="noopener">http://mycli.net/install</a></p><p>Windows 下使用 <code>cmd</code> 连接数据库，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mycli -hlocalhost -P3306 -uroot -p123456</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSON 框架系列之 Jackson 总结</title>
      <link href="2017/02/10/java-jackson/"/>
      <url>2017/02/10/java-jackson/</url>
      
        <content type="html"><![CDATA[<h1 id="JsonNode-的使用"><a href="#JsonNode-的使用" class="headerlink" title="JsonNode 的使用"></a>JsonNode 的使用</h1><p><code>com.fasterxml.jackson.databind.JsonNode</code> 表示一个 JSON 节点，可以通过 <code>ObjectMapper#readTree</code> 方法解析出来，也可以通过 <code>JsonNode</code> 的子类 API 自定义构建：</p><p><img src="/img/java/jackson/JsonNode.png" alt="JsonNode"></p><p>构建代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JsonNode jsonNode =</span><br><span class="line">    <span class="keyword">new</span> ObjectNode(JsonNodeFactory.instance, ImmutableMap.of(</span><br><span class="line">        <span class="string">"hello"</span>,</span><br><span class="line">        <span class="keyword">new</span> ArrayNode(JsonNodeFactory.instance, ImmutableList.of(</span><br><span class="line">            <span class="keyword">new</span> ObjectNode(JsonNodeFactory.instance, ImmutableMap.of(<span class="string">"key"</span>, <span class="keyword">new</span> TextNode(<span class="string">"value0"</span>))),</span><br><span class="line">            <span class="keyword">new</span> ObjectNode(JsonNodeFactory.instance, ImmutableMap.of(<span class="string">"key"</span>, <span class="keyword">new</span> TextNode(<span class="string">"value1"</span>))),</span><br><span class="line">            <span class="keyword">new</span> ObjectNode(JsonNodeFactory.instance, ImmutableMap.of(<span class="string">"key2"</span>, <span class="keyword">new</span> TextNode(<span class="string">"value2"</span>)))</span><br><span class="line">        )),</span><br><span class="line">        <span class="string">"test"</span>,</span><br><span class="line">        <span class="keyword">new</span> ObjectNode(JsonNodeFactory.instance, ImmutableMap.of(</span><br><span class="line">            <span class="string">"key3"</span>, <span class="keyword">new</span> TextNode(<span class="string">"value3"</span>)))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;"hello":[&#123;"key":"value0"&#125;,&#123;"key":"value1"&#125;,&#123;"key2":"value2"&#125;],"test":&#123;"key3":"value3"&#125;&#125;</span></span><br><span class="line">log.info(jsonNode.toString());</span><br></pre></td></tr></table></figure><p><code>JsonNode</code> 构建完成后，可以灵活的读取其值，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [value0, value1]</span></span><br><span class="line">log.info(jsonNode.get(<span class="string">"hello"</span>).findValuesAsText(<span class="string">"key"</span>).toString());</span><br><span class="line"><span class="comment">// value3</span></span><br><span class="line">log.info(jsonNode.get(<span class="string">"test"</span>).get(<span class="string">"key3"</span>).asText());</span><br></pre></td></tr></table></figure><h1 id="ObjectMapper-工具类"><a href="#ObjectMapper-工具类" class="headerlink" title="ObjectMapper 工具类"></a>ObjectMapper 工具类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.core.type.TypeReference;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.*;</span><br><span class="line"><span class="keyword">import</span> lombok.experimental.UtilityClass;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jackson工具类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@UtilityClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper OBJECT_MAPPER = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//false: 空对象不抛异常 e.g. handler&#123; &#125;</span></span><br><span class="line">        OBJECT_MAPPER.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//false: 解析JSON时忽略未知属性</span></span><br><span class="line">        OBJECT_MAPPER.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//true :空字符串可以解析为空对象</span></span><br><span class="line">        OBJECT_MAPPER.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ObjectMapper <span class="title">getObjectMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> OBJECT_MAPPER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj POJO</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> JSON</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">toJson</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getObjectMapper().writeValueAsString(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"to json failure"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text JSON</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type Class&lt;?&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;  泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> POJO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromJson</span><span class="params">(String text, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getObjectMapper().readValue(text, type);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"fromJson failure"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JsonNode <span class="title">fromJson</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getObjectMapper().readTree(text);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"from json failure"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromJson</span><span class="params">(String text, JavaType javaType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getObjectMapper().readValue(text, javaType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"from json failure"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromJson</span><span class="params">(String text, TypeReference&lt;T&gt; valueTypeRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getObjectMapper().readValue(text, valueTypeRef);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"from json failure"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> src  JSON字节</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type Class&lt;?&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;  泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> POJO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromByte</span><span class="params">(<span class="keyword">byte</span>[] src, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getObjectMapper().readValue(src, OBJECT_MAPPER.constructType(type));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">"from byte failure"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  Map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type Class&lt;?&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;  泛型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> POJO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">fromMap</span><span class="params">(Map&lt;String, Object&gt; map, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getObjectMapper().convertValue(map, OBJECT_MAPPER.getTypeFactory().constructType(type));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            log.error(<span class="string">"fromMap failure"</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text JSON</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type Class&lt;?&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;  T</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> List</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">fromJsonToList</span><span class="params">(String text, Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//     fromJson(java.lang.String, com.fasterxml.jackson.databind.JavaType)</span></span><br><span class="line">        <span class="keyword">return</span> fromJson(text, OBJECT_MAPPER.getTypeFactory().constructParametricType(ArrayList<span class="class">.<span class="keyword">class</span>, <span class="title">type</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JavaType-的使用"><a href="#JavaType-的使用" class="headerlink" title="JavaType 的使用"></a>JavaType 的使用</h1><p>工具类的方法 <code>fromJsonToList</code>，使用了方法 <code>OBJECT_MAPPER.getTypeFactory().constructParametricType(...)</code>，其值调试如下：</p><p><img src="/img/java/jackson/CollectionType.png" alt=""></p><p>这个值为 <code>JavaType</code> 的子类 <code>CollectionType</code>，可用于调用方法 <code>ObjectMapper#readValue(java.lang.String, com.fasterxml.jackson.databind.JavaType)</code> 进行集合类型的 JSON 转换：</p><p><img src="/img/java/jackson/JavaType.png" alt="JavaType"></p><h1 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h1><p>本例中，我们需要获取以下两个方法的泛型返回值中的实际类型参数 <code>XxxRespDTO</code> 的 <code>Class</code> 类型，以用于 JSON 转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApiService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口一</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RespDTO&lt;XxxRespDTO&gt; <span class="title">get</span><span class="params">(XxxReqDTO reqDTO)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口二</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RespDTO&lt;List&lt;XxxRespDTO&gt;&gt; list(XxxReqDTO reqDTO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个方法，用于转换 JSON：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">getObject</span><span class="params">(Method method, String json)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取该方法的泛型返回值，然后获取其第一个实际类型参数</span></span><br><span class="line">    ParameterizedType returnType = (ParameterizedType) method.getGenericReturnType();</span><br><span class="line">    Type type = returnType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理接口一的情况</span></span><br><span class="line">    <span class="keyword">if</span> (type <span class="keyword">instanceof</span> Class) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = (Class&lt;?&gt;) type;</span><br><span class="line">        result = JsonUtils.fromJson(json, clazz);  <span class="comment">// ObjectMapper#readValue(String, Class&lt;T&gt;)</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">        ParameterizedType nestedReturnType = (ParameterizedType) type;</span><br><span class="line">        <span class="comment">// 处理接口二的情况</span></span><br><span class="line">        <span class="keyword">if</span> (nestedReturnType.getRawType() == List<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            Class&lt;?&gt; clazz = (Class&lt;?&gt;) nestedReturnType.getActualTypeArguments()[<span class="number">0</span>];</span><br><span class="line">            result = JsonUtils.fromJsonToList(decryptedRespData, clazz);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"未实现的 JSON 解析！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"未实现的 JSON 解析！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种用法常常出现在框架之中。下面来看下调试效果：</p><h2 id="接口一"><a href="#接口一" class="headerlink" title="接口一"></a>接口一</h2><p>下图展示了变量 <code>returnType</code> 为参数化类型 <code>ParameterizedType</code>，其实际类型参数 <code>type</code> 为 <code>Class</code> 类型，值为 <code>XxxRespDTO</code> ：</p><p><img src="/img/java/jackson/ObjectMapper_example.png" alt="JsonNode"></p><h2 id="接口二"><a href="#接口二" class="headerlink" title="接口二"></a>接口二</h2><p>下图展示了变量 <code>returnType</code> 的实际类型参数 <code>type</code> 与接口一为 <code>Class</code> 类型不同，接口二为 <code>ParameterizedType</code> 参数化类型，值为 <code>List&lt;XxxRespDTO&gt;</code>：</p><p><img src="/img/java/jackson/ObjectMapper_example_2.png" alt=""></p><h1 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h1><h2 id="Unrecognized-field-not-marked-as-ignorable"><a href="#Unrecognized-field-not-marked-as-ignorable" class="headerlink" title="Unrecognized field, not marked as ignorable"></a>Unrecognized field, not marked as ignorable</h2><p>该错误的意思是说，不能够识别的字段没有标示为可忽略。出现该问题的原因就是 JSON 中包含了目标 Java 对象没有的属性。</p><p>解决方法有如下几种：</p><ol><li>保证传入的 JSON 串不包含目标对象的没有的属性。</li><li><code>@JsonIgnoreProperties(ignoreUnknown = true)</code> 在目标对象的类级别上加上该注解和属性，则 Jackson 在反序列化的时候，会忽略该目标对象不存在的属性。</li><li>全局 <code>DeserializationFeature</code> 配置<br><code>objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,false)</code> 配置该 <code>objectMapper</code> 在反序列化时，忽略目标对象没有的属性。凡是使用该 <code>objectMapper</code> 反序列化时，都会拥有该特性。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Fiddler 代理调试 APP 页面</title>
      <link href="2017/02/07/fiddler/"/>
      <url>2017/02/07/fiddler/</url>
      
        <content type="html"><![CDATA[<p>我们知道如何在电脑上通过 Chrome、Firefox 调试页面请求，但在手机端呢？我们可以使用 fiddler 来调试webapp。fiddler 是一个很好的调试、抓包工具。</p><p>问题：在客户端打开页面有问题，但浏览器正常；（由于客户端特定的环境，我们无法在电脑端浏览器调试定位一些问题，线上环境，更不能修改代码来调试。怎么办？ 用Fiddler 代理本地文件来调试）</p><p>解决办法： 使用Fiddler 代理调试APP页面；</p><h1 id="PC-端设置"><a href="#PC-端设置" class="headerlink" title="PC 端设置"></a>PC 端设置</h1><h2 id="Fiddler-安装"><a href="#Fiddler-安装" class="headerlink" title="Fiddler 安装"></a>Fiddler 安装</h2><p><a href="https://www.telerik.com/download/fiddler" target="_blank" rel="noopener">https://www.telerik.com/download/fiddler</a></p><h2 id="Fiddler-设置"><a href="#Fiddler-设置" class="headerlink" title="Fiddler 设置"></a>Fiddler 设置</h2><p>首先打开Fiddler-&gt;Tools-&gt;Fiddler Options 进行配置，配置完成后重启 Fiddler，如下图：</p><p><img src="/img/fiddler/fiddler_setting.png" alt="Fiddler 设置"></p><h2 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h2><p>关闭本机防火墙，避免手机无法 ping 通。</p><h1 id="iPhone-手机端调试"><a href="#iPhone-手机端调试" class="headerlink" title="iPhone 手机端调试"></a>iPhone 手机端调试</h1><p>参考：<a href="http://blog.csdn.net/asmcvc/article/details/51566569" target="_blank" rel="noopener">http://blog.csdn.net/asmcvc/article/details/51566569</a></p><h2 id="安装-Fiddler-证书"><a href="#安装-Fiddler-证书" class="headerlink" title="安装 Fiddler 证书"></a>安装 Fiddler 证书</h2><p>手机浏览器访问 172.22.31.43:8888 ，点击安装证书：</p><p><img src="/img/fiddler/fiddler_certificate_install_1.png" alt="安装 Fiddler 证书"></p><p>提示警告，继续安装：</p><p><img src="/img/fiddler/fiddler_certificate_install_2.png" alt="安装 Fiddler 证书"></p><p>安装完毕：</p><p><img src="/img/fiddler/fiddler_certificate_install_3.png" alt="安装 Fiddler 证书"></p><h2 id="证书信任设置"><a href="#证书信任设置" class="headerlink" title="证书信任设置"></a>证书信任设置</h2><p>iOS 10 需要设置：通用 - 关于本机 - 证书信任设置 - 针对根证书启用完全信任：</p><p><img src="/img/fiddler/fiddler_certificate_install_4.png" alt="证书信任设置"></p><h2 id="WIFI-代理设置"><a href="#WIFI-代理设置" class="headerlink" title="WIFI 代理设置"></a>WIFI 代理设置</h2><p><img src="/img/fiddler/fiddler_wifi_setting.png" alt="WIFI 代理设置"></p><h1 id="开始抓包调试"><a href="#开始抓包调试" class="headerlink" title="开始抓包调试"></a>开始抓包调试</h1><h2 id="嗅探所有请求、响应"><a href="#嗅探所有请求、响应" class="headerlink" title="嗅探所有请求、响应"></a>嗅探所有请求、响应</h2><p>打开APP页面，可以嗅探被过滤的请求：</p><p><img src="/img/fiddler/fiddler_inspect.png" alt="嗅探器"></p><h2 id="解码-URL-请求参数"><a href="#解码-URL-请求参数" class="headerlink" title="解码 URL 请求参数"></a>解码 URL 请求参数</h2><p>普通表单的显示如下：</p><p><img src="/img/fiddler/fiddler_inspect_webforms.png" alt="解码 URL 请求参数"></p><p>可以使用 Send to TextWizard 进一步解码：</p><p><img src="/img/fiddler/fiddler_inspect_webforms_2.png" alt="解码 URL 请求参数"></p><h2 id="设置断点，修改请求、响应"><a href="#设置断点，修改请求、响应" class="headerlink" title="设置断点，修改请求、响应"></a>设置断点，修改请求、响应</h2><p>Fiddler 最强大的功能莫过于设置断点了，设置好断点后，你可以修改请求头（如 cookie）、请求体、响应头、响应体。</p><p><img src="/img/fiddler/break_request.png" alt="断点原理"></p><p>设置断点有两种方法：</p><p>第一种：设置全局断点</p><p>打开 Fiddler 点击 Rules-&gt; Automatic Breakpoint -&gt; Before Requests，可修改请求；After Responses，可修改响应。</p><p>如何消除全局断点呢？ 点击Rules-&gt; Automatic Breakpoint -&gt;Disabled</p><p><img src="/img/fiddler/break_request_1.png" alt="设置全局断点"></p><p>第二种：设置指定断点</p><p>在命令行中输入命令: bpu <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> (这种方法只会中断 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>)</p><p>如何消除命令呢？ 在命令行中输入命令 bpu</p><p>断点效果如下：</p><p><img src="/img/fiddler/break_request_2.png" alt="设置指定断点"></p><p><img src="/img/fiddler/break_request_3.png" alt="设置指定断点"></p><h2 id="自动响应"><a href="#自动响应" class="headerlink" title="自动响应"></a>自动响应</h2><p>有时候，线上客户端环境下打开的页面有bug无法用浏览器调试，则可以用fiddler代理本地文件来进行调试，非常方便。例如：</p><p><img src="/img/fiddler/auto_response.png" alt="设置自动响应"></p><p>我们将线上JS文件代理为本地文件，我们可以修改本地文件，就能用客户端打开看到修改结果，非常方便，当然我们可以同时代理 引入 vconsole  来在手机端打印错误日志。</p><p>也可以将一个接口代理下来，然后新建一个json文件，和代理js文件是同样的方法，就可以修改接口的请求了。</p><p>PS：代理接口时可能会出现跨域问题，解决方法<a href="http://www.choujindeputao.com/fiddler-cross-origin/" target="_blank" rel="noopener">点这里</a>。</p><h2 id="显示-IP"><a href="#显示-IP" class="headerlink" title="显示 IP"></a>显示 IP</h2><p>如何显示 IP？只需配置一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FiddlerObject.UI.lvSessions.AddBoundColumn(&quot;IP&quot;, 120, &quot;X-HostIP&quot;);</span><br></pre></td></tr></table></figure><p><img src="/img/fiddler/show_ip.png" alt="显示 IP"></p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ol><li>多级代理相互影响（数据库连接vpn_ssl、蓝灯、xx-net等）</li><li>代理缓存</li><li>左下角的“Captuing”仅用于控制电脑端抓包，不影响手机端，可以关掉，避免影响电脑端的正常上网（例如网易云音乐听歌，印象笔记同步）。</li><li>开启代理后，响应体不会被 gzip，也没有响应头：Content-Encoding: gzip。可以自行用 Chrome 和 IE 对比测试。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动 Web 开发要点总结</title>
      <link href="2017/01/14/webapp-development/"/>
      <url>2017/01/14/webapp-development/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/javascript/key_of_webapp_dev.png" alt="移动 Web 开发要点总结"></p><p>总结下其中几个要点：</p><h1 id="iOS-300ms-点击延时问题"><a href="#iOS-300ms-点击延时问题" class="headerlink" title="iOS 300ms 点击延时问题"></a>iOS 300ms 点击延时问题</h1><p>为什么存在这个问题？</p><blockquote><p>这要追溯至 2007 年初。苹果公司在发布首款 iPhone 前夕，遇到一个问题 —— 当时的网站都是为大屏幕设备所设计的。于是苹果的工程师们做了一些约定，应对 iPhone 这种小屏幕浏览 PC 端站点的问题。这当中最出名的，当属双击缩放(double tap to zoom)。</p><p>双击缩放，顾名思义，即用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。</p><p>那么问题来了，假设用户在 iOS Safari 里边点击了一个链接，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。</p><p>因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。如果没有，就触发 click 点击事件。</p></blockquote><p>According to Google:</p><blockquote><p>… mobile browsers will wait approximately 300ms from the time that you tap the button to fire the click event. The reason for this is that the browser is waiting to see if you are actually performing a double tap.</p></blockquote><h2 id="验证问题"><a href="#验证问题" class="headerlink" title="验证问题"></a>验证问题</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">"button"</span>),</span></span><br><span class="line">                record;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            button.addEventListener(<span class="string">"touchstart"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                record = <span class="built_in">Date</span>.now();</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"button touchstart"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="actionscript">            button.addEventListener(<span class="string">"touchend"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delay = <span class="built_in">Date</span>.now() - record;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"button touchend delay: "</span> + delay + <span class="string">"ms"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="actionscript">            button.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delay = <span class="built_in">Date</span>.now() - record;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"button click delay: "</span> + delay + <span class="string">"ms"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delay = <span class="built_in">Date</span>.now() - record;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"document click delay: "</span> + delay + <span class="string">"ms"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>iOS Safari 上点击后，显示结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button touchstart</span><br><span class="line">button touchend delay: 59ms</span><br><span class="line">button click delay: 310ms</span><br><span class="line">document click delay: 312ms</span><br></pre></td></tr></table></figure><p>可见，<code>click</code> 事件延迟了 300ms 左右。</p><h2 id="找出原因"><a href="#找出原因" class="headerlink" title="找出原因"></a>找出原因</h2><p>当一个用户点击屏幕的时候，会产生两个事件：<code>touch</code> 和 <code>click</code> 。<code>touch</code> 事件会首先触发，完成捕获、冒泡的事件流。同时在点击的 300ms 延时后，触发 <code>click</code> 事件。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>如今移动端 webapp 性能都追求与原生应用匹配，上述 iOS 单击事件 300ms 延迟，显然是不可接受的。有三个解决方案：</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>只使用 <code>touch</code> 事件，然后使用 <code>e.preventDefault()</code> 来阻止默认行为 <code>click</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">"button"</span>),</span></span><br><span class="line">                record;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            button.addEventListener(<span class="string">"touchstart"</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                record = <span class="built_in">Date</span>.now();</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"button touchstart"</span>);</span></span><br><span class="line">                e.preventDefault();</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="actionscript">            button.addEventListener(<span class="string">"touchend"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delay = <span class="built_in">Date</span>.now() - record;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"button touchend delay: "</span> + delay + <span class="string">"ms"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="actionscript">            button.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delay = <span class="built_in">Date</span>.now() - record;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"button click delay: "</span> + delay + <span class="string">"ms"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delay = <span class="built_in">Date</span>.now() - record;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"document click delay: "</span> + delay + <span class="string">"ms"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">button touchstart</span><br><span class="line">button touchend delay: 60ms</span><br></pre></td></tr></table></figure><p>这种方案看起来简单易行，然而功能复杂的时候容易出问题。比如滑动加选择，会因为滑动触发 <code>touchend</code>，从而触发选择行为。所以如果本该绑定在 <code>click</code> 上的事件全部绑定到 <code>touchend</code> 事件上，就会出现问题。请看下例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">"button"</span>),</span></span><br><span class="line">                record;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            button.addEventListener(<span class="string">"touchstart"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                record = <span class="built_in">Date</span>.now();</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"button touchstart"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.addEventListener(<span class="string">"touchmove"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"document move"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="actionscript">            button.addEventListener(<span class="string">"touchend"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delay = <span class="built_in">Date</span>.now() - record;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"button touchend delay: "</span> + delay + <span class="string">"ms"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="actionscript">            button.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delay = <span class="built_in">Date</span>.now() - record;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"button click delay: "</span> + delay + <span class="string">"ms"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delay = <span class="built_in">Date</span>.now() - record;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"document click delay: "</span> + delay + <span class="string">"ms"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当点击按钮并拖动时，显示结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">button touchstart</span><br><span class="line">document move</span><br><span class="line">document move</span><br><span class="line">document move</span><br><span class="line">document move</span><br><span class="line">document move</span><br><span class="line">button touchend delay: 943ms</span><br></pre></td></tr></table></figure><p>可见：</p><ul><li><p>该例中用户可能只想拖动页面，但却被迫触发了 <code>touchend</code> 事件。所以如果本该绑定在 <code>click</code> 上的事件全部绑定到 <code>touchend</code> 事件上，就会出现问题，违背用户意图。</p></li><li><p>拖动行为会导致 <code>click</code> 事件不会执行，可以理解为  <code>touchmove</code> 和 <code>click</code> 是相斥的。</p></li></ul><p>因此，建议用回 <code>click</code>。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>使用 zepto.js 的 <code>tap</code> 事件，底层是 <code>click</code> 事件并去掉 300ms 延时，然而会有点击穿透的问题。</p><h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>使用 <a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">fastclick</a>，兼容性好，用法简单，没有点透问题，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"fastclick.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> button = <span class="built_in">document</span>.querySelector(<span class="string">"button"</span>),</span></span><br><span class="line">                record;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            button.addEventListener(<span class="string">"touchstart"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                record = <span class="built_in">Date</span>.now();</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"button touchstart"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="actionscript">            button.addEventListener(<span class="string">"touchend"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delay = <span class="built_in">Date</span>.now() - record;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"button touchend delay: "</span> + delay + <span class="string">"ms"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="actionscript">            button.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delay = <span class="built_in">Date</span>.now() - record;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"button click delay: "</span> + delay + <span class="string">"ms"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> delay = <span class="built_in">Date</span>.now() - record;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"document click delay: "</span> + delay + <span class="string">"ms"</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                FastClick.attach(<span class="built_in">document</span>.body);</span></span><br><span class="line"><span class="actionscript">                &#125;, <span class="literal">false</span>);</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">button touchstart</span><br><span class="line">button touchend delay: 60ms</span><br><span class="line">button click delay: 60ms</span><br><span class="line">document click delay: 60ms</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://developer.telerik.com/featured/300-ms-click-delay-ios-8/" target="_blank" rel="noopener">http://developer.telerik.com/featured/300-ms-click-delay-ios-8/</a></p><p><a href="https://www.sitepoint.com/5-ways-prevent-300ms-click-delay-mobile-devices/" target="_blank" rel="noopener">https://www.sitepoint.com/5-ways-prevent-300ms-click-delay-mobile-devices/</a></p><p><a href="http://www.linovo.me/front/webapp-300ms.html" target="_blank" rel="noopener">http://www.linovo.me/front/webapp-300ms.html</a></p><p><a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">https://github.com/ftlabs/fastclick</a></p><p><a href="https://github.com/filamentgroup/tappy/" target="_blank" rel="noopener">https://github.com/filamentgroup/tappy/</a></p><p><a href="http://labs.ft.com/2011/08/fastclick-native-like-tapping-for-touch-apps/" target="_blank" rel="noopener">http://labs.ft.com/2011/08/fastclick-native-like-tapping-for-touch-apps/</a></p><p><a href="http://www.mamicode.com/info-detail-666685.html" target="_blank" rel="noopener">http://www.mamicode.com/info-detail-666685.html</a></p><p><a href="https://www.jianshu.com/p/dc3bceb10dbb" target="_blank" rel="noopener">https://www.jianshu.com/p/dc3bceb10dbb</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H5 存储的四种方案介绍</title>
      <link href="2017/01/07/h5-storage/"/>
      <url>2017/01/07/h5-storage/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/javascript/h5_storage.png" alt="h5 存储"></p><p>Cookie 指令在 HTTP 头的形式如下：</p><ul><li><p>HTTP 请求头 <code>Cookie</code> 指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: code&#x3D;23365f1409b; __auth&#x3D;eda2ebe49a4a91d3546435c3</span><br></pre></td></tr></table></figure></li><li><p>HTTP 响应头 <code>Set-Cookie</code> 指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: code&#x3D;23365f1409b; Expires&#x3D;Thu, 31-Dec-2016 07:23:59 GMT; Domain&#x3D;x.y.z.com; Path&#x3D;&#x2F;ws; Secure; HttpOnly</span><br></pre></td></tr></table></figure></li></ul><p>其中 Cookie 的 <code>domain</code> 属性比较特殊，存在一些读写限制：可读写本身或上一级 <code>domain</code> 的 cookie，但无法读写同级或下一级 <code>domain</code> 的 cookie。</p><table><thead><tr><th></th><th>z.com</th><th>y.z.com</th></tr></thead><tbody><tr><td>z.com</td><td>√</td><td>√</td></tr><tr><td>y.z.com</td><td>×</td><td>√</td></tr><tr><td>x.z.com</td><td>×</td><td>×</td></tr><tr><td>x.y.z.com</td><td>×</td><td>×</td></tr></tbody></table><p>如果不设置 Cookie 的 <code>Expires</code> 或者 <code>Max-Age</code> 属性，其默认值是 Session，也就是关闭浏览器后该 Cookie 就消失了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.ibm.com/developerworks/cn/java/books/javaweb_xlb/10/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/books/javaweb_xlb/10/index.html</a></p><p><a href="http://www.cnblogs.com/xiaowei0705/archive/2011/04/19/2021372.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiaowei0705/archive/2011/04/19/2021372.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化构建工具 Gulp.js</title>
      <link href="2016/12/05/javascript-gulpjs/"/>
      <url>2016/12/05/javascript-gulpjs/</url>
      
        <content type="html"><![CDATA[<p>某段时期前端技术选型上使用过 <a href="https://www.gulpjs.com.cn/" target="_blank" rel="noopener">Gulp.js</a> 解决前端工程化及自动化构建问题，下表整理了其在实践项目中常用的插件：</p><table><thead><tr><th>插件</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td><a href="https://www.npmjs.com/package/gulp-jshint" target="_blank" rel="noopener">gulp-jshint</a></td><td>检查 JavaScript 语法</td><td><a href="http://jshint.com/docs/options/" target="_blank" rel="noopener">http://jshint.com/docs/options/</a></td></tr><tr><td><a href="https://www.npmjs.com/package/gulp-uglify" target="_blank" rel="noopener">gulp-uglify</a></td><td>压缩 JavaScript</td><td></td></tr><tr><td><a href="https://www.npmjs.com/package/gulp-sourcemaps" target="_blank" rel="noopener">gulp-sourcemaps</a></td><td>输出 sourcemaps</td><td>部署前端之前，开发者通常会对代码进行打包压缩，这样可以减少代码大小，从而有效提高访问速度。然而，压缩代码的报错信息是很难Debug的，因为它的行号和列号已经失真。这时就需要Source Map来还原真实的出错位置了。</td></tr><tr><td><a href="https://www.npmjs.com/package/gulp-imagemin" target="_blank" rel="noopener">gulp-imagemin</a></td><td>压缩图片</td><td><code>progressive</code> JPEG 图像渐进式扫描；<code>interlaced</code> GIF 图像隔行扫描</td></tr><tr><td><a href="https://www.npmjs.com/package/gulp-rev" target="_blank" rel="noopener">gulp-rev</a></td><td>静态资源 hash</td><td>在实际生产环境中，我们页面引用的静态资源的文件名都是带版本号的（非覆盖式升级），这样方便版本管理（如更新与回滚）和防止缓存。通常我们使用文件的md5编码作为版本号，生成文件指纹。</td></tr><tr><td><a href="https://www.npmjs.com/package/gulp-less" target="_blank" rel="noopener">gulp-less</a></td><td>Less 文件编译</td><td>用于引入 Less 扩展 CSS 语言，提升前端样式的开发效率。</td></tr><tr><td><a href="https://www.npmjs.com/package/gulp-autoprefixer" target="_blank" rel="noopener">gulp-autoprefixer</a></td><td>根据所需兼容的浏览器版本，自动补全厂商前缀</td><td></td></tr><tr><td><a href="https://www.npmjs.com/package/gulp-css-base64/" target="_blank" rel="noopener">gulp-css-base64</a></td><td>将CSS 样式表中引用的图片和字体通过 base64 编码压缩合并到一起，减少文件请求数</td><td><code>maxWeightResource</code> 资源最大阈值，默认为 32K</td></tr><tr><td><a href="https://www.npmjs.com/package/gulp-ejs" target="_blank" rel="noopener">gulp-ejs</a></td><td>编译 HTML 中的 ejs 模板，可用于页面布局拆分，提升代码复用性</td><td><a href="http://ejs.co/" target="_blank" rel="noopener">http://ejs.co/</a></td></tr><tr><td><a href="https://www.npmjs.com/package/gulp-htmlmin" target="_blank" rel="noopener">gulp-htmlmin</a></td><td>压缩 HTML</td><td></td></tr><tr><td><a href="https://www.npmjs.com/package/gulp-inline-source" target="_blank" rel="noopener">gulp-inline-source</a></td><td>将 HTML 外部引用的样式和脚本以内联的方式嵌到 HTML 文件中，减少文件请求数</td><td></td></tr><tr><td><a href="https://www.npmjs.com/search?q=gulp-if" target="_blank" rel="noopener">gulp-if</a></td><td>编译时动态判断</td><td></td></tr><tr><td><a href="https://www.npmjs.com/package/gulp-replace" target="_blank" rel="noopener">gulp-replace</a></td><td>编译时动态替换字符串</td><td>可用于根据不同环境构建代码，解决各环境间的差异。例如正则匹配并全局替换 HTML 中的 <code>${web}</code> 变量。</td></tr><tr><td><a href="https://www.npmjs.com/package/gulp-tar" target="_blank" rel="noopener">gulp-tar</a></td><td>打包静态资源</td><td><a href="https://github.com/mafintosh/tar-stream" target="_blank" rel="noopener">tar-stream</a></td></tr><tr><td><a href="https://github.com/sanyueyu/gulp-mock-server" target="_blank" rel="noopener">gulp-mock-server</a></td><td>API Mock Server，前后端分离后的 API 模拟利器</td><td></td></tr><tr><td><a href="https://www.npmjs.com/package/browser-sync" target="_blank" rel="noopener">browser-sync</a></td><td>监听本地文件变化并同步刷新浏览器，提升开发效率的利器</td><td><a href="https://www.browsersync.io/" target="_blank" rel="noopener">https://www.browsersync.io/</a></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH 协议及其实现总结</title>
      <link href="2016/10/06/ssh/"/>
      <url>2016/10/06/ssh/</url>
      
        <content type="html"><![CDATA[<h1 id="连接协议对比"><a href="#连接协议对比" class="headerlink" title="连接协议对比"></a>连接协议对比</h1><p>常见的几种连接协议：</p><ul><li>SSH2（默认，相对于SSH1进行了加密算法的改进，使用最广泛）</li><li>SSH1</li><li>Telnet</li><li>Telnet/SSL</li><li>Rlogin</li><li>Serial</li><li>TAPI</li></ul><p>在出现 SSH 之前，系统管理员需要登入远程服务器执行系统管理任务时，都是用 <code>telnet</code> 来实现的，telnet 协议采用明文密码传送，在传送过程中对数据也不加密，很容易被不怀好意的人在网络上监听到密码。</p><p>同样，在 SSH 工具出现之前 R 系列命令也很流行（由于这些命令都以字母 r 开头，故把这些命令合称为 R 系列命令，R 是 remote 的意思），比如 <code>rexec</code> 是用来执行远程服务器上的命令的，和 <code>telnet</code> 的区别是 <code>telnet</code> 需要先登录远程服务器再实行相关的命令，而 R 系列命令可以把登录和执行命令并登出系统的操作整合在一起。这样就不需要为在远程服务器上执行一个命令而特地登录服务器了。</p><p>SSH 全称 Secure SHell，顾名思义就是非常安全的 shell 的意思，SSH 协议是 IETF（Internet Engineering Task Force） 的 Network Working Group 所制定的一种协议。SSH 的主要目的是用来<strong>取代传统的 telnet 和 R 系列命令</strong>（<code>rlogin</code>、<code>rsh</code>、<code>rexec</code> 等）远程登录和远程执行命令的工具，实现对远程登录和远程执行命令加密。防止由于网络监听而出现的密码泄漏，对系统构成威胁。</p><p>SSH 是一种加密协议，不仅在登录过程中对密码进行加密传送，而且对登录后执行的命令的数据也进行加密，这样即使别人在网络上监听并截获了你的数据包，他也看不到其中的内容。SSH 协议底层使用 TCP 协议，端口号 22。</p><h1 id="鉴权方式对比"><a href="#鉴权方式对比" class="headerlink" title="鉴权方式对比"></a>鉴权方式对比</h1><p>不同于 <code>telnet</code> 只支持 Password 密码鉴权，SSH 同时支持以下几种鉴权方式（Authentication）：</p><ul><li>Password（密码）</li><li><strong>Public Key</strong>（公钥）</li><li>Keyboard Interactive（键盘交互）</li><li>GSSAPI </li></ul><p>目前 SSH 最常用的鉴权方式有 Password 和 Public key 。Public Key 非对称（asymmetric）鉴权认证使用一对相关联的 Key Pair（一个公钥 Public Key，一个私钥 Private Key）来代替传统的密码（Password）。顾名思义，Public Key 是用来公开的，可以将其放到 SSH 服务器自己的帐号中，而 Private Key 只能由自己保管，用来证明自己身份。</p><p>使用 Public Key 加密过的数据只有用与之相对应的 Private Key 才能解密。这样在鉴权的过程中，Public Key 拥有者便可以通过 Public Key 加密一些东西发送给对应的 Private Key 拥有者，如果在通信的双方都拥有对方的 Public Key（自己的 Private Key 只由自己保管），那么就可以通过这对 Key Pair 来安全地交换信息，从而实现相互鉴权。</p><h1 id="OpenSSH"><a href="#OpenSSH" class="headerlink" title="OpenSSH"></a>OpenSSH</h1><p><a href="http://www.openssh.com/" target="_blank" rel="noopener">OpenSSH</a> 是 SSH 协议的<strong>免费开源实现</strong>。OpenSSH 套件由以下工具集组成：</p><p>远程操作工具：</p><ul><li><code>ssh</code>（替代 <code>telnet</code> 和 <code>rlogin</code>）</li><li><code>scp</code>（替代 <code>rcp</code>）</li><li><code>sftp</code>（替代 <code>ftp</code>）</li></ul><p>公私钥管理工具：</p><ul><li><code>ssh-add</code> Tool which adds private keys to the authentication agent.</li><li><code>ssh-keygen</code> Key generation tool.</li><li><code>ssh-keysign</code> Helper program for host-based authentication.</li><li><code>ssh-keyscan</code> Utility for gathering public host keys from a number of hosts.</li></ul><p>客户端工具：</p><ul><li><code>ssh-agent</code> An authentication agent that can store private keys.</li></ul><p>服务端工具：</p><ul><li><code>sshd</code> 一个运行于服务端的独立守护进程（standalone daemon）</li><li><code>sftp-server</code> SFTP 服务器</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>当管理的服务器较多时，ssh 远程需要频繁的输入用户名、密码、服务器 IP，操作非常繁琐，下面介绍一些命令结合配置以简化操作。</p><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><p><code>ssh</code> 命令用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh [-p port] [user@]hostname [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure><p>有时候输入 <code>ssh</code> 的参数繁琐，一旦服务器较多，要一个个记住并且敲入时非常低效。因此 <code>ssh</code> 提供了配置文件的方式简化命令行选项。<code>ssh</code> 依序从下列来源中获取配置，最先获取的值将优先使用：</p><ol><li>命令行选项（command-line options）</li><li>用户配置文件 <code>~/.ssh/config</code></li><li>系统配置文件 <code>/etc/ssh/ssh_config</code></li></ol><p>常用配置项如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host    别名</span><br><span class="line">    HostName        主机名</span><br><span class="line">    Port            端口</span><br><span class="line">    User            用户名</span><br><span class="line">    IdentityFile    密钥文件的路径</span><br></pre></td></tr></table></figure><p>通过配置，<code>ssh</code> 远程命令简化如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh 别名</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh pc2 /sbin/ifconfig</span><br></pre></td></tr></table></figure><p><code>pc2</code> 是从 <code>~/.ssh/config</code> 中获取的 hostname 别名。</p><h3 id="ssh-keygen"><a href="#ssh-keygen" class="headerlink" title="ssh-keygen"></a>ssh-keygen</h3><p>在使用 <code>ssh</code> 进行远程登录时，由于默认使用的是 Password 鉴权方式，因此每次登录都需要输入密码，操作麻烦。下面介绍使用 Public Key  鉴权方式实现<strong>免密登录</strong>。</p><p>一、创建一对公私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C who@<span class="built_in">where</span></span><br><span class="line">询问密码时，保持为空并回车</span><br></pre></td></tr></table></figure><p>二、启动 SSH 认证代理程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">eval</span> `ssh-agent`</span><br><span class="line">Agent pid 1760</span><br></pre></td></tr></table></figure><p>三、添加私钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~/.ssh/id_rsa</span><br><span class="line">Identity added: ~/.ssh/id_rsa</span><br><span class="line">$ ssh-add -l</span><br><span class="line">2048 8a:63:12:ae:b1:4c:be:03:e7:7f:92:3e:e5:44:56:bb ~/.ssh/id_rsa (RSA)</span><br></pre></td></tr></table></figure><p>四、将公钥上传到服务端，添加到<strong>被登录帐户</strong>的<strong>可信列表文件</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp ~/.ssh/id_rsa.pub who@<span class="built_in">where</span>:~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>五、修改服务端文件权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 700 ~/.ssh</span><br><span class="line">$ chmod 600 ~/.ssh/*</span><br></pre></td></tr></table></figure><p>之后再使用 <code>ssh</code> 登录时，客户端的 <code>ssh-agent</code> 会发送私钥去和服务端上的公钥做匹配，如果匹配成功就可以免密登录了。</p><h3 id="ssh-add"><a href="#ssh-add" class="headerlink" title="ssh-add"></a>ssh-add</h3><p><code>ssh-add</code> 命令常见用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">usage: ssh-add [options] [file ...]</span><br><span class="line">Options:</span><br><span class="line">  -l          List fingerprints of all identities.</span><br><span class="line">  -E <span class="built_in">hash</span>     Specify <span class="built_in">hash</span> algorithm used <span class="keyword">for</span> fingerprints.</span><br><span class="line">  -L          List public key parameters of all identities.</span><br><span class="line">  -k          Load only keys and not certificates.</span><br><span class="line">  -c          Require confirmation to sign using identities</span><br><span class="line">  -t life     Set lifetime (<span class="keyword">in</span> seconds) when adding identities.</span><br><span class="line">  -d          Delete identity.</span><br><span class="line">  -D          Delete all identities.</span><br><span class="line">  -x          Lock agent.</span><br><span class="line">  -X          Unlock agent.</span><br><span class="line">  -s pkcs11   Add keys from PKCS<span class="comment">#11 provider.</span></span><br><span class="line">  -e pkcs11   Remove keys provided by PKCS<span class="comment">#11 provider.</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add -D</span><br><span class="line">All identities removed.</span><br><span class="line"></span><br><span class="line">$ ssh-add -l</span><br><span class="line">The agent has no identities.</span><br></pre></td></tr></table></figure><p>参考：<a href="http://linux.101hacks.com/unix/ssh-add/" target="_blank" rel="noopener">http://linux.101hacks.com/unix/ssh-add/</a></p><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><p><code>scp</code> 命令常用参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r 递归复制（用以传输文件夹）</span><br><span class="line">-p 传输时保留文件权限及时间戳</span><br><span class="line">-C 传输时进行数据压缩</span><br></pre></td></tr></table></figure><p>可以结合 bash 的 <code>for</code> 循环实现批量 <code>scp</code> 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">HOST_IP=(<span class="string">'192.168.0.1'</span> <span class="string">'192.168.0.2'</span> <span class="string">'192.168.0.3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="variable">$&#123;HOST_IP[@]&#125;</span>  </span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    scp -rp /some/files <span class="variable">$&#123;ip&#125;</span>:/some/</span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h2><p>SSH 相关文件和配置：</p><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td>~/.ssh/id_rsa.pub</td><td>公钥（Public Key）</td></tr><tr><td>~/.ssh/id_rsa</td><td>私钥（Private Key）</td></tr><tr><td>~/.ssh/known_hosts</td><td>位于客户端的公钥列表文件，首次与目标主机建立 SSH 连接时，需要添加对方的公钥到这个文件以便后续通信</td></tr><tr><td>~/.ssh/authorized_keys</td><td>位于服务端的公钥列表文件，列出了所有被允许登录进来的可信公钥信息（Lists the public keys that are permitted for logging in）</td></tr><tr><td>~/.ssh/config</td><td>用户配置文件，可以通过 <code>man ssh_config</code> 命令查看帮助。</td></tr><tr><td>/etc/ssh/ssh_config</td><td>系统配置文件</td></tr></tbody></table><h1 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h1><p>批量 <code>scp</code> 的缺点是会全量同步，且删除行为无法同步，可以用 <code>rsync</code> 命令优化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">拉取：</span><br><span class="line">$ rsync [option...] [user@]host:src... [dest]</span><br><span class="line"></span><br><span class="line">推送：</span><br><span class="line">$ rsync [option...] src... [user@]host:dest</span><br></pre></td></tr></table></figure><p>如果双方都修改了同一文件的同一个地方，<code>rsync</code> 不管源和目标的修改时间谁先谁后，而是以源作为基准去覆盖目标文件。</p><p>常用参数：</p><ul><li><code>-a</code>：归档模式，等价于 <code>-rlptgoD</code>（不包括 <code>-H</code>, <code>-A</code>, <code>-X</code>）<ul><li><code>-r</code>, <code>--recursive</code>：递归遍历目录</li><li><code>-l</code>, <code>--links</code>：复制软链接（symbolic link, symlinks）</li><li><code>-p</code>, <code>--perms</code>：保留权限</li><li><code>-t</code>, <code>--times</code>：保留修改时间</li><li><code>-g</code>, <code>--group</code>：保留属组</li><li><code>-o</code>, <code>--owner</code>：保留属主</li><li><code>-D</code>：等价于：<ul><li><code>--devices</code>：保留设备文件</li><li><code>--specials</code>：保留特殊文件</li></ul></li></ul></li><li><code>-v</code>, <code>--verbose</code>：详细输出信息</li><li><code>-H</code>, <code>--hard-links</code>：保留硬链接（hard links）</li></ul><h2 id="批量-rsync"><a href="#批量-rsync" class="headerlink" title="批量 rsync"></a>批量 rsync</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">HOST_IP=(<span class="string">'192.168.0.1'</span> <span class="string">'192.168.0.2'</span> <span class="string">'192.168.0.3'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="variable">$&#123;HOST_IP[@]&#125;</span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">    rsync -avH --delete /some/* <span class="variable">$&#123;ip&#125;</span>:/some/</span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>进行如下文件操作测试：</p><ul><li>新增文件：web-banner-20170717.jpg</li><li>删除文件：web-banner-20170716.jpg</li></ul><p>从输出可见，只会增量同步并删除指定的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sending incremental file list</span><br><span class="line">resmarket&#x2F;static&#x2F;site&#x2F;v1&#x2F;img&#x2F;banner&#x2F;</span><br><span class="line">resmarket&#x2F;static&#x2F;site&#x2F;v1&#x2F;img&#x2F;banner&#x2F;web-banner-20170717.jpg</span><br><span class="line">deleting resmarket&#x2F;static&#x2F;site&#x2F;v1&#x2F;img&#x2F;banner&#x2F;web-banner-20170716.jpg</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="http://linux.101hacks.com/unix/ssh-add/" target="_blank" rel="noopener">5 Unix / Linux ssh-add Command Examples to Add SSH Key to Agent</a>》</p><p><a href="http://roclinux.cn/?p=2643" target="_blank" rel="noopener">《rsync同步的艺术》–linux命令五分钟系列之四十二</a></p><p>《<a href="https://www.jianshu.com/p/c6a7ffe01ac3" target="_blank" rel="noopener">ssh keygen 中生成的 randomart image 是什么</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端模块化框架 Require.js</title>
      <link href="2016/07/05/javascript-requirejs/"/>
      <url>2016/07/05/javascript-requirejs/</url>
      
        <content type="html"><![CDATA[<p>某段时期前端技术选型上使用过 Require.js 解决前端模块化的问题，下面整理了一些简单实践：</p><h1 id="Require-js-使用"><a href="#Require-js-使用" class="headerlink" title="Require.js 使用"></a>Require.js 使用</h1><p>第一步，按功能将 JS 分门别类：</p><ul><li>dist/</li><li>app/<ul><li>js/<ul><li>require_config.js</li><li>entry/<ul><li>main.js</li></ul></li><li>module/<ul><li>sub.js</li></ul></li><li>lib/<ul><li>require.js</li><li>zepto.js</li></ul></li><li>util/</li></ul></li><li>css/</li><li>img/</li><li>……</li></ul></li></ul><table><thead><tr><th>本地路径</th><th>功能描述</th></tr></thead><tbody><tr><td>js/entry</td><td>各功能主模块（主入口）</td></tr><tr><td>js/module</td><td>各功能子模块</td></tr><tr><td>js/lib</td><td>第三方库</td></tr><tr><td>js/util</td><td>自定义库</td></tr></tbody></table><p>第二步，参考《<a href="https://github.com/requirejs/requirejs/wiki/Patterns-for-separating-config-from-the-main-module" target="_blank" rel="noopener">Patterns for separating config from the main module</a>》将 RequireJS 配置项从各功能主模块中剥离出来，放到 <code>js/require_config.js</code> 统一管理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义 RequireJS 全局配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">require</span> = &#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        mod: <span class="string">'/contextpath/js/module'</span>,</span><br><span class="line">        wgt: <span class="string">'/contextpath/js/widget'</span></span><br><span class="line">        lib: <span class="string">'/contextpath/js/lib'</span>,</span><br><span class="line">        util: <span class="string">'/contextpath/js/util'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第三步，在页面中引入配置文件及入口文件，注意先后顺序：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 先注册配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/require_config.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 然后引入 require.js ，并载入主模块 main.js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/lib/require.js"</span> <span class="attr">data-main</span>=<span class="string">"js/entry/main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第四步，使用 <code>define()</code> 函数编写子模块 <code>js/module/sub.js</code>。引入所需的模块，如 zepto：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子模块依赖 zepto</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">define([<span class="string">'lib/zepto'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>第五步，使用 <code>require()</code> 函数编写主模块 <code>js/entry/main.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主模块依赖 sub.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'mod/sub'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过 AMD 规范定义的两个关键函数 <code>define()</code> 和 <code>require()</code> ，我们可以很轻松的在老版本 ES5 上实现模块化功能，解决依赖关系混乱和全局变量的问题。</p><h1 id="Require-js-构建"><a href="#Require-js-构建" class="headerlink" title="Require.js 构建"></a>Require.js 构建</h1><p>需要注意的是，模块拆分之后脚本文件数量会变多，HTTP 请求也会相应增多。使用 RequireJS 的<a href="http://www.requirejs.org/docs/optimization.html" target="_blank" rel="noopener">优化工具</a> <code>r.js</code> 合并压缩相关联的脚本文件，可以解决这个问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>JavaScript 模块化技术的起源：《<a href="http://yuiblog.com/blog/2007/06/12/module-pattern/" target="_blank" rel="noopener">A JavaScript Module Pattern</a>》</p><p>JavaScript 模块化技术的一些高级特性：《<a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="noopener">JavaScript Module Pattern: In-Depth</a>》（<a href="http://blog.csdn.net/flybywind/article/details/8095724" target="_blank" rel="noopener">中文版</a>）</p><p>RequireJS 的一些入门用法参考：</p><ul><li>《<a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="noopener">Javascript模块化编程（一）：模块的写法</a>》</li><li>《<a href="http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html" target="_blank" rel="noopener">Javascript模块化编程（二）：AMD规范</a>》</li><li>《<a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html" target="_blank" rel="noopener">Javascript模块化编程（三）：require.js的用法</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC 入门教程</title>
      <link href="2016/06/25/spring-mvc/"/>
      <url>2016/06/25/spring-mvc/</url>
      
        <content type="html"><![CDATA[<p>一张图简要描述 Spring MVC 的处理流程：</p><p><img src="/img/spring/spring-mvc.png" alt="Spring MVC"></p><ul><li>Spring MVC 的核心前端控制器 <code>DispatcherServlet</code> 接收 HTTP 请求并询问 <code>Handler mapping</code> 该请求应该转发到哪个 <code>Controller</code> 方法。</li><li><code>Controller</code> 业务处理完毕，返回 <em>逻辑视图名(通常是一个字符串)</em> 。</li><li>最后 <code>viewResolver</code> 解析逻辑视图名并返回相应的 <code>View</code>，如 JSP、FreeMarker。</li></ul><h1 id="实现一个-Controller"><a href="#实现一个-Controller" class="headerlink" title="实现一个 Controller"></a>实现一个 Controller</h1><p>下面介绍编写控制器过程中常用的注解：</p><h2 id="定义一个控制器"><a href="#定义一个控制器" class="headerlink" title="定义一个控制器"></a>定义一个控制器</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><p>Traditional MVC controller relying on a <a href="https://spring.io/understanding/view-templates" target="_blank" rel="noopener">view technology</a> to perform server-side rendering.</p><h3 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h3><p>RESTful web service controller simply populates and returns a object that will be written directly to the HTTP response as JSON. Thanks to Spring’s HTTP message converter support, you don’t need to do this conversion manually. Because <a href="http://wiki.fasterxml.com/JacksonHome" target="_blank" rel="noopener">Jackson 2</a> is on the classpath, Spring’s <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/converter/json/MappingJackson2HttpMessageConverter.html" target="_blank" rel="noopener"><code>MappingJackson2HttpMessageConverter</code></a> is automatically chosen to convert the object to JSON.</p><p>It’s shorthand for <code>@Controller</code> and <code>@ResponseBody</code> rolled together. </p><h2 id="映射请求"><a href="#映射请求" class="headerlink" title="映射请求"></a>映射请求</h2><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><p><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestMapping.html" target="_blank" rel="noopener"><code>@RequestMapping</code></a> 用于将 HTTP 请求映射到指定的 <code>Controller</code> 类或方法。</p><p>一、可匹配的请求属性如下：</p><ul><li><code>value</code> 用于匹配指定的请求路径，例如：<code>value = &quot;/index&quot;</code>。</li><li><code>method</code> 用于匹配指定的请求方法，例如：<code>method = RequestMethod.POST</code>。</li><li><code>consumes</code> 用于匹配指定的请求头 <code>Content-Type</code>，例如：<code>consumes = MediaType.APPLICATION_JSON_UTF8_VALUE</code>。</li><li><code>produces</code> 用于匹配指定的请求头 <code>Accept</code>，例如：<code>produces = MediaType.APPLICATION_JSON_UTF8_VALUE</code>。</li><li><code>params</code> 用于匹配指定的请求参数，例如：<ul><li>匹配存在：<code>params = &quot;myParam&quot;</code></li><li>匹配不存在：<code>params = &quot;!myParam&quot;</code></li><li>匹配指定参数值：<code>params = &quot;myParam=myValue&quot;</code> </li></ul></li><li><code>headers</code> 用于匹配指定的请求头，例如：<ul><li>匹配存在：<code>headers = &quot;myHeader&quot;</code></li><li>匹配不存在：<code>headers = &quot;!myHeader&quot;</code></li><li>匹配指定值：<code>headers = &quot;myHeader=myValue&quot;</code></li></ul></li></ul><p>尽管你可以使用媒体类型通配符（例如：<code>content-type=text/*</code> 或 <code>accept=xxx</code>）去匹配 <code>Content-Type</code> 或 <code>Accept</code> 请求头，但还是更推荐使用 <code>consumes</code> 或 <code>produces</code> 属性。因为它们专门用于此目的。</p><p>二、Spring Framework 4.3 还引入了五个等价的变体注解，相当于 <code>@RequestMapping</code> 注解与 <code>method</code> 属性的组合使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping</span><br><span class="line">@PostMapping</span><br><span class="line">@PutMapping</span><br><span class="line">@DeleteMapping</span><br><span class="line">@PatchMapping</span><br></pre></td></tr></table></figure><p>三、标注了 <code>@RequestMapping</code> 注解的方法可以拥有非常灵活的方法签名。支持以下参数类型/注解、返回类型/注解：</p><h2 id="方法参数类型"><a href="#方法参数类型" class="headerlink" title="方法参数类型"></a>方法参数类型</h2><p><code>@RequestMapping</code> 注解的方法，参数可以是下列任一类型：</p><h3 id="Request-Response"><a href="#Request-Response" class="headerlink" title="Request / Response"></a>Request / Response</h3><p>用于访问当前 <code>javax.servlet.http.HttpServletRequest</code> / <code>javax.servlet.http.HttpServletResponse</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    request.getHeader(<span class="string">"host"</span>); <span class="comment">// 读取指定 HTTP 请求头</span></span><br><span class="line">    response.getWriter().write(<span class="string">"hello world"</span>); <span class="comment">// 浏览器将会显示：hello world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这类方法参数有点类似于传统的 Servlet 编程。</p><h3 id="InputStream-Reader"><a href="#InputStream-Reader" class="headerlink" title="InputStream / Reader"></a>InputStream / Reader</h3><p>用于访问当前请求内容的 <code>java.io.InputStream</code> / <code>java.io.Reader</code></p><h3 id="OutputStream-Writer"><a href="#OutputStream-Writer" class="headerlink" title="OutputStream / Writer"></a>OutputStream / Writer</h3><p>用于生成当前响应内容的 <code>java.io.OutputStream</code> / <code>java.io.Writer</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">(Writer writer)</span> </span>&#123;</span><br><span class="line">    writer.write(<span class="string">"hello world"</span>); <span class="comment">// 浏览器将会显示：hello world</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>用于访问当前 <code>javax.servlet.http.HttpSession</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">(HttpSession session)</span> </span>&#123;</span><br><span class="line">    session.getAttribute(<span class="string">"xxx"</span>); <span class="comment">// 读取指定 Session 值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HttpEntity-lt-gt"><a href="#HttpEntity-lt-gt" class="headerlink" title="HttpEntity&lt;?&gt;"></a>HttpEntity&lt;?&gt;</h3><p><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/HttpEntity.html" target="_blank" rel="noopener"><code>HttpEntity&lt;?&gt;</code></a> 用于同时访问 <em>HTTP 请求头和请求体（HTTP request headers and contents）</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">(HttpEntity&lt;String&gt; httpEntity)</span> </span>&#123;</span><br><span class="line">    String body = httpEntity.getBody();</span><br><span class="line">    HttpHeaders headers = httpEntity.getHeaders();</span><br><span class="line">    String host = headers.getFirst(<span class="string">"host"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-Model-ModelMap"><a href="#Map-Model-ModelMap" class="headerlink" title="Map / Model / ModelMap"></a>Map / Model / ModelMap</h3><p><code>Map</code> / <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/ui/Model.html" target="_blank" rel="noopener"><code>Model</code></a> / <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/ui/ModelMap.html" target="_blank" rel="noopener"><code>ModelMap</code></a> 用于在 <code>Controller</code> 层填充将会暴露给 <code>View</code> 层的 <code>Model</code> 对象。</p><h2 id="方法参数注解"><a href="#方法参数注解" class="headerlink" title="方法参数注解"></a>方法参数注解</h2><p>尽管使用常规类型的方法参数更接近于人们所熟悉的传统 Servlet 编程，但在 Spring 编程中却不建议这么做。因为这样会导致 JavaBean 与 Servlet 容器耦合，侵入性强，难以进行单元测试（如 Mock 测试）。最佳实践应当是传入注解后被解析好的数据类型，下面介绍这些常用的注解：</p><h3 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h3><p><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/PathVariable.html" target="_blank" rel="noopener"><code>@PathVariable</code></a> 用于标注某个方法参数与某个 <em>URI 模板变量（URI template variable）</em> 的绑定关系，常用于 <em>RESTful URL</em>，例如 <code>/hotels/{hotel}</code>。</p><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestParam.html" target="_blank" rel="noopener"><code>@RequestParam</code></a> 用于标注某个方法参数与某个 <em>HTTP 请求参数（HTTP request parameter）</em> 的绑定关系。</p><p>使用时需要注意 <code>required</code> 这个属性：</p><ul><li>方法参数不写 <code>@RequestParam</code>，默认的 <code>required</code> 为 <code>false</code></li><li>方法参数写了 <code>@RequestParam</code>，默认的 <code>required</code> 为 <code>true</code></li><li>方法参数同时写了 <code>@RequestParam</code> + <code>defaultValue</code>，默认的 <code>required</code> 为 <code>false</code></li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;test HTTP&#x2F;1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">data&#x3D;123,234</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;test?data&#x3D;123,234 HTTP&#x2F;1.1</span><br><span class="line">Host: localhost:8080</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(@RequestParam(<span class="string">"data"</span>)</span> String data) </span>&#123;</span><br><span class="line">    log.info(data);  <span class="comment">// 123, 234</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Type conversion is applied automatically if the target method parameter type is not String. See the section called “<a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#mvc-ann-typeconversion" target="_blank" rel="noopener">Method Parameters And Type Conversion</a>”.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(@RequestParam(<span class="string">"data"</span>)</span> ArrayList&lt;String&gt; data) </span>&#123;</span><br><span class="line">    log.info(data.toString());  <span class="comment">// 123, 234</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When an <code>@RequestParam</code> annotation is used on a <code>Map&lt;String, String&gt;</code> or <code>MultiValueMap&lt;String, String&gt;</code> argument, the map is populated with all request parameters.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(@RequestParam(<span class="string">"data"</span>)</span> Map&lt;String, String&gt; data) </span>&#123;</span><br><span class="line">    log.info(data.get(<span class="string">"data"</span>));  <span class="comment">// 123, 234</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><p><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestBody.html" target="_blank" rel="noopener"><code>@RequestBody</code></a> 用于标注某个方法参数与某个 <em>HTTP 请求体（HTTP request body）</em> 的绑定关系。 <code>@RequestBody</code> 会调用合适的 <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/converter/HttpMessageConverter.html" target="_blank" rel="noopener">message converters</a> 将 <em>HTTP 请求体（HTTP request body）</em> 写入指定对象，默认的 `HttpMessageConverter 如下：</p><ul><li><code>ByteArrayHttpMessageConverter</code> converts byte arrays.</li><li><code>StringHttpMessageConverter</code> converts strings.</li><li><code>FormHttpMessageConverter</code> converts form data to/from a MultiValueMap&lt;String, String&gt;.</li><li><code>SourceHttpMessageConverter</code> converts to/from a javax.xml.transform.Source.</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;test HTTP&#x2F;1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Content-Type: application&#x2F;json</span><br><span class="line"></span><br><span class="line">[&quot;123&quot;, &quot;234&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(@RequestBody List&lt;String&gt; data)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>An <code>@RequestBody</code> method parameter can be annotated with <code>@Valid</code>, in which case it will be validated using the configured <code>Validator</code> instance. When using the MVC namespace or the MVC Java config, a JSR-303 validator is configured automatically assuming a JSR-303 implementation is available on the classpath.</p><h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h3><p><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestHeader.html" target="_blank" rel="noopener"><code>@RequestHeader</code></a> 用于标注某个方法参数与某个 <em>HTTP 请求头（HTTP request header）</em> 的绑定关系。</p><h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h3><p><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/CookieValue.html" target="_blank" rel="noopener"><code>@CookieValue</code></a> 用于标注某个方法参数与某个 <em>HTTP cookie</em> 的绑定关系。方法参数可以是 <code>javax.servlet.http.Cookie</code>，也可以是具体的 Cookie 值（如字符串、数字类型等）。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">getEmployeeBy</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    @RequestParam(<span class="string">"name"</span>)</span> String name, </span></span><br><span class="line"><span class="function">    @<span class="title">RequestHeader</span><span class="params">(<span class="string">"host"</span>)</span> String host, </span></span><br><span class="line"><span class="function">    @RequestBody String body) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="方法参数验证"><a href="#方法参数验证" class="headerlink" title="方法参数验证"></a>方法参数验证</h2><p>Spring MVC 可以快速整合 JSR 303 - Bean Validation 实现方法参数校验，用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(@Validated RequestVO request, BindingResult bindingResult)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bindingResult.hasErrors()) &#123;</span><br><span class="line">        String errMsg = bindingResult.getAllErrors().stream()</span><br><span class="line">                .map(DefaultMessageSourceResolvable::getDefaultMessage)</span><br><span class="line">                .collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用到：</p><p><code>org.springframework.validation.annotation.Validated</code> 注解</p><p><code>org.springframework.validation.BindingResult</code> 接口</p><p>参考：</p><p>《<a href="https://blog.csdn.net/VagueCoder/article/details/48398517" target="_blank" rel="noopener">Spring4新特性——集成Bean Validation 1.1(JSR-349)到SpringMVC</a>》</p><h2 id="方法返回类型"><a href="#方法返回类型" class="headerlink" title="方法返回类型"></a>方法返回类型</h2><p><code>@RequestMapping</code> 注解的方法，返回类型可以是下列任一常规类型：</p><h3 id="HttpEntity-lt-gt-1"><a href="#HttpEntity-lt-gt-1" class="headerlink" title="HttpEntity&lt;?&gt;"></a>HttpEntity&lt;?&gt;</h3><p><code>org.springframework.http.HttpEntity</code></p><p>Represents an HTTP request or response entity, consisting of headers and body.</p><p>Typically used in combination with the <code>RestTemplate</code>, like so:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">headers.setContentType(MediaType.TEXT_PLAIN);</span><br><span class="line">HttpEntity&lt;String&gt; entity = <span class="keyword">new</span> HttpEntity&lt;String&gt;(helloWorld, headers);</span><br><span class="line">URI location = template.postForLocation(<span class="string">"http://example.com"</span>, entity);</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HttpEntity&lt;String&gt; entity = template.getForEntity(<span class="string">"http://example.com"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">String body = entity.getBody();</span><br><span class="line">MediaType contentType = entity.getHeaders().getContentType();</span><br></pre></td></tr></table></figure><p>Can also be used in Spring MVC, as a return value from a <code>@Controller</code> method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/handle"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpEntity&lt;String&gt; <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  HttpHeaders responseHeaders = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">  responseHeaders.set(<span class="string">"MyResponseHeader"</span>, <span class="string">"MyValue"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HttpEntity&lt;String&gt;(<span class="string">"Hello World"</span>, responseHeaders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ResponseEntity-lt-gt"><a href="#ResponseEntity-lt-gt" class="headerlink" title="ResponseEntity&lt;?&gt;"></a>ResponseEntity&lt;?&gt;</h3><p><code>org.springframework.http.ResponseEntity</code></p><p>Extension of <code>HttpEntity</code> that adds a <code>HttpStatus</code> status code. Used in <code>RestTemplate</code> as well <code>@Controller</code> methods.</p><p>In <code>RestTemplate</code>, this class is returned by <code>getForEntity()</code> and <code>exchange()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ResponseEntity&lt;String&gt; entity = template.getForEntity(<span class="string">"http://example.com"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">String body = entity.getBody();</span><br><span class="line">MediaType contentType = entity.getHeaders().getContentType();</span><br><span class="line">HttpStatus statusCode = entity.getStatusCode();</span><br></pre></td></tr></table></figure><p>Can also be used in Spring MVC, as the return value from a <code>@Controller</code> method:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/handle"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  URI location = ...;</span><br><span class="line">  HttpHeaders responseHeaders = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">  responseHeaders.setLocation(location);</span><br><span class="line">  responseHeaders.set(<span class="string">"MyResponseHeader"</span>, <span class="string">"MyValue"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;String&gt;(<span class="string">"Hello World"</span>, responseHeaders, HttpStatus.CREATED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Or, by using a builder accessible via static methods:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/handle"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  URI location = ...;</span><br><span class="line">  <span class="keyword">return</span> ResponseEntity.created(location).header(<span class="string">"MyResponseHeader"</span>, <span class="string">"MyValue"</span>).body(<span class="string">"Hello World"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><p><code>org.springframework.web.servlet.ModelAndView</code></p><p>Holder for both Model and View in the web MVC framework.</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>表示直接返回视图名。</p><h2 id="方法返回注解"><a href="#方法返回注解" class="headerlink" title="方法返回注解"></a>方法返回注解</h2><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>用于标注某个方法返回值与 <em>WEB 响应体（response body）</em> 的绑定关系。 <code>@ResponseBody</code> 会跳过 <code>ViewResolver</code> 部分，调用合适的 <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/converter/HttpMessageConverter.html" target="_blank" rel="noopener">message converters</a>，将方法返回值作为 <em>WEB 响应体（response body）</em> 写入输出流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ResponseStatus"><a href="#ResponseStatus" class="headerlink" title="@ResponseStatus"></a>@ResponseStatus</h3><p><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/ResponseStatus.html" target="_blank" rel="noopener"><code>@ResponseStatus</code></a> 用于返回 HTTP 响应码，例如返回 404：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line"><span class="meta">@ResponseStatus</span>(value = HttpStatus.NOT_FOUND, reason = <span class="string">"找不到网页"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="视图处理"><a href="#视图处理" class="headerlink" title="视图处理"></a>视图处理</h1><h1 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h1><p>Classes annotated with <code>@ControllerAdvice</code> can contain <code>@ExceptionHandler</code>, <code>@InitBinder</code>, and <code>@ModelAttribute</code> annotated methods, and these methods will apply to <code>@RequestMapping</code> methods across all controller hierarchies as opposed to the controller hierarchy within which they are declared.</p><p><code>@RestControllerAdvice</code> is an alternative where <code>@ExceptionHandler</code> methods assume <code>@ResponseBody</code> semantics by default.</p><p>Both <code>@ControllerAdvice</code> and <code>@RestControllerAdvice</code> can target a subset of controllers:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Target all Controllers annotated with @RestController</span><br><span class="line">@ControllerAdvice(annotations &#x3D; RestController.class)</span><br><span class="line">public class AnnotationAdvice &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Target all Controllers within specific packages</span><br><span class="line">@ControllerAdvice(&quot;org.example.controllers&quot;)</span><br><span class="line">public class BasePackageAdvice &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Target all Controllers assignable to specific classes</span><br><span class="line">@ControllerAdvice(assignableTypes &#x3D; &#123;ControllerInterface.class, AbstractController.class&#125;)</span><br><span class="line">public class AssignableTypesAdvice &#123;&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(Throwable<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">ResponseEntity</span>&lt;<span class="title">String</span>&gt; <span class="title">handleException</span>(<span class="title">Throwable</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">        log.error(e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;&gt;(e.getMessage(), HttpStatus.valueOf(<span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CORS-支持"><a href="#CORS-支持" class="headerlink" title="CORS 支持"></a>CORS 支持</h1><h1 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="https://spring.io/guides/gs/serving-web-content/" target="_blank" rel="noopener">Serving Web Content with Spring MVC</a>》</p><p>《<a href="https://spring.io/guides/gs/rest-service/" target="_blank" rel="noopener">Building a RESTful Web Service</a>》</p><p>《<a href="https://spring.io/guides/gs/rest-service-cors/" target="_blank" rel="noopener">Enabling Cross Origin Requests for a RESTful Web Service</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 事件委托机制</title>
      <link href="2016/05/22/javascript-event-delegation/"/>
      <url>2016/05/22/javascript-event-delegation/</url>
      
        <content type="html"><![CDATA[<p>本文目的：</p><ul><li>能够理解事件绑定和事件委托两种机制的区别</li><li>能够使用原生 API 和 jQuery API 两种方式进行事件委托</li></ul><h1 id="Native-API"><a href="#Native-API" class="headerlink" title="Native API"></a>Native API</h1><p>项目开发时遇到一个需求：修改页面中所有 <code>A</code> 链接的默认行为。</p><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><p>最开始想到了用“事件绑定”机制进行实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> showMessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 阻止 A 链接的默认行为（不进行跳转）</span></span><br><span class="line">        event.preventDefault();</span><br><span class="line">        <span class="comment">// 仅弹窗显示链接的 href 属性</span></span><br><span class="line">        alert(event.currentTarget.href);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> links = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; links.length; i++) &#123;</span><br><span class="line">    links[i].addEventListener(<span class="string">'click'</span>, showMessage, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法的问题是：如果页面中绑定了大量的事件处理程序，将直接影响页面的整体运行性能，因为：</p><ol><li>函数即对象，对象越多，越占用内存，性能就越差。</li><li>事件绑定前，必须先找到指定的 DOM 元素。而 DOM 元素查找次数越多，页面的交互就绪时间就越长。</li></ol><p>更麻烦的是，如果页面加载完后再次插入新元素，需要再次绑定事件处理程序，灵活性差：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newLink = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">newLink.innerHTML = <span class="string">'Click Me'</span>;</span><br><span class="line">newLink.href = <span class="string">'http://localhost'</span>;</span><br><span class="line">newLink.addEventListener(<span class="string">'click'</span>, showMessage, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(newLink);</span><br></pre></td></tr></table></figure><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>利用事件委托机制可以同时解决上述两个问题。只需在 DOM 树中尽量最高的层次上添加一个事件处理程序，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> showMessage = <span class="function"><span class="keyword">function</span>(<span class="params">event, target</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 阻止 A 链接的默认行为（不进行跳转）</span></span><br><span class="line">        event.preventDefault();</span><br><span class="line">        <span class="comment">// 仅弹窗显示链接的 href 属性</span></span><br><span class="line">        alert(target.href);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 递归查询指定父元素</span></span><br><span class="line">    findTarget = <span class="function"><span class="keyword">function</span>(<span class="params">target, tagName</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (target.tagName &amp;&amp; target.tagName !== tagName.toUpperCase()) &#123;</span><br><span class="line">            target = target.parentNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (target.tagName &amp;&amp; target.tagName === tagName.toUpperCase()) ? target : <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 间接判断 A 链接是否被点击</span></span><br><span class="line">    <span class="keyword">var</span> target = findTarget(event.target, <span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">if</span> (target) &#123;</span><br><span class="line">        showMessage(event, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>由于所有 <code>A</code> 链接都是 <code>body</code> 元素的子节点，并且它们的事件都会冒泡，因此点击事件最终会被 <code>body</code> 上添加的事件处理程序所处理。代码重构后在以下方面提升了页面性能：</p><ul><li>由于 <code>document</code> 对象很快就可以访问，而且可以在页面生命周期的任何时点上为它添加事件处理程序（无需等待 <code>DOMContentLoaded</code> 或 <code>load</code> 事件），因此只要可点击的元素呈现在页面上，就可以立即具备适当的功能。</li><li>由于只添加一个事件处理程序，因此所需的 DOM 引用更少，整个页面占用的内存空间也更少。</li></ul><p>此外，事件会关联到当前以及以后添加的子元素上面，可以避免反复为新元素绑定事件处理程序，可谓一劳永逸。</p><h1 id="jQuery-API"><a href="#jQuery-API" class="headerlink" title="jQuery API"></a>jQuery API</h1><p>理解了两种机制的区别后，看看如何使用 jQuery 进行最快的实现：</p><h2 id="on"><a href="#on" class="headerlink" title="on()"></a>on()</h2><p>jQuery 1.7+ 推出了 <code>on()</code> 方法，其目的有两个：</p><ol><li><p>统一接口</p></li><li><p>提高性能</p></li></ol><p>用法如下：</p><ul><li>事件绑定：<code>on(events,[data],fn)</code> ，用于替换 <code>bind()</code></li><li>事件委托：<code>on(events,[selector],[data],fn)</code>  ，用于替换 <code>live()</code> 、 <code>delegate()</code> 。这里的 <code>[selector]</code> 参数很关键，起到了一个过滤器的效果，只有被选中元素的 <strong>子元素</strong> 才会触发事件。</li></ul><p>用 <code>on()</code> 方法重构后的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'body'</span>).on(<span class="string">'click'</span>, <span class="string">'a'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    alert(event.currentTarget.href);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可见，代码重构后非常简洁，推荐使用。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《<a href="http://www.jb51.net/article/36064.htm" target="_blank" rel="noopener">关于jQuery新的事件绑定机制on()的使用技巧</a>》</li><li>《<a href="http://www.diguage.com/archives/71.html" target="_blank" rel="noopener">实例分析JavaScript中的事件委托和事件绑定</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 事件绑定机制</title>
      <link href="2016/05/08/javascript-event-binding/"/>
      <url>2016/05/08/javascript-event-binding/</url>
      
        <content type="html"><![CDATA[<p>本文目的：</p><ul><li>理解并能按需使用各种事件绑定 API</li><li>理解事件对象</li><li>理解事件流</li></ul><h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><p>事件是用户或浏览器自身执行的某种动作，例如 <code>onclick</code> 、 <code>onload</code> ，都是事件的名字。而响应某个事件的函数就叫做 <strong>事件处理程序（Event Handlers）</strong>。为事件绑定处理程序的方式有以下几种：</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>做法：在 HTML 元素中直接编写事件处理程序：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 输出“Clicked” —— 事件处理程序中，可以直接编写 JavaScript 代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert('Clicked')"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 输出“click” —— 事件处理程序中，可以直接访问事件对象 event --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert('event.type')"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 输出“Click Me” —— 事件处理程序中，this 指向事件的目标元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert('this.value')"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>其中除了可以编写 JavaScript 代码，还可以调用外部脚本：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"showMessage()"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">showMessage</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">"Hello world!"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>特点：上述 <code>onclick</code> 事件将自动产生一个事件处理程序（函数），例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onclick</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Clicked'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：简单、粗暴，浏览器兼容性好。</p><p>缺点：</p><ul><li>存在时差问题。用户可能会在 HTML 元素一出现在页面上时，就触发相应事件，但当时的事件处理程序有可能还未具备执行条件（例如事件处理程序所在的外部脚本文件还未加载或解析完毕），此时会引发 <code>undefined</code> 错误。</li></ul><ul><li>HTML 与 JavaScript 代码紧密耦合。如果要重命名事件处理程序，就要改动两个地方，容易改漏、改错。</li></ul><h2 id="DOM-Level-0"><a href="#DOM-Level-0" class="headerlink" title="DOM Level 0"></a>DOM Level 0</h2><p>做法：首先获取目标 HTML 元素的引用，然后将一个事件处理程序赋值给其指定的事件属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">'btn'</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 绑定事件处理程序</span></span></span><br><span class="line"><span class="actionscript">    btn.onclick = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">'Clicked'</span>);</span></span><br><span class="line"><span class="actionscript">        alert(<span class="keyword">this</span>.id);    <span class="comment">// 输出“myDiv” —— this 指向事件的目标元素</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 删除事件处理程序</span></span></span><br><span class="line"><span class="actionscript">    btn.onclick = <span class="literal">null</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>特点：本质上，DOM 0级事件处理程序 <strong>等于</strong> HTML 事件处理程序，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">'btn'</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> <span class="attr">onclick</span>=<span class="string">"alert('Clicked')"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span></span><br><span class="line"><span class="actionscript">        alert(<span class="keyword">typeof</span> btn.onclick);    <span class="comment">// 通过 HTML 的事件属性，访问其 HTML 事件处理程序，并输出其类型“function”</span></span></span><br><span class="line"><span class="actionscript">        btn.onclick = <span class="literal">null</span>;    <span class="comment">// 几秒后，将会删除该按钮的事件处理程序</span></span></span><br><span class="line">    &#125;, 3000);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>传统、常用、浏览器兼容性好。</li><li>解决了 HTML 事件处理程序的两个缺点。</li></ul><p>缺点：一个事件只能绑定唯一一个事件处理程序。</p><h2 id="DOM-Level-2"><a href="#DOM-Level-2" class="headerlink" title="DOM Level 2"></a>DOM Level 2</h2><p>做法：目前最主流的写法，可以支持事件冒泡或捕获：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> id=<span class="string">'btn'</span> value=<span class="string">"Click Me"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>),</span><br><span class="line">        showMessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">'Clicked'</span>);</span><br><span class="line">            alert(<span class="keyword">this</span>.id);    <span class="comment">// 输出“myDiv” —— this 指向事件的目标元素</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定事件处理程序。false 表示在“冒泡阶段”和“目标阶段”触发</span></span><br><span class="line">    btn.addEventListener(<span class="string">'click'</span>, showMessage, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除事件处理程序。注意，匿名函数无法移除</span></span><br><span class="line">    btn.removeEventListener(<span class="string">'click'</span>, showMessage, <span class="literal">false</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>优点：一个事件可以绑定多个事件处理程序，以绑定的顺序执行。</p><p>缺点：浏览器兼容性差，IE8 及以下版本不支持。</p><p>API：<code>element.addEventListener(event, function, useCapture)</code> 。其中 <code>useCapture</code> 可选，布尔值，指定事件是否在捕获或冒泡阶段执行：</p><ul><li><code>true</code> 捕获阶段执行</li><li><code>false</code> 冒泡阶段执行（默认值）</li></ul><h2 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h2><p>IE 实现了与 DOM 2 级类似的两个方法，只支持事件冒泡：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> id=<span class="string">'btn'</span> value=<span class="string">"Click Me"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>),</span><br><span class="line">        showMessage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            alert(<span class="string">'Clicked'</span>);</span><br><span class="line">            alert(<span class="keyword">this</span> === <span class="built_in">window</span>);    <span class="comment">// 输出“true” —— 注意 this 指向 window</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定事件处理程序。仅在“冒泡阶段”和“目标阶段”触发</span></span><br><span class="line">    btn.attachEvent(<span class="string">'onclick'</span>, showMessage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除事件处理程序。注意，匿名函数无法移除</span></span><br><span class="line">    btn.detachEvent(<span class="string">'onclick'</span>, showMessage);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>优点：一个事件可以绑定多个事件处理程序，以绑定的顺序 <strong>逆序</strong> 执行。</p><p>缺点：浏览器兼容性差，仅支持 IE 及 Opera。</p><h2 id="Cross-Browser"><a href="#Cross-Browser" class="headerlink" title="Cross-Browser"></a>Cross-Browser</h2><p>鉴于上述几种方式的各有优劣，为了以跨浏览器的方式处理事件，可以定义自己的  <code>EventUtil</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line"></span><br><span class="line">    addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (element.addEventListener)&#123;</span><br><span class="line">            element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent)&#123;</span><br><span class="line">            element.attachEvent(“on” + type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[“on” + type] = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (element.removeEventListener)&#123;</span><br><span class="line">            element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent)&#123;</span><br><span class="line">            element.detachEvent(“on” + type, handler);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            element[“on” + type] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h1><p>在触发 DOM 上的某个事件时，会产生一个事件对象 <code>event</code> ，这个对象中包含着所有与事件有关的信息。尽管触发的事件类型不同，可用属性和方法也会不同，但是所有事件都会包含下列常用成员：</p><table><thead><tr><th>DOM Level 2</th><th>Type</th><th>IE</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><code>type</code></td><td>String</td><td><code>type</code></td><td>String</td><td>被触发的事件类型</td></tr><tr><td><code>eventPhase</code></td><td>Integer</td><td>-</td><td>-</td><td>调用事件处理程序的所处阶段：<code>1</code> 表示捕获阶段，<code>2</code> 表示“处于目标”，<code>3</code> 表示冒泡阶段</td></tr><tr><td><code>target</code></td><td>Element</td><td><code>srcElement</code></td><td>Element</td><td>事件的目标元素</td></tr><tr><td><code>currentTarget</code></td><td>Element</td><td>-</td><td>-</td><td>当前正在处理事件的元素。如果事件处于目标元素，则 <code>this === currentTarget === target</code></td></tr><tr><td><code>stopPropagation()</code></td><td>Function</td><td><code>cancelBubble</code></td><td>Boolean</td><td>取消事件的进一步捕获或冒泡</td></tr><tr><td><code>preventDefault()</code></td><td>Function</td><td><code>returnValue</code></td><td>Boolean</td><td>取消事件的默认行为。该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。例如，如果 <code>type</code> 属性是 “submit”，可以阻止提交表单。</td></tr></tbody></table><h1 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h1><p>最后总结下与事件处理程序息息相关的“事件流”。事件流是指从页面中接收事件的顺序。但有意思的是，历史上 IE 和 Netscape 开发团队居然提出了 <strong>完全相反</strong> 的事件流概念 —— IE 使用“<strong>事件冒泡（Event Bubbling）</strong>”、Netscape 使用“<strong>事件捕获（Event Capturing）</strong>”。下图演示了这两种事件流的区别：</p><p><img src="/img/javascript/event-flow.png" alt="事件流（Event Flow）"></p><p>下表列出了四种事件绑定所使用的事件流模型：</p><table><thead><tr><th></th><th>事件冒泡 or 事件捕获？</th></tr></thead><tbody><tr><td>HTML</td><td>取决于 IE or Netscape</td></tr><tr><td>DOM Level 0</td><td>取决于 IE or Netscape</td></tr><tr><td>DOM Level 2</td><td>事件冒泡 + 事件捕获</td></tr><tr><td>IE</td><td>事件冒泡</td></tr></tbody></table><p>下面重点讲解 DOM Level 2 事件处理程序所规定的事件流，其共包含三个阶段（其运行效果如上图从 1 到 10）：</p><ol><li>事件捕获阶段，可用于事件截获</li><li>处于目标阶段</li><li>事件冒泡阶段，可用于<a href="/2016/05/22/javascript-event-delegation">事件委托（Event Delegation）</a></li></ol><p>下面这段代码演示了 DOM Level 2 的整个事件流：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">id</span>=<span class="string">'btn'</span> <span class="attr">value</span>=<span class="string">"Click Me"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 仅在“事件捕获阶段”和“处于目标阶段”触发</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.body.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(event.eventPhase + <span class="string">' body'</span>);</span></span><br><span class="line"><span class="actionscript">    &#125;, <span class="literal">true</span>);</span></span><br><span class="line">  </span><br><span class="line"><span class="actionscript">    <span class="comment">// 仅在“事件冒泡阶段”和“处于目标阶段”触发</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(event.eventPhase + <span class="string">' input'</span>);</span></span><br><span class="line"><span class="actionscript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 仅在“事件冒泡阶段”和“处于目标阶段”触发</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(event.eventPhase + <span class="string">' document'</span>);</span></span><br><span class="line"><span class="actionscript">    &#125;, <span class="literal">false</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击 <code>input</code> 按钮，将依次输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 body</span><br><span class="line">2 input</span><br><span class="line">3 document</span><br></pre></td></tr></table></figure><p>可见，DOM Level 2 是同时支持事件冒泡 + 事件捕获的。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《JavaScript 高级程序设计》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无缝迁移 Pages 服务</title>
      <link href="2016/05/08/optimizing-hexo-speed-with-coding-pages/"/>
      <url>2016/05/08/optimizing-hexo-speed-with-coding-pages/</url>
      
        <content type="html"><![CDATA[<p>一年前，为了优化这个博客的访问速度，我将 <a href="/2015/05/17/optimizing-hexo-speed/">Pages 服务迁移</a> 到了 GitCafe，没想到一年后 GitCafe 竟被 codeing.net 收购了，其服务将在五月底全面停止，真是令人叹息。</p><p>幸好 <a href="https://coding.net/help/doc/pages/" target="_blank" rel="noopener">Coding Pages</a> 支持免费绑定自定义域名，其配置也非常简单。在完成配置之后，只需要到 DNSPod 切换下 cname ，等待 DNS 解析生效即可。整个过程对网站用户透明。</p><p>最后，<a href="http://www.figotan.org/2016/04/06/how-to-choose-vcs-as-your-static-website-pages/" target="_blank" rel="noopener">这里</a> 列举了不少知名的 Pages 服务可供选择。不过对于国内用户来说，还是使用国内服务最快、最稳定。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 动态加载脚本</title>
      <link href="2016/04/30/javascript-dynamic-scripts/"/>
      <url>2016/04/30/javascript-dynamic-scripts/</url>
      
        <content type="html"><![CDATA[<p>本文演示如何动态加载脚本。即脚本在页面加载时不存在，但将来的某一时刻通过修改 DOM 动态添加脚本，从而实现按需加载脚本。</p><h1 id="加载脚本文件"><a href="#加载脚本文件" class="headerlink" title="加载脚本文件"></a>加载脚本文件</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptFile</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    script.src = url;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行到这行代码将 &lt;script&gt; 元素添加到页面之前，不会下载指定外部文件</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内联脚本代码"><a href="#内联脚本代码" class="headerlink" title="内联脚本代码"></a>内联脚本代码</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScriptString</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    script.text = code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行到这行代码将 &lt;script&gt; 元素添加到页面之前，不会下载指定外部文件</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这种方式加载的代码会在全局作用域中执行，而且当脚本执行后将立即可用。实际上，这样执行代码与在全局作用域中把相同的字符串传递给 <code>eval()</code> 是一样的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（十三）Git 分支模型实践</title>
      <link href="2016/04/05/git-branch-in-action/"/>
      <url>2016/04/05/git-branch-in-action/</url>
      
        <content type="html"><![CDATA[<p>有了一套成熟的<a href="/2016/04/03/git-branch/">分支模型</a>以及配套的<a href="/2016/04/04/git-permissions/">权限控制</a>之后，接下来我们以一个例子来演示如何实践这套流程。</p><h1 id="分支模型实践"><a href="#分支模型实践" class="headerlink" title="分支模型实践"></a>分支模型实践</h1><h2 id="创建版本分支"><a href="#创建版本分支" class="headerlink" title="创建版本分支"></a>创建版本分支</h2><p>首先，项目管理员（Master）从 <code>master</code> 分支中创建出版本分支 <code>release-*</code> 进行新版本的开发，<code>*</code> 为发布日期：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b release-20190101</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> something and commit...</span><br><span class="line"></span><br><span class="line">$ git push origin release-20190101</span><br></pre></td></tr></table></figure><p>版本分支 <code>release-*</code> 一般是锁起来的，不允许随便提交代码。</p><h2 id="创建特性分支"><a href="#创建特性分支" class="headerlink" title="创建特性分支"></a>创建特性分支</h2><p>然后，开发人员（Developer）从版本分支中创建出特性分支，并在其上进行特性开发：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b feature-test</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> something and commit...</span><br><span class="line"></span><br><span class="line">$ git push origin feature-test</span><br></pre></td></tr></table></figure><p>由于特性分支可能会跨版本开发，因此需要定期维护：主要的工作就是定期将 <code>master</code> 分支或版本分支合并进来，保持同步，代码够新。使用命令：<a href="https://qidawu.github.io/2015/08/20/git-rebase/">rebase</a>。</p><h2 id="Merge-Request"><a href="#Merge-Request" class="headerlink" title="Merge Request"></a>Merge Request</h2><p>开发完毕后，开发人员（Developer）需要<strong>整理特性分支</strong>——例如从中挑选出能够发版的提交，剔除掉不能发版的提交。如果想要筛选出将要被合并的提交有哪些，可以参考<a href="/2015/08/04/git-log/#筛选提交历史">这里</a>。</p><p>整理完毕后，给项目管理员（Master）发起一个 MR，请求合并到版本分支。</p><h2 id="标记新版本"><a href="#标记新版本" class="headerlink" title="标记新版本"></a>标记新版本</h2><p>当版本分支发布完毕，Master 打 Tag 标记该新版本，以便后续回顾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git tag tag-20190101 -m <span class="string">"XX 项目 v1.0 版本"</span></span><br><span class="line">$ git push origin tag-20190101</span><br></pre></td></tr></table></figure><p>注意，在默认情况下，<code>git push</code> 并不会把标签（tag）推送到远端仓库上，只有通过显式命令才能分享标签到远端仓库。其命令格式如同推送分支，运行 <code>git push origin [tagname]</code> 即可。如果要一次推送所有本地新增的标签上去，可以使用 <code>--tags</code> 选项。</p><h2 id="清理分支"><a href="#清理分支" class="headerlink" title="清理分支"></a>清理分支</h2><p>最后是一些清理工作，Master 需要删除已完成开发的版本分支、特性分支，避免分支越来越多导致不好管理。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d release-20190101</span><br><span class="line">$ git push --delete origin release-20190101</span><br></pre></td></tr></table></figure><p>最后，列出所有远程和本地分支确认下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -a</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="代码提交指南"><a href="#代码提交指南" class="headerlink" title="代码提交指南"></a>代码提交指南</h2><ul><li>请不要在更新中提交多余的白字符（whitespace）。Git 有种检查此类问题的方法，在提交之前，先运行 <code>git diff --check</code> ，会把可能的多余白字符修正列出来。</li><li>请将每次提交限定于完成一次逻辑功能。并且可能的话，适当地分解为多次小更新，以便每次小型提交都更易于理解。</li><li>最后需要谨记的是提交说明的撰写。可以理解为第一行的简要描述将用作邮件标题，其余部分作为邮件正文。</li></ul><h2 id="分支管理指南"><a href="#分支管理指南" class="headerlink" title="分支管理指南"></a>分支管理指南</h2><ul><li>主分支 <code>master</code> 一般不提交代码，只合并代码。</li><li>各特性分支要定期将 <code>master</code> 分支合并进来，避免后续处理合并请求时产生冲突，以减轻项目管理员的工作负担。</li><li>发版之后，项目管理员要记得打 tag 。</li></ul><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h2><p>查看本地分支和远程分支的跟踪关系：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -vv</span><br><span class="line"></span><br><span class="line">* feature-modify-remit-recon f898c3c [origin/feature-modify-remit-recon: ahead 2, behind 6] chore:xxx</span><br><span class="line">  feature-recon-history      cfbf905 [origin/feature-recon-history] Merge branch master into feature-recon-history</span><br><span class="line">  master                     e1f5e67 [origin/master] chore:xxx</span><br></pre></td></tr></table></figure><p>设置本地分支 <code>master</code> 跟踪远程分支 <code>origin/&lt;branch&gt;</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream-to=origin/&lt;branch&gt; master</span><br></pre></td></tr></table></figure><h2 id="删除本地远程分支"><a href="#删除本地远程分支" class="headerlink" title="删除本地远程分支"></a>删除本地远程分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-r</span><br><span class="line">--remotes</span><br><span class="line">List or delete (if used with -d) the remote-tracking branches.</span><br></pre></td></tr></table></figure><p>删除本地远程分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -r -d origin/branch-name</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《<a href="https://git-scm.com/book/zh/v1/%E5%88%86%E5%B8%83%E5%BC%8F-Git" target="_blank" rel="noopener">分布式 Git</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（十二）Git 权限控制</title>
      <link href="2016/04/04/git-permissions/"/>
      <url>2016/04/04/git-permissions/</url>
      
        <content type="html"><![CDATA[<p>除了 Git 命令，权限控制也是 Git 中极为重要的组成部分，本文主要介绍 GitLab 系统提供的最常用的权限控制功能。</p><h1 id="分配成员角色"><a href="#分配成员角色" class="headerlink" title="分配成员角色"></a>分配成员角色</h1><p>首先来了解下，Git 中的五种角色：</p><table><thead><tr><th>角色</th><th>描述</th></tr></thead><tbody><tr><td>Owner</td><td>Git 系统管理员</td></tr><tr><td>Master</td><td>Git 项目管理员</td></tr><tr><td>Developer</td><td>Git 项目开发人员</td></tr><tr><td>Reporter</td><td>Git 项目测试人员</td></tr><tr><td>Guest</td><td>访客</td></tr></tbody></table><p>每一种角色所拥有的权限都不同，如下图：</p><p><img src="/img/git/git_permissions.png" alt="Git 权限控制"></p><p>我们需要做的是，为项目成员分配恰当的角色，以限制其权限。</p><h1 id="Protected-Branches"><a href="#Protected-Branches" class="headerlink" title="Protected Branches"></a>Protected Branches</h1><p>在对 Git 不熟悉的时候，时常苦恼于各个分支不受约束，任何开发人员都可以向任何分支直接推送任何提交，各种未经审查的代码、花样百出的 Bug 就这样流窜在预发布分支上。</p><p>其实我们可以通过 GitLab 的<strong>受保护分支（Protected Branches）</strong>功能解决该问题，该功能可用于：</p><blockquote><p>Keep stable branches secure and force developers to use <strong>merge requests</strong>.</p><p>By default, protected branches are designed to:</p><ul><li>prevent their creation, if not already created, from everybody except Masters</li><li>prevent pushes from everybody except Masters</li><li>prevent <strong>anyone</strong> from force pushing to the branch</li><li>prevent <strong>anyone</strong> from deleting the branch</li></ul></blockquote><p>接下来我们就使用这项功能，锁定我们的受保护分支——主分支 <code>master</code> 和预发布分支 <code>release-*</code>，以阻止 Developer 直接向这两类分支中推送代码：</p><p><img src="/img/git/git_protected_branches.png" alt="Git 受保护分支"></p><p>锁定后，Developer 推送代码将会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">Counting objects: 4, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2&#x2F;2), done.</span><br><span class="line">Writing objects: 100% (3&#x2F;3), 283 bytes | 0 bytes&#x2F;s, done.</span><br><span class="line">Total 3 (delta 1), reused 1 (delta 0)</span><br><span class="line">remote: GitLab: You are not allowed to access master!</span><br><span class="line">remote: error: hook declined to update refs&#x2F;heads&#x2F;master</span><br><span class="line">To git@website:project.git</span><br><span class="line"> ! [remote rejected] master -&gt; master (hook declined)</span><br><span class="line">error: failed to push some refs to &#39;git@website:project.git&#39;</span><br></pre></td></tr></table></figure><h1 id="Merge-Requests"><a href="#Merge-Requests" class="headerlink" title="Merge Requests"></a>Merge Requests</h1><p>锁定受保护分支后，要么 Master 需要时刻、主动关注各特性分支的进度，要么 Developer 需要线下、口头向 Master 汇报其特性分支的进度，这两种做法都非常不便于 Master 管理每个预发布分支的合并，尤其在团队大、分支多的情况。</p><p>我们可以通过 GitLab 的<strong>发起合并请求（Merge Request）</strong>功能解决该问题，这样既可以让 Developer 更自如的掌控自己分支进度，在必要的时候才主动发起合并请求；又可以减轻 Master 的合并工作量和沟通成本，可谓一举两得。</p><h2 id="新建-MR"><a href="#新建-MR" class="headerlink" title="新建 MR"></a>新建 MR</h2><p>第一步，按表单要求填写合并请求。注意，对于 Developer 而言：</p><ul><li><code>Source branch</code> 是你的特性分支 <code>feature-*</code>；</li><li><code>Tagget branch</code> 只可能是预发布分支 <code>release-*</code>；</li><li><code>Title</code> 和 <code>Description</code> 要填写恰当的分支描述；</li><li><code>Assignee</code> 是该项目的 Master。</li></ul><p><img src="/img/git/git_new_merge_request.png" alt="新建合并请求"></p><h2 id="审查-MR"><a href="#审查-MR" class="headerlink" title="审查 MR"></a>审查 MR</h2><p>第二步，Master 收到合并请求后，进行代码审查。逐一查看 <code>Commits</code> 或 <code>Changes</code> 一栏提交的内容即可，对于需要改进的代码，可以直接在该行添加注释，非常方便。</p><p>如果对整个请求还有疑问的地方，还可以通过 <code>Discussion</code> 功能进行线上讨论。</p><h2 id="处理-MR"><a href="#处理-MR" class="headerlink" title="处理 MR"></a>处理 MR</h2><p>第三步，针对审查结果进行相应处理：</p><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>对于完全不合格的垃圾代码、或者废弃的特性分支的合并请求，Master 点击右上角的 <code>Close</code> 按钮即可。合并请求将被关闭，相当于扔进回收站。</p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>对于分支内需改进的代码，Developer 直接修正并推送即可，合并请求将会自动包含最新的推送提交。</p><h3 id="接受"><a href="#接受" class="headerlink" title="接受"></a>接受</h3><p>Master 审查无误后，可以接受该次合并请求。点击 <code>Accept Merge Request</code> 按钮将自动合并分支，勾选 <code>Remove source-branch</code> 将同时删除该特性分支。</p><p>整个自动合并过程如果以命令形式手工执行的话，步骤如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Step 1. Update the repo and checkout the branch we are going to merge </span></span><br><span class="line">git fetch origin</span><br><span class="line">git checkout -b <span class="built_in">test</span> origin/feature-test</span><br><span class="line"></span><br><span class="line"><span class="comment">#Step 2. Merge the branch and push the changes to GitLab </span></span><br><span class="line">git checkout release-2016.4.7</span><br><span class="line">git merge --no-ff feature-test</span><br><span class="line">git push origin release-2016.4.7</span><br></pre></td></tr></table></figure><p>以<a href="/2015/08/17/git-merge/#非快进式合并">非快进式合并</a>完成后，祖先图谱（graph）的展现结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   be512fa (HEAD, origin&#x2F;release-2016.4.7, release-2016.4.7)  Merge branch &#39;test&#39; into &#39;release-2016.4.7&#39;</span><br><span class="line">|\</span><br><span class="line">| * 1f52adf 测试</span><br><span class="line">|&#x2F;</span><br><span class="line">*   a4febbb (tag: 1.0.0, origin&#x2F;master) 格式化货币保留两位小数</span><br></pre></td></tr></table></figure><p>最后需要注意的是，只有 <code>Assignee</code> 才能够接受合并请求，其它人只会被通知：</p><blockquote><p>You don’t have permission to merge this MR</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>GitLab 提供的上述功能非常实用，为项目的源码管理提供了有力的支持。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（十一）Git 分支模型总结</title>
      <link href="2016/04/03/git-branch/"/>
      <url>2016/04/03/git-branch/</url>
      
        <content type="html"><![CDATA[<p>项目总归要协作开发，在此总结我在团队中推广使用的分支模型。</p><p><img src="/img/git/git_branch.png" alt="A successful Git branching model"></p><h1 id="分支模型"><a href="#分支模型" class="headerlink" title="分支模型"></a>分支模型</h1><h2 id="主分支（Main-branches）"><a href="#主分支（Main-branches）" class="headerlink" title="主分支（Main branches）"></a>主分支（Main branches）</h2><p>企业的项目开发不像开源的项目开发，通常只会有一个远程仓库。这种情况下，通常会有两个常驻分支：</p><table><thead><tr><th>Branch Name</th><th>Is locked?</th><th>Description</th></tr></thead><tbody><tr><td><code>master</code></td><td>YES</td><td>主干分支，仅用于发布新版本，平时不能在上面干活，只做代码合并、以及打标记（<code>git tag</code>）。<br/> 理论上，每当对 <code>master</code> 分支有一个合并提交操作，我们就可以使用 Git 钩子脚本来自动构建并且发布软件到生产服务器。</td></tr><tr><td><code>dev</code></td><td>NO</td><td>开发分支，平时干活的地方。每当发版时，需要被合并到 <code>master</code>。</td></tr></tbody></table><p>对于简单的项目而言，这样的分支模型已经够用了。</p><h2 id="辅助性分支（Supporting-branches）"><a href="#辅助性分支（Supporting-branches）" class="headerlink" title="辅助性分支（Supporting branches）"></a>辅助性分支（Supporting branches）</h2><p>除了常驻分支，通常大的特性开发或生产缺陷修复还建议创建相应的临时分支。因为：</p><ol><li>在分支上开发可以让你随意尝试，进退自如，比如碰上无法正常工作的特性或补丁，可以先搁在那边，直到有时间仔细核查修复为止。</li><li>团队中如果有代码审查流程，独立的分支还可以留给审查者抽空审查的时间和改进代码的余地，并将是否合并、是否发布的权利留给审查者，为代码质量设一道门槛。</li></ol><p>每一类分支都有一个特定目的，如何命名每一类分支？建议用相关的主题关键字进行命名，并且建议将分支名称分置于不同<strong>命名空间（前缀）</strong>下，例如：</p><table><thead><tr><th>Branch Name</th><th>May branch off from</th><th>Must merge back into</th><th>Is locked?</th><th>Description</th></tr></thead><tbody><tr><td><code>feature-*</code></td><td><code>dev</code></td><td><code>dev</code></td><td>NO</td><td>特性分支，为了开发某种特定功能而建。开发完成并测试通过后，需发送 Merge Request 到 <code>release-*</code> 进行代码审查及合版。</td></tr><tr><td><code>release-*</code></td><td><code>dev</code></td><td><code>dev</code> <br/> <code>master</code></td><td>YES</td><td>预发布分支，为了新版本的发布做准备，一般命名为 <code>release-&lt;版本号&gt;</code>。这是一个稳定分支，只接受审核通过的 Merge Request。</td></tr><tr><td><code>hotfix-*</code></td><td><code>master</code></td><td><code>dev</code> <br/> <code>master</code></td><td>NO</td><td>补丁分支，为了修复生产缺陷而建，一般命名为 <code>hotfix-&lt;issue 编号&gt;</code></td></tr></tbody></table><p>与主分支不同，这些辅助性分支总是有一个有限的生命期，因为他们在被合并到主分支之后，就会被移除掉。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《<a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a>》</li><li>《<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">Git 分支管理策略 - 阮一峰</a>》</li><li>《<a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="noopener">A successful Git branching model</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（十）git diff 命令对比文件差异</title>
      <link href="2016/04/01/git-diff/"/>
      <url>2016/04/01/git-diff/</url>
      
        <content type="html"><![CDATA[<p>对比两个分支中，所有文件的详细差异，常用于合并操作之后确认有没有遗漏文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff branch1 branch2</span><br></pre></td></tr></table></figure><p>对比两个分支中，指定文件的详细差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff branch1 branch2 文件名(带路径)</span><br></pre></td></tr></table></figure><p>对比两个分支中，差异的文件列表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff branch1 branch2 --<span class="built_in">stat</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 编程最佳实践</title>
      <link href="2016/03/10/javascript-best-practice/"/>
      <url>2016/03/10/javascript-best-practice/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文总结出一些广受认可的编程最佳实践，用于解决特定领域的问题。</p><h1 id="编程最佳实践"><a href="#编程最佳实践" class="headerlink" title="编程最佳实践"></a>编程最佳实践</h1><h2 id="避免使用全局变量"><a href="#避免使用全局变量" class="headerlink" title="避免使用全局变量"></a>避免使用全局变量</h2><p>在 JavaScript 所有的糟糕特性之中，最为糟糕的一个就是它对全局变量的依赖。JS 大神 Douglas Crockford 甚至称之为“毒瘤”。想象一下，一个全局变量可以被程序的任何部分在任意时间修改，将使得程序的行为变得极度复杂。可怕的全局变量还带来了以下问题：</p><ol><li>命名冲突</li><li>代码的脆弱性</li><li>难以测试</li></ol><p>共有三种方式定义全局变量，这些方式都是我们要避免的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = value;       <span class="comment">// 1、在任何函数之外放置一个 var 语句</span></span><br><span class="line"><span class="built_in">window</span>.foo = value;    <span class="comment">// 2、直接给全局对象添加属性</span></span><br><span class="line">foo = value;           <span class="comment">// 3、直接使用未经声明的变量，即隐式的全局变量。一般都是开发者忘记声明，这将导致查找 bug 非常困难</span></span><br></pre></td></tr></table></figure><p>下面是一些解决办法：</p><h3 id="零全局变量"><a href="#零全局变量" class="headerlink" title="零全局变量"></a>零全局变量</h3><p>如果你编写的是一段不会被其它脚本访问到的完全独立的脚本，可以使用一个立即执行的匿名函数来<a href="/2016/03/09/javascript-style-guideline/#创建私有作用域">创建私有作用域</a>。</p><h3 id="单全局变量"><a href="#单全局变量" class="headerlink" title="单全局变量"></a>单全局变量</h3><p>最小化使用全局变量的方法之一是为你的应用创建唯一一个全局变量，并将你所有的功能代码都挂载到这个全局对象上。这种做法既降低了模块之间发生冲突的可能，又能保证模块之间的正常通信。可以参考 <a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="noopener">JavaScript 模块模式</a>。</p><p>目前这种单全局变量模式已经在各种流行的库中广泛使用了：</p><ul><li>jQuery 定义了两个全局对象，<code>$</code> 和 <code>jQuery</code>。只有在 <code>$</code> 被其它库使用了的情况下，为了避免冲突，才使用 <code>jQuery</code>。</li><li>YUI 定义了唯一一个 <code>YUI</code> 全局对象。</li><li>Dojo 定义了唯一一个 <code>dojo</code> 全局对象。</li><li>……</li></ul><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>最后一种、也是最为推崇的做法是使用“模块化”方式组织代码：</p><ul><li>ECMAScript 6 可以使用最新的原生模块标准语法；</li><li>使用主流的模块框架规范，如 AMD 和 CMD（<a href="https://www.zhihu.com/question/20351507/answer/14859415" target="_blank" rel="noopener">AMD 和 CMD 的区别有哪些？</a>）。</li></ul><h2 id="不是你的对象不要动"><a href="#不是你的对象不要动" class="headerlink" title="不是你的对象不要动"></a>不是你的对象不要动</h2><p>JavaScript 独一无二之处在于任何东西都不是神圣不可侵犯的。默认情况下，你可以修改任何你可以触及的对象。解析器根本就不在乎这些对象是开发者定义的还是默认执行环境的一部分——只要是能访问到的对象都可以修改。如果你的代码没有创建这些对象，禁止修改它们，包括：</p><ul><li>原生对象（<code>Object</code>、<code>Array</code> 等等）；</li><li>文档对象模型（DOM）（<code>document</code> 等等）；</li><li>浏览器对象模型（BOM）（<code>window</code> 等等）；</li><li>类库的对象（<code>$</code>、<code>jQuery</code> 等等）。</li></ul><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><h4 id="不覆盖方法"><a href="#不覆盖方法" class="headerlink" title="不覆盖方法"></a>不覆盖方法</h4><p>覆盖方法将会导致所有依赖该方法的代码失效：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法 - 覆盖了 DOM 方法</span></span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 任意代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="不新增方法"><a href="#不新增方法" class="headerlink" title="不新增方法"></a>不新增方法</h4><p>新增方法将会导致未来潜在的命名冲突，因为一个对象此刻没有某个方法不代表它未来没有。更糟糕的是如果将来原生的方法和你新增的方法行为不一致，将会陷入一场代码维护的噩梦：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法，在 DOM 对象上增加了方法</span></span><br><span class="line"><span class="built_in">document</span>.getElementsByClassName = <span class="function"><span class="keyword">function</span>(<span class="params">classes</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 非原生实现。</span></span><br><span class="line">    <span class="comment">// 该新增方法在 HTML 5 中被官方实现了，这将会导致所有依赖该方法的代码报错。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不好的写法，在原生对象上增加了方法</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.reverseSort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sort().reverse();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不好的写法，在库对象上增加了方法</span></span><br><span class="line">$.doSomeThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 任意代码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="不删除方法"><a href="#不删除方法" class="headerlink" title="不删除方法"></a>不删除方法</h4><p>删除方法将会导致所有依赖该方法的代码运行时错误。对于已发布的库来说，无用的方法应该被标识位“废弃”而不是直接删掉：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法 - 删除了 DOM 方法</span></span><br><span class="line"><span class="built_in">document</span>.getElementById = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>下面介绍一些解决方法：</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>如果一种类型的对象已经做到了你想要的大多数工作，那么继承它然后再新增一些功能是最好的做法。JavaScript 中有两种基本的继承形式：</p><ul><li>基于对象的继承</li><li>基于类型的继承</li></ul><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyError = <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.message = message;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();    <span class="comment">// 基于类型的继承，继承自原生的 Error 类</span></span><br></pre></td></tr></table></figure><h4 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h4><p>JavaScript 的继承有一些很大的限制，就是无法继承自 DOM 或 BOM 对象。解决办法是利用门面模式为这些已存在的对象创建一个新的接口，达到二次封装的效果。jQuery 和 YUI 的 DOM 接口都使用了门面模式。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义一个 DOM 对象包装器</span></span><br><span class="line"><span class="keyword">var</span> DOMWrapper = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DOMWrapper.prototype = &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: DOMWrapper,</span><br><span class="line">    addClass: function(className) &#123;</span><br><span class="line">        <span class="keyword">this</span>.element.className += <span class="string">' '</span> + className;</span><br><span class="line">    &#125;,</span><br><span class="line">    remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element.parentNode.removeChild(<span class="keyword">this</span>.element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">var</span> wrapper = <span class="keyword">new</span> DOMWrapper(<span class="built_in">document</span>.getElementById(<span class="string">"my-div"</span>));</span><br><span class="line"><span class="comment">// 添加一个 className</span></span><br><span class="line">wrapper.addClass(<span class="string">"selected"</span>);</span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">wrapper.remove();</span><br></pre></td></tr></table></figure><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="解耦事件处理"><a href="#解耦事件处理" class="headerlink" title="解耦事件处理"></a>解耦事件处理</h3><p>事件处理常见的问题是将事件处理程序和业务逻辑紧紧耦合在一起，降低了代码的可维护性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">var</span> handleClick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM Level 2</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line">    event.stopPropagation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 耦合业务逻辑</span></span><br><span class="line">    <span class="keyword">var</span> popup = <span class="built_in">document</span>.getElementById(<span class="string">"popup"</span>);</span><br><span class="line">    popup.style.left = event.clientX + <span class="string">"px"</span>;</span><br><span class="line">    popup.style.top = event.clientY + <span class="string">"px"</span>;</span><br><span class="line">    popup.className = <span class="string">"reveal"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'btn-action'</span>)</span><br><span class="line">            .addEventListener(<span class="string">"click"</span>, handleClick, <span class="literal">false</span>);    <span class="comment">// DOM Level 2</span></span><br></pre></td></tr></table></figure><p>正确的做法应该是解耦事件处理程序和业务逻辑，提高代码的可维护性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理程序，唯一能接触 event 对象的函数</span></span><br><span class="line"><span class="keyword">var</span> handleClick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// DOM Level 2</span></span><br><span class="line">        event.preventDefault();</span><br><span class="line">        event.stopPropagation();</span><br><span class="line"></span><br><span class="line">        showPopup(event.clientX, event.clientY);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 抽取业务逻辑，与事件隔离，便于重用与测试</span></span><br><span class="line">    showPopup = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> popup = <span class="built_in">document</span>.getElementById(<span class="string">"popup"</span>);</span><br><span class="line">        popup.style.left = x + <span class="string">"px"</span>;</span><br><span class="line">        popup.style.top = y + <span class="string">"px"</span>;</span><br><span class="line">        popup.className = <span class="string">"reveal"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'btn-action'</span>)</span><br><span class="line">            .addEventListener(<span class="string">"click"</span>, handleClick, <span class="literal">false</span>);    <span class="comment">// DOM Level 2</span></span><br></pre></td></tr></table></figure><p>可见，业务逻辑不应该依赖于 <code>event</code> 对象来完成功能，原因如下：</p><ul><li>好的 API 一定是对于期望和依赖都是透明的，因此方法接口应该表明哪些数据是必要的。将 <code>event</code> 对象作为参数并不能告诉你 <code>event</code> 的哪些属性是有用的，用来干什么？</li><li>如果想测试这个方法，你必须构建一个 <code>event</code> 对象并作为参数传入。这迫使你关注方法内部实现，以确切地知道这个方法使用了哪些信息，这样才能正确地写出测试代码。</li></ul><h3 id="使用事件委托"><a href="#使用事件委托" class="headerlink" title="使用事件委托"></a>使用事件委托</h3><p>关于“事件绑定（Event Binding）”和“事件委托（Event Delegation）”两种机制的区别在 <a href="/2016/05/22/javascript-event-delegation">本文</a> 有详细的描述。简而言之，从“内存消耗”、“处理速度”、“新增元素的处理”三方面考虑，都更建议使用“事件委托”。下例演示了如何使用 jQuery 语法进行“事件委托”：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#list'</span>).on(<span class="string">'click'</span>, <span class="string">'li'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//function code here.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当 <code>#list</code> 内任一 <code>li</code> 子元素被点击时，<code>click</code> 事件将冒泡到其父元素 <code>#list</code> 并触发 <code>#list</code> 的事件处理程序，即子元素的事件都委托给父元素进行处理。这种做法有利于提升性能，推荐使用。</p><h2 id="UI-层保持松耦合"><a href="#UI-层保持松耦合" class="headerlink" title="UI 层保持松耦合"></a>UI 层保持松耦合</h2><p>保持 Web UI 层的松耦合，以便在以下场景中调试代码，定位问题：</p><ul><li>当发生了文本或结构相关的问题，通过查找 HTML 即可定位；</li><li>当发生了样式相关的问题，通过查找 CSS 即可定位；</li><li>当发生了行为和交互相关的问题，通过查找 JavaScript 即可定位。</li></ul><p>这种快速定位问题的能力是 Web 界面可维护性的核心关键。</p><h3 id="将-JavaScript-从-CSS-中抽离"><a href="#将-JavaScript-从-CSS-中抽离" class="headerlink" title="将 JavaScript 从 CSS 中抽离"></a>将 JavaScript 从 CSS 中抽离</h3><p>禁止使用 CSS 表达式（CSS Expression）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line">.box &#123;</span><br><span class="line">    width: expression(<span class="built_in">document</span>.body.offsetWidth + <span class="string">"px"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CSS 表达式是 IE8 及更早版本中的一个特性，它允许你将 JavaScript 直接插入到 CSS 中，这样可以在 CSS 代码中直接执行运算或其它操作。但 CSS 表达式会带来两个问题：</p><ul><li>性能问题</li><li>代码可维护性问题</li></ul><h3 id="将-CSS-从-JavaScript-中抽离"><a href="#将-CSS-从-JavaScript-中抽离" class="headerlink" title="将 CSS 从 JavaScript 中抽离"></a>将 CSS 从 JavaScript 中抽离</h3><p>禁止在 JavaScript 脚本中直接操作 CSS 样式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line">element.style.color = <span class="string">'red'</span>;</span><br><span class="line">element.style.left = <span class="string">'10px'</span>;</span><br><span class="line">element.style.cssText = <span class="string">'color: red; left: 10px'</span>;</span><br></pre></td></tr></table></figure><p>当需要通过 JavaScript 来操作元素样式的时候，最佳方法是操作 CSS 的 <code>className</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">element.className = <span class="string">'className'</span>;    <span class="comment">// 原生方法</span></span><br><span class="line">$(element).addClass(<span class="string">'className'</span>);   <span class="comment">// jQuery</span></span><br></pre></td></tr></table></figure><p>CSS 的 <code>className</code> 应该成为 CSS 和 JavaScript 之间通信的桥梁。JavaScript 不应当直接操作 CSS 样式，以便保持和 CSS 的松耦合。</p><h3 id="将-JavaScript-从-HTML-中抽离"><a href="#将-JavaScript-从-HTML-中抽离" class="headerlink" title="将 JavaScript 从 HTML 中抽离"></a>将 JavaScript 从 HTML 中抽离</h3><p>禁止在 HTML 标签中嵌入 JavaScript 脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 不好的写法，不该直接为 HTML 标签的 on 属性挂载事件处理程序 --&gt;</span><br><span class="line">&lt;button onclick=<span class="string">"doSomeThing()"</span> id=<span class="string">"btn-action"</span>&gt;Click Me&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>这样会导致 HTML 页面和 JavaScript 脚本紧紧耦合。正确的做法应当是在外部脚本文件中添加事件处理程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomeThing() &#123;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'btn-action'</span>)</span><br><span class="line">            .addEventListener(<span class="string">"click"</span>, doSomeThing, <span class="literal">false</span>);    <span class="comment">// DOM Level 2</span></span><br><span class="line">$(<span class="string">'#btn-action'</span>).click(doSomeThing);    <span class="comment">// jQuery</span></span><br></pre></td></tr></table></figure><p>这种做法的优势在于，函数 <code>doSomeThing()</code> 的定义和事件处理程序的绑定都是在同一个文件中完成的。如果函数名称需要修改，则只需修改一个文件即可；如果点击发生时想额外做一些动作，也只需在一处做修改。</p><p>此外，不到迫不得已，不建议在 HTML 页面中嵌入 JavaScript 脚本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  不好的做法 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    doSomeThing();</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="将-HTML-从-JavaScript-中抽离"><a href="#将-HTML-从-JavaScript-中抽离" class="headerlink" title="将 HTML 从 JavaScript 中抽离"></a>将 HTML 从 JavaScript 中抽离</h3><p>不建议在 JavaScript 脚本文件中嵌入 HTML 操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的做法</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'my-div'</span>);</span><br><span class="line">div.innerHTML = <span class="string">"&lt;h3&gt;Error&lt;/h3&gt;&lt;p&gt;Invalid e-mail address.&lt;/p&gt;"</span>;</span><br></pre></td></tr></table></figure><p>这样会导致 JavaScript 脚本和 HTML 标签紧紧耦合，从而降低了代码的可维护性，增加了跟踪文本和结构性问题的复杂度。正常来说，调试上述这段标签的典型方法，应当是先去浏览器调试工具中的 DOM 树中查找，然后打开页面的 HTML 源码对比其不同。一旦 JavaScript 脚本文件中做了除简单 DOM 操作之外的事情，如渲染标签，追踪 Bug 就变得很麻烦。因为脚本和标签都耦合成一坨了，让人望而却步。</p><p>HTML 文本和标签应该只存放于一个地方：可以控制你 HTML 代码的地方。最为推崇的做法是利用 <strong>JavaScript 模板引擎</strong> 解决这个问题。</p><p>项目中我引入了模板引擎 <a href="https://github.com/aui/artTemplate" target="_blank" rel="noopener">artTemplate</a> 进行 HTML 渲染，并通过修改源码内置了两个常用的格式化工具：</p><ul><li>货币格式化：<a href="http://openexchangerates.github.io/accounting.js/" target="_blank" rel="noopener">accounting.js</a></li><li>日期格式化：datetime.js</li></ul><p>详见 DEMO：finance-marketres-mobi\js\utility\util-demo.html</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《编写可维护的 JavaScript》</li><li>《JavaScript 高级程序设计》</li><li>《JavaScript 权威指南》</li><li>《JavaScript 语言精粹》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 编程风格规范</title>
      <link href="2016/03/09/javascript-style-guideline/"/>
      <url>2016/03/09/javascript-style-guideline/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在团队开发中，所有的代码看起来风格一致是极其重要的，原因有以下几点：</p><ul><li>任何开发者都不会在乎某个文件的作者是谁，因为所有代码排版格式看起来应当是非常一致，不该花费额外精力去理解代码逻辑并重新排版。</li><li>风格一致能够让人很容易识别出问题代码并发现错误。如果所有代码看起来很像，当你看到一段与众不同的代码时，很可能错误就产生在这段代码中。</li></ul><p>当项目变得庞大时，统一的编程风格能够节省的大量时间成本。</p><h1 id="基本编程风格"><a href="#基本编程风格" class="headerlink" title="基本编程风格"></a>基本编程风格</h1><p>本节编程风格（Style Guideline）是用于规范单文件中的代码，使团队编程风格保持一致。</p><h2 id="缩进层级"><a href="#缩进层级" class="headerlink" title="缩进层级"></a>缩进层级</h2><p>每一行的层级由 <strong>四个空格</strong> 组成，避免使用制表符（Tab）进行缩进，以便在所有的系统和编辑器中，文件的展现格式不会有任何差异。建议在文本编辑器中配置敲击 <code>Tab</code> 键时插入四个空格。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="行的长度"><a href="#行的长度" class="headerlink" title="行的长度"></a>行的长度</h2><p>每行长度不应该超过 80 个字符。如果一行多于 80 个字符，应当在一个<strong>运算符（逗号、加号等）后换行</strong>。下一行应当<strong>增加两级缩进（8 个字符）</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 好的写法</span><br><span class="line">doSomething(arg1, arg2, arg3, arg4,</span><br><span class="line">        arg5);</span><br><span class="line"></span><br><span class="line">// 不好的写法：第二行只有 4 个空格的缩进</span><br><span class="line">doSomething(arg1, arg2, arg3, arg4,</span><br><span class="line">    arg5);</span><br><span class="line"></span><br><span class="line">// 不好的写法：在运算符之前换行</span><br><span class="line">doSomething(arg1, arg2, arg3, arg4</span><br><span class="line">        , arg5);</span><br></pre></td></tr></table></figure><h2 id="语句格式"><a href="#语句格式" class="headerlink" title="语句格式"></a>语句格式</h2><ul><li>始终使用分号 <code>;</code> 结束一个语句。禁止省略分号，因为：<ul><li>后续使用构建工具时，可以通过自动删除多余的空格和换行来压缩代码行（代码行结尾处没有分号会导致压缩错误）。</li><li>在某些情况下增进代码的性能，因为这样解析器就不必再花时间推测应该在哪里插入分号了。</li><li>避免解析器错误的插入分号，导致程序报错。</li></ul></li><li>始终使用花括号 <code>{}</code> 包住块语句，可以让编程意图更清晰，降低修改代码时出错的几率。</li></ul><p>这里展示了一些例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法，缺少花括号</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    doSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法，左花括号应当放在块语句中第一句代码的末尾</span></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法，缺少空格间隔</span></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法，缺少适当的换行</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123; doSomething(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法，缺少分号结尾</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    doSomething()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符间隔"><a href="#操作符间隔" class="headerlink" title="操作符间隔"></a>操作符间隔</h2><p>二元操作符（如赋值、逻辑运算）前后必须使用一个空格来保持表达式的整洁。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> found = (value[i] === item);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不好的写法：丢失了空格</span></span><br><span class="line"><span class="keyword">var</span> found=(value[i]===item);</span><br></pre></td></tr></table></figure><h2 id="注释声明"><a href="#注释声明" class="headerlink" title="注释声明"></a>注释声明</h2><p>注释有时候可以用于给一段代码声明额外的信息。这些声明的格式如下：</p><table><thead><tr><th>注释声明</th><th>描述</th></tr></thead><tbody><tr><td><code>TODO</code></td><td>说明代码还未完成。此时应当描述下一步要做的事情。</td></tr><tr><td><code>HACK</code></td><td>说明代码实现走了一个捷径。此时应当描述为何使用 hack 的原因。这也可能表明该问题可能会有更好的解决方法。</td></tr><tr><td><code>FIXME</code></td><td>说明代码是有问题的需要尽快修复。此时应当描述问题出在哪里，或者提供解决方案。</td></tr><tr><td><code>REVIEW</code></td><td>说明代码任何可能的改动都需要评审。</td></tr></tbody></table><p>注释声明可以用于单行或多行注释，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 我希望找到一种效率更快的实现方式</span></span><br><span class="line">doSomething();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * HACK: 不得不针对 IE 做的特殊处理。我计划后续有时间时</span></span><br><span class="line"><span class="comment"> * 重写这部分。这些代码可能需要在 v1.2 版本之后替换掉。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.all) &#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h2><ul><li>变量命名使用小驼峰式（Camel Case）命名法，即以小写字母开头，后续每个单词首字母都大写。</li><li>常量命名使用大写字母和下划线。</li><li>私有属性、方法使用下划线前缀：<code>_</code>。</li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>所有字母大写，不同单词之间用单个下划线 <code>_</code> 分隔。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数使用大驼峰式（Pascal Case）命名法，即以大写字母开头，后续每个单词首字母都大写。</p><h3 id="函数变量"><a href="#函数变量" class="headerlink" title="函数变量"></a>函数变量</h3><p>函数变量使用前缀：<code>fn</code>。</p><h3 id="DOM-变量"><a href="#DOM-变量" class="headerlink" title="DOM 变量"></a>DOM 变量</h3><ul><li>class：使用全小写字母 + 中划线的形式命名。如果该类是用于在 JS 中引用的，还需要添加前缀 <code>js-</code>。注意用于 JS 的类严禁用于样式文件中引用。</li><li>id：使用小驼峰命名，并添加前缀如下：</li></ul><table><thead><tr><th>前缀</th><th>描述</th></tr></thead><tbody><tr><td><code>ipt</code></td><td>input 输入框</td></tr><tr><td><code>btn</code></td><td>按钮</td></tr><tr><td><code>lbl</code></td><td>Label</td></tr><tr><td><code>chk</code></td><td>CheckBox</td></tr><tr><td><code>lnk</code></td><td>A链接</td></tr><tr><td><code>img</code></td><td>图片</td></tr></tbody></table><h2 id="禁止使用的"><a href="#禁止使用的" class="headerlink" title="禁止使用的"></a>禁止使用的</h2><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>JavaScript 中有三种<a href="/2016/02/11/javascript-primitive-types/#基本包装类型">基本包装类型</a>：<code>Boolean</code>、<code>Number</code>、<code>String</code>，每种类型都代表全局作用域中的一个构造函数，并分别表示各自对应的原始值的对象。基本包装类型的主要作用是让原始值具有对象般的行为。</p><p>禁止使用这些基本包装类型声明变量，应该直接使用对应的字面量：</p><table><thead><tr><th>类型</th><th>描述</th><th>注意项</th></tr></thead><tbody><tr><td>布尔值</td><td>统一使用字面量 <code>true</code>、<code>false</code> 而不是构造函数 <code>new Boolean()</code></td><td></td></tr><tr><td>数字值</td><td>统一使用<a href="/2016/02/11/javascript-primitive-types/#字面量">字面量</a>，而不是构造函数 <code>new Number()</code></td><td>避免使用八进制字面量</td></tr><tr><td>字符串</td><td>统一使用单引号 <code>&#39;&#39;</code>，而不是构造函数 <code>new String()</code></td><td>避免在字符串中使用斜杠 <code>\</code> 另起一行</td></tr><tr><td><a href="/2016/02/17/javascript-object/">对象</a></td><td>统一使用字面量 <code>{}</code> 而不是构造函数 <code>new Object()</code></td><td></td></tr><tr><td><a href="/2016/02/18/javascript-array/">数组</a></td><td>统一使用字面量 <code>[]</code> 而不是构造函数 <code>new Array()</code></td><td></td></tr></tbody></table><h3 id="等号操作符"><a href="#等号操作符" class="headerlink" title="等号操作符"></a>等号操作符</h3><p>由于相等（<code>==</code>）和不相等（<code>!=</code>）操作符存在 <strong>自动类型转换</strong> 的问题，因此禁止使用。为了保持代码中数据类型的完整性，要求使用全等（<code>===</code>）和不全等（<code>!==</code>）操作符。</p><h3 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h3><p><code>setTimeout()</code>、<code>setInterval()</code> 函数中的回调代码禁止使用字符串格式。</p><p><code>eval()</code> 函数禁止使用。</p><h2 id="空链接跳转"><a href="#空链接跳转" class="headerlink" title="空链接跳转"></a>空链接跳转</h2><p>常用的三种空链接跳转：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line">javascript:<span class="keyword">void</span>(<span class="number">0</span>);</span><br><span class="line">javascript:;    <span class="comment">// 推荐这种</span></span><br></pre></td></tr></table></figure><h1 id="进阶编程风格"><a href="#进阶编程风格" class="headerlink" title="进阶编程风格"></a>进阶编程风格</h1><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p>在具有块级作用域的语言中，在狭小的作用域内让变量声明和使用变量的代码尽可能彼此靠近，通常是个好的编程习惯。因此在编写 JavaScript 时常常会出现类似的惯性思维：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'for 语句内，i='</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'for 语句外，i='</span> + i);    <span class="comment">// 注意这里，JavaScript 没有块级作用域，因此 for 语句外仍然可以读取变量 i</span></span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 语句内，i=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> 语句内，i=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> 语句内，i=<span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> 语句外，i=<span class="number">3</span>    <span class="comment">// 注意这里</span></span><br></pre></td></tr></table></figure><p>但由于 JavaScript 中并没有块级作用域（block scope），只有函数作用域（function scope），因此函数内声明的所有变量在函数体内始终是可见的。这个特性被非正式地称为 <strong>声明提前（hoisting）</strong>，即 JavaScript 函数内声明的所有变量（但不涉及赋值）都被“提前”至函数顶部。这步操作是在代码开始运行之前、<a href="http://www.slideshare.net/lijing00333/javascript-engine" target="_blank" rel="noopener">JavaScript 引擎</a>的“预编译”阶段进行的。上述代码编译如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i;    <span class="comment">// 变量声明提前</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'for 语句内，i='</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'for 语句外，i='</span> + i);</span><br></pre></td></tr></table></figure><p>变量声明提前意味着：在函数内部任意地方声明变量和在函数顶部声明变量是完全一样的。为了让源代码能够非常清晰地反映出真实的变量作用域，避免潜藏错误，规范要求始终在函数顶部使用单 <code>var</code> 语句统一声明所有变量，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个变量声明都独占一行，同时注意每行的缩进</span></span><br><span class="line"><span class="keyword">var</span> iptUsername = $(<span class="string">'input[name="username"]'</span>),</span><br><span class="line">    iptPwd = $(<span class="string">'input[name="pwd"]'</span>),</span><br><span class="line">    btnLogin = $(<span class="string">'#js-btn-login'</span>),</span><br><span class="line">    fnLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>和上述变量声明提前一样，函数声明也会被 JavaScript 引擎提前（function declaration hoisting）。因此，在代码中函数的调用可以出现在函数声明之前：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line">doSomeThing();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello world!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是可以正常运行的，因为 JavaScript 引擎将这段代码解析为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明提前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomeThing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello world!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomeThing();</span><br></pre></td></tr></table></figure><p>由于 JavaScript 的这种行为会放宽函数必须 <strong>先声明后使用</strong> 的要求，因此会导致代码混乱。</p><p>规范要求函数始终 <strong>先声明后使用</strong>。</p><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>更好的办法是使用 <strong>函数表达式</strong> 代替函数声明：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> doSomeThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello world!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">doSomeThing();</span><br></pre></td></tr></table></figure><p>这种形式看起来像是常规的变量赋值语句，即创建一个函数并将它赋值给变量 <code>doSomeThing</code>。这种情况下创建的函数叫做 <strong>匿名函数（anonymous function）</strong>（也称为 <strong>拉姆达函数</strong>），因为 <code>function</code> 关键字后面没有标识符，其 <code>name</code> 属性为空。</p><p>与使用函数声明的区别在于，如果执行顺序颠倒，函数调用 <code>doSomeThing()</code> 将会报错。因为函数表达式必须等到解析器执行到它所在的代码行，才会真正被解释执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> doSomeThing === <span class="string">'undefined'</span>;    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doSomeThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello world!'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>除此之外，函数声明与函数表达式的语法其实是等价的。尽管如此，规范仍然要求优先使用函数表达式，原因有二：</p><ul><li>强制开发者 <strong>先声明后使用</strong> 函数，避免函数声明提升带来的混乱；</li><li>函数表达式更能明确表示一个包含函数的变量。要学好这门语言，理解 <strong>函数就是对象</strong> 是很重要的。因为函数是对象，所以它们可以像任何其它的值一样被使用。例如：<ul><li>函数可以保存在变量、对象和数组中；</li><li>函数可以被当做 <strong>参数</strong> 传递给其它函数，也可以被作为函数的 <strong>返回值</strong>；</li><li>函数可以拥有方法。</li></ul></li></ul><h2 id="立即执行的函数"><a href="#立即执行的函数" class="headerlink" title="立即执行的函数"></a>立即执行的函数</h2><p>使用函数表达式可以声明匿名函数，并将匿名函数赋值给变量或者属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomeThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'doSomeThing'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> doSomeThing === <span class="string">'function'</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这种匿名函数可以通过在最后加上一对圆括号 <code>()</code> 来 <strong>立即执行并返回</strong> 一个值给变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不好的写法</span></span><br><span class="line"><span class="keyword">var</span> doSomeThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'doSomeThing'</span>;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> doSomeThing === <span class="string">'string'</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这种写法的问题在于，会让人误以为将一个匿名函数赋值给了这个变量。除非读完整段代码并看到最后一行的那对圆括号 <code>()</code>，否则你不会知道是将函数赋值给变量还是将函数的执行结果赋值给变量。这种困惑会影响代码的可读性。</p><p>为了让立即执行的函数能够被一眼看出来，可以用一对圆括号 <code>()</code> 将函数包起来。这样做并不会影响代码的执行结果，却能让人一眼就看出这是个立即执行的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 好的写法</span></span><br><span class="line"><span class="keyword">var</span> doSomeThing = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'doSomeThing'</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> doSomeThing === <span class="string">'string'</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="创建私有作用域"><a href="#创建私有作用域" class="headerlink" title="创建私有作用域"></a>创建私有作用域</h3><p>此外，还可以使用<a href="http://www.zuojj.com/archives/631.html" target="_blank" rel="noopener">立即执行的匿名函数（immediately executed anonymous function）</a>来创建私有作用域，从而解决全局变量污染的问题。这种函数一般是没有返回值的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hidden_variable = <span class="string">'Hello world!'</span>;    <span class="comment">// hidden_variable 只是一个局部变量</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>要注意的是在这种场景下，函数表达式外的那对圆括号 <code>()</code> 绝不能省略，因为官方的语法假定以单词 <code>function</code> 开头的语句是一个函数声明语句，而函数声明语句是无法匿名的，否则会报错。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《编写可维护的 JavaScript》</li><li>《JavaScript 高级程序设计》</li><li>《JavaScript 权威指南》</li><li>《JavaScript 语言精粹》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 类型判断</title>
      <link href="2016/02/19/javascript-data-types-determine/"/>
      <url>2016/02/19/javascript-data-types-determine/</url>
      
        <content type="html"><![CDATA[<p>鉴于 ECMAScript 是松散类型（loosely typed）的，因此需要有一种手段来检测给定变量的数据类型——<code>typeof</code> 和 <code>instanceof</code> 操作符提供了这方面的信息：</p><h1 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h1><p><code>typeof</code> 操作符可能返回下列某个字符串：</p><table><thead><tr><th>类型字符串</th><th>描述</th></tr></thead><tbody><tr><td><code>undefined</code></td><td>如果这个值未定义</td></tr><tr><td><code>boolean</code></td><td>如果这个值是布尔值</td></tr><tr><td><code>string</code></td><td>如果这个值是字符串</td></tr><tr><td><code>number</code></td><td>如果这个值是数值</td></tr><tr><td><code>object</code></td><td>如果这个值是对象或 <code>null</code></td></tr><tr><td><code>function</code></td><td>如果这个值是函数</td></tr></tbody></table><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span></span><br><span class="line"><span class="string">"undefined"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span></span><br><span class="line"><span class="string">"object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span></span><br><span class="line"><span class="string">"boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">false</span></span><br><span class="line"><span class="string">"boolean"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">''</span></span><br><span class="line"><span class="string">"string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">""</span></span><br><span class="line"><span class="string">"string"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">70</span></span><br><span class="line"><span class="string">"number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">070</span></span><br><span class="line"><span class="string">"number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">0xA</span></span><br><span class="line"><span class="string">"number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3.125e7</span></span><br><span class="line"><span class="string">"number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">3e-7</span></span><br><span class="line"><span class="string">"number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span></span><br><span class="line"><span class="string">"number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">Infinity</span></span><br><span class="line"><span class="string">"number"</span></span><br></pre></td></tr></table></figure><h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>由于在检测对象的值时，<code>typeof</code> 无法辨别出 <code>null</code> 与对象，因此建议使用下列这样的判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> my_value = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (my_value &amp;&amp; <span class="keyword">typeof</span> my_value === <span class="string">'object'</span>) &#123;    <span class="comment">// null 值为 false</span></span><br><span class="line">    <span class="comment">// my_value 是一个对象或数组！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h2><p><code>typeof</code> 无法辨别出 <code>NaN</code> 和数字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> === <span class="string">'number'</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>isNaN()</code> 函数可以解决这类判断问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>);     <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h2><p><code>typeof</code> 无法辨别出 <code>Infinity</code> 和数字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">Infinity</span> === <span class="string">'number'</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可以自定义一个 <code>isNumber()</code> 函数用于判断数字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">'number'</span> </span><br><span class="line">        &amp;&amp; <span class="built_in">isFinite</span>(value);    <span class="comment">// isFinite 函数会筛选掉 NaN 和 Infinity</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">isNumber(<span class="number">100</span>);    <span class="comment">// true</span></span><br><span class="line">isNumber(<span class="literal">NaN</span>);    <span class="comment">// false</span></span><br><span class="line">isNumber(<span class="literal">Infinity</span>);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><p>比较特殊的类型是 <code>function</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="string">"function"</span></span><br></pre></td></tr></table></figure><p>从技术角度讲，函数在 ECMAScript 中是对象，而不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 <code>typeof</code> 操作符来区分函数和其他对象是有必要的。</p><h1 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h1><p><code>typeof</code> 操作符存在一个问题：在判断任何引用类型时都会返回 <code>&quot;object&quot;</code>，因此 ECMAScript 引入了 <code>instanceof</code> 操作符来解决这个问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>() <span class="keyword">instanceof</span> <span class="built_in">Date</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《JavaScript 高级程序设计》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 引用类型之 Array</title>
      <link href="2016/02/18/javascript-array/"/>
      <url>2016/02/18/javascript-array/</url>
      
        <content type="html"><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>除了 <code>Object</code> 之外，<code>Array</code> 类型恐怕是 ECMAScript 中最常用的类型了。ECMAScript 的数组特点如下：</p><ul><li>数组是有序列表；</li><li>数组的每一项可以保存不同类型的数据；</li><li>数组的大小可以动态调整，可以随着数据的添加自动增长以容纳新增数据。</li></ul><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>创建 <code>Array</code> 实例的方式有两种。第一种是使用 <code>Array</code> 构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();    <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);    <span class="comment">// 创建 length 值为 20 的数组</span></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);    <span class="comment">// 创建一个包含 3 个字符串值的数组</span></span><br></pre></td></tr></table></figure><p>另一种方式是使用数组字面量表示法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [];    <span class="comment">// 创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];    <span class="comment">// 创建一个包含 3 个字符串的数组</span></span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>针对数组有很多常用方法：</p><h3 id="栈、队列方法"><a href="#栈、队列方法" class="headerlink" title="栈、队列方法"></a>栈、队列方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>push()</code></td><td>入栈（向数组的末尾添加一个或更多元素，并返回新的长度）</td></tr><tr><td><code>pop()</code></td><td>出栈（删除并返回数组的最后一个元素）</td></tr><tr><td><code>unshift()</code></td><td>向数组的开头添加一个或更多元素，并返回新的长度。</td></tr><tr><td><code>shift()</code></td><td>出队（删除并返回数组的第一个元素）</td></tr></tbody></table><h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>sort()</code></td><td>按升序排列数组项</td></tr><tr><td><code>reverse()</code></td><td>反转数组项的顺序</td></tr></tbody></table><h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>concat()</code></td><td>拼接并返回新数组</td></tr><tr><td><code>slice()</code></td><td>裁剪并返回新数组</td></tr></tbody></table><h3 id="拼接方法"><a href="#拼接方法" class="headerlink" title="拼接方法"></a>拼接方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>join()</code></td><td>把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。</td></tr><tr><td><code>toString()</code></td><td>把数组转换为字符串，并返回结果。</td></tr><tr><td><code>toLocaleString()</code></td><td>把数组转换为本地字符串，并返回结果。</td></tr></tbody></table><h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><p>ECMAScript 5 新增的方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>indexOf()</code></td><td>查询特定项在数组的起始索引</td></tr><tr><td><code>lastIndexOf()</code></td><td>查询特定项在数组的结束索引</td></tr></tbody></table><h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>ECMAScript 5 新增的方法：</p><p><code>every()</code> 和 <code>some()</code> 是一组相似的方法，用于查询数组中的项是否满足某个条件：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>every()</code></td><td>对数组中的每一项运行给定函数，如果该函数对每一项都返回 <code>true</code>，则返回 <code>true</code>。</td></tr><tr><td><code>some()</code></td><td>对数组中的每一项运行给定函数，如果该函数对任一项返回 <code>true</code>，则返回 <code>true</code>。</td></tr></tbody></table><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>filter()</code></td><td>对数组中的每一项运行给定函数，返回该函数会返回 <code>true</code> 的项组成的数组。</td></tr><tr><td><code>map()</code></td><td>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</td></tr><tr><td><code>forEach()</code></td><td>对数组中的每一项运行给定函数。这个方法没有返回值。</td></tr></tbody></table><p>这些数组方法通过执行不同的操作，可以大大方便处理数组的任务。</p><h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><p>ECMAScript 5 新增的方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>reduce()</code></td><td>从数组的第一项开始，逐个遍历到最后，执行给定的归并函数。</td></tr><tr><td><code>reduceRight()</code></td><td>从数组的最后一项开始，向前遍历到第一项，执行给定的归并函数。</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《JavaScript 高级程序设计》</li><li>《<a href="https://www.runoob.com/w3cnote/es6-array.html" target="_blank" rel="noopener">ES6 数组</a>》</li><li>《<a href="https://www.w3school.com.cn/jsref/jsref_obj_array.asp" target="_blank" rel="noopener">JavaScript Array 对象</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 引用类型之 Object</title>
      <link href="2016/02/17/javascript-object/"/>
      <url>2016/02/17/javascript-object/</url>
      
        <content type="html"><![CDATA[<h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>ECMAScript 中使用最多的类型就是 <code>Object</code>。虽然 <code>Object</code> 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们是非常理想的选择。</p><h2 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h2><p>创建 <code>Object</code> 实例的方式有两种。第一种是使用 <code>new</code> 操作符后跟 <code>Object</code> 构造函数，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure><p>另一种方式是使用对象字面量表示法。对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name : <span class="string">"Nicholas"</span>,</span><br><span class="line">    age : <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用这种对象字面量语法要求的代码量更少，而且能够给人以封装数据的感觉。</p><p>实际上，对象字面量也是向函数传递大量可选参数的首选方式。一般来讲，命名参数虽然容易处理，但在有多个可选参数的情况下就会显示不够灵活。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">arg0, arg1, arg2, arg3, arg4</span>) </span>&#123;　　</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething(<span class="string">''</span>, <span class="string">'foo'</span>, <span class="number">5</span>, [], <span class="literal">false</span>);    <span class="comment">// 这里必须传够五个命名参数，无法跳过中间某个可选参数</span></span><br></pre></td></tr></table></figure><p>但最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 不传任何参数也能正常运行</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">arguments</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 undefined 的参数设置默认值</span></span><br><span class="line">    <span class="keyword">var</span> oArgs = <span class="built_in">arguments</span>[<span class="number">0</span>]</span><br><span class="line">        arg0  = oArgs.arg0 || <span class="string">""</span>,</span><br><span class="line">        arg1  = oArgs.arg1 || <span class="string">""</span>,</span><br><span class="line">        arg2  = oArgs.arg2 || <span class="number">0</span>,</span><br><span class="line">        arg3  = oArgs.arg3 || [],</span><br><span class="line">        arg4  = oArgs.arg4 || <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入可选参数而不报错</span></span><br><span class="line">doSomething(&#123;</span><br><span class="line">    arg1: <span class="string">"foo"</span>,</span><br><span class="line">    arg2: <span class="number">5</span>,</span><br><span class="line">    arg4: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h2><p>由于在 ECMAScript 中 <code>Object</code> 是所有对象的基础，因此所有对象都具有下列这些基本的属性和方法：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><code>constructor</code></td><td>保存着用于创建当前对象的函数。</td></tr><tr><td><code>isPrototypeOf(object)</code></td><td>用于检查传入的对象是否是传入对象的原型。</td></tr><tr><td><code>hasOwnProperty(propertyName)</code></td><td>用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。</td></tr><tr><td><code>propertyIsEnumerable(propertyName)</code></td><td>用于检查给定的属性是否能够使用 <code>for-in</code> 语句来枚举。</td></tr><tr><td><code>toLocaleString()</code></td><td>返回对象的字符串表示，该字符串与执行环境的地区对应。</td></tr><tr><td><code>toString()</code></td><td>返回对象的字符串表示。</td></tr><tr><td><code>valueOf()</code></td><td>返回对象的字符串、数值或布尔值表示。通常与 <code>toString()</code> 方法的返回值相同。</td></tr></tbody></table><p>例如，要检查某个对象的专有属性，可以使用 <code>hasOwnProperty(propertyName)</code> 方法进行判断：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">foo</span>: <span class="string">'foo'</span>, <span class="attr">bar</span>: <span class="string">'bar'</span>&#125;;</span><br><span class="line">obj.hasOwnProperty(<span class="string">'foo'</span>)    <span class="comment">// true</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">'constructor'</span>)    <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《JavaScript 高级程序设计》</li><li>《JavaScript 语言精粹》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 基本数据类型</title>
      <link href="2016/02/11/javascript-primitive-types/"/>
      <url>2016/02/11/javascript-primitive-types/</url>
      
        <content type="html"><![CDATA[<p>尽管 ECMAScript 是一门弱类型语言，但它的内部提供了五种基本数据类型以便开发者使用。下面分别介绍：</p><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h2><p>在使用 <code>var</code> 声明变量但未对其加以初始化时，这个变量的值就是 <code>undefined</code>。</p><h2 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h2><p>表示一个空对象指针。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String 类型用于表示 16 位 Unicode 字符组成的字符序列，即字符串。字符串可以由双引号（<code>&quot;&quot;</code>）或单引号（<code>&#39;&#39;</code>）表示，内含转义字符。</p><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>虽然 Boolean 类型只有两个字面值——<code>true</code>、<code>false</code>，但 ECMAScript 中所有类型的值都有与之等价的值。下表给出了转换规则：</p><h3 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h3><table><thead><tr><th>数据类型</th><th>转换为 <code>true</code> 的值</th><th>转换为 <code>false</code> 的值</th></tr></thead><tbody><tr><td>Boolean</td><td><code>true</code></td><td><code>false</code></td></tr><tr><td>String</td><td>任何非空字符串</td><td><code>&quot;&quot;</code>（空字符串）</td></tr><tr><td>Number</td><td>任何非零数字值（包括无穷大 <code>Infinity</code>）</td><td><code>0</code>、<code>NaN</code></td></tr><tr><td>Object</td><td>任何对象</td><td><code>null</code></td></tr><tr><td>Undefined</td><td>不适用</td><td><code>undefined</code></td></tr></tbody></table><p>这些转换规则对于理解流控制语句（如 <code>if</code> 语句）、布尔操作符（<code>!</code>、<code>&amp;&amp;</code>、<code>||</code>）自动执行相应的 Boolean 转换非常重要，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="string">'false'</span>) &#123;<span class="built_in">console</span>.log(<span class="string">'true'</span>)&#125;</span><br><span class="line"><span class="literal">true</span>    <span class="comment">// 输出 true，因为进行了自动类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.hello;    <span class="comment">// undefined，因为该成员属性不存在</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">window</span>.hello || <span class="string">'unknown'</span>;    <span class="comment">// 布尔操作符 || 可以用来填充默认值</span></span><br><span class="line">foo;    <span class="comment">// 值为 'unknown'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.hello.world;    <span class="comment">// 抛出 TypeError 异常，因为尝试从 undefined 的成员属性中取值</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="built_in">window</span>.hello &amp;&amp; <span class="built_in">window</span>.hello.world;    <span class="comment">// 布尔操作符 &amp;&amp; 可以用来避免该异常</span></span><br><span class="line">bar;    <span class="comment">// 值为 undefined</span></span><br></pre></td></tr></table></figure><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><table><thead><tr><th>字面量</th><th>描述</th></tr></thead><tbody><tr><td><code>70</code></td><td>十进制的 70。</td></tr><tr><td><code>-70</code></td><td>十进制的负 70。</td></tr><tr><td><code>070</code></td><td>八进制的 56。八进制字面值的第一位必须是零(<code>0</code>)，然后是八进制数字序列(<code>0~7</code>)。</td></tr><tr><td><code>0xA</code></td><td>十六进制的 10。十六进制字面值的前两位必须是 <code>0x</code>，后跟任何十六进制数字(<code>0~9</code> 及 <code>A~F</code>)。</td></tr><tr><td><code>3.125e7</code></td><td>科学计数法，表示“3.125 乘以 10 的 7 次幂（<code>3.125 * Math.pow(10, 7)</code>）”，即 31250000。推荐使用这种简洁的方式来表示那些极大或极小的数值。</td></tr><tr><td><code>3e-7</code></td><td>科学计数法，表示 0.0000003。默认情况下，ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法表示的数值。</td></tr><tr><td><code>Infinity</code></td><td>如果某次计算的结果得到了一个超出 ECMAScript 数值范围的值，那么该值将被自动转换成特殊的 <code>Infinity</code> 值。该值将无法继续参与下一次的计算，因为 <code>Infinity</code> 不是能够参与计算的数值。要想确定一个数值是不是有穷的（即是否位于最小和最大的数值之间），可以使用 <code>isFinite()</code> 函数进行判断。</td></tr><tr><td><code>NaN</code></td><td>非数值（Not a Number）是一个特殊的数值，用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。ECMAScript 定义了 <code>isNaN()</code> 函数，接收任何类型参数并（调用 <code>Number()</code> 函数）进行 <strong>自动类型转换</strong>，如果转换失败则这个参数“不是数值”。</td></tr></tbody></table><h3 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h3><p>Number 类型使用 IEEE754 格式来表示整数和浮点数值。这种格式有个通病：浮点数值计算会产生 <strong>舍入误差</strong> 的问题，从而导致无法测试 <strong>特定的</strong> 浮点数值，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a + b == <span class="number">0.3</span>) &#123; <span class="comment">// 不要做这样的浮点测试！例如 0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。</span></span><br><span class="line">    alert(<span class="string">"You got 0.3."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，浮点数值的最高精度虽然有 17 位小数，但在进行算术计算时其精确度远远不如整数。因此建议先将浮点数值转换成整数值进行计算后，再转回浮点数，如此一来就能缓解这个问题。</p><p>此外，由于保存浮点数值需要的内存空间是保存整数值的 <strong>两倍</strong>，因此 ECMAScript 会不失时机地将浮点数值转换为整数值，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.</span>;    <span class="comment">// 小数点后面没有数字——解析为 1</span></span><br><span class="line"><span class="keyword">var</span> floatNum2 = <span class="number">10.0</span>;  <span class="comment">// 浮点数值本身表示整数——解析为 10</span></span><br></pre></td></tr></table></figure><h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>由于内存限制，ECMAScript 并不能保存世界上所有的数值，其限制范围下表：</p><table><thead><tr><th>常量</th><th>描述</th></tr></thead><tbody><tr><td><code>Number.MIN_VALUE</code></td><td>ECMAScript 能够表示的最小数值，大多数浏览器中为 <code>5e-324</code></td></tr><tr><td><code>Number.MAX_VALUE</code></td><td>ECMAScript 能够表示的最大数值，大多数浏览器中为 <code>1.7976931348623157e+308</code></td></tr></tbody></table><p>如果某次计算的结果得到了一个超出 ECMAScript 数值范围的值，那么该值将被自动转换成特殊的 <code>Infinity</code> 值。该值将无法继续参与下一次的计算，因为 <code>Infinity</code> 不是能够参与计算的数值。要想确定一个数值是不是有穷的（即是否位于最小和最大的数值之间），可以使用 <code>isFinite()</code> 函数进行判断。</p><h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p>有 3 个函数可以把非数值转换为数值：<code>Number()</code>、<code>parseInt()</code> 和 <code>parseFloat()</code>。第一个函数可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。<br>但由于 <code>Number()</code> 函数在转换字符串时比较复杂而且不够合理，因此更常用的是 <code>parseInt()</code> 和 <code>parseFloat()</code> 函数。</p><p><code>parseInt()</code> 函数在转换字符串时，更多的是看其是否符合数值模式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">'  70'</span>);       <span class="comment">// 70（忽略字符串前面的空格，直至找到第一个非空格字符）</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">'blue'</span>);       <span class="comment">// NaN（如果第一个字符不是数字字符或者负号，返回 NaN）</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">""</span>);           <span class="comment">// NaN（转换空字符串，也返回 NaN）</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="string">"1234blue"</span>);   <span class="comment">// 1234（解析直至遇到一个非数字字符）</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>);         <span class="comment">// 22（小数点并不是有效的数字字符）</span></span><br></pre></td></tr></table></figure><p>如果字符串中的第一个字符是数字字符，<code>parseInt()</code> 也能够识别出各种整数格式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">"70"</span>);         <span class="comment">// 70(十进制数)</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">"070"</span>);        <span class="comment">// 存在分歧，ECMAScript 3 认为是 56 (八进制),ECMAScript 5 认为是 70 (十进制)</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"0xA"</span>);        <span class="comment">// 10(十六进制数)</span></span><br></pre></td></tr></table></figure><p>为了消除在使用 <code>parseInt()</code> 函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">2</span>);    <span class="comment">// 2 (按二进制解析)</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">8</span>);    <span class="comment">// 8 (按八进制解析)</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">10</span>);   <span class="comment">// 10 (按十进制解析)</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="string">"10"</span>, <span class="number">16</span>);   <span class="comment">// 16 (按十六进制解析)</span></span><br></pre></td></tr></table></figure><p>多数情况下，我们要解析的都是十进制数值，因此始终将 10 作为第二个参数是非常必要的。</p><h1 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h1><p>为了便于操作基本类型值，ECMAScript 还提供了以下 3 个特殊的引用类型，它们都具有与各自的基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就会<strong>隐式地</strong>创建一个对应的基本包装类型的对象，从而让我们能够调用一些实用方法来操作这些数据。</p><table><thead><tr><th>字面量</th><th>包装方法</th><th>实用方法</th></tr></thead><tbody><tr><td><code>true</code>、<code>false</code></td><td><code>Boolean()</code></td><td></td></tr><tr><td><code>70</code> 十进制<br/><code>070</code> 八进制<br/><code>0xA</code> 十六进制<br/><code>3.125e7</code> 科学计数法</td><td><code>Number()</code></td><td><code>toFixed(fractionDigits)</code> 按照指定的小数位四舍五入<br/><code>toExponential(fractionDigits)</code> 科学计数法<br/><code>toPrecision(precision)</code><br/><code>toString(radix)</code> 使用指定基数（即多少进制）将数字转换为字符串</td></tr><tr><td><code>&quot;&quot;</code>、<code>&#39;&#39;</code></td><td><code>String()</code></td><td><code>charAt()</code><br/><code>concat()</code><br/><code>substring()</code><br/><code>indexOf()</code><br/><code>toLowerCase()</code><br/><code>match()</code><br/>……</td></tr></tbody></table><p>不建议<strong>显式地</strong>创建基本包装类型的对象，因为会造成 <code>typeof</code> 操作符判断不符合预期：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="string">"object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">70</span>)</span><br><span class="line"><span class="string">"object"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">''</span>)</span><br><span class="line"><span class="string">"object"</span></span><br></pre></td></tr></table></figure><h1 id="快速类型转换"><a href="#快速类型转换" class="headerlink" title="快速类型转换"></a>快速类型转换</h1><p>最后是一些类型转换的小技巧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myVar   = <span class="string">"3.14159"</span>,</span><br><span class="line">    str     = <span class="string">""</span>+myVar, <span class="comment">//  to string</span></span><br><span class="line">    int     = ~~myVar,  <span class="comment">//  to integer</span></span><br><span class="line">    float   = <span class="number">1</span>*myVar,  <span class="comment">//  to float</span></span><br><span class="line">    bool    = !!myVar,  <span class="comment">//  to boolean - any string with length and any number except 0 are true</span></span><br><span class="line">    array   = [myVar];  <span class="comment">//  to array</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《JavaScript 高级程序设计》</li><li>《JavaScript 语言精粹》</li><li>《<a href="http://www.w3school.com.cn/js/pro_js_typeconversion.asp" target="_blank" rel="noopener">ECMAScript 类型转换</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 简介</title>
      <link href="2016/02/10/javascript-intro/"/>
      <url>2016/02/10/javascript-intro/</url>
      
        <content type="html"><![CDATA[<p>一个完整的 JavaScript 实现由下列三个不同的部分组成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------+</span><br><span class="line">|                          |</span><br><span class="line">|        JavaScript        |</span><br><span class="line">|                          |</span><br><span class="line">| +----------+ +---+ +---+ |</span><br><span class="line">| |ECMAScript| |DOM| |BOM| |</span><br><span class="line">| +----------+ +---+ +---+ |</span><br><span class="line">|                          |</span><br><span class="line">+--------------------------+</span><br></pre></td></tr></table></figure><p>下面分别介绍这些部分：</p><h1 id="核心（ECMAScript）"><a href="#核心（ECMAScript）" class="headerlink" title="核心（ECMAScript）"></a>核心（ECMAScript）</h1><p>以网景的 Netscape Navigator 内置的 JavaScript 1.1 为蓝本，由 ECMA-262 定义的 ECMAScript 是一种 <strong>与 Web 浏览器没有依赖关系</strong> 的脚本语言标准，它由下列基础部分组成：</p><ul><li>语法（Syntax）</li><li>类型（Types）</li><li>语句（Statements）</li><li>关键字（Keywords）</li><li>保留字（Reserved words）</li><li>操作符（Operators）</li><li>对象（Objects）</li></ul><h2 id="宿主环境"><a href="#宿主环境" class="headerlink" title="宿主环境"></a>宿主环境</h2><p>ECMA-262 定义的只是这门语言的基础部分，而在此基础之上，<strong>宿主环境（host environment）</strong> 可以构建更完善的脚本语言。常见的宿主环境有：</p><ul><li>Web Broswer</li><li>Node.js</li><li>Adobe Flash</li></ul><p>以我们最常见的 Web Broswer 为例，不仅提供了基本的 ECMAScript 实现，同时还提供了该语言的扩展，以便语言与环境之间对接交互。而这些扩展——如 DOM，则利用 ECMAScript 的核心类型（Types）和语法（Syntax）提供更多更具体的功能，以便实现针对环境的操作。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>ECMA-262 目前已经发布了六个大版本的 ECMAScript：</p><table><thead><tr><th>版本</th><th>发布时间</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>1997 年 6 月</td><td>以网景的 Netscape Navigator 内置的 JavaScript 1.1 为蓝本制定，但删除了所有针对浏览器的代码，并支持 Unicode 标准（从而支持多语言开发）。</td></tr><tr><td>2</td><td>1998 年 6 月</td><td>基本没有修改。</td></tr><tr><td>3</td><td>1999 年 12 月</td><td>标准的第一次大修改，涉及：新增的正则表达式，更好的字符串处理，新的控制语句，try / catch 异常处理的支持，更严格的错误定义，数值格式化输出和其它增强功能。该版标志着 ECMAScript 成为了一门真正的编程语言。</td></tr><tr><td><del>4</del></td><td><del>已废弃</del></td><td>该版对 ECMAScript 进行了大刀阔斧的修改，但由于复杂的语言政治分歧而被废弃了。</td></tr><tr><td>5</td><td>2009 年 12 月</td><td>澄清了第三版规范许多模糊之处，并增加了一些新功能，如：原生 JSON 对象、继承的方法和高级属性定义，以及“严格模式（strict mode）”。<strong>是目前浏览器兼容性最好、最主流的版本。</strong></td></tr><tr><td>5.1</td><td>2011 年 6 月</td><td>基本没有修改。</td></tr><tr><td>6</td><td>2015 年 6 月</td><td>标准的又一次大修改，被称为 ECMAScript 2015。它为编写日益复杂的应用程序增加了大量重要的新语法，包括：类（classes）和模块（modules）、新的迭代器（iterators）和 for/of 循环（loops）、Python 风格的生成器（generators）和生成器表达式、arrow functions, binary data, typed arrays, collections (maps, sets and weak maps), promises, number and math enhancements, reflection, and proxies …<br/>更多特性详见<a href="http://es6-features.org/#Constants" target="_blank" rel="noopener">这里</a>。</td></tr><tr><td>7</td><td>制定中</td><td></td></tr></tbody></table><h2 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h2><p>各个浏览器对 ECMAScript 5 的兼容性可查看 <a href="http://caniuse.com/#feat=es5" target="_blank" rel="noopener">这里</a> 。</p><h1 id="文档对象模型（DOM）"><a href="#文档对象模型（DOM）" class="headerlink" title="文档对象模型（DOM）"></a>文档对象模型（DOM）</h1><p>文档对象模型（DOM，Document Object Model）是针对 XML 但经过扩展用于 HTML 的 API。借助 DOM 提供的 API，开发人员可以轻松自如地删除、添加、替换或修改任何节点，获得控制页面内容和结构的主动权。</p><h1 id="浏览器对象模型（BOM）"><a href="#浏览器对象模型（BOM）" class="headerlink" title="浏览器对象模型（BOM）"></a>浏览器对象模型（BOM）</h1><p>浏览器对象模型（BOM，Browser Object Model）是一组浏览器提供的自定义扩展 API，可以控制浏览器显示的页面以外的部分，例如：</p><ul><li>弹出新浏览器窗口的功能；</li><li>移动、缩放和关闭浏览器窗口的功能；</li><li>提供浏览器详细信息的 navigator 对象；</li><li>提供浏览器所加载页面的详细信息的 location 对象；</li><li>提供用户显示器分辨率详细信息的 screen 对象；</li><li>对 cookies 的支持；</li><li>像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象。</li></ul><p>常用的 BOM API 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">window</span><br><span class="line">  |</span><br><span class="line">  +--&gt; document</span><br><span class="line">  |</span><br><span class="line">  +--&gt; location</span><br><span class="line">  |</span><br><span class="line">  +--&gt; navigator</span><br><span class="line">  |</span><br><span class="line">  +--&gt; screen</span><br><span class="line">  |</span><br><span class="line">  +--&gt; history</span><br><span class="line">  |</span><br><span class="line">  +--&gt; ...</span><br></pre></td></tr></table></figure><p>由于没有 BOM 标准可以遵循，因此每个浏览器都有自己的实现。虽然也存在一些事实标准，例如要有 window 对象和 navigator 对象等，但每个浏览器都会为这两个对象乃至其它对象定义自己的属性和方法。如今 HTML 5 致力于把很多 BOM 功能纳入正式规范，BOM 实现的细节有望朝着兼容性越来越高的方向发展。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《JavaScript 高级程序设计》</li><li>《<a href="https://en.wikipedia.org/wiki/ECMAScript" target="_blank" rel="noopener">ECMAScript - Wikipedia</a>》</li><li>《<a href="https://en.wikipedia.org/wiki/Document_Object_Model" target="_blank" rel="noopener">Document Object Model - Wikipedia</a>》</li><li>《<a href="https://en.wikipedia.org/wiki/Browser_Object_Model" target="_blank" rel="noopener">Browser Object Model - Wikipedia</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统主要目录介绍</title>
      <link href="2015/11/22/fhs/"/>
      <url>2015/11/22/fhs/</url>
      
        <content type="html"><![CDATA[<p>从 Windows 转到 Linux 的初学者，往往对 Linux 的目录结构感到无所适从。本文介绍的 FHS 标准，是理解这些目录结构的关键。</p><h1 id="FHS-标准"><a href="#FHS-标准" class="headerlink" title="FHS 标准"></a>FHS 标准</h1><p>FHS（Filesystem Hierarchy Standard，文件系统层次结构标准）采用树形结构组织文件，并定义了 Linux 系统中主要目录的用途、所需要的最小构成的文件和目录，同时还给出了例外处理与矛盾处理。多数 Linux 版本采用这种目录组织形式，类似于 Windows 操作系统中 C 盘的文件目录。</p><p>事实上，FHS 针对目录树结构仅定义出两层目录（<code>/</code> 及 <code>/usr</code>、<code>/var</code>）底下应该放置什么数据，下面分别介绍这些目录：</p><h2 id="root"><a href="#root" class="headerlink" title="/ (root)"></a>/ (root)</h2><p>在 FHS 标准中，所有的文件和目录都必须出现在根目录 <code>/</code> 下，即使它们存储在不同的存储设备或网络主机中。此外还要求根目录 <code>/</code> 下必须要有以下目录或符号链接（symbolic links）：</p><table><thead><tr><th>目录</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>/etc</code></td><td>Host-specific system configuration</td><td>系统配置文件</td></tr><tr><td><code>/dev</code></td><td>Device files</td><td>设备文件</td></tr><tr><td><code>/bin</code></td><td>Essential command binaries (for use by all users)</td><td>重要的执行文件</td></tr><tr><td><code>/sbin</code></td><td>Essential system binaries (for use by root)</td><td>重要的系统执行文件</td></tr><tr><td><code>/lib</code></td><td>Essential shared libraries and kernel modules</td><td>执行文件所需的函数库与内核所需的模块。<code>/bin</code> 和 <code>/sbin</code> 中二进制文件必要的函数库</td></tr><tr><td><code>/boot</code></td><td>Static files of the boot loader (include kenerl file、drivers)</td><td>系统开机文件</td></tr><tr><td><code>/media</code></td><td>Mount point for removeable media</td><td></td></tr><tr><td><code>/mnt</code></td><td>Mount point for mounting a filesystem temporarily (include hard disk、U disk、CD、DVD…)</td><td></td></tr><tr><td><code>/opt</code></td><td>Add-on application software packages</td><td></td></tr><tr><td><code>/srv</code></td><td>Data for services provided by this system</td><td></td></tr><tr><td><code>/tmp</code></td><td>Temporary files</td><td>临时文件</td></tr></tbody></table><p>注意：</p><ul><li>由于根目录 <code>/</code> 与<strong>开机、还原、系统修复</strong>等操作有关，而开机过程中<strong>仅有根目录会被挂载，其它分区则是在开机完成之后才会持续进行挂载</strong>，因此，根目录下与开机过程有关的目录（即上表前六个目录）不能够与根目录分开到不同分区。</li><li>由于 FHS 的目录结构已经提供了足够的灵活性，因此标准要求，应用程序禁止在根目录下创建新的子目录，理由如下：<ul><li>这会额外占用根目录所在分区的空间，但系统管理员基于性能与安全考虑，会希望保持该分区小而简（small and simple）；</li><li>It evades whatever discipline the system administrator may have set up for distributing standard file hierarchies across mountable volumes.</li></ul></li></ul><h2 id="usr-unix-software-resource"><a href="#usr-unix-software-resource" class="headerlink" title="/usr (unix software resource)"></a>/usr (unix software resource)</h2><p>该目录与软件安装/执行有关。</p><ul><li>FHS 建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的子目录，而<strong>不要自行建立该软件自己独立的目录</strong>。</li><li>由于所有系统默认的软件（distribution 发布者提供的软件）都会放置到 <code>/usr</code> 下，因此这个目录有点类似 Windows 系统的 <code>C:\Windows\</code> 和 <code>C:\Program files\</code> 这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。</li><li>用户后续安装的应用程序，也建议放置到 <code>/usr</code> 下。</li></ul><h2 id="var-variable"><a href="#var-variable" class="headerlink" title="/var (variable)"></a>/var (variable)</h2><p>该目录与系统运作过程有关。</p><p>如果 <code>/usr</code> 是系统安装时会占用较大硬盘容量的目录，那么 <code>/var</code> 则是在系统运行时才会渐渐占用硬盘容量的目录。 <code>/var</code> 目录主要针对常态性变动的文件，包括缓存（cache）、登录文件（log file）以及某些软件运行所产生的日志文件，因此这个目录会越来越大，建议单独挂载分区。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>由于根目录所在分区的容量有限，因此像 <code>/usr</code>、<code>/var</code>、<code>/home</code> 这种大目录最好不要与根目录放在同一个分区内，而是建议单独挂载分区。如此一来不但可以提高系统性能，根目录所在的文件系统也不容易发生问题。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="http://www.ruanyifeng.com/blog/2012/02/a_history_of_unix_directory_structure.html" target="_blank" rel="noopener">Unix目录结构的来历</a>》<br>《<a href="http://vbird.dic.ksu.edu.tw/linux_basic/0210filepermission.php" target="_blank" rel="noopener">Linux 的文件权限与目录配置</a>》<br>《<a href="http://www.pathname.com/fhs/" target="_blank" rel="noopener">FHS 官方文档</a>》<br>《<a href="http://www.pathname.com/fhs/pub/fhs-2.3.html" target="_blank" rel="noopener">FHS 2.3 官方文档</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU 常用文本处理命令</title>
      <link href="2015/11/15/gnu-text-utilities/"/>
      <url>2015/11/15/gnu-text-utilities/</url>
      
        <content type="html"><![CDATA[<p>续上文。</p><p>GNU/CoreUtils 的 Text utilities 提供了一些便利的文本处理命令，配合“管道”组合使用可以大大提高文本处理效率。</p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>下面介绍一些最常用的利用管道进行组合的命令：</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p><code>grep</code> 命令使用正则表达式以行为单位进行文本搜索（global search regular expression(RE) and print out the line），其命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] &#39;PATTERN&#39; [文本文件]</span><br></pre></td></tr></table></figure><p>常用选项：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-c, --count</code></td><td>打印匹配的行数</td></tr><tr><td><code>-n, --line-number</code></td><td>打印行号</td></tr><tr><td><code>-v, --revert-match</code></td><td>反转查找</td></tr><tr><td><code>-A , --after</code></td><td>可加数字，表示打印后面n行</td></tr><tr><td><code>-B , --before</code></td><td>可加数字，表示打印前面n行</td></tr><tr><td><code>--color</code></td><td>关键字高亮</td></tr></tbody></table><h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><p><code>tr</code> 命令用于替换或删除指定的字符（注意不接收文件参数），其命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr [options] string1 string2</span><br></pre></td></tr></table></figure><p>可用于将小写转换成大写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'abcdef'</span> | tr <span class="string">'a-z'</span> <span class="string">'A-Z'</span></span><br><span class="line">ABCDEF</span><br></pre></td></tr></table></figure><p> <code>-d</code> 参数可用于删除指定的字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'abcdef'</span> | tr -d <span class="string">'def'</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p><code>-s</code> 参数可用于删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'abbbbbbbbbc'</span> | tr -s <span class="string">'b'</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure><p><code>-d</code> 和 <code>-s</code> 常用于删除所有换行符 <code>\n</code> 和合并空格 <code>[:space:]</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat logfile | tr -d <span class="string">'\n\t'</span> | tr -s [:space:]</span><br></pre></td></tr></table></figure><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p><code>cut</code> 命令以行为单位，用于截取某段数据，如字节、字符和字段。其命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut [选项] [范围] [文本文件]</span><br></pre></td></tr></table></figure><p>使用 <code>-d</code> 指定分隔符（默认为制表符），例如：<code>cut -d &#39;:&#39; -f -2 /etc/passwd</code>。</p><p>常用的几种选项如下：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-f, --fields</code></td><td>以字段为单位</td></tr><tr><td><code>-c, --characters</code></td><td>以字符为单位</td></tr><tr><td><code>-b, -- bytes</code></td><td>以字节为单位</td></tr></tbody></table><p>常用的几种范围如下：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>n</code></td><td>第 n 个</td></tr><tr><td><code>n-</code></td><td>从第 n 个到最后一个</td></tr><tr><td><code>n-m</code></td><td>从第 n 个到第 m 个</td></tr><tr><td><code>-m</code></td><td>从第一个到第 m 个</td></tr><tr><td><code>-</code></td><td>从第一个到最后一个</td></tr><tr><td><code>n,m</code></td><td>第 n、m 个</td></tr></tbody></table><p>注意，在 UTF-8 编码下，汉字占三个字节。</p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p><code>sort</code> 命令以行为单位，用于对文本文件内容进行<strong>排序</strong>。其命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort [选项] [文本文件]</span><br></pre></td></tr></table></figure><p>常用的选项如下：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-n</code></td><td>依照数值的大小排序（默认是以文字）</td></tr><tr><td><code>-r</code></td><td>反向排序</td></tr></tbody></table><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p><code>uniq</code> 命令以行为单位，用于<strong>合并</strong>文本文件中重复出现的行列。它比较相邻的行，在正常情况下，第二个及以后更多个重复行将被删去，因此在合并前常常会先使用 <code>sort</code> 命令排序。行比较是根据所用字符集的排序序列进行的。其命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq [选项] [文本文件]</span><br></pre></td></tr></table></figure><p>常用的选项如下：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-i</code></td><td>忽略大小写</td></tr><tr><td><code>-c</code></td><td>进行计数</td></tr><tr><td><code>-d</code></td><td>只显示重复行</td></tr><tr><td><code>-u</code></td><td>只显示不重复的行</td></tr></tbody></table><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p><code>wc</code> 命令用于统计字节数、字数、行数，其命令格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [选项] [文本文件]</span><br></pre></td></tr></table></figure><p>常用的选项如下：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-l, --lines</code></td><td>只显示行数</td></tr><tr><td><code>-w, --words</code></td><td>只显示字数</td></tr><tr><td><code>-c, --chars 或 --bytes</code></td><td>只显示字节数</td></tr></tbody></table><h2 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h2><p><code>tee</code> 是一种双向重定向命令，用于可以将数据流处理过程中的<strong>某段结果</strong>保存到文件，其处理过程如下：</p><p><img src="/img/gnu-text-utilities/tee.png" alt="tee"></p><p>常用的选项如下：</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-a, --append</code></td><td>附加到既有文件的后面，而非覆盖它</td></tr><tr><td><code>-i, --ignore-interrupts</code></td><td>忽略中断信号</td></tr></tbody></table><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>1、统计 Nginx 独立 IP 数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cut -d &quot; &quot; -f 1 nginx_log | sort | uniq | wc –l</span><br></pre></td></tr></table></figure><p>2、统计当前用户最常用的 10 条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cut -d &quot; &quot; -f 1 ~&#x2F;.bash_history | sort | uniq -c | sort -nr | head</span><br></pre></td></tr></table></figure><p>3、统计重复行，逆序方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sort &#x2F;data&#x2F;tradehistory_20150804.txt | uniq -cd | sort -nr</span><br></pre></td></tr></table></figure><p>4、统计多个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;data&#x2F;tradehistory_2015080*.txt | cut -d &#39;,&#39; -f 13 | sort | uniq -c | sort -nr</span><br><span class="line">29549 20150803</span><br><span class="line">24086 20150805</span><br><span class="line">19520 20150804</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU/CoreUtils 常用命令总结</title>
      <link href="2015/11/10/gnu-coreutils/"/>
      <url>2015/11/10/gnu-coreutils/</url>
      
        <content type="html"><![CDATA[<p>GNU/CoreUtils 是一组类 Unix 操作系统所需的基础软件包。它包含三组命令，常用的命令如 <code>cat</code>、<code>ls</code>、<code>rm</code>。学习 GNU/Linux 的第一步，就是要熟悉软件包下常用的命令。下面分别介绍这三组常用的命令：</p><h1 id="File-utilities"><a href="#File-utilities" class="headerlink" title="File utilities"></a>File utilities</h1><h2 id="Basic-operations"><a href="#Basic-operations" class="headerlink" title="Basic operations"></a>Basic operations</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>cp</code></td><td>Copy files and directories</td><td><code>cp -rp</code> 备份目录。<br/><code>-r</code> 递归复制目录，否则提示“略过目录‘xxx’”。<br/><code>-p</code> 保留源文件或目录的属性（包括属主、属组、权限、修改时间等）。<br/><code>-f</code> 强制覆盖。</td></tr><tr><td><code>mv</code></td><td>Move (rename) files</td><td></td></tr><tr><td><code>rm</code></td><td>Remove files or directories</td><td><code>rm -rf</code> 强制递归删除文件或目录。<br/><code>-r</code> 递归删除，将指定目录下的所有文件及子目录一并处理。<br/><code>-f</code> 强制删除文件或目录。</td></tr><tr><td><code>ln</code></td><td>Create a link to a file</td><td><code>ln -s TARGET LINK_NAME</code> 创建软链接。</td></tr><tr><td><code>mkdir</code></td><td>Create a directory</td><td><code>-p</code> 递归创建目录。</td></tr><tr><td><code>rmdir</code></td><td>Remove empty directories</td><td><code>-p</code> 递归删除空目录，如果目录非空会删除失败并提示：<code>rmdir: failed to remove &#39;xxx&#39;: Directory not empty</code></td></tr></tbody></table><h2 id="Directory-listing"><a href="#Directory-listing" class="headerlink" title="Directory listing"></a>Directory listing</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>ls</code></td><td>List directory contents</td><td><code>-l</code> 查看详细信息。<br/><code>-a</code> 显示隐藏文件。<br/><code>-d</code> 仅列出目录本身，而不是列出目录内的文件。<br/><code>-h</code> 将文件容量以人类较易读的方式（如GB、KB等）列出来。<br/><code>-t</code> 按时间排序显示，默认为新的排在前面。<br/><code>-S</code> 按文件容量大小排序，而不是用文件名。</td></tr><tr><td><code>dir</code></td><td>List directory contents briefly</td><td>Exactly like <code>ls -C -b</code></td></tr><tr><td><code>vdir</code></td><td>List directory contents verbosely</td><td>Exactly like <code>ls -l -b</code></td></tr></tbody></table><h2 id="Changing-file-attributes"><a href="#Changing-file-attributes" class="headerlink" title="Changing file attributes"></a>Changing file attributes</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>chown</code></td><td>Change file owner and group</td><td><code>chown -R owner:group /there/is/a/file</code><br/><code>-R</code> 递归修改，常用于一次性更改某一目录内所有的文件、目录。目标属主必须在 <code>/etc/passwd</code>。</td></tr><tr><td><code>chgrp</code></td><td>Change group ownership</td><td><code>-R</code> 递归修改，目标属组必须在 <code>/etc/group</code>。</td></tr><tr><td><code>chmod</code></td><td>Change access permissions</td><td><code>chmod [ugoa...][[+-=][rwxX]...][,...]</code><br/>可用：<code>u</code>、<code>g</code>、<code>o</code>、<code>a</code>，可用权限：<code>r=4</code>、<code>w=2</code>、<code>x=1</code><br/>例如：<code>chmod u+x</code></td></tr><tr><td><code>touch</code></td><td>Change file timestamps</td><td>改变文件访问和修改时间，也可用于快速创建一个文件。</td></tr></tbody></table><h2 id="Disk-usage"><a href="#Disk-usage" class="headerlink" title="Disk usage"></a>Disk usage</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>df</code></td><td>Show disk free space on file systems</td><td><code>-h</code> 以 K，M，G 为单位，更易读的方式显示。<br/><code>-i</code> list inode information instead of block usage</td></tr><tr><td><code>du</code></td><td>Show disk usage on file systems</td><td><code>-h</code> 以 K，M，G 为单位，更易读的方式显示。<br/><code>-s, --summarize</code> 汇总显示（等于 <code>--max-depth=0</code>）<br/><code>-d, --max-depth=N</code> 显示第 N 层子目录各自的大小，常用于找出最占空间的目录。例如：<code>du --max-depth=1 -h ./</code><br/><code>--exclude=PATTERN</code> Exclude files that match PATTERN.</td></tr><tr><td><code>stat</code></td><td>Return data about an inode</td><td></td></tr><tr><td><code>truncate</code></td><td>Shrink or extend the size of a file to the specified size</td><td>-s 参数指定一个大小：K, M, G, T, P, E, Z, Y</td></tr></tbody></table><h1 id="Text-utilities"><a href="#Text-utilities" class="headerlink" title="Text utilities"></a>Text utilities</h1><h2 id="Output-of-entire-files"><a href="#Output-of-entire-files" class="headerlink" title="Output of entire files"></a>Output of entire files</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>cat</code></td><td>Concatenates and prints files on the standard output</td><td>常用于连接并输出多个文件的内容。</td></tr><tr><td><code>tac</code></td><td>Concatenates and prints files on the standard output in reverse</td><td>常用于反向连接并输出多个文件的内容。</td></tr><tr><td><code>nl</code></td><td>Numbers lines of files</td><td><code>-b</code> 指定行号的方式，主要有 <code>a</code> <code>t</code>两种：<br/><code>-b a</code> 无论是否是空行，同样列出行号。<br/><code>-b t</code> 默认值，不列出空行行号。</td></tr><tr><td><code>base64</code></td><td>base64 encode/decode data and print to standard output</td><td></td></tr></tbody></table><h2 id="Output-of-parts-of-files"><a href="#Output-of-parts-of-files" class="headerlink" title="Output of parts of files"></a>Output of parts of files</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>head</code></td><td>Output the first part of files</td><td>默认输出 10 行</td></tr><tr><td><code>tail</code></td><td>Output the last part of files</td><td><code>-n</code> 输出倒数 n 行（默认输出 10 行）<br/><code>-f</code> 不停读取输出文件的最新内容，常用于实时监视日志输出，用 <code>Ctrl＋C</code> 来终止。</td></tr><tr><td><code>tailf</code></td><td></td><td>等同于 <code>tail -f -n 10</code></td></tr><tr><td><code>split</code></td><td>Split a file into pieces</td><td>用于按行、按大小分割文件</td></tr><tr><td><code>csplit</code></td><td>Split a file into context-determined pieces</td><td></td></tr></tbody></table><h2 id="Operating-on-sorted-files"><a href="#Operating-on-sorted-files" class="headerlink" title="Operating on sorted files"></a>Operating on sorted files</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>sort</code></td><td>Sort text files</td><td>详见<a href="http://www.cnblog.me/2015/11/15/gnu-text-utilities/" target="_blank" rel="noopener">本文</a></td></tr><tr><td><code>shuf</code></td><td>Shuffling text</td><td></td></tr><tr><td><code>uniq</code></td><td>Uniquify files</td><td>详见<a href="http://www.cnblog.me/2015/11/15/gnu-text-utilities/" target="_blank" rel="noopener">本文</a></td></tr></tbody></table><h2 id="Operating-on-fields"><a href="#Operating-on-fields" class="headerlink" title="Operating on fields"></a>Operating on fields</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>cut</code></td><td>Print selected parts of lines</td><td>详见<a href="http://www.cnblog.me/2015/11/15/gnu-text-utilities/" target="_blank" rel="noopener">本文</a></td></tr><tr><td><code>paste</code></td><td>Merge lines of files</td><td>合并多个文件的所有行</td></tr><tr><td><code>join</code></td><td>Joins lines of two files on a common field</td><td>合并两个文件中相同位置的行</td></tr></tbody></table><h2 id="Operating-on-characters"><a href="#Operating-on-characters" class="headerlink" title="Operating on characters"></a>Operating on characters</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>tr</code></td><td>Translate or delete characters</td><td>详见<a href="http://www.cnblog.me/2015/11/15/gnu-text-utilities/" target="_blank" rel="noopener">本文</a></td></tr><tr><td><code>expand</code></td><td>Convert tabs to spaces</td><td></td></tr><tr><td><code>unexpand</code></td><td>Convert spaces to tabs</td><td></td></tr></tbody></table><h2 id="Summarizing-files"><a href="#Summarizing-files" class="headerlink" title="Summarizing files"></a>Summarizing files</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>wc</code></td><td>Print the number of bytes, words, and lines in files</td><td>详见<a href="http://www.cnblog.me/2015/11/15/gnu-text-utilities/" target="_blank" rel="noopener">本文</a></td></tr><tr><td><code>sum</code></td><td></td><td></td></tr><tr><td><code>cksum</code></td><td></td><td></td></tr><tr><td><code>md5sum</code></td><td></td><td></td></tr><tr><td><code>sha1sum</code></td><td></td><td></td></tr><tr><td><code>sha256sum</code></td><td></td><td></td></tr><tr><td><code>sha512sum</code></td><td></td><td></td></tr></tbody></table><h1 id="Shell-utilities"><a href="#Shell-utilities" class="headerlink" title="Shell utilities"></a>Shell utilities</h1><h2 id="User-information"><a href="#User-information" class="headerlink" title="User information"></a>User information</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>id</code></td><td>Print user identity</td><td>显示当前用户的信息（uid、gid、groups）</td></tr><tr><td><code>logname</code></td><td>Print current login name</td><td></td></tr><tr><td><code>whoami</code></td><td>Print effective user ID</td><td></td></tr><tr><td><code>groups</code></td><td>Print group names a user is in</td><td></td></tr><tr><td><code>users</code></td><td>Print login names of users currently logged in</td><td></td></tr><tr><td><code>who</code></td><td>Print who is currently logged in</td><td></td></tr></tbody></table><h2 id="System-context"><a href="#System-context" class="headerlink" title="System context"></a>System context</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>date</code></td><td>Print or set system date and time</td><td><code>date +%Y-%m-%d</code>  2016-12-28</td></tr><tr><td><code>arch</code></td><td>Print machine hardware name</td><td></td></tr><tr><td><code>nproc</code></td><td>Print the number of available processors</td><td></td></tr><tr><td><code>uname</code></td><td>Print system information</td><td></td></tr><tr><td><code>hostname</code></td><td>Print or set system name</td><td></td></tr><tr><td><code>hostid</code></td><td>Print numeric host identifier</td><td></td></tr><tr><td><code>uptime</code></td><td>Print system uptime and load</td><td>常用于查看系统负载</td></tr></tbody></table><h2 id="Working-context"><a href="#Working-context" class="headerlink" title="Working context"></a>Working context</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>pwd</code></td><td>Print working directory</td><td>显示当前所在目录</td></tr><tr><td><code>stty</code></td><td>Print or change terminal characteristics</td><td></td></tr><tr><td><code>tty</code></td><td>Print file name of terminal on standard input</td><td></td></tr><tr><td><code>printenv</code></td><td>Print all or some environment variables</td><td></td></tr></tbody></table><h2 id="Modified-command-invocation"><a href="#Modified-command-invocation" class="headerlink" title="Modified command invocation"></a>Modified command invocation</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>nohup</code></td><td>Run a command immune to hangups</td><td></td></tr><tr><td><code>timeout</code></td><td>Run a command with a time limit</td><td></td></tr><tr><td><code>env</code></td><td>Run a command in a modified environment</td><td></td></tr></tbody></table><h2 id="Process-control"><a href="#Process-control" class="headerlink" title="Process control"></a>Process control</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>kill</code></td><td>Send a signal to processes</td><td></td></tr></tbody></table><h2 id="Delaying"><a href="#Delaying" class="headerlink" title="Delaying"></a>Delaying</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>sleep</code></td><td>Delay for a specified time</td><td></td></tr></tbody></table><h2 id="Redirection"><a href="#Redirection" class="headerlink" title="Redirection"></a>Redirection</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>tee</code></td><td>Redirect output to multiple files or processes</td><td>详见<a href="http://www.cnblog.me/2015/11/15/gnu-text-utilities/" target="_blank" rel="noopener">本文</a></td></tr></tbody></table><h2 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>false</code></td><td>Do nothing, unsuccessfully</td><td></td></tr><tr><td><code>true</code></td><td>Do nothing, successfully</td><td></td></tr><tr><td><code>test</code></td><td>Check file types and compare values</td><td></td></tr><tr><td><code>expr</code></td><td>Evaluate expressions</td><td></td></tr></tbody></table><h2 id="Printing-text"><a href="#Printing-text" class="headerlink" title="Printing text"></a>Printing text</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>echo</code></td><td>Print a line of text</td><td><code>-n</code> 不输出末尾换行符<br/><code>-e</code> 开启转义字符，例如：反斜杠 <code>\\</code>、换行符 <code>\n</code></td></tr><tr><td><code>printf</code></td><td>Format and print data</td><td></td></tr><tr><td><code>yes</code></td><td>Print a string until interrupted</td><td></td></tr></tbody></table><p><code>yes</code> 命令小技巧，使用管道自动输入“y”进行文件强制覆盖，方法：<code>yes | cp 源文件 目的文件</code></p><h2 id="Numeric-operations"><a href="#Numeric-operations" class="headerlink" title="Numeric operations"></a>Numeric operations</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>seq</code></td><td>Print numeric sequences</td><td></td></tr><tr><td><code>numfmt</code></td><td>Reformat numbers</td><td>常用于格式化数字</td></tr></tbody></table><h2 id="File-name-manipulation"><a href="#File-name-manipulation" class="headerlink" title="File name manipulation"></a>File name manipulation</h2><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>basename</code></td><td>Strip directory and suffix from a file name</td><td>截取出文件名</td></tr><tr><td><code>dirname</code></td><td>Strip last file name component</td><td>截取出目录名</td></tr></tbody></table><h1 id="zip-压缩文件查看命令"><a href="#zip-压缩文件查看命令" class="headerlink" title="zip 压缩文件查看命令"></a>zip 压缩文件查看命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">zip -rmq dist.zip dist</span><br><span class="line"></span><br><span class="line">-q表示不显示压缩进度状态</span><br><span class="line">-r表示子目录子文件全部压缩为zip；这部分比较重要，不然的话只有something这个文件夹被压缩，里面的没有被压缩进去</span><br><span class="line">-e表示你的压缩文件需要加密，终端会提示你输入密码的；还有种加密方法，这种是直接在命令行里做的，比如zip -r -P Password01! modudu.zip SomeDir, 就直接用Password01!来加密modudu.zip了</span><br><span class="line">-m表示压缩完删除原文件</span><br><span class="line"></span><br><span class="line">unzip [选项] dist.zip</span><br><span class="line"></span><br><span class="line">-x 文件列表 解压缩文件，但不包括指定的file文件。 </span><br><span class="line">-v 查看压缩文件目录，但不解压。 </span><br><span class="line">-t 测试文件有无损坏，但不解压。 </span><br><span class="line">-d 目录 把压缩文件解到指定目录下。 </span><br><span class="line">-z 只显示压缩文件的注解。 </span><br><span class="line">-n 不覆盖已经存在的文件。 </span><br><span class="line">-o 覆盖已存在的文件且不要求用户确认。 </span><br><span class="line">-j 不重建文档的目录结构，把所有文件解压到同一目录下。</span><br></pre></td></tr></table></figure><table><thead><tr><th>命令</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td><code>zcat</code></td><td></td><td></td></tr><tr><td><code>zless</code></td><td></td><td></td></tr><tr><td><code>zmore</code></td><td></td><td></td></tr><tr><td><code>zgrep</code></td><td></td><td></td></tr><tr><td><code>zdiff</code></td><td></td><td></td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《<a href="https://en.wikipedia.org/wiki/List_of_GNU_packages" target="_blank" rel="noopener">List of GNU packages</a>》</li><li>《<a href="https://en.wikipedia.org/wiki/GNU_Core_Utilities" target="_blank" rel="noopener">GNU Core Utilities</a>》</li><li>《<a href="http://www.gnu.org/software/coreutils/manual/html_node/index.html" target="_blank" rel="noopener">GNU Coreutils Manual</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析基于 DNS 解析方式的 GSLB</title>
      <link href="2015/09/30/cdn-gslb-dns/"/>
      <url>2015/09/30/cdn-gslb-dns/</url>
      
        <content type="html"><![CDATA[<p>GSLB（Global Server Load Balance，全局负载均衡）作为 CDN 系统架构中最核心的部分，负责流量调度。本文站在服务提供方的视角，做一些技术总结。</p><h1 id="GSLB-横向对比"><a href="#GSLB-横向对比" class="headerlink" title="GSLB 横向对比"></a>GSLB 横向对比</h1><p>下表是三种常见的实现方式对比：</p><table><thead><tr><th>比较项</th><th>基于 DNS 解析方式</th><th>基于 HTTP 重定向方式</th><th>基于 IP 路由方式</th></tr></thead><tbody><tr><td>性能</td><td>本地 DNS 服务器和用户终端 DNS 缓存能力使 GSLB 的负载得到有效分担</td><td>GSLB 处理压力大，容易成为系统性能的瓶颈</td><td>借助 IP 网络设备完成负载均衡，没有单点性能瓶颈</td></tr><tr><td>准确度</td><td>定位准确度取决于本地 DNS 覆盖范围，用户的<strong>本地 DNS 设置错误会造成定位不准确</strong></td><td>在对用户 IP 地址数据进行有效维护的前提下，定位准确且精度高</td><td>就近性调度准确，但对设备健康性等动态信息响应会有延迟</td></tr><tr><td>效率</td><td>效率约等于 DNS 系统本身处理效率</td><td>依靠服务器做处理，对硬件资源的要求高</td><td>效率约等于 IP 设备本身效率</td></tr><tr><td>扩展性</td><td>扩展性和通用性好</td><td>扩展性较差，需对各种应用协议进行定制开发</td><td>通用性好，但适用范围有限</td></tr><tr><td>商用性</td><td>在 Web 加速领域使用较多</td><td>国内流媒体 CDN 应用较多</td><td>尚无商用案例</td></tr></tbody></table><p>其中，基于 DNS 解析方式的 GSLB 有两个注意点：</p><h2 id="准确度"><a href="#准确度" class="headerlink" title="准确度"></a>准确度</h2><p>本地 DNS 服务器（英文：Local DNS Server，缩写：LDNS）是用户所在局域网或 ISP 网络中使用的域名服务器，定位准确度就取决于它了。因为当用户在浏览器里访问某个域名时，浏览器会首先向 LDNS 发起查询，LDNS 再<strong>代为</strong>向整个 DNS 域名系统发起查询，直到找到解析结果。域名解析流程详见<a href="http://www.cnblog.me/2015/09/24/dns/" target="_blank" rel="noopener">本文</a>。</p><p>如果 LDNS 设置不当，例如没有使用当前 ISP 提供的当地 LDNS，如 8.8.8.8，这种实现方式可能会误判用户的位置，从而将用户误导到错误的 CDN 缓存节点，造成加速效果差的问题。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>DNS 的查询机制给使用它的互联网应用带来额外的时延，有时时延还比较大，为了解决问题，引入了“缓存”机制。缓存是指 DNS 查询结果在 LDNS 中缓存，当其它主机向它发起查询请求时，它就直接向主机返回缓存中能够找到的结果，直到数据过期。</p><p>在基于 DNS 解析方式下无论采用何种工作方式，都会有一些请求不会到达 GSLB，这是 DNS 系统本身的缓存机制在起作用。当用户请求的域名在本地 DNS 或本机（客户端浏览器）得到了解析结果，这些请求就不会达到 GSLB。Cache 更新时间越短，用户请求到达 GSLB 的几率越大。由于 DNS 的缓存机制屏蔽掉相当一部分用户请求，从而大大减轻了 GSLB 处理压力，使得系统抗流量冲击能力显著提升，这也是很多商业 CDN 选择 DNS 机制做全局负载均衡的原因之一。但弊端在于，如果在 DNS 缓存刷新间隔之内系统发生影响用户服务的变化，比如某个节点故障，某个链路拥塞等，用户依然会被调度到故障点去。</p><h1 id="智能-DNS-实现浅析"><a href="#智能-DNS-实现浅析" class="headerlink" title="智能 DNS 实现浅析"></a>智能 DNS 实现浅析</h1><p>基于 DNS 解析方式的 GSLB 的实现关键，就在于使 DNS “智能化”。简单来说，就是通过建立 IP 地址访问列表，判断用户的访问来源，以确定其访问节点的位置。下面浅析如何实现智能 DNS：</p><h2 id="IP-地址收集策略"><a href="#IP-地址收集策略" class="headerlink" title="IP 地址收集策略"></a>IP 地址收集策略</h2><p>由于基于 DNS 解析方式的 CDN 使用 LDNS 进行寻址，因此我们只需要收集互联网上 DNS 服务器的 IP 地址。这样一来，收集的数量就会大大降低。为了更进一步缩小范围，一般使用 IP 地址加子网掩码的形式，如 123.175.0.0/16。在 IP 地址列表文件，就这么一行，却可以囊括很多 DNS 服务器。</p><h2 id="IP-地址收集方法"><a href="#IP-地址收集方法" class="headerlink" title="IP 地址收集方法"></a>IP 地址收集方法</h2><p>除了可以跟第三方购买 IP 地址段之外，这里重点介绍下如何自行收集 IP 地址段。</p><p><img src="https://upload.wikimedia.org/wikipedia/en/thumb/4/4f/ICANN.svg/171px-ICANN.svg.png" alt="ICANN"></p><p><a href="https://en.wikipedia.org/wiki/ICANN" target="_blank" rel="noopener">ICANN</a> —— 一个负责 IP 地址分配以及域名管理的机构，与之关联的五个 <a href="https://en.wikipedia.org/wiki/Regional_Internet_registry" target="_blank" rel="noopener">RIR</a> 机构负责替 ICANN 分配与登记部分区域的 IP 地址段：</p><table><thead><tr><th>RIR</th><th>Region</th></tr></thead><tbody><tr><td><a href="http://www.afrinic.net/" target="_blank" rel="noopener">AFRINIC</a></td><td>Africa region</td></tr><tr><td><a href="http://www.apnic.net/" target="_blank" rel="noopener">APNIC</a></td><td>Asia and Pacific region</td></tr><tr><td><a href="http://www.arin.net/" target="_blank" rel="noopener">ARIN</a></td><td>Canada, many Caribbean and North Atlantic islands, and the United States</td></tr><tr><td><a href="http://www.lacnic.net/" target="_blank" rel="noopener">LACNIC</a></td><td>Latin America and parts of the Caribbean</td></tr><tr><td><a href="http://www.ripe.net/" target="_blank" rel="noopener">RIPE NCC</a></td><td>Europe, the Middle East and parts of Central Asia</td></tr></tbody></table><p>可见，亚太地区的 IP 地址由 APNIC 分配，访问<a href="https://www.apnic.net/publications/research-and-insights/stats" target="_blank" rel="noopener">这里</a>可以知道在何处得到 IP 地址分配的有用信息。进入 FTP ，阅读 README 以了解该下载哪个文件以及文件的格式。下载 <code>delegated-apnic-latest</code> 文件，过滤出分配给中国大陆（CN）的 IP 地址。</p><p>然后可以通过 <a href="http://ipwhois.cnnic.cn/" target="_blank" rel="noopener">CNNIC IP 地址注册信息查询系统</a>查询这个地址段属于哪个运营商，但一次只能查询一个地址段，根本无法手工完成所有地址段的查询，因此推荐在 Linux 下使用 whois 工具以遍历的方式逐个查询，然后按关键字归类、去重、排序，按运营商产生几个独立的文件。如果各 IP 地址租用方未能按统一的标准在 APNIC 提交注册信息则需要特殊处理。</p><h2 id="IP-地址列表使用"><a href="#IP-地址列表使用" class="headerlink" title="IP 地址列表使用"></a>IP 地址列表使用</h2><p>最后，将每个 IP 地址列表文件关联一个 Bind 的视图 View。定义视图的目的在于，当有来自某个文件所列 IP 范围内的客户发起查询请求时，使用本视图的区文件进行域名解析。通俗的说，就是让某个运营商线路的用户，去访问某个运营商机房的服务器。</p>]]></content>
      
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS 知识总结</title>
      <link href="2015/09/24/dns/"/>
      <url>2015/09/24/dns/</url>
      
        <content type="html"><![CDATA[<p>工作、生活中常与域名打交道，尤其是近期需要为公司的系统上 CDN 服务，因此对 CDN 的核心 DNS 做了一番重温、总结。</p><h1 id="DNS-是什么？"><a href="#DNS-是什么？" class="headerlink" title="DNS 是什么？"></a>DNS 是什么？</h1><p>DNS 是互联网的一项基础服务，它将人类易记的<a href="https://en.wikipedia.org/wiki/Domain_name" target="_blank" rel="noopener">域名</a>解析为不易记的 IP 地址，使人更方便的访问互联网。</p><h1 id="DNS-的结构？"><a href="#DNS-的结构？" class="headerlink" title="DNS 的结构？"></a>DNS 的结构？</h1><p><a href="https://en.wikipedia.org/wiki/Domain_Name_System" target="_blank" rel="noopener">域名系统（DNS）</a>是一个多层级、分布式的系统，就如同一个树状结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">                    +---+                                 </span><br><span class="line">                    | . |   Root nameserver               </span><br><span class="line">                    +-+-+                                 </span><br><span class="line">                      |                                   </span><br><span class="line">  +-------+-------+---+---+-------+-------+               </span><br><span class="line">  |       |       |       |       |       |               </span><br><span class="line">+-+-+   +-+-+   +-+-+   +-+-+   +-+-+   +-+-+    </span><br><span class="line">|com|   |net|   |org|   |gov|   |cn |   |...|   Top-level domain</span><br><span class="line">+---+   +---+   +-+-+   +---+   +---+   +---+             </span><br><span class="line">                  |                                       </span><br><span class="line">             +----+----+                     </span><br><span class="line">             |wikipedia|   First-level domain                     </span><br><span class="line">             +----+----+                                  </span><br><span class="line">                  |                                       </span><br><span class="line">          +---------------+                               </span><br><span class="line">          |       |       |                               </span><br><span class="line">        +-+-+   +-+-+   +-+--+                            </span><br><span class="line">        |www|   |ftp|   |mail|   Resource record          </span><br><span class="line">        +---+   +---+   +----+</span><br></pre></td></tr></table></figure><p>域名系统（DNS）的每一级只知道直接下级的位置，而无法获得跨级的位置，因此在域名解析的时候，需要自上而下、逐级查询。这种机制虽然看似低效，却能够提供分布式、高容错的服务，避免让域名系统（DNS）成为一个集中式的单点系统。</p><h1 id="DNS-如何解析域名？"><a href="#DNS-如何解析域名？" class="headerlink" title="DNS 如何解析域名？"></a>DNS 如何解析域名？</h1><p>对某个域名发起第一次解析请求时，负责处理递归查询的<strong>本地 DNS 服务器</strong>要发送好几次查询：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/An_example_of_theoretical_DNS_recursion.svg/1024px-An_example_of_theoretical_DNS_recursion.svg.png" alt="A DNS recursor consults three name servers to resolve the address www.wikipedia.org."></p><p>域名解析的时候，需要自上而下、逐级查询：先查根域，再查顶级域，再查一级域名，最终定位到 IP 地址。<code>dig</code> 命令加 <code>+trace</code> 参数可以<strong>追踪</strong>整个域名解析过程，从中了解经过的每一级 nameserver，其结果简化如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ dig +trace www.wikipedia.org</span><br><span class="line"></span><br><span class="line">;; global options: +cmd</span><br><span class="line">.                    NS      a.root-servers.net.</span><br><span class="line">.                    NS      b.root-servers.net.</span><br><span class="line">.                    NS      c.root-servers.net.</span><br><span class="line">.                    NS      d.root-servers.net.</span><br><span class="line">.                    NS      e.root-servers.net.</span><br><span class="line">.                    NS      f.root-servers.net.</span><br><span class="line">.                    NS      g.root-servers.net.</span><br><span class="line">.                    NS      h.root-servers.net.</span><br><span class="line">.                    NS      i.root-servers.net.</span><br><span class="line">.                    NS      j.root-servers.net.</span><br><span class="line">.                    NS      k.root-servers.net.</span><br><span class="line">.                    NS      l.root-servers.net.</span><br><span class="line">.                    NS      m.root-servers.net.</span><br><span class="line">;; Received 315 bytes from 202.96.128.166#53(202.96.128.166) in 642 ms</span><br><span class="line"></span><br><span class="line">org.                 NS      a0.org.afilias-nst.info.</span><br><span class="line">org.                 NS      a2.org.afilias-nst.info.</span><br><span class="line">org.                 NS      b0.org.afilias-nst.org.</span><br><span class="line">org.                 NS      b2.org.afilias-nst.org.</span><br><span class="line">org.                 NS      c0.org.afilias-nst.info.</span><br><span class="line">org.                 NS      d0.org.afilias-nst.org.</span><br><span class="line">;; Received 691 bytes from 199.7.83.42#53(l.root-servers.net) in 408 ms</span><br><span class="line"></span><br><span class="line">wikipedia.org.       NS      ns0.wikimedia.org.</span><br><span class="line">wikipedia.org.       NS      ns1.wikimedia.org.</span><br><span class="line">wikipedia.org.       NS      ns2.wikimedia.org.</span><br><span class="line">;; Received 651 bytes from 199.19.53.1#53(c0.org.afilias-nst.info) in 1155 ms</span><br><span class="line"></span><br><span class="line">www.wikipedia.org.   A       198.35.26.96</span><br><span class="line">;; Received 90 bytes from 91.198.174.239#53(ns2.wikimedia.org) in 365 ms</span><br></pre></td></tr></table></figure><p>下面分别介绍每一级 nameserver：</p><h2 id="根域名（Root-nameserver）"><a href="#根域名（Root-nameserver）" class="headerlink" title="根域名（Root nameserver）"></a>根域名（Root nameserver）</h2><p><code>.</code> 代表的<a href="https://en.wikipedia.org/wiki/Root_name_server" target="_blank" rel="noopener">根域名服务器（Root nameserver）</a>，是 DNS 中最高级别的<a href="https://en.wikipedia.org/wiki/Name_server" target="_blank" rel="noopener">域名服务器（nameserver）</a>，负责返回顶级域名的<a href="https://en.wikipedia.org/wiki/Authoritative_name_server" target="_blank" rel="noopener">权威域名服务器（authoritative nameserver）</a>的地址。</p><p>早期的域名必须以英文句号“<code>.</code>”结尾，当用户访问 <code>www.wikipedia.org</code> 的 HTTP 服务时必须在地址栏中输入：<code>http://www.wikipedia.org.</code>，这样 DNS 才能够进行域名解析。如今 DNS 服务器已经可以自动补上结尾的句号。</p><p>目前全球共有 13 组根域名服务器，以英文字母 A 到 M 依序编号，域名格式为“<code>字母.root-servers.net</code>”。编号相同的根域名服务器使用同一个 IP，数百台根域名服务器总共只使用 13 个 IP，因此可以抵抗针对其所进行的分布式拒绝服务攻击（DDoS）。这些根域名服务器的运行软件皆为 <a href="https://en.wikipedia.org/wiki/BIND" target="_blank" rel="noopener">BIND</a>、<a href="https://en.wikipedia.org/wiki/NSD" target="_blank" rel="noopener">NSD</a>。</p><h2 id="顶级域名（Top-level-domain）"><a href="#顶级域名（Top-level-domain）" class="headerlink" title="顶级域名（Top-level domain）"></a>顶级域名（Top-level domain）</h2><p><a href="https://en.wikipedia.org/wiki/Top-level_domain" target="_blank" rel="noopener">顶级域名（Top-level domain, TLD）</a>主要分为两类：</p><ul><li><a href="http://zh.wikipedia.org/wiki/GTLD" target="_blank" rel="noopener">通用顶级域名（Generic top-level domain，gTLD）</a>，如常见的：<code>.com</code>、<code>.net</code>、<code>.org</code>、<code>.gov</code>、… 本站 <code>.me</code> 是一个新开放的通用顶级域名。</li><li><a href="http://zh.wikipedia.org/wiki/CcTLD" target="_blank" rel="noopener">国家和地区顶级域名（Country code top-level domain，ccTLD）</a>，一般用两个字母的国家或地区名缩写代称，如：<code>.cn</code>、<code>.jp</code>、…</li></ul><p>顶级域名的数量仍在不断增长中，除了英文字母的域名，还不断新增各种语系的域名，如中文域名。</p><h2 id="一级域名（First-level-domain）"><a href="#一级域名（First-level-domain）" class="headerlink" title="一级域名（First-level domain）"></a>一级域名（First-level domain）</h2><p>组织或个人通过域名代理服务商（如 GoDaddy、万网）进行注册的域名。根据需要还可以自行在一级域名下新增二级、三级等子域名。</p><h2 id="资源记录（Resource-record）"><a href="#资源记录（Resource-record）" class="headerlink" title="资源记录（Resource record）"></a>资源记录（Resource record）</h2><p>域名系统中，一般一个<a href="https://en.wikipedia.org/wiki/DNS_zone" target="_blank" rel="noopener">域（DNS zone）</a>通过一个 <a href="https://en.wikipedia.org/wiki/Zone_file" target="_blank" rel="noopener">zone 文件</a>保存该域的相关配置信息。zone 文件包含了域名和 IP 地址等资源之间的映射，以<a href="https://en.wikipedia.org/wiki/Domain_Name_System#DNS_resource_records" target="_blank" rel="noopener">资源记录（Resource recerd, RR）</a>的文本形式进行组织。<a href="https://en.wikipedia.org/wiki/List_of_DNS_record_types" target="_blank" rel="noopener">这里</a>列举了所有的资源记录类型。</p><p>以域名 <code>example.com</code> 为例，其 zone 文件简化如下：</p><table><thead><tr><th>name</th><th>ttl</th><th>record class</th><th>record type</th><th>record data</th><th>comment</th></tr></thead><tbody><tr><td>example.com.</td><td>1h</td><td>IN</td><td>NS</td><td>ns</td><td>ns.example.com is a nameserver for example.com</td></tr><tr><td>ns</td><td>1h</td><td>IN</td><td>A</td><td>192.0.2.2</td><td>IPv4 address for ns.example.com</td></tr><tr><td>example.com.</td><td>1h</td><td>IN</td><td>A</td><td>192.0.2.1</td><td>IPv4 address for example.com</td></tr><tr><td>www</td><td>1h</td><td>IN</td><td>CNAME</td><td>example.com.</td><td><a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> is an alias for example.com</td></tr></tbody></table><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>综上，注册域名、管理资源记录都是站长最常见的操作。至于域名解析就交给本地 DNS 服务器代为处理，一般用户都无需操心。</p>]]></content>
      
      
      
        <tags>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim 使用总结</title>
      <link href="2015/09/17/vim/"/>
      <url>2015/09/17/vim/</url>
      
        <content type="html"><![CDATA[<p><img src="/img/vim/vim.png" alt="Vim"></p><p>使用 <a href="http://www.vim.org/" target="_blank" rel="noopener">Vim</a> 也有好几年了，虽然这款“编辑器之神”的学习曲线非常陡峭，但一旦上手将会极大提高文本编辑效率，因此值得投入精力学习。</p><p>本文我将会从三个方面总结 Vim 的知识。</p><h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>Vim 效率之高的秘密，就在于它拥有多种“模式”。如果你已经习惯了 Windows 下的编辑器，这些模式在一开始会很违反你的使用直觉。因此学习 Vim 的第一件事，就是要习惯这些模式之间的切换。</p><p>Vim 共具有 6 种基本模式和 5 种派生模式，下面只介绍最常用的 4 个基本模式：</p><h2 id="普通模式（NORMAL-MODE）"><a href="#普通模式（NORMAL-MODE）" class="headerlink" title="普通模式（NORMAL MODE）"></a>普通模式（NORMAL MODE）</h2><p>Vim 启动后的默认模式。这正好和许多新用户期待的操作方式相反，因为大多数编辑器的默认模式为插入模式（就是一打开编辑器就可以开始码字）。</p><p>Vim 强大的编辑能力中很大部分是来自于其普通模式的命令（及组合）。在普通模式下，用户可以执行一般的编辑器命令，比如移动光标，删除文本等等。如果进一步学习各种各样的文本间移动／跳转命令和其它编辑命令，并且能够<strong>灵活组合使用</strong>的话，能够比那些没有模式的编辑器更加高效的进行文本编辑。</p><p>下面介绍普通模式下几类常用的快捷键：</p><h3 id="移动命令"><a href="#移动命令" class="headerlink" title="移动命令"></a>移动命令</h3><p>跨行移动：</p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>hjkl</code></td><td>VIM allows using the cursor keys in order to move around. However, for a pure VIM experience you should stick to using ‘h’, ‘j’, ‘k’ and ‘l’. It’s considered more efficient since you don’t have to move your hand from the home row when you’re typing.</td></tr><tr><td><code>gg</code></td><td>到第一行</td></tr><tr><td><code>G</code></td><td>到最后一行</td></tr><tr><td><code>nG</code></td><td>到第 n 行</td></tr><tr><td><code>%</code></td><td>匹配括号移动，包括 () {} []（需要先把光标先移到括号上）</td></tr><tr><td><code>*</code></td><td>匹配光标当前所在的单词（<code>#</code> 反向）</td></tr></tbody></table><p>当前行移动：</p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>0</code></td><td>到行头（<code>$</code> 反向）</td></tr><tr><td><code>^</code></td><td>到本行第一个非 blank 字符的位置（所谓 blank 字符就是空格、tab、换行、回车等）</td></tr><tr><td><code>w</code></td><td>到下一个单词的开头（<code>b</code> 反向）</td></tr><tr><td><code>e</code></td><td>到下一个单词的结尾</td></tr><tr><td><code>f</code></td><td>Find next character（<code>F</code> 反向） <br/> <code>fi</code> 到字符 i 处<br/> <code>4fi</code> 到第四个字符 i 处</td></tr><tr><td><code>t</code></td><td>Find before character（<code>T</code> 反向）</td></tr></tbody></table><p><img src="/img/vim/vim_line_moves.jpg" alt="Vim 当前行移动"></p><h3 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h3><p>文本替换：</p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>r</code></td><td>Replace current character <br/> When you need to replace only one character under your cursor, <strong>without changing to insert mode</strong>, use <code>r</code>.</td></tr></tbody></table><p>剪切/复制/粘贴：</p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>x</code></td><td>Cut current character</td></tr><tr><td><code>d</code></td><td><code>dd</code> Cut current line <br/> <code>dt</code> Cut till …</td></tr><tr><td><code>y</code></td><td><code>yy</code> Copy current line (yank) <br/> <code>yt</code> Copy till …</td></tr><tr><td><code>p</code></td><td>Paste</td></tr></tbody></table><p>缩进/补全：</p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>&lt;&lt;</code></td><td>左缩进</td></tr><tr><td><code>&gt;&gt;</code></td><td>右缩进</td></tr><tr><td><code>=</code></td><td>自动缩进</td></tr><tr><td><code>Ctrl + p</code></td><td>在 Insert 模式下，自动补全…</td></tr></tbody></table><p>从别的编辑器里粘贴到 vim 里的代码经常由于不正常的缩进变得格式混乱，可以使用如下命令：</p><ul><li><p>自动缩进当前行： <code>==</code></p></li><li><p>全文格式化：<code>gg=G</code> ，即：</p><ol><li>gg - Goto the beginning of the file</li><li>= - apply indentation</li><li>G - till end of file</li></ol></li></ul><h3 id="重复命令"><a href="#重复命令" class="headerlink" title="重复命令"></a>重复命令</h3><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>.</code></td><td>重复执行上一个命令</td></tr><tr><td><code>n&lt;command&gt;</code></td><td>重复执行某个命令 n 次</td></tr><tr><td><code>&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</code></td><td>对某段起止文本执行某个命令，例如：<code>d</code>（删除）、<code>y</code>（复制）、<code>v</code>（选择）、<code>gU</code>（变大写）、<code>gu</code>（变小写）。例如：<code>gg=G</code></td></tr></tbody></table><h2 id="插入模式（INSERT-MODE）"><a href="#插入模式（INSERT-MODE）" class="headerlink" title="插入模式（INSERT MODE）"></a>插入模式（INSERT MODE）</h2><p>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器在编辑过程中一直保持这个模式。</p><p>使用以下快捷键进入插入模式：</p><h3 id="当前行插入"><a href="#当前行插入" class="headerlink" title="当前行插入"></a>当前行插入</h3><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>i</code></td><td>Switch to insert mode <strong>on current character</strong></td></tr><tr><td><code>a</code></td><td>Switch to insert mode <strong>after current character</strong></td></tr><tr><td><code>I</code></td><td>Switch to insert mode <strong>on first visible character of the current line</strong></td></tr><tr><td><code>A</code></td><td>Switch to insert mode <strong>on last visible character of the current line</strong></td></tr></tbody></table><h3 id="另起一行插入"><a href="#另起一行插入" class="headerlink" title="另起一行插入"></a>另起一行插入</h3><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>o</code></td><td>Switch to insert mode <strong>after current line</strong></td></tr><tr><td><code>O</code></td><td>Switch to insert mode <strong>before current line</strong></td></tr></tbody></table><h2 id="可视模式（VISUAL-MODE）"><a href="#可视模式（VISUAL-MODE）" class="headerlink" title="可视模式（VISUAL MODE）"></a>可视模式（VISUAL MODE）</h2><p>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令（例如复制、删除）时，命令会被执行到这块高亮的区域上。</p><p>使用以下快捷键进入可视模式：</p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>Ctrl + v</code></td><td>Switch to visual block mode</td></tr><tr><td><code>v</code></td><td>Switch to visual character mode</td></tr><tr><td><code>V</code></td><td>Switch to visual line mode</td></tr></tbody></table><h2 id="命令行模式（COMMAND-MODE）"><a href="#命令行模式（COMMAND-MODE）" class="headerlink" title="命令行模式（COMMAND MODE）"></a>命令行模式（COMMAND MODE）</h2><p>在命令行模式中可以输入命令。在命令执行完后，Vim 返回到命令行模式之前的模式，通常是普通模式。</p><p>使用以下快捷键进入命令行模式：</p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>:</code></td><td>执行命令： <br/> <code>:h</code> 帮助文档，例如查看 <code>s</code>文本替换命令（substitude）的帮助：<code>:h s</code></td></tr><tr><td><code>!</code></td><td>过滤命令</td></tr><tr><td><code>/</code> 或 <code>?</code></td><td>搜索字符串</td></tr></tbody></table><h3 id="range-参数"><a href="#range-参数" class="headerlink" title="[range] 参数"></a>[range] 参数</h3><p><code>[range]</code> 有以下一些表示方法，例如常用的 <code>%</code> 表示替换所有行，等价于 <code>1,$</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">不写range   ：  默认为光标所在的行。</span><br><span class="line">.           ：  光标所在的行。</span><br><span class="line">1           ：  第一行。</span><br><span class="line">$           ：  最后一行。</span><br><span class="line">33          ：  第33行。</span><br><span class="line">&#39;a          ：  标记a所在的行（之前要使用ma做过标记）。</span><br><span class="line">.+1         ：  当前光标所在行的下面一行。</span><br><span class="line">$-1         ：  倒数第二行。（这里说明我们可以对某一行加减某个数值来</span><br><span class="line">                取得相对的行）。</span><br><span class="line">22,33       ：  第22～33行。</span><br><span class="line">1,$         ：  第1行 到 最后一行。</span><br><span class="line">1,.         ：  第1行 到 当前行。</span><br><span class="line">.,$         ：  当前行 到 最后一行。</span><br><span class="line">&#39;a,&#39;b       ：  标记a所在的行 到 标记b所在的行。</span><br><span class="line"></span><br><span class="line">%           ：  所有行（与 1,$ 等价）。</span><br><span class="line"></span><br><span class="line">?chapter?   ：  从当前位置向上搜索，找到的第一个chapter所在的行。（</span><br><span class="line">                其中chapter可以是任何字符串或者正则表达式。</span><br><span class="line">&#x2F;chapter&#x2F;   ：  从当前位置向下搜索，找到的第一个chapter所在的行。（</span><br><span class="line">                其中chapter可以是任何字符串或者正则表达式。</span><br><span class="line"></span><br><span class="line">注意，上面的所有用于range的表示方法都可以通过 +、- 操作来设置相对偏</span><br><span class="line">移量。</span><br></pre></td></tr></table></figure><h3 id="Deleting-text"><a href="#Deleting-text" class="headerlink" title="Deleting text"></a>Deleting text</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>:[range]d[elete] [x]</code></td><td>Delete <code>[range]</code> lines (default: current line) [into register <code>x</code>].</td></tr><tr><td><code>:[range]d[elete] [x] {count}</code></td><td>Delete <code>{count}</code> lines, starting with <code>[range]</code>(default: current line) [into register <code>x</code>].</td></tr><tr><td><code>:[range]j[oin][!] [flags]</code></td><td>Join <code>[range]</code> lines.</td></tr><tr><td><code>:[range]j[oin][!] {count} [flags]</code></td><td>Join <code>{count}</code> lines, starting with <code>[range]</code> (default: current line).</td></tr></tbody></table><p>例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 刪除 1-10 行</span></span><br><span class="line">:1,10d</span><br></pre></td></tr></table></figure><h3 id="Copying-and-moving-text"><a href="#Copying-and-moving-text" class="headerlink" title="Copying and moving text"></a>Copying and moving text</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>:[range]y[ank] [x]</code></td><td>Yank <code>[range]</code> lines [into register <code>x</code>].</td></tr><tr><td><code>:[range]y[ank] [x] {count}</code></td><td>Yank {count} lines, starting with last line number in [range] (default: current line), [into register <code>x</code>].</td></tr><tr><td><code>:[range]co[py] {address}</code></td><td>Copy the lines given by <code>[range]</code> to below the line given by <code>{address}</code>.</td></tr><tr><td><code>:[range]m[ove] {address}</code></td><td>Move the lines given by <code>[range]</code> to below the line given by <code>{address}</code>.</td></tr></tbody></table><h3 id="Formatting-text"><a href="#Formatting-text" class="headerlink" title="Formatting text"></a>Formatting text</h3><p>Shifting lines left or right: </p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>:[range]&lt;</code></td><td>Shift <code>[range]</code> lines one <code>&#39;shiftwidth&#39;</code> left.  Repeat <code>&#39;&lt;&#39;</code> for shifting multiple <code>&#39;shiftwidth&#39;</code>s.</td></tr><tr><td><code>:[range]&lt; {count}</code></td><td>Shift <code>{count}</code> lines one <code>&#39;shiftwidth&#39;</code> left, starting with <code>[range]</code> (default current line). Repeat ‘&lt;’ for shifting multiple <code>&#39;shiftwidth&#39;</code>s.</td></tr><tr><td><code>:[range]&gt; [flags]</code></td><td>Shift <code>{count}</code> <code>[range]</code> lines one <code>&#39;shiftwidth&#39;</code> right. Repeat <code>&#39;&gt;&#39;</code> for shifting multiple <code>&#39;shiftwidth&#39;</code>s.</td></tr><tr><td><code>:[range]&gt; {count} [flags]</code></td><td>Shift <code>{count}</code> lines one <code>&#39;shiftwidth&#39;</code> right, starting with <code>[range]</code> (default current line). Repeat <code>&#39;&gt;&#39;</code> for shifting multiple <code>&#39;shiftwidth&#39;</code>s.</td></tr></tbody></table><p>Left-align, right-align lines or center lines: </p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>:[range]le[ft] [indent]</code></td><td>Left-align lines in <code>[range]</code>.  Sets the indent in the lines to <code>[indent]</code> (default <code>0</code>).</td></tr><tr><td><code>:[range]ri[ght] [width]</code></td><td>Right-align lines in <code>[range]</code> at <code>[width]</code> columns<br/>(default <code>&#39;textwidth&#39;</code> or <code>80</code> when <code>&#39;textwidth&#39;</code> is <code>0</code>).</td></tr><tr><td><code>:[range]ce[nter] [width]</code></td><td>Center lines in <code>[range]</code> between <code>[width]</code> columns<br/>(default <code>&#39;textwidth&#39;</code> or <code>80</code> when <code>&#39;textwidth&#39;</code> is <code>0</code>).</td></tr></tbody></table><h3 id="Sorting-text"><a href="#Sorting-text" class="headerlink" title="Sorting text"></a>Sorting text</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>:[range]sor[t][!] [b][f][i][n][o][r][u][x] [/{pattern}/]</code></td><td>Sort lines in <code>[range]</code>.  When no range is given all lines are sorted.<br/>With <code>[!]</code> the order is reversed.<br/>With <code>[i]</code> case is ignored.<br/>…</td></tr></tbody></table><h3 id="Substitute-Text"><a href="#Substitute-Text" class="headerlink" title="Substitute Text"></a>Substitute Text</h3><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>:[range]s[ubstitute]/{pattern}/{string}/[flags] [count]</code></td><td>For each line in <code>[range]</code> replace a match of <code>{pattern}</code> with <code>{string}</code>.</td></tr></tbody></table><p>详细命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">4.2 Substitute                                          *:substitute*</span><br><span class="line">                                                        *:s* *:su*</span><br><span class="line">:[range]s[ubstitute]&#x2F;&#123;pattern&#125;&#x2F;&#123;string&#125;&#x2F;[flags] [count]</span><br><span class="line">                        For each line in [range] replace a match of &#123;pattern&#125; with &#123;string&#125;.</span><br><span class="line">                        For the &#123;pattern&#125; see |pattern|.</span><br><span class="line">                        &#123;string&#125; can be a literal string, or something special; see |sub-replace-special|.</span><br><span class="line">                        When [range] and [count] are omitted, replace in the current line only.</span><br><span class="line">                        When [count] is given, replace in [count] lines, starting with the last line in [range].</span><br><span class="line">                        When [range] is omitted start in the current line.</span><br><span class="line">                        Also see |cmdline-ranges|.</span><br><span class="line">                        See |:s_flags| for [flags].</span><br></pre></td></tr></table></figure><p><code>[flags]</code> 有以下一些表示方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">无      ：  只对指定范围内的第一个匹配项进行替换。</span><br><span class="line">g       ：  对指定范围内的所有匹配项进行替换。</span><br><span class="line">c       ：  在替换前请求用户确认。</span><br><span class="line">e       ：  忽略执行过程中的错误。</span><br><span class="line">i       :   Ignore case for the pattern.</span><br><span class="line">I       :   Don&#39;t ignore case for the pattern.</span><br><span class="line"></span><br><span class="line">注意：上面的所有flags都可以组合起来使用，比如 gc 表示对指定范围内的所有匹配项进行替换，并且在每一次替换之前都会请用户确认。</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.  替换当前行中的内容：    :s&#x2F;from&#x2F;to&#x2F;    （s即substitude）</span><br><span class="line">    :s&#x2F;from&#x2F;to&#x2F;     ：  将当前行中的第一个from，替换成to。如果当前行含有多个</span><br><span class="line">                        from，则只会替换其中的第一个。</span><br><span class="line">    :s&#x2F;from&#x2F;to&#x2F;g    ：  将当前行中的所有from都替换成to。</span><br><span class="line">    :s&#x2F;from&#x2F;to&#x2F;gc   ：  将当前行中的所有from都替换成to，但是每一次替换之前都</span><br><span class="line">                        会询问请求用户确认此操作。</span><br><span class="line"></span><br><span class="line">    注意：这里的from和to都可以是任何字符串，其中from还可以是正则表达式。</span><br><span class="line"></span><br><span class="line">2.  替换某一行的内容：      :33s&#x2F;from&#x2F;to&#x2F;g</span><br><span class="line">    :.s&#x2F;from&#x2F;to&#x2F;g   ：  在当前行进行替换操作。</span><br><span class="line">    :33s&#x2F;from&#x2F;to&#x2F;g  ：  在第33行进行替换操作。</span><br><span class="line">    :$s&#x2F;from&#x2F;to&#x2F;g   ：  在最后一行进行替换操作。</span><br><span class="line"></span><br><span class="line">3.  替换某些行的内容：      :10,20s&#x2F;from&#x2F;to&#x2F;g</span><br><span class="line">    :10,20s&#x2F;from&#x2F;to&#x2F;g   ：  对第10行到第20行的内容进行替换。</span><br><span class="line">    :1,$s&#x2F;from&#x2F;to&#x2F;g     ：  对第一行到最后一行的内容进行替换（即全部文本）。</span><br><span class="line">    :1,.s&#x2F;from&#x2F;to&#x2F;g     ：  对第一行到当前行的内容进行替换。</span><br><span class="line">    :.,$s&#x2F;from&#x2F;to&#x2F;g     ：  对当前行到最后一行的内容进行替换。</span><br><span class="line">    :&#39;a,&#39;bs&#x2F;from&#x2F;to&#x2F;g   ：  对标记a和b之间的行（含a和b所在的行）进行替换。</span><br><span class="line">                            其中a和b是之前用m命令所做的标记。</span><br><span class="line"></span><br><span class="line">4.  替换所有行的内容：      :%s&#x2F;from&#x2F;to&#x2F;g</span><br><span class="line">    :%s&#x2F;from&#x2F;to&#x2F;g   ：  对所有行的内容进行替换。</span><br></pre></td></tr></table></figure><p>例子，批量替换所有空格：</p><ul><li><code>:</code> 进入命令行模式</li><li><code>%</code> 表示所有行（与 <code>1,$</code> 等价）</li><li><code>s</code> 表示文本替换命令</li><li><code>\s</code> 表示空格</li><li><code>g</code> 表示对指定范围内的所有匹配项进行替换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s&#x2F;\s&#x2F;&#x2F;g</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># JSON 格式化</span></span><br><span class="line"><span class="comment"># : 进入命令行模式</span></span><br><span class="line"><span class="comment"># % [range] 参数，指定所有行</span></span><br><span class="line"><span class="comment"># ! 执行具体的命令，这里使用 python</span></span><br><span class="line"><span class="comment"># -m json.tool 调用python里json.tool这个模块</span></span><br><span class="line">:%!python -m json.tool</span><br></pre></td></tr></table></figure><p>可以将该常用命令放到 <code>~/.vimrc</code> 配置文件中，方便使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" F3 快捷键 JSON 格式化当前行</span></span><br><span class="line"><span class="string">map &lt;F3&gt; :.!python -m json.tool&lt;CR&gt;</span></span><br><span class="line"><span class="string">"</span> F4 快捷键 JSON 格式化全文</span><br><span class="line">map &lt;F4&gt; :%!python -m json.tool&lt;CR&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">" :JsonFormat 命令格式化全文</span></span><br><span class="line"><span class="string">command! JsonFormat :execute '%!python -m json.tool'</span></span><br><span class="line"><span class="string">"</span> :JsonFormat 命令格式化全文，并解决汉字以 unicode 码显示问题，参考：http://qiita.com/tomoemon/items/cc29b414a63e08cd4f89</span><br><span class="line"><span class="built_in">command</span>! JsonFormat :execute <span class="string">'%!python -m json.tool'</span></span><br><span class="line">  \ | :execute <span class="string">'%!python -c "import re,sys;chr=__builtins__.__dict__.get(\"unichr\", chr);sys.stdout.write(re.sub(r\"\\u[0-9a-f]&#123;4&#125;\", lambda x: chr(int(\"0x\" + x.group(0)[2:], 16)).encode(\"utf-8\"), sys.stdin.read()))"'</span></span><br><span class="line">  \ | :<span class="built_in">set</span> ft=javascript</span><br><span class="line">  \ | :1</span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>使用 Vim 年月较久后总会定制一套个性化的 Vim 配置，例如截取一段常用的 <code>~/.vimrc</code> 配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">set number                  &quot; 显示行号</span><br><span class="line">set cursorline              &quot; 突出显示当前行</span><br><span class="line">set ruler                   &quot; 打开状态栏标尺</span><br><span class="line">set shiftwidth&#x3D;4            &quot; 设定 &lt;&lt; 和 &gt;&gt; 命令缩进时的宽度为 4</span><br><span class="line">set softtabstop&#x3D;4           &quot; 使得按退格键时可以一次删掉 4 个空格</span><br><span class="line">set tabstop&#x3D;4               &quot; 设定 tab 长度为 4</span><br><span class="line">set nowrapscan              &quot; 禁止在搜索到文件两端时重新搜索</span><br><span class="line">set incsearch               &quot; 输入搜索内容时就显示搜索结果</span><br><span class="line">set hlsearch                &quot; 高亮显示搜索结果</span><br><span class="line">syntax on                   &quot; 程序语法开关</span><br><span class="line">inoremap jj &lt;ESC&gt;           &quot; 重映射 ESCAPE 键</span><br><span class="line">&quot; 定义缩写：ab [缩写] [要替换的文字]</span><br><span class="line">ab asap as soon as possible</span><br></pre></td></tr></table></figure><p>另外注意，Vim 的操作记录会写入 <code>~/.viminfo</code> 。</p><h2 id="设置键盘映射"><a href="#设置键盘映射" class="headerlink" title="设置键盘映射"></a>设置键盘映射</h2><p><a href="https://blog.csdn.net/lym152898/article/details/52171494" target="_blank" rel="noopener">https://blog.csdn.net/lym152898/article/details/52171494</a></p><h1 id="GVim"><a href="#GVim" class="headerlink" title="GVim"></a>GVim</h1><p><a href="http://www.vim.org" target="_blank" rel="noopener">GVim</a> 是 Windows 版的 Vim，因为有了标准的 Windows 风格的图形界面，所以叫 G(Graphical)Vim。</p><p>GVim 的多标签切换：</p><table><thead><tr><th>快捷键</th><th>说明</th></tr></thead><tbody><tr><td><code>:tabnew</code></td><td>新建标签页</td></tr><tr><td><code>:tabs</code></td><td>显示已打开标签页的列表</td></tr><tr><td><code>:tabc</code></td><td>关闭当前标签页</td></tr><tr><td><code>:tabn</code></td><td>移动到下一个标签页</td></tr><tr><td><code>:tabp</code></td><td>移动到上一个标签页</td></tr><tr><td><code>:tabfirst</code></td><td>移动到第一个标签页</td></tr><tr><td><code>:tablast</code></td><td>移动到最后一个标签页</td></tr></tbody></table><p>字符集配置参考 <a href="http://sunchuanzhen.blog.51cto.com/3076506/670193" target="_blank" rel="noopener">这里</a>，其它小技巧参考 <a href="http://www.cnblogs.com/alphaqiu/archive/2012/04/12/2444147.html" target="_blank" rel="noopener">这里</a> 。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《<a href="https://zh.wikipedia.org/wiki/Vim" target="_blank" rel="noopener">Vim - wikipedia</a>》</li><li>《<a href="http://coolshell.cn/articles/5426.html" target="_blank" rel="noopener">简明 Vim 练级攻略</a>》</li><li>《<a href="http://coolshell.cn/articles/894.html" target="_blank" rel="noopener">如何在 Vim 中得到你最喜爱的 IDE 特性</a>》</li><li>《<a href="http://www.oschina.net/news/28608/vim-direction-keys" target="_blank" rel="noopener">为什么 Vim 使用 HJKL 键作为方向键</a>》</li><li>《<a href="https://www.cnblogs.com/wind-wang/p/5768000.html" target="_blank" rel="noopener">vim文本替换命令</a>》</li><li>《<a href="https://mp.weixin.qq.com/s?__biz=MzU3NTgyODQ1Nw==&mid=2247499367&idx=2&sn=bfd12789b31b0a6c7810769ec24ba842&chksm=fd1f86e1ca680ff7c7d212139b022ebeefa77f848513fe913359eee5297e8825b0c98ad27e61" target="_blank" rel="noopener">5分钟学会 Vim 分屏操作方方面面</a>》</li><li>VIM 插件：<a href="https://vimawesome.com/plugin/json-vim" target="_blank" rel="noopener">https://vimawesome.com/plugin/json-vim</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（九）git mergetool 工具解决冲突</title>
      <link href="2015/08/27/git-mergetool/"/>
      <url>2015/08/27/git-mergetool/</url>
      
        <content type="html"><![CDATA[<p>续<a href="/2015/08/25/git-resolving-conflicts/">上文</a>。</p><p>有时候合并操作并不会如此顺利。如果在不同的分支中都修改了同一个文件的同一部分，Git 就无法干净地把两者合到一起。这种问题只能由人来裁决，解决冲突的办法无非是从冲突中二者选其一或者由你亲自整合到一起。</p><p>你完全可以手工编辑处理冲突，或者推荐使用图形化的外部合并与比较工具（mergetool）。</p><h1 id="mergetool-是什么？"><a href="#mergetool-是什么？" class="headerlink" title="mergetool 是什么？"></a>mergetool 是什么？</h1><blockquote><p>Merge tool is a GUI that steps you through each conflict, and you get to choose how to merge. Sometimes it requires a bit of hand editing afterwards, but usually it’s enough by itself. It is much better than doing the whole thing by hand certainly.</p></blockquote><h1 id="mergetool-如何选择？"><a href="#mergetool-如何选择？" class="headerlink" title="mergetool 如何选择？"></a>mergetool 如何选择？</h1><p><strong>mergetool 需自行选择安装。</strong>选择很多，例如：meld, opendiff, kdiff3, tkdiff, xxdiff, tortoisemerge, gvimdiff, diffuse, ecmerge, p4merge, araxis, vimdiff, emerge …</p><p>推荐使用 <a href="http://meldmerge.org/" target="_blank" rel="noopener">meld</a>，一款优秀的可视化 diff 和代码合并工具（merge tool），支持特性如下：</p><ul><li>跨平台，支持 Linux/Unix、 OS X、Windows，多种便捷的安装方式</li><li>跨工具，支持多种版本控制系统（VCS），如 Git、SVN、Mercurial …</li><li>支持双方或三方文件、目录对比</li><li>GUI 界面好看 :)</li></ul><h1 id="meld-如何使用？"><a href="#meld-如何使用？" class="headerlink" title="meld 如何使用？"></a>meld 如何使用？</h1><p>安装好 meld ，还需进行如下配置：</p><h2 id="用于-git-diff"><a href="#用于-git-diff" class="headerlink" title="用于 git diff"></a>用于 git diff</h2><p>首先配置好 git ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global diff.external ~/meld.sh</span><br></pre></td></tr></table></figure><p>然后准备编写 <code>meld.sh</code> 包装脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/meld.sh</span><br></pre></td></tr></table></figure><p>默认情况下， <code>git diff</code> 会传递 7 个参数给该包装脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path old-file old-hex old-mode new-file new-hex new-mode</span><br></pre></td></tr></table></figure><p>但我们仅仅只需要 <code>old-file</code> 和 <code>new-file</code> 参数，因此需要用包装脚本来传递它们。脚本内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">meld <span class="variable">$2</span> <span class="variable">$5</span></span><br></pre></td></tr></table></figure><p>如果对涉及到的参数感兴趣，可以在脚本补充一段 <code>echo $0 $*</code>。</p><p>最后对于 Linux/Unix、OS X，还需要增加脚本的可执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x ~/meld.sh</span><br></pre></td></tr></table></figure><p>以上配置好后，就可以调用图形化工具愉快的使用 <code>git diff</code> 了。</p><h2 id="用于-git-mergetool"><a href="#用于-git-mergetool" class="headerlink" title="用于 git mergetool"></a>用于 git mergetool</h2><p>首先配置好 git ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global merge.tool meld</span><br></pre></td></tr></table></figure><p>如果合并的时候出现如下冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> index.html Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mergetool</span><br></pre></td></tr></table></figure><p>就可以调用图形化工具愉快的解决冲突了。</p><p>在解决了所有文件的所有冲突后，运行 <code>git add</code> 将把它们标记为已解决状态即可（一旦暂存，就表示冲突已经解决）。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《<a href="http://stackoverflow.com/questions/161813/fix-merge-conflicts-in-git" target="_blank" rel="noopener">How do I fix merge conflicts in Git?</a>》</li><li>《<a href="http://www.gitguys.com/topics/merging-with-a-gui/" target="_blank" rel="noopener">Git Mergetool – Merging With a GUI</a>》</li><li>《<a href="http://git-scm.com/book/zh/v1/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-%E9%85%8D%E7%BD%AE-Git#外部的合并与比较工具" target="_blank" rel="noopener">外部的合并与比较工具</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（八）Git 解决冲突</title>
      <link href="2015/08/25/git-resolving-conflicts/"/>
      <url>2015/08/25/git-resolving-conflicts/</url>
      
        <content type="html"><![CDATA[<p>如果工作目录的本地代码做了修改但尚未提交，<code>pull</code> 拉取远程仓库的新提交时，往往会提示冲突：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">error: Your <span class="built_in">local</span> changes to the following files would be overwritten by merge:</span><br><span class="line">        /there/is/a/conflict/file</span><br><span class="line">Please, commit your changes or stash them before you can merge.</span><br></pre></td></tr></table></figure><p>如上所示，有 <code>commit</code> 和 <code>stash</code> 两种处理方法。针对本地代码的<strong>完成情况</strong>我们需要作出选择。</p><h1 id="代码已完成"><a href="#代码已完成" class="headerlink" title="代码已完成"></a>代码已完成</h1><p>如果确认本地代码已经<strong>完成无误</strong>，可以先将本地代码 <code>commit</code> 到本地仓库。再次 <code>pull</code> 拉取远程仓库时，如无冲突，Git 会自动产生一次“合并”提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git lg</span><br><span class="line">*   e6f4e18 - Merge branch <span class="string">'master'</span> of origin (1 minutes ago)</span><br><span class="line">|\  </span><br><span class="line">* | abfa93b - 本地仓库的提交 (2 minutes ago)</span><br><span class="line">| * 1f1c21d - 远程仓库的提交 (3 minutes ago)</span><br><span class="line">|/  </span><br><span class="line">* 17ef24c - 基准版本 (4 minutes ago)</span><br></pre></td></tr></table></figure><p>这是因为 <code>pull</code> 的默认策略是“fetch + <a href="/2015/08/17/git-merge/">merge</a>”。如果本地仓库的提交一直不 <code>push</code> 到远程仓库，极端情况下每一次 <code>pull</code> 都可能会产生一次“合并”提交，这会造成祖先图谱（graph）无谓的复杂。此时推荐使用 <a href="/2015/08/20/git-rebase/">rebase</a> 避免本地仓库无谓的合并节点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull --rebase</span><br></pre></td></tr></table></figure><h1 id="代码未完成"><a href="#代码未完成" class="headerlink" title="代码未完成"></a>代码未完成</h1><p>但如果本地代码<strong>仍未完成</strong>，此时推荐使用 <code>stash</code> 命令暂存修改，避免将未完成的功能代码 <code>commit</code> 到本地仓库，污染仓库。</p><h2 id="暂存当前修改"><a href="#暂存当前修改" class="headerlink" title="暂存当前修改"></a>暂存当前修改</h2><p>第一步，<code>stash</code> 暂存当前修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash save <span class="string">"填写你的备注"</span></span><br><span class="line">Saved working directory and index state ......</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>可以看到暂存后工作目录一干二净。这是因为 <code>stash</code> 命令可以将“修改过的被追踪的文件（modified tracked files）”和“暂存的变更（staged changes）”暂存到临时堆栈中，并将工作目录还原干净，以便后续的操作。</p><blockquote><p>Stashing takes the dirty state of your working directory – that is, your modified tracked files and staged changes – and saves it on a stack of unfinished changes that you can reapply at any time.</p></blockquote><h2 id="拉取远程仓库"><a href="#拉取远程仓库" class="headerlink" title="拉取远程仓库"></a>拉取远程仓库</h2><p>第二步，继续 <code>pull</code> 拉取远程仓库并进行自动合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure><h2 id="重新还原暂存"><a href="#重新还原暂存" class="headerlink" title="重新还原暂存"></a>重新还原暂存</h2><p>第三步，<code>stash pop</code> 重新还原暂存修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h2 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h2><p>最后一步，如果还原后产生冲突，需要<a href="/2015/08/27/git-mergetool/">手工或使用 <code>mergetool</code></a> 进行处理。处理完毕后，使用 <code>add</code> 标明冲突已解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="http://git-scm.com/book/zh/v1/Git-工具-储藏（Stashing）" target="_blank" rel="noopener">Git-工具-储藏（Stashing）</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（七）git cherry-pick 命令选取合并</title>
      <link href="2015/08/21/git-cherry-pick/"/>
      <url>2015/08/21/git-cherry-pick/</url>
      
        <content type="html"><![CDATA[<p><code>cherry-pick</code> 这个命令的名字是比较形象的，即“摘樱桃”，使用该命令可以将任意的 commit 合并到你想要的分支上。 例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到 master 分支</span></span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># cherry-pick 特性分支上的三个 commit</span></span><br><span class="line">$ git cherry-pick e7ce3f8 915fe84 dc6baf3</span><br></pre></td></tr></table></figure><p>合并完毕后，会在 master 分支上新产生三个 commit 号，但提交内容不变。</p><p>如果只是想<a href="/2015/08/20/git-rebase/">整理当前分支</a>，可以使用 rebase 命令。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="http://www.cnblogs.com/ludashi/p/8116434.html" target="_blank" rel="noopener">Git知识总览(四) git分支管理之rebase 以及 cherry-pick相关操作</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（六）git rebase 命令衍合分支</title>
      <link href="2015/08/20/git-rebase/"/>
      <url>2015/08/20/git-rebase/</url>
      
        <content type="html"><![CDATA[<p>本文介绍一个生僻但相当好用的命令 <code>rebase</code>（衍合）。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>衍合的两个使用场景：</p><ol><li>生成干净历史、补丁</li><li>整理当前分支</li></ol><h2 id="生成干净历史"><a href="#生成干净历史" class="headerlink" title="生成干净历史"></a>生成干净历史</h2><p>开发过程中，常常需要定期将最新的远程分支拉取（<code>pull</code>）到本地分支，保持本地代码最新（up to date）。如果拉取频繁，<code>pull</code> 默认的 <code>merge</code> 行为会造成祖先图谱（ancestry graph）无谓的复杂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master    &#x2F;&#x2F; pull &#x3D; fetch + merge</span><br><span class="line"></span><br><span class="line">*   ab900eb - 三方合并版本（注意这里！）</span><br><span class="line">|\</span><br><span class="line">| * 756ba83 - 本地分支提交的版本</span><br><span class="line">* | 915fe84 - 先被推送到远程分支的版本</span><br><span class="line">|&#x2F;</span><br><span class="line">*   e7ce3f8 - 基准版本（共同祖先）</span><br></pre></td></tr></table></figure><p>解决方案是改用 <code>rebase</code> 命令，其产生的祖先图谱如下，非常简洁：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   dc6baf3 - 本地分支提交的版本（注意这个提交被改写了！）</span><br><span class="line">|</span><br><span class="line">*   915fe84 - 先被推送到远程分支的版本</span><br><span class="line">|</span><br><span class="line">*   e7ce3f8 - 基准版本（共同祖先）</span><br></pre></td></tr></table></figure><p>可见，这个神奇的命令功能类似 <code>merge</code> ，但它避免了上述无谓的合并节点，从而产生一个更为整洁的提交历史。如果视察一个衍合过的分支历史，仿佛所有的提交都是在一根时间轴上先后进行的，尽管实际上它们原本是同时并行发生的。这么做的好处是，非常便于项目管理人员按时间轴进行<strong>代码审查</strong>。</p><h3 id="命令用法"><a href="#命令用法" class="headerlink" title="命令用法"></a>命令用法</h3><p>可以在 <code>pull</code> 时主动加上 <code>--rebase</code> 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull --rebase origin master</span><br></pre></td></tr></table></figure><p>甚至推荐将 <code>rebase</code> 设为 <code>pull</code> 命令的默认行为，从而应用于所有新建分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global branch.autosetuprebase always</span><br></pre></td></tr></table></figure><p>注意，对于应用上述命令前已存在的分支（例如 <code>master</code>），需要补充执行如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config branch.master.rebase <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="命令原理"><a href="#命令原理" class="headerlink" title="命令原理"></a>命令原理</h3><p> 下面进一步介绍 <code>rebase</code> 命令的原理：</p><ol><li>把本地分支从上一次 <code>pull</code> 之后的变更暂存起来；</li><li>恢复到上一次 <code>pull</code> 时的情况；</li><li>合并远程分支的提交；</li><li>最后再逐一合并刚暂存下来的本地提交（相当于重放一遍）。</li></ol><h2 id="生成干净补丁"><a href="#生成干净补丁" class="headerlink" title="生成干净补丁"></a>生成干净补丁</h2><p>使用衍合的另一个目的，是想要得到一个能在远程分支上干净应用的补丁 — 比如某些项目、或些分支你不是维护者，但想帮点忙的话，最好用衍合：先在自己的一个独立分支中进行开发，当准备向主项目提交补丁的时候，根据最新的 <code>origin/master</code> 进行一次 <code>git rebase</code> 衍合操作然后再提交，这样维护者就<strong>不需要做任何整合工作</strong>（实际上是把解决分支补丁同最新主干代码之间冲突的责任，化转为由提交补丁的人来解决。），只需根据你提供的仓库地址作一次<strong>快进合并</strong>，或者直接采纳你提交的补丁。</p><h2 id="整理当前分支"><a href="#整理当前分支" class="headerlink" title="整理当前分支"></a>整理当前分支</h2><p>衍合的另一个用法是整理当前分支，使用 <code>git rebase [-i | --interactive]</code> 命令。</p><p>首先选取提交范围，<code>e7ce3f8</code> 为当前分支的历史提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*   dc6baf3 - commit3</span><br><span class="line">|</span><br><span class="line">*   915fe84 - commit2</span><br><span class="line">|</span><br><span class="line">*   e7ce3f8 - commit1</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase -i e7ce3f8</span><br><span class="line"></span><br><span class="line">  1 pick dc6baf3 本地分支提交的版本</span><br><span class="line">  2 pick 915fe84 先被推送到远程分支的版本</span><br><span class="line">  3</span><br><span class="line">  4 <span class="comment"># Rebase 1ff20826..61527529 onto 1ff20826 (2 commands)</span></span><br><span class="line">  5 <span class="comment">#</span></span><br><span class="line">  6 <span class="comment"># Commands:</span></span><br><span class="line">  7 <span class="comment"># p, pick = use commit</span></span><br><span class="line">  8 <span class="comment"># r, reword = use commit, but edit the commit message</span></span><br><span class="line">  9 <span class="comment"># e, edit = use commit, but stop for amending</span></span><br><span class="line"> 10 <span class="comment"># s, squash = use commit, but meld into previous commit</span></span><br><span class="line"> 11 <span class="comment"># f, fixup = like "squash", but discard this commit's log message</span></span><br><span class="line"> 12 <span class="comment"># x, exec = run command (the rest of the line) using shell</span></span><br><span class="line"> 13 <span class="comment"># d, drop = remove commit</span></span><br><span class="line"> 14 <span class="comment">#</span></span><br><span class="line"> 15 <span class="comment"># These lines can be re-ordered; they are executed from top to bottom.</span></span><br><span class="line"> 16 <span class="comment">#</span></span><br><span class="line"> 17 <span class="comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span></span><br><span class="line"> 18 <span class="comment">#</span></span><br><span class="line"> 19 <span class="comment"># However, if you remove everything, the rebase will be aborted.</span></span><br><span class="line"> 20 <span class="comment">#</span></span><br><span class="line"> 21 <span class="comment"># Note that empty commits are commented out</span></span><br></pre></td></tr></table></figure><p>可见，我们可以选取、编辑、合并、丢弃指定提交，达到整理分支的目的。</p><h1 id="使用风险"><a href="#使用风险" class="headerlink" title="使用风险"></a>使用风险</h1><p>注意，衍合必须遵守的准则：<strong>一旦本地分支中的提交（commit）已经被推送到远程仓库，就千万不要对该分支进行衍合操作。</strong>如果把衍合当成一种<strong>在推送（<code>push</code>）代码之前</strong>整理提交历史的手段，而且仅仅衍合那些<strong>尚未推送</strong>的本地提交，就没问题。如果衍合那些已经推送的提交，并且已经有人基于这些提交对象开展了后续开发工作的话，就会出现叫人沮丧的麻烦。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《<a href="https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E8%A1%8D%E5%90%88#%E8%A1%8D%E5%90%88%E7%9A%84%E9%A3%8E%E9%99%A9" target="_blank" rel="noopener">Git-分支-分支的衍合#衍合的风险</a>》</li><li>《<a href="http://segmentfault.com/q/1010000000430041" target="_blank" rel="noopener">团队开发里频繁使用 git rebase 来保持树的整洁好吗?</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（五）git merge 分支合并策略</title>
      <link href="2015/08/17/git-merge/"/>
      <url>2015/08/17/git-merge/</url>
      
        <content type="html"><![CDATA[<h1 id="快进式合并"><a href="#快进式合并" class="headerlink" title="快进式合并"></a>快进式合并</h1><p>默认情况下，当使用 <code>git merge</code> 合并代码时，背后实际上是进行了一次“快进式合并”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge feature-test</span><br></pre></td></tr></table></figure><p>什么是“快进式合并（fast-forward merge）”？如果顺着一个分支走下去可以直接到达另一个分支的话，那么 Git 在合并两者时，只会简单地把指针右移，因为这种单线的历史分支不存在任何需要解决的分歧，所以这种合并过程可以称为快进（Fast forward）。</p><p>![fast-forward merge](/img/git/fast-forward merge.png)</p><h1 id="非快进式合并"><a href="#非快进式合并" class="headerlink" title="非快进式合并"></a>非快进式合并</h1><p>作为对比，加上 <code>--no-ff</code> 参数进行“非快进式合并（no-fast-forward merge）”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge --no-ff feature-test</span><br></pre></td></tr></table></figure><p>其祖先图谱如下：</p><p>![no-fast-forward merge](/img/git/no-fast-forward merge.png)</p><p>可见，合并后保留有分支历史痕迹（每一次提交），能看得出来曾经做过分支合并，版本演进比较清晰。</p><h1 id="压缩合并"><a href="#压缩合并" class="headerlink" title="压缩合并"></a>压缩合并</h1><p>但大多数时候，没有必要把特性分支的历史保留得太细，只需把整个特性分支压缩（squash）为主干上的一个提交即可。这样的祖先图谱既清晰，又能方便后人审查代码，推荐使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git merge --squash feature-test</span><br><span class="line">$ git commit</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758410364457b9e3d821f4244beb0fd69c61a185ae0000" target="_blank" rel="noopener">Git 分支管理策略 - 廖雪峰</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（四）git checkout 命令撤销修改</title>
      <link href="2015/08/15/git-checkout/"/>
      <url>2015/08/15/git-checkout/</url>
      
        <content type="html"><![CDATA[<p><code>checkout</code> 命令可以用于三种场景：</p><ul><li>切换分支</li><li>创建分支</li><li>撤销修改</li></ul><p>本文只介绍第三种场景。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>如果我们想要撤销一个文件的本地修改，自然可以手工编辑恢复，但这样做实在是吃力不讨好。 <code>checkout</code> 命令可以帮助我们：</p><h2 id="只撤销本地修改"><a href="#只撤销本地修改" class="headerlink" title="只撤销本地修改"></a>只撤销本地修改</h2><p>修改文件后，使用 <code>status</code> 命令查看一下文件状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">      modified:   /there/is/a/modified/file</span><br></pre></td></tr></table></figure><p>Git 提示我们，对于未 <code>add</code> 进暂存区的文件，可以使用 <code>git checkout -- &lt;file&gt;</code> 快速撤销本地修改。</p><h2 id="同时撤销本地和暂存区修改"><a href="#同时撤销本地和暂存区修改" class="headerlink" title="同时撤销本地和暂存区修改"></a>同时撤销本地和暂存区修改</h2><p>那么，对于已 <code>add</code> 进暂存区的文件，如何撤销本地修改？还是先使用 <code>status</code> 命令查看一下文件状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">      modified:   /there/is/a/modified/file</span><br></pre></td></tr></table></figure><h3 id="先取消暂存修改"><a href="#先取消暂存修改" class="headerlink" title="先取消暂存修改"></a>先取消暂存修改</h3><p>Git 提示我们，可以使用 <code>reset</code> 命令取消暂存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset &#x2F;there&#x2F;is&#x2F;a&#x2F;modified&#x2F;file</span><br></pre></td></tr></table></figure><p>取消暂存后，文件状态就回到了跟“例1”一样了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add/rm &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">      modified:   /there/is/a/modified/file</span><br></pre></td></tr></table></figure><h3 id="再撤销本地修改"><a href="#再撤销本地修改" class="headerlink" title="再撤销本地修改"></a>再撤销本地修改</h3><p>这时按提示使用 <code>checkout</code> 即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- /there/is/a/modified/file</span><br></pre></td></tr></table></figure><p>这时工作目录就干净了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>可以看到，结合使用 <code>reset</code> 和 <code>checkout</code> 命令，可以撤销 index 和 working tree 的修改。</p><h3 id="一步到位"><a href="#一步到位" class="headerlink" title="一步到位"></a>一步到位</h3><p>那么有更便捷的、一步到位的办法吗？有，指定提交即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">      modified:   /there/is/a/modified/file</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout HEAD -- /there/is/a/modified/file</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>那么 <code>checkout</code> 命令的全貌究竟是怎样的呢？</p><h1 id="checkout-命令格式"><a href="#checkout-命令格式" class="headerlink" title="checkout 命令格式"></a><code>checkout</code> 命令格式</h1><p><code>checkout</code> 命令的格式及描述如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout [&lt;tree-ish&gt;] [--] &lt;paths&gt;...</span><br><span class="line"></span><br><span class="line">Updates the named paths <span class="keyword">in</span> the working tree from the index file (default) or from a named &lt;tree-ish&gt; (most often a commit, tag or branch)</span><br></pre></td></tr></table></figure><ul><li>默认使用 index 暂存区的内容覆盖本地修改，如果不指定 <code>&lt;tree-ish&gt;</code> 参数。</li><li>或者可以使用指定的提交、标记、分支版本覆盖本地修改。</li><li>为了避免文件路径 <code>&lt;paths&gt;</code> 和 <code>&lt;tree-ish&gt;</code> 同名而发生冲突，在 <code>&lt;paths&gt;</code> 前用 <code>--</code> 作为分隔。</li></ul><h1 id="checkout-与-reset"><a href="#checkout-与-reset" class="headerlink" title="checkout 与 reset"></a><code>checkout</code> 与 <code>reset</code></h1><p>还记得在《<a href="http://www.cnblog.me/2015/08/09/git-reset/" target="_blank" rel="noopener">git reset 命令回退版本</a>》中介绍的 <code>reset</code> 命令吗？它与 <code>checkout</code> 命令之间有什么区别与关系？</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>在这里介绍 <code>reset</code> 命令的另一种形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset [&lt;tree-ish&gt;] [--] &lt;paths&gt;...</span><br><span class="line"></span><br><span class="line">This form copy entries from &lt;tree-ish&gt; to the index <span class="keyword">for</span> all &lt;paths&gt;. (It does not affect the working tree or the current branch.)</span><br></pre></td></tr></table></figure><p>与 <code>checkout</code> 命令的参数一模一样，区别是什么？</p><table><thead><tr><th>命令</th><th>操作目标</th><th>描述</th></tr></thead><tbody><tr><td><code>checkout</code></td><td>工作目录（working tree）</td><td>用于撤销本地修改</td></tr><tr><td><code>reset</code></td><td>暂存区（index）</td><td>只用于覆盖暂存区</td></tr></tbody></table><p>因此 <code>git reset &lt;paths&gt;</code> 等于 <code>git add &lt;paths&gt;</code> 的逆向操作。</p><p>如果企图用 <code>reset</code> 命令覆盖工作目录，是会报错的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard &#x2F;there&#x2F;is&#x2F;a&#x2F;modified&#x2F;file</span><br><span class="line">fatal: Cannot do hard reset with paths.</span><br></pre></td></tr></table></figure><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><blockquote><p>After running <code>git reset &lt;paths&gt;</code> to update the index entry, you can use <code>git checkout -- &lt;paths&gt;</code> to check the contents out of the index to the working tree. </p><p>Alternatively, using <code>git checkout [&lt;tree-ish&gt;] [--] &lt;paths&gt;</code> and specifying a commit, you can copy the contents of a path out of a commit to the <strong>index</strong> and to the <strong>working tree</strong> in one go.</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="http://git-scm.com/docs/git-checkout/" target="_blank" rel="noopener">git checkout</a>》<br>《<a href="http://git-scm.com/docs/git-reset/" target="_blank" rel="noopener">git reset</a>》<br>《<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001374831943254ee90db11b13d4ba9a73b9047f4fb968d000" target="_blank" rel="noopener">Git 教程 - 撤销修改</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（三）git reset 命令回退版本</title>
      <link href="2015/08/09/git-reset/"/>
      <url>2015/08/09/git-reset/</url>
      
        <content type="html"><![CDATA[<p>Git 相比 SVN 的其中一个卓越之处，就在于有各种“后悔药”可吃。其中一种“后悔药”叫做 <code>reset</code> 命令，相当好用。</p><h1 id="三个工作区域"><a href="#三个工作区域" class="headerlink" title="三个工作区域"></a>三个工作区域</h1><p>理解 <code>reset</code> 命令的前提是理解文件流转的三个工作区域：</p><ul><li>工作目录（working directory）</li><li>暂存区域（staging area）</li><li>本地仓库（repo）</li></ul><p><img src="https://git-scm.com/figures/18333fig0106-tn.png" alt=""></p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p><code>reset</code> 命令有三种参数形式，本文只介绍最常用的一种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset [&lt;mode&gt;] [&lt;commit&gt;]</span><br><span class="line"></span><br><span class="line">Reset the current branch head (HEAD) to &lt;commit&gt;, optionally modifying index and working tree to match.</span><br></pre></td></tr></table></figure><p>该命令用于回退本地仓库当前分支下的版本，并可以选择重置暂存区域、工作目录的修改。</p><h2 id="mode-参数"><a href="#mode-参数" class="headerlink" title="mode 参数"></a>mode 参数</h2><p>mode 参数必须是以下五种中的一种：</p><h3 id="soft"><a href="#soft" class="headerlink" title="--soft"></a><code>--soft</code></h3><blockquote><p>HEAD Only</p></blockquote><p>Git 本地仓库的版本回退速度之所以快，全因为 Git 在内部有个指向当前版本的 HEAD 指针，当你回退版本的时候，Git 仅仅是把 HEAD 指针往回移动。</p><h3 id="mixed"><a href="#mixed" class="headerlink" title="--mixed"></a><code>--mixed</code></h3><blockquote><p>HEAD and Index</p></blockquote><p>默认参数。除了回退本地仓库的版本，还会重置暂存区域（也称为 Index File 索引文件）。</p><p>这个默默无闻的 <code>--mixed</code> 参数其实很常见，每次运行 <code>git status</code> 时都会看到它的作用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   /there/is/a/new/file</span><br><span class="line">        modified:   README.md</span><br></pre></td></tr></table></figure><p>由于该命令实在太常用了，因此会被设为 alias 以便使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.unstage <span class="string">'reset HEAD'</span></span><br><span class="line">$ git unstage</span><br></pre></td></tr></table></figure><h3 id="hard"><a href="#hard" class="headerlink" title="--hard"></a><code>--hard</code></h3><blockquote><p>HEAD, Index, and Working Directory</p></blockquote><p>终极武器，将包括工作目录在内的三个工作区域全部重置或回退，工作目录将重置得一干二净，慎用。</p><p>常见的做法是回退到上一个版本，连同工作目录，就像一切从未发生过一样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD~1</span><br><span class="line">HEAD is now at ......</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure><p>如果“回退前的版本”已经 <code>push</code> 到远程仓库，则不建议这么做。</p><h3 id="merge"><a href="#merge" class="headerlink" title="--merge"></a><code>--merge</code></h3><p>待补充。</p><h3 id="keep"><a href="#keep" class="headerlink" title="--keep"></a><code>--keep</code></h3><p>待补充。</p><h2 id="commit-参数"><a href="#commit-参数" class="headerlink" title="commit 参数"></a>commit 参数</h2><p>commit 参数有三种常见形式：</p><h3 id="SHA1"><a href="#SHA1" class="headerlink" title="SHA1"></a>SHA1</h3><p>使用 SHA1 值回退到指定的版本，适用于 SH1 值已知的情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset 17ef24c</span><br></pre></td></tr></table></figure><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>更常用的参数，适用于偷懒：</p><ul><li><code>HEAD</code> 表示当前版本（默认参数）。</li><li>上一个版本为 <code>HEAD^</code> ，上上一个版本为 <code>HEAD^^</code> ，以此类推。</li><li>上 100 个版本，简写为 <code>HEAD~100</code> 。</li><li><code>ORIG_HEAD</code> 表示上一个 <code>HEAD</code> ，一般用于撤销上一次 <code>reset</code> 。（”reset” copies the old head to .git/ORIG_HEAD）</li></ul><h3 id="HEAD-1"><a href="#HEAD-1" class="headerlink" title="HEAD@{}"></a>HEAD@{}</h3><p>Git 在 1.8.5 版本之后，加入了 <code>HEAD@{}</code> 功能，它通过一个链表记录 <code>HEAD</code> 的移动路径，链表头部的 <code>HEAD@{0}</code> 即 <code>HEAD</code> 指针。这个功能可以用于回退到一个早已忘记的提交。</p><p>这个功能一般配合 <code>reflog</code> 命令使用。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>更多例子参见 <code>git help reset</code> 的 EXAMPLES 部分。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="http://www.th7.cn/Program/c/201409/280832.shtml" target="_blank" rel="noopener">Git 中 HEAD 和 ORIG_HEAD 指针分别指的是什么？</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（二）git log 查看提交历史</title>
      <link href="2015/08/04/git-log/"/>
      <url>2015/08/04/git-log/</url>
      
        <content type="html"><![CDATA[<p>在提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，可以使用 <code>git log</code> 命令查看，或者推荐使用 git 自带的图形化工具 <code>gitk</code>。</p><h1 id="命令方式"><a href="#命令方式" class="headerlink" title="命令方式"></a>命令方式</h1><h2 id="定制输出格式-1"><a href="#定制输出格式-1" class="headerlink" title="定制输出格式 1"></a>定制输出格式 1</h2><p><code>git log</code> 的默认输出格式非常不便于查阅提交历史，使用时可以带上以下三个参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --oneline --decorate</span><br><span class="line">*   e6f4e18 (HEAD, master) Merge branch <span class="string">'master'</span> of origin</span><br><span class="line">|\  </span><br><span class="line">* | abfa93b 本地仓库的提交</span><br><span class="line">| * 1f1c21d (origin/master) 远程仓库的提交</span><br><span class="line">|/  </span><br><span class="line">*   17ef24c 基准版本</span><br></pre></td></tr></table></figure><p>命令的输出形象地展示了提交历史，包括本地分支比远程分支领先了多少个提交版本。</p><h2 id="定制输出格式-2"><a href="#定制输出格式-2" class="headerlink" title="定制输出格式 2"></a>定制输出格式 2</h2><p>如果对输出格式还不满意，可以使用 <code>--pretty</code> 参数定制输出格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -5 --pretty=format:<span class="string">"%h - %an, %ar : %s"</span></span><br><span class="line"></span><br><span class="line">f757dcd - wuqd, 20 hours ago : commit msg 5</span><br><span class="line">5ca68df - wuqd, 13 days ago : commit msg 4</span><br><span class="line">486b8d4 - wuqd, 3 weeks ago : commit msg 3</span><br><span class="line">e58ae38 - wuqd, 3 weeks ago : commit msg 2</span><br><span class="line">4830852 - wuqd, 3 weeks ago : commit msg 1</span><br></pre></td></tr></table></figure><p>由于该参数的选项较多，推荐设置为别名（alias）使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.lg <span class="built_in">log</span> --graph --pretty=format:<span class="string">'%Cred%h%Creset - %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;'</span></span><br><span class="line">$ git lg</span><br><span class="line">*   e6f4e18 - Merge branch <span class="string">'master'</span> of origin (1 minutes ago) &lt;Cyn&gt;</span><br><span class="line">|\  </span><br><span class="line">* | abfa93b - 本地仓库的提交 (2 minutes ago) &lt;Pete&gt;</span><br><span class="line">| * 1f1c21d - 远程仓库的提交 (3 minutes ago) &lt;John&gt;</span><br><span class="line">|/  </span><br><span class="line">*   17ef24c - 基准版本 (4 minutes ago) &lt;Jerry&gt;</span><br></pre></td></tr></table></figure><p>格式化输出，代码着色，而且附上了作者、提交时间和祖先图谱。</p><h2 id="筛选提交历史"><a href="#筛选提交历史" class="headerlink" title="筛选提交历史"></a>筛选提交历史</h2><p>当某个特性分支开发完成之后，我们想要筛选并看清将要合并到主干的是哪些代码，从而理解它们到底做了些什么，是否真的要并入。可以用 <code>--not</code> 选项屏蔽 <code>master</code> 分支，这样就会剔除重复的提交历史，看起来更清晰：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> feature-cache --not origin/master</span><br></pre></td></tr></table></figure><p>也可用于筛选出准备 <code>push</code> 到远程仓库的提交，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph --oneline --decorate HEAD --not origin/master</span><br><span class="line">*   e6f4e18 (HEAD, master) Merge branch <span class="string">'master'</span> of origin</span><br><span class="line">|  </span><br><span class="line">*   abfa93b 本地仓库的提交</span><br></pre></td></tr></table></figure><h1 id="图形化方式"><a href="#图形化方式" class="headerlink" title="图形化方式"></a>图形化方式</h1><p>如果对输出格式还不满意，推荐使用 <code>gitk</code> 命令调用图形化工具查阅提交历史：</p><p><img src="http://git-scm.com/figures/18333fig0202-tn.png" alt="gitk"></p><p>上半个窗口显示的是历次提交的分支祖先图谱，下半个窗口显示当前点选的提交对应的具体差异（其中右边 Patch 窗口显示当前提交的<strong>文件列表</strong>，左边 Diff 窗口显示每个文件的提交差异）。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="http://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="noopener">Git 基础 - 查看提交历史</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 实战系列（一）Git 安装与配置</title>
      <link href="2015/08/03/git-setup/"/>
      <url>2015/08/03/git-setup/</url>
      
        <content type="html"><![CDATA[<p>要想 Git 用得爽，首先要安装与配置好。</p><h1 id="如何选择版本？"><a href="#如何选择版本？" class="headerlink" title="如何选择版本？"></a>如何选择版本？</h1><h2 id="Git-1-x"><a href="#Git-1-x" class="headerlink" title="Git 1.x"></a>Git 1.x</h2><p>旧版本，不再维护。</p><h2 id="Git-2-x"><a href="#Git-2-x" class="headerlink" title="Git 2.x"></a>Git 2.x</h2><p>新版本，推荐使用。不向下兼容 1.x。</p><h1 id="如何安装？"><a href="#如何安装？" class="headerlink" title="如何安装？"></a>如何安装？</h1><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>需要安装 Git for Windows 的客户端 <a href="https://github.com/msysgit/msysgit" target="_blank" rel="noopener">msysgit</a>。推荐使用 <a href="http://git-scm.com/download/wint" target="_blank" rel="noopener">绿色便携版</a> ，优势如下：</p><ul><li>无需安装，无需写注册表，无需管理员权限；</li><li>可以从任意目录运行，甚至 U 盘；</li></ul><p>与安装版的区别：</p><ul><li>不提供右键上下文菜单（如 <code>Git GUI Here</code>、<code>Git Bash Here</code>），因为该功能需要写入注册表；</li><li>不修改环境变量 <code>%path%</code> ，因此无法在命令行工具 <code>cmd</code> 中直接运行 <code>git.exe</code> 和 <code>gitk.exe</code>，解决办法：<ul><li>推荐使用自带的 <code>Git Bash</code> （类 Unix Shell）或 <code>Git Cmd</code> 进行替代；</li><li>或将 <code>%GIT_HOME%\cmd</code> 目录永久加入环境变量 <code>%path%</code> （如果只想在当前会话中临时使用，只需在 <code>cmd</code> 中运行 <code>set path=%GIT_HOME%\cmd;%path%</code> 即可），然后运行 <code>git --help</code> 测试配置效果；</li></ul></li></ul><h2 id="Linux-Unix"><a href="#Linux-Unix" class="headerlink" title="Linux / Unix"></a>Linux / Unix</h2><p>使用包管理 apt-get 或 yum 即可。</p><h2 id="OS-X"><a href="#OS-X" class="headerlink" title="OS X"></a>OS X</h2><p>Homebrew 是最快最便捷的安装方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo brew install git</span><br></pre></td></tr></table></figure><h1 id="如何配置？"><a href="#如何配置？" class="headerlink" title="如何配置？"></a>如何配置？</h1><p>Git 相关的配置文件有三个：</p><ol><li><code>/etc/gitconfig</code> 包含了适用于系统所有用户和所有项目的值。</li><li><code>~/.gitconfig</code> 只适用于当前登录用户的配置。</li><li>Git 项目中的 <code>.git/config</code> 适用于特定 Git 项目的配置。</li></ol><p>对于同一配置项，三个配置文件的优先级是 3 &gt; 2 &gt;1。</p><h2 id="配置提交作者"><a href="#配置提交作者" class="headerlink" title="配置提交作者"></a>配置提交作者</h2><p>开始使用 Git 之前，第一件重要的事情就是配置提交作者，配置后就可以愉快的开始使用 Git 了。更多配置请参考 <a href="http://git-scm.com/docs/git-config" target="_blank" rel="noopener">这里</a> 。</p><p>首先做如下检查：</p><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><p>使用 <code>--global</code> 查看或修改全局配置文件 <code>~/.gitconfig</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config -l | grep user</span><br></pre></td></tr></table></figure><p>如果返回为空表示未配置，需要配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"你的姓名"</span></span><br><span class="line">$ git config --global user.email <span class="string">"你的邮箱"</span></span><br></pre></td></tr></table></figure><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>如果需要单独修改项目配置文件 <code>.git/config</code>，去掉 <code>--global</code> 参数即可，或者直接打开该文件添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[user]</span><br><span class="line">name &#x3D; who</span><br><span class="line">email &#x3D; who@where.com</span><br></pre></td></tr></table></figure><h2 id="配置格式化与空白"><a href="#配置格式化与空白" class="headerlink" title="配置格式化与空白"></a>配置格式化与空白</h2><blockquote><p>格式化与空白是许多开发人员在协作时，特别是在跨平台情况下，遇到的令人头疼的细小问题。由于编辑器的不同或者Windows程序员在跨平台项目中的文件行尾加入了回车换行符，一些细微的空格变化会不经意地进入大家合作的工作或提交的补丁中。不用怕，Git 的一些配置选项会帮助你解决这些问题。</p></blockquote><h3 id="core-autocrlf"><a href="#core-autocrlf" class="headerlink" title="core.autocrlf"></a>core.autocrlf</h3><p>Git 在你提交时<strong>自动地</strong>把行结束符 CRLF 转换成 LF，而在签出代码时把 LF 转换成 CRLF。假如团队成员只在 Windows 上写程序，可以关闭此功能，避免 Git 自动格式化代码后干扰代码对比：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.autocrlf <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="core-whitespace"><a href="#core-whitespace" class="headerlink" title="core.whitespace"></a>core.whitespace</h3><p>Git 预先设置了一些选项来探测和修正空白问题，配置方法待补充。</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>Git 长期使用上的一点不便，解决方案仅供参考。</p><h2 id="中文乱码显示问题"><a href="#中文乱码显示问题" class="headerlink" title="中文乱码显示问题"></a>中文乱码显示问题</h2><ol><li><p>打开 GitBash（git-bash.exe）后，对窗口右键-&gt;Options-&gt;Text-&gt;Locale 改为 <code>zh_CN</code>，Character set 改为 <code>GBK</code> ;</p></li><li><p>键入exit退出关闭再打开即可。</p></li></ol><h2 id="配置工作目录"><a href="#配置工作目录" class="headerlink" title="配置工作目录"></a>配置工作目录</h2><p>Git 默认使用程序运行目录作为工作目录，这会带来使用上的不便。解决办法是新建 <code>.bashrc</code> 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~/.bashrc</span><br></pre></td></tr></table></figure><p>添加一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请将 /d/Repos/ 替换成你的仓库目录</span></span><br><span class="line"><span class="built_in">cd</span> /d/Repos/</span><br></pre></td></tr></table></figure><p>即可自动切换到本地仓库所在目录。</p><h2 id="配置-SSH-代理和密钥"><a href="#配置-SSH-代理和密钥" class="headerlink" title="配置 SSH 代理和密钥"></a>配置 SSH 代理和密钥</h2><p>另一个潜在的问题是运行 <code>Git Bash</code> 并拉取远程仓库提示错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></table></figure><p>这是因为 <code>ssh-agent</code> 未随 <code>bash</code> 一起启动。你可以每次都手工启动，或推荐编写脚本自启动。</p><p>新建 <code>.bashrc</code> 文件，并添加如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="keyword">if</span> [ -f ~/.agent.env ]; <span class="keyword">then</span></span><br><span class="line">  . ~/.agent.env &gt;/dev/null</span><br><span class="line">  <span class="built_in">kill</span> -15 <span class="variable">$SSH_AGENT_PID</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Starting ssh-agent..."</span></span><br><span class="line"><span class="built_in">eval</span> `ssh-agent |tee ~/.agent.env`</span><br><span class="line">ssh-add ~/.ssh/github_rsa</span><br></pre></td></tr></table></figure><p>这将会自启动 <code>ssh-agent</code> 并添加指定私钥。 <code>ssh-agent</code> 是一个密钥管理器，运行 <code>ssh-agent</code> 以后，使用 <code>ssh-add</code> 将指定私钥交给 <code>ssh-agent</code> 保管，其它程序（例如 git）在需要身份认证的时候，可以将认证申请交给 <code>ssh-agent</code> 来代为完成整个认证过程。</p><p>那么以后每次运行 <code>Git Bash</code> 的时候，就会看到输出效果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Starting ssh-agent...</span><br><span class="line">Agent pid 8828</span><br><span class="line">Identity added: ~/.ssh/github_rsa</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《<a href="http://best-windows.vlaurie.com/environment-variables.html" target="_blank" rel="noopener">How To Use Environment Variables in Windows</a>》</li><li>《<a href="http://linux.101hacks.com/unix/ssh-add/" target="_blank" rel="noopener">Unix / Linux ssh-add Command Examples to Add SSH Key to Agent</a>》</li><li>《<a href="http://git-scm.com/book/zh/v1/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-%E9%85%8D%E7%BD%AE-Git" target="_blank" rel="noopener">自定义 Git - 配置 Git</a>》</li><li>《<a href="https://github.com/msysgit/msysgit/tags" target="_blank" rel="noopener">Git for Windows 1.x 归档版本下载地址</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优化 Hexo 博客的访问速度</title>
      <link href="2015/05/17/optimizing-hexo-speed/"/>
      <url>2015/05/17/optimizing-hexo-speed/</url>
      
        <content type="html"><![CDATA[<p>之前本博客是挂在 GitHub Pages 空间上的，但由于众所周知的原因访问速度一直很慢，甚至频繁收到无法访问的告警邮件，实在是不堪其扰啊。因此决定迁移博客到国内的空间，并且对部分资源进行 CDN 加速。</p><h1 id="迁移-Pages-服务"><a href="#迁移-Pages-服务" class="headerlink" title="迁移 Pages 服务"></a>迁移 Pages 服务</h1><p>很多国内的空间都支持部署静态博客，例如 <a href="">GitCafe</a>、<a href="https://coding.net">Coding</a>、<a href="http://sae.sina.com.cn/" target="_blank" rel="noopener">SAE</a>、<a href="http://www.qiniu.com/" target="_blank" rel="noopener">七牛</a>、……</p><p>在此特别介绍 GitCafe，一个 GitHub 的国内版，但访问速度比 GitHub 快，其 Pages 服务免费且支持绑定自定义域名，就选它了。</p><p>如何创建 GitCafe Pages 服务？参考<a href="https://gitcafe.com/GitCafe/Help/wiki/Pages-%E7%9B%B8%E5%85%B3%E5%B8%AE%E5%8A%A9" target="_blank" rel="noopener">这里</a>。</p><p>如何将 Hexo 静态博客部署到 GitCafe 仓库？参考<a href="https://github.com/hexojs/hexo-deployer-git#options" target="_blank" rel="noopener">这里</a>，我的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: git@github.com:cynthia903&#x2F;cynthia903.github.io.git,master</span><br><span class="line">    coding: git@git.coding.net:cynthia903&#x2F;cynthia903,coding-pages</span><br><span class="line">    gitcafe: git@gitcafe.com:cynthia903&#x2F;cynthia903.git,gitcafe-pages</span><br></pre></td></tr></table></figure><p>注意仓库地址须使用 SSH 而不是 HTTP 协议，这样在推送代码时就无须繁琐的输入账号密码了。</p><p>运行命令即可生成站点并推送部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><h1 id="使用-CDN-加速"><a href="#使用-CDN-加速" class="headerlink" title="使用 CDN 加速"></a>使用 CDN 加速</h1><p>利用 CDN 服务商遍布全国甚至全球的 CDN 缓存节点，可以使得各地网民迅速的访问到网站资源。对于 Hexo 这种静态博客来说，使用 CDN 进行 HTTP 网页加速尤为合适，缓存命中率极高，减轻源站的访问压力，在博客达到一定访问量时可以考虑使用这种方案。</p><p>目前来说，只需对部分静态资源进行 CDN 加速即可，使用 CDN 公共库可以满足需求。什么是 CDN 公共库？引述自 <a href="http://www.cnbeta.com/articles/304469.htm" target="_blank" rel="noopener">cnbeta</a>：</p><blockquote><p>CDN公共库是指将常用的JS库存放在CDN节点，以方便广大开发者直接调用。使用CDN公共库不仅可以为你节省流量，还能通过CDN加速，获得更快的访问速度。</p></blockquote><p>目前国内一些比较大的 CDN 公共库：</p><ul><li>百度CDN公共库：<a href="http://developer.baidu.com/wiki/index.php?title=docs/cplat/libs" target="_blank" rel="noopener">http://developer.baidu.com/wiki/index.php?title=docs/cplat/libs</a></li><li>新浪云计算CDN公共库：<a href="http://lib.sinaapp.com" target="_blank" rel="noopener">http://lib.sinaapp.com</a></li><li>BootCDN公共库：<a href="http://www.bootcdn.cn" target="_blank" rel="noopener">http://www.bootcdn.cn</a></li><li>360公共库：<a href="http://libs.useso.com" target="_blank" rel="noopener">http://libs.useso.com</a></li><li>七牛云存储 开放静态文件CDN：<a href="http://www.staticfile.org" target="_blank" rel="noopener">http://www.staticfile.org</a></li><li>又拍云JS库CDN服务：<a href="http://jscdn.upai.com" target="_blank" rel="noopener">http://jscdn.upai.com</a></li><li>CDNJS：<a href="http://www.cdnjs.com" target="_blank" rel="noopener">http://www.cdnjs.com</a></li></ul><p>由于 BootCDN 公共库的资源较全，在此推荐选用。</p><p>以 hexo 主题 jacman 为例，修改文件 <code>themes\jacman\layout\_partial\after_footer.ejs</code>，找到以下 JS 和 CSS：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"&lt;%- config.root %&gt;js/jquery-2.0.3.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="&lt;%- config.root %&gt;js/</span>jquery.imagesloaded.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>&lt;%- config.root %&gt;fancybox/jquery.fancybox.pack.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;link rel="</span>stylesheet<span class="string">" href="</span>&lt;%- config.root %&gt;fancybox/jquery.fancybox.css<span class="string">" media="</span>screen<span class="string">" type="</span>text/css<span class="string">"&gt;</span></span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"http://cdn.bootcss.com/jquery/2.0.3/jquery.min.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src="http:/</span><span class="regexp">/cdn.bootcss.com/</span>jquery.imagesloaded/<span class="number">2.1</span><span class="number">.0</span>/jquery.imagesloaded.min.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;script src="</span>http:<span class="comment">//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"&gt;&lt;/script&gt;</span></span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"http://cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"</span> media=<span class="string">"screen"</span> type=<span class="string">"text/css"</span>&gt;</span><br></pre></td></tr></table></figure><p>即可生效。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP EL 表达式总结</title>
      <link href="2015/05/03/java-el/"/>
      <url>2015/05/03/java-el/</url>
      
        <content type="html"><![CDATA[<p>在 JSP 标签中指定一个属性值 <code>value</code> 时，可以使用字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:setProperty name&#x3D;&quot;box&quot; property&#x3D;&quot;perimeter&quot; value&#x3D;&quot;100&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>也可以使用 EL 表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:setProperty name&#x3D;&quot;box&quot; property&#x3D;&quot;perimeter&quot; value&#x3D;&quot;$&#123;expr&#125;&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>那么，EL 表达式 <code>${expr}</code> 中可以放些什么呢？</p><h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><p>EL 表达式支持大部分 Java 所提供的算术和逻辑操作符：</p><h2 id="基本操作符"><a href="#基本操作符" class="headerlink" title="基本操作符"></a>基本操作符</h2><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td><code>.</code></td><td>访问一个 Bean 的属性或者一个映射条目</td></tr><tr><td><code>[]</code></td><td>访问一个数组或者链表的元素</td></tr><tr><td><code>()</code></td><td>组织一个子表达式以改变优先级</td></tr></tbody></table><h2 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h2><table><thead><tr><th>操作符</th><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td><code>+</code></td><td></td><td>加</td></tr><tr><td><code>-</code></td><td></td><td>减或负</td></tr><tr><td><code>*</code></td><td></td><td>乘</td></tr><tr><td><code>/</code></td><td><code>div</code></td><td>除</td></tr><tr><td><code>%</code></td><td><code>mod</code></td><td>取模</td></tr></tbody></table><h2 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h2><table><thead><tr><th>操作符</th><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td><code>==</code></td><td><code>eq</code></td><td>测试是否相等</td></tr><tr><td><code>!=</code></td><td><code>ne</code></td><td>测试是否不等</td></tr><tr><td><code>&lt;</code></td><td><code>lt</code></td><td>测试是否小于</td></tr><tr><td><code>&gt;</code></td><td><code>gt</code></td><td>测试是否大于</td></tr><tr><td><code>&lt;=</code></td><td><code>le</code></td><td>测试是否小于等于</td></tr><tr><td><code>&gt;=</code></td><td><code>ge</code></td><td>测试是否大于等于</td></tr><tr><td><code>&amp;&amp;</code></td><td><code>and</code></td><td>测试逻辑与</td></tr><tr><td><code>&#124;&#124;</code></td><td><code>or</code></td><td>测试逻辑或</td></tr><tr><td><code>!</code></td><td><code>not</code></td><td>测试取反</td></tr><tr><td></td><td><code>empty</code></td><td>测试是否空值</td></tr></tbody></table><h1 id="隐式对象"><a href="#隐式对象" class="headerlink" title="隐式对象"></a>隐式对象</h1><p>JSP 隐式对象（也称为预定义变量）是 JSP 容器为每个页面提供的 Java 对象，开发者可以直接使用它们而不用显式声明。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><table><thead><tr><th>对象</th><th>等价物</th><th>描述</th></tr></thead><tbody><tr><td><code>pageScope</code></td><td><code>this</code></td><td>page 作用域</td></tr><tr><td><code>requestScope</code></td><td><code>javax.servlet.http.HttpServletRequest</code></td><td>request 作用域</td></tr><tr><td><code>sessionScope</code></td><td><code>javax.servlet.http.HttpSession</code></td><td>session 作用域</td></tr><tr><td><code>applicationScope</code></td><td><code>javax.servlet.ServletContext</code></td><td>application 作用域</td></tr></tbody></table><h2 id="HTTP-请求参数"><a href="#HTTP-请求参数" class="headerlink" title="HTTP 请求参数"></a>HTTP 请求参数</h2><table><thead><tr><th>对象</th><th>等价物</th><th>描述</th></tr></thead><tbody><tr><td><code>param</code></td><td><code>request.getParameter(...)</code></td><td>获取指定 HTTP 请求参数，字符串</td></tr><tr><td><code>paramValues</code></td><td><code>request.getParameterValues()</code></td><td>获取所有 HTTP 请求参数，字符串数组</td></tr></tbody></table><p>例如，要判断 HTTP 请求参数 <code>from</code> 是否为空，可以结合使用 JSTL <code>&lt;c:if&gt;</code> 和 EL 操作符 <code>not</code>、<code>empty</code>、EL 隐式对象 <code>param</code> 进行判断：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:if test&#x3D;&quot;$&#123;not empty param.from&#125;&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="HTTP-请求头"><a href="#HTTP-请求头" class="headerlink" title="HTTP 请求头"></a>HTTP 请求头</h2><table><thead><tr><th>对象</th><th>等价物</th><th>描述</th></tr></thead><tbody><tr><td><code>header</code></td><td><code>request.getHeader(...)</code></td><td>获取指定 HTTP 请求头，字符串</td></tr><tr><td><code>headerValues</code></td><td><code>request.getHeaders()</code></td><td>获取所有 HTTP 请求头，字符串数组</td></tr></tbody></table><p>例如，获取请求来源：<code>${header.Referer}</code>。</p><h2 id="HTTP-Cookie"><a href="#HTTP-Cookie" class="headerlink" title="HTTP Cookie"></a>HTTP Cookie</h2><table><thead><tr><th>对象</th><th>等价物</th><th>描述</th></tr></thead><tbody><tr><td><code>cookie</code></td><td><code>request.getCookies()</code></td><td><code>javax.servlet.http.Cookie</code> 数组</td></tr></tbody></table><p>例如，获取指定 <code>Cookie</code> 的值：<code>${cookie.key.value}</code>。这段 EL 表达式会被 JSP 容器解析成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line">Cookie current = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(Cookie cookie : cookies) &#123; </span><br><span class="line">    <span class="keyword">if</span>(cookie.getName().equals(<span class="string">"key"</span>)) &#123;</span><br><span class="line">        current = cookie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(current != <span class="keyword">null</span>) &#123; </span><br><span class="line">    out.print(current.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h2><table><thead><tr><th>对象</th><th>等价物</th><th>描述</th></tr></thead><tbody><tr><td><code>initParam</code></td><td></td><td>上下文初始化参数，即 <code>web.xml</code> 的 <code>&lt;context-param&gt;</code></td></tr><tr><td><code>pageContext</code></td><td><code>javax.servlet.jsp.PageContext</code></td><td>提供对 JSP 页面所有对象以及命名空间的访问</td></tr></tbody></table><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>EL 表达式支持使用函数，其使用语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;ns:fn(param1, param2, ...)&#125;</span><br></pre></td></tr></table></figure><p><code>ns</code> 指的是命名空间（namespace），<code>fn</code> 指的是函数的名称，<code>param1</code> 指的是第一个参数，<code>param2</code> 指的是第二个参数，以此类推。</p><p>例如，要获取一个字符串的长度，可以使用 JSTL 的 <code>length</code> 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;fn:length(&quot;Get my length&quot;)&#125;</span><br></pre></td></tr></table></figure><p>更多 JSTL 函数，参考<a href="http://www.cnblog.me/2015/05/02/java-jstl/#函数标签库" target="_blank" rel="noopener">这里</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP 标准标签库（JSTL）总结</title>
      <link href="2015/05/02/java-jstl/"/>
      <url>2015/05/02/java-jstl/</url>
      
        <content type="html"><![CDATA[<p>JSP 标准标签库（JSP Standard Tag Library）是一个 JSP 标签集合，它封装了 JSP 应用的通用核心功能。</p><p>它的出现，是因为人们开始注重软件的分层设计，不希望在 JSP 页面中出现 JAVA 逻辑代码。同时也由于自定义标签的开发难度较大、不利于技术的标准化，因此产生了 JSTL。</p><p>JSTL 和 EL 的结合，基本可以让页面再无 <code>&lt;% %&gt;</code> 代码。</p><p>JSTL 标准标签库可分为五类：</p><h1 id="核心标签库"><a href="#核心标签库" class="headerlink" title="核心标签库"></a>核心标签库</h1><p>共 14 个，从功能上可以分为 4 类。引用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;</span><br></pre></td></tr></table></figure><h2 id="表达式控制"><a href="#表达式控制" class="headerlink" title="表达式控制"></a>表达式控制</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;c:out&gt;</code></td><td>用于显示数据，就像 <code>&lt;%= %&gt;</code>，区别在于 <code>&lt;c:out&gt;</code> 标签可以直接通过 <code>.</code> 操作符来访问属性</td></tr><tr><td><code>&lt;c:set&gt;</code></td><td>用于保存数据</td></tr><tr><td><code>&lt;c:remove&gt;</code></td><td>用于删除数据</td></tr><tr><td><code>&lt;c:catch&gt;</code></td><td>用来处理产生错误的异常状况，并且将错误信息储存起来</td></tr></tbody></table><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;c:if&gt;</code></td><td>与我们在一般程序中用的 <code>if</code> 一样</td></tr><tr><td><code>&lt;c:choose&gt;</code></td><td>本身只当做 <code>&lt;c:when&gt;</code> 和 <code>&lt;c:otherwise&gt;</code> 的父标签</td></tr><tr><td><code>&lt;c:when&gt;</code></td><td><code>&lt;c:choose&gt;</code> 的子标签，用来判断条件是否成立</td></tr><tr><td><code>&lt;c:otherwise&gt;</code></td><td><code>&lt;c:choose&gt;</code> 的子标签，接在 <code>&lt;c:when&gt;</code> 标签后，当 <code>&lt;c:when&gt;</code> 标签判断为 <code>false</code> 时被执行</td></tr></tbody></table><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;c:forEach&gt;</code></td><td>基础迭代标签，接受多种集合类型</td></tr><tr><td><code>&lt;c:forTokens&gt;</code></td><td>根据指定的<strong>分隔符</strong>来分隔内容并迭代输出</td></tr></tbody></table><h2 id="URL-操作"><a href="#URL-操作" class="headerlink" title="URL 操作"></a>URL 操作</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;c:import&gt;</code></td><td>检索一个绝对或相对 URL，然后将其内容暴露给页面</td></tr><tr><td><code>&lt;c:url&gt;</code></td><td>使用可选的查询参数来创造一个 URL</td></tr><tr><td><code>&lt;c:redirect&gt;</code></td><td>重定向至一个新的 URL</td></tr><tr><td><code>&lt;c:param&gt;</code></td><td>用来给包含或重定向的页面传递参数</td></tr></tbody></table><h1 id="格式化标签库"><a href="#格式化标签库" class="headerlink" title="格式化标签库"></a>格式化标签库</h1><p>用于格式化并输出文本、日期、时间、数字，这里只介绍最最最常用的两个标签。引用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix&#x3D;&quot;fmt&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;fmt&quot; %&gt;</span><br></pre></td></tr></table></figure><h2 id="格式化数字"><a href="#格式化数字" class="headerlink" title="格式化数字"></a>格式化数字</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;fmt:formatNumber&gt;</code></td><td>使用指定的格式或精度格式化数字</td></tr></tbody></table><h2 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;fmt:formatDate&gt;</code></td><td>使用指定的风格或模式格式化日期和时间</td></tr></tbody></table><h1 id="SQL-标签库"><a href="#SQL-标签库" class="headerlink" title="SQL 标签库"></a>SQL 标签库</h1><p>不常用。引用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix&#x3D;&quot;sql&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;sql&quot; %&gt;</span><br></pre></td></tr></table></figure><h1 id="XML-标签库"><a href="#XML-标签库" class="headerlink" title="XML 标签库"></a>XML 标签库</h1><p>不常用。引用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix&#x3D;&quot;x&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;xml&quot; %&gt;</span><br></pre></td></tr></table></figure><h1 id="函数标签库"><a href="#函数标签库" class="headerlink" title="函数标签库"></a>函数标签库</h1><p>大部分都是通用的字符串处理函数，用于配合 <strong>EL 表达式</strong>使用。引用方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix&#x3D;&quot;fn&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;functions&quot; %&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>fn:contains()</code></td><td>测试输入的字符串是否包含指定的子串</td></tr><tr><td><code>fn:containsIgnoreCase()</code></td><td>测试输入的字符串是否包含指定的子串，大小写不敏感</td></tr><tr><td><code>fn:endsWith()</code></td><td>测试输入的字符串是否以指定的后缀结尾</td></tr><tr><td><code>fn:escapeXml()</code></td><td>跳过可以作为XML标记的字符</td></tr><tr><td><code>fn:indexOf()</code></td><td>返回指定字符串在输入字符串中出现的位置</td></tr><tr><td><code>fn:join()</code></td><td>将数组中的元素合成一个字符串然后输出</td></tr><tr><td><code>fn:length()</code></td><td>返回字符串长度</td></tr><tr><td><code>fn:replace()</code></td><td>将输入字符串中指定的位置替换为指定的字符串然后返回</td></tr><tr><td><code>fn:split()</code></td><td>将字符串用指定的分隔符分隔然后组成一个子字符串数组并返回</td></tr><tr><td><code>fn:startsWith()</code></td><td>测试输入字符串是否以指定的前缀开始</td></tr><tr><td><code>fn:substring()</code></td><td>返回字符串的子集</td></tr><tr><td><code>fn:substringAfter()</code></td><td>返回字符串在指定子串之后的子集</td></tr><tr><td><code>fn:substringBefore()</code></td><td>返回字符串在指定子串之前的子集</td></tr><tr><td><code>fn:toLowerCase()</code></td><td>将字符串中的字符转为小写</td></tr><tr><td><code>fn:toUpperCase()</code></td><td>将字符串中的字符转为大写</td></tr><tr><td><code>fn:trim()</code></td><td>移除首位的空白符</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="http://www.runoob.com/jsp/jsp-jstl.html" target="_blank" rel="noopener">JSP 标准标签库（JSTL）</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP 标签总结</title>
      <link href="2015/05/01/java-jsp/"/>
      <url>2015/05/01/java-jsp/</url>
      
        <content type="html"><![CDATA[<p>JSP 有以下三类标签：</p><h1 id="JSP-Directive"><a href="#JSP-Directive" class="headerlink" title="JSP Directive"></a>JSP Directive</h1><p>指令标签用于设置与整个 JSP 页面相关的属性，非常常用。</p><table><thead><tr><th>标签</th><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;%@ page ... %&gt;</code></td><td><code>&lt;jsp:directive.page attribute=&quot;value&quot; /&gt;</code></td><td>定义页面的依赖属性，例如脚本语言、页面编码、缓存需求等等</td></tr><tr><td><code>&lt;%@ include ... %&gt;</code></td><td><code>&lt;jsp:directive.include file=&quot;relative url&quot; /&gt;</code></td><td>引入其它文件，例如 JSP、HTML、文本文件</td></tr><tr><td><code>&lt;%@ taglib ... %&gt;</code></td><td><code>&lt;jsp:directive.taglib uri=&quot;uri&quot; prefix=&quot;prefixOfTag&quot; /&gt;</code></td><td>引入标签库，可以是 JSP 标准标签库（JSTL）、也可以是自定义标签库</td></tr></tbody></table><h1 id="JSP-Syntax"><a href="#JSP-Syntax" class="headerlink" title="JSP Syntax"></a>JSP Syntax</h1><p>语法标签是 Java 早期为了便于开发人员在 JSP 页面中书写业务逻辑而设计的，但目前不再建议使用。</p><table><thead><tr><th>标签</th><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;% scriptlet %&gt;</code></td><td><code>&lt;jsp:scriptlet&gt; scriptlet &lt;/jsp:scriptlet&gt;</code></td><td>脚本程序，可以包含任意有效的 Java 语句、变量、方法或表达式</td></tr><tr><td><code>&lt;%! declaration %&gt;</code></td><td><code>&lt;jsp:declaration&gt; declaration &lt;/jsp:declaration&gt;</code></td><td>声明语句，可以声明一个或多个变量、方法，供后面的 Java 代码使用</td></tr><tr><td><code>&lt;%= expression %&gt;</code></td><td><code>&lt;jsp:expression&gt; expression &lt;/jsp:expression&gt;</code></td><td>表达式，其结果会被转为字符串并输出到 HTML 页面</td></tr><tr><td><code>&lt;%-- comment --%&gt;</code></td><td></td><td>代码注释</td></tr></tbody></table><p>举个栗子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%! String output &#x3D; &quot;world&quot;; %&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;% out.println(&quot;Hello &quot; + output); %&gt;</span><br><span class="line">    &lt;br&#x2F;&gt;</span><br><span class="line">    &lt;%&#x3D; &quot;Hello &quot; + output %&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>渲染输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello world </span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure><p>上例中，虽然结合使用这三种语法标签，可以在 JSP 页面中写出大段的 Java 逻辑代码，但强烈不建议这么做，因为这样会导致前端页面和业务逻辑之间紧耦合，以致后续难以维护。</p><h1 id="JSP-Action"><a href="#JSP-Action" class="headerlink" title="JSP Action"></a>JSP Action</h1><p>函数标签是一些预定义好的行为标签，但不常用。</p><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;jsp:include&gt;</code></td><td>用于在当前页面中包含静态或动态资源</td></tr><tr><td><code>&lt;jsp:useBean&gt;</code></td><td>寻找和初始化一个 JavaBean 组件</td></tr><tr><td><code>&lt;jsp:setProperty&gt;</code></td><td>设置 JavaBean 组件的值</td></tr><tr><td><code>&lt;jsp:getProperty&gt;</code></td><td>将 JavaBean 组件的值插入到 output 中</td></tr><tr><td><code>&lt;jsp:forward&gt;</code></td><td>从一个 JSP 文件向另一个文件传递一个包含用户请求的 request 对象</td></tr><tr><td><code>&lt;jsp:plugin&gt;</code></td><td>用于在生成的 HTML 页面中包含 Applet 和 JavaBean 对象</td></tr><tr><td><code>&lt;jsp:element&gt;</code></td><td>动态创建一个 XML 元素</td></tr><tr><td><code>&lt;jsp:attribute&gt;</code></td><td>定义动态创建的 XML 元素的属性</td></tr><tr><td><code>&lt;jsp:body&gt;</code></td><td>定义动态创建的 XML 元素的主体</td></tr><tr><td><code>&lt;jsp:text&gt;</code></td><td>用于封装模板数据</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 DNSPod 解决 GoDaddy 域名解析不稳定的问题</title>
      <link href="2015/04/26/dnspod/"/>
      <url>2015/04/26/dnspod/</url>
      
        <content type="html"><![CDATA[<p>由于众所周知的原因，GoDaddy 的 Nameservers 有时会被墙，导致其在国内的域名解析服务一直都很不稳定，因此抽空改用了国内的 DNSPod 服务，步骤如下：</p><h1 id="注册-DNSPod-账号"><a href="#注册-DNSPod-账号" class="headerlink" title="注册 DNSPod 账号"></a>注册 DNSPod 账号</h1><p>DNSPod 已并入腾讯，使用 QQ 账号绑定并登录即可。</p><h1 id="添加域名"><a href="#添加域名" class="headerlink" title="添加域名"></a>添加域名</h1><p>添加在域名服务商中购买的域名即可，不带 www 前缀。</p><h1 id="添加-CNAME-记录（canonical-name）"><a href="#添加-CNAME-记录（canonical-name）" class="headerlink" title="添加 CNAME 记录（canonical name）"></a>添加 CNAME 记录（canonical name）</h1><p>这里各人需求不同，设置因人而异。</p><p>对于我的需求而言，需要为域名 <code>cnblog.me</code> 添加两条 <code>CNAME</code> 记录，分别是带 www 前缀和不带的：</p><table><thead><tr><th>主机记录</th><th>记录类型</th><th>记录值</th></tr></thead><tbody><tr><td>www</td><td>CNAME</td><td>cynthia903.github.io</td></tr><tr><td>@</td><td>CNAME</td><td>cynthia903.github.io</td></tr></tbody></table><p>什么是主机记录？DNSPod 的备注清晰地描述道，主机记录就是域名前缀，常见用法有：</p><table><thead><tr><th>主机记录</th><th>描述</th></tr></thead><tbody><tr><td>www</td><td>解析后的域名为 <a href="http://www.cnblog.me" target="_blank" rel="noopener">www.cnblog.me</a></td></tr><tr><td>@</td><td>直接解析主域名 cnblog.me</td></tr><tr><td>*</td><td>泛解析，匹配其他所有域名 *.cnblog.me</td></tr></tbody></table><h1 id="修改-NS-记录（name-server）"><a href="#修改-NS-记录（name-server）" class="headerlink" title="修改 NS 记录（name server）"></a>修改 NS 记录（name server）</h1><p>什么是 <code>NS</code> 记录？</p><blockquote><p>即域名服务器记录，用于指定该域名由哪个 DNS 服务器进行域名解析。注册域名时，总会有默认的 NS 记录。</p></blockquote><p>接下来我们需要将域名服务商 GoDaddy 默认配置的 <code>NS</code> 记录修改为 DNSPod 提供的 <code>NS</code> 记录，以解决域名解析不稳定的问题。</p><h2 id="记下-DNSPod-的-NS-记录"><a href="#记下-DNSPod-的-NS-记录" class="headerlink" title="记下 DNSPod 的 NS 记录"></a>记下 DNSPod 的 NS 记录</h2><p>DNSPod 默认配置并提供的 <code>NS</code> 记录如下：</p><table><thead><tr><th>主机记录</th><th>记录类型</th><th>记录值</th></tr></thead><tbody><tr><td>@</td><td>NS</td><td>f1g1ns1.dnspod.net</td></tr><tr><td>@</td><td>NS</td><td>f1g1ns2.dnspod.net</td></tr></tbody></table><h2 id="修改默认配置的-NS-记录"><a href="#修改默认配置的-NS-记录" class="headerlink" title="修改默认配置的 NS 记录"></a>修改默认配置的 NS 记录</h2><p>进入 GoDaddy 的 NAMESERVER SETTINGS ，SETUP TYPE 默认为 Standard ，并默认配置了一组 <code>NS</code> 记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ns35.domaincontrol.com</span><br><span class="line">ns36.domaincontrol.com</span><br></pre></td></tr></table></figure><p>由于 GoDaddy 默认配置的这组 Nameservers <code>*.domaincontrol.com</code> 被墙，导致域名解析不稳定，需要修改为国内 DNSPod 的 Nameservers 。</p><p>将 SETUP TYPE 切换到 Custom ，并添加 DNSPod 提供的 <code>NS</code> 记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1g1ns1.dnspod.net</span><br><span class="line">f1g1ns2.dnspod.net</span><br></pre></td></tr></table></figure><p>修改成功后，域名 <code>cnblog.me</code> 将会使用 DNSPod 提供的域名解析服务。</p><h1 id="DNS-解析测试"><a href="#DNS-解析测试" class="headerlink" title="DNS 解析测试"></a>DNS 解析测试</h1><p>使用 dig 命令测试，可见 <code>www.cnblog.me</code> 的 <code>CNAME</code> 记录、 <code>NS</code> 记录已经配置成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ dig +trace www.cnblog.me</span><br><span class="line"></span><br><span class="line">......（此处略过 Root、TLD，只展示权威域名服务器的解析结果）</span><br><span class="line">www.cnblog.me.          600     IN      CNAME   cynthia903.github.io.</span><br><span class="line">cnblog.me.              600     IN      NS      f1g1ns1.dnspod.net.</span><br><span class="line">cnblog.me.              600     IN      NS      f1g1ns2.dnspod.net.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DNS </tag>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse 系列之常用默认快捷键</title>
      <link href="2015/04/21/eclipse-default-key-assist/"/>
      <url>2015/04/21/eclipse-default-key-assist/</url>
      
        <content type="html"><![CDATA[<p>常用的 Eclipse 默认快捷键，总结如下：</p><h1 id="源码类"><a href="#源码类" class="headerlink" title="源码类"></a>源码类</h1><p>这一类快捷键是我的最爱，可以极大的提高编程和重构效率。</p><table><thead><tr><th>Command</th><th>Binding</th><th>Description</th></tr></thead><tbody><tr><td>Quick Fix</td><td>Ctrl+1</td><td>Suggest possible fixes for a problem</td></tr><tr><td>Content Assist</td><td>Alt+/</td><td>内容辅助（代码提示）</td></tr><tr><td>Show Source Quick Menu</td><td>Alt+Shift+S</td><td>重构</td></tr><tr><td>Rename</td><td>Alt+Shift+R</td><td>重命名</td></tr><tr><td>Extract Function</td><td>Alt+Shift+M</td><td>抽取方法</td></tr><tr><td>Organize Imports</td><td>Ctrl+Shift+O</td><td>自动导入类包</td></tr></tbody></table><h1 id="搜索类"><a href="#搜索类" class="headerlink" title="搜索类"></a>搜索类</h1><p>Eclipse 这类 IDE 区别于其它文本编辑器（如 Vim、UE、EP、Notepad2 等）的一大优势是拥有强大的引用和搜索功能。</p><table><thead><tr><th>Command</th><th>Binding</th><th>Description</th></tr></thead><tbody><tr><td>Incremental Find</td><td>Ctrl+J</td><td>增量搜索</td></tr><tr><td>Incremental Find Reverse</td><td>Ctrl+Shift+J</td><td>反向搜索</td></tr><tr><td>Go to Line</td><td>Ctrl+L</td><td>定位到指定行</td></tr><tr><td>Open Search Dialog</td><td>Ctrl+H</td><td>打开搜索对话框</td></tr><tr><td>Open Resource</td><td>Ctrl+Shift+R</td><td>开发目标资源文件</td></tr><tr><td>Open Call Hierarchy</td><td>Ctrl+Alt+H</td><td>查找指定元素的调用栈 / Open a call hierarchy on the selected element</td></tr><tr><td>Show Occurrences in File Quick Menu</td><td>Ctrl+Shift+U</td><td>在<strong>当前文件</strong>中查找指定元素的引用</td></tr><tr><td>References in Workspace</td><td>Ctrl+Shift+G</td><td>在<strong>工作空间</strong>中查找指定元素的引用</td></tr></tbody></table><h1 id="文本编辑类"><a href="#文本编辑类" class="headerlink" title="文本编辑类"></a>文本编辑类</h1><p>偷懒者必备。</p><table><thead><tr><th>Command</th><th>Binding</th><th>Description</th></tr></thead><tbody><tr><td>Delete Line</td><td>Ctrl+D</td><td>删除当前行</td></tr><tr><td>Toggle Comment</td><td>Ctrl+/</td><td>注释当前行</td></tr><tr><td>Move Lines Up</td><td>Alt+↑</td><td>将选定行上移</td></tr><tr><td>Move Lines Down</td><td>Alt+↓</td><td>将选定行下移</td></tr><tr><td>Duplicate Lines</td><td>Ctrl+Alt+↑</td><td>复制选定行</td></tr><tr><td>Copy Lines</td><td>Ctrl+Alt+↓</td><td>复制选定行</td></tr><tr><td>To Upper Case</td><td>Ctrl+Shift+X</td><td>将所选区域字母设置为大写</td></tr><tr><td>To Lower Case</td><td>Ctrl+Shift+Y</td><td>将所选区域字母设置为小写</td></tr><tr><td>Toggle Block Selection</td><td>Alt+Shift+A</td><td>块编辑功能 / Toggle block / column selection in the current text editor</td></tr></tbody></table><h1 id="其它类"><a href="#其它类" class="headerlink" title="其它类"></a>其它类</h1><table><thead><tr><th>Command</th><th>Binding</th><th>Description</th></tr></thead><tbody><tr><td>Backward History</td><td>Alt+←</td><td>前一个编辑页面 / Move backward in the editor navigation history</td></tr><tr><td>Forward History</td><td>Alt+→</td><td>后一个编辑页面 / Move forward in the editor navigation history</td></tr><tr><td>Scroll Line Up</td><td>Ctrl+↑</td><td>向上滚动一行文本 / Scroll up one line of text</td></tr><tr><td>Scroll Line Down</td><td>Ctrl+↓</td><td>向下滚动一行文本 / Scroll down one line of text</td></tr><tr><td>Maximize Active View or Editor</td><td>Ctrl+M</td><td>全屏 / Toggles maximize/restore state of active view or editor</td></tr><tr><td>Properties</td><td>Alt+Enter</td><td>Display the properties of the selected item</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse 系列之自定义高效快捷键</title>
      <link href="2015/04/19/eclipse-customize-key-assist/"/>
      <url>2015/04/19/eclipse-customize-key-assist/</url>
      
        <content type="html"><![CDATA[<blockquote><p>好的快捷键可以提高编码的效率。</p></blockquote><h1 id="第三方解决方案"><a href="#第三方解决方案" class="headerlink" title="第三方解决方案"></a>第三方解决方案</h1><p>曾经使用过 Eclipse 的 Vim 插件 <a href="http://www.viplugin.com/" target="_blank" rel="noopener">viplugin</a> 提升光标移动和文本编辑的效率，但终因一些热键冲突问题而放弃使用了，有兴趣的同学可以参考 《<a href="http://viplugin.com/files/User_Manual_viPlugin.pdf" target="_blank" rel="noopener">viplugin 用户手册</a>》，付费破解参考<a href="http://blog.163.com/thomaskjh@126/blog/static/37082998201231810718341/" target="_blank" rel="noopener">这里</a>。</p><p>其它解决方案还有 <a href="http://vrapper.sourceforge.net/" target="_blank" rel="noopener">vrapper</a>、<a href="http://eclim.org/" target="_blank" rel="noopener">eclim</a> ，可以自行体验。</p><h1 id="我的方案"><a href="#我的方案" class="headerlink" title="我的方案"></a>我的方案</h1><p>经过权衡，还是决定自定义一套属于自己的快捷键。键位主要参考 Vim 和 Bash ，并主要利用闲置的 <code>Alt</code> 键避免冲突，配置总结如下：</p><h2 id="移动光标类"><a href="#移动光标类" class="headerlink" title="移动光标类"></a>移动光标类</h2><table><thead><tr><th>Command</th><th>Binding</th><th>Description</th></tr></thead><tbody><tr><td>Line Up</td><td><code>Alt + K</code></td><td>↑</td></tr><tr><td>Line Down</td><td><code>Alt + J</code></td><td>↓</td></tr><tr><td>Previous Column</td><td><code>Alt + H</code></td><td>←</td></tr><tr><td>Next Column</td><td><code>Alt + L</code></td><td>→</td></tr><tr><td>Line Start</td><td><code>Alt + A</code></td><td></td></tr><tr><td>Line End</td><td><code>Alt + E</code></td><td></td></tr><tr><td>Previous Word</td><td><code>Alt + B</code></td><td></td></tr><tr><td>Next Word</td><td><code>Alt + F</code></td><td></td></tr><tr><td>Go to Next Member</td><td><code>Alt + G</code></td><td></td></tr><tr><td>Go to Previous Member</td><td><code>Alt + Shift + G</code></td><td></td></tr><tr><td>Open Implementation</td><td><code>Alt + Q</code></td><td></td></tr></tbody></table><h2 id="通用类"><a href="#通用类" class="headerlink" title="通用类"></a>通用类</h2><table><thead><tr><th>Command</th><th>Binding</th></tr></thead><tbody><tr><td>Delete</td><td><code>Alt + D</code></td></tr><tr><td>Select Enclosing Element</td><td><code>Alt + S</code></td></tr><tr><td>File Search</td><td><code>Ctrl + H</code></td></tr><tr><td>Next View</td><td><code>Alt + V</code></td></tr><tr><td>Rerun JUnit Test</td><td><code>Alt + R</code></td></tr><tr><td>Run Maven Clean</td><td><code>Alt + Shift + X, C</code></td></tr></tbody></table><h2 id="Git-类"><a href="#Git-类" class="headerlink" title="Git 类"></a>Git 类</h2><table><thead><tr><th>Command</th><th>Binding</th></tr></thead><tbody><tr><td>Pull</td><td><code>Alt + 1</code></td></tr><tr><td>Commit</td><td><code>Alt + 2</code></td></tr><tr><td>Show in History</td><td><code>Alt + 3</code></td></tr><tr><td>Compare with HEAD Revision</td><td><code>Alt + 4</code></td></tr><tr><td>Replace with HEAD Revision</td><td><code>Alt + 5</code></td></tr><tr><td>Show In (Git Repositories)</td><td><code>Alt + 6</code></td></tr></tbody></table><h2 id="SVN-类"><a href="#SVN-类" class="headerlink" title="SVN 类"></a>SVN 类</h2><table><thead><tr><th>Command</th><th>Binding</th></tr></thead><tbody><tr><td>更新</td><td><code>Alt + 1</code></td></tr><tr><td>提交</td><td><code>Alt + 2</code></td></tr><tr><td>Show History</td><td><code>Alt + 3</code></td></tr><tr><td>Compare with Local Base Revision</td><td><code>Alt + 4</code></td></tr><tr><td>复原</td><td><code>Alt + 5</code></td></tr></tbody></table><p>注意，Eclipse 有 Bug 在配置完以上 SVN 快捷键之后，快捷键是无法使用的，需要为当前的视图（Perspective）添加一个 SVN 的工具。配置如下：</p><blockquote><p>Window &gt; Customize Perspective… &gt; Tool Bar Visibility</p></blockquote><p>勾选 SVN 即可。</p><h1 id="另辟蹊径的方案"><a href="#另辟蹊径的方案" class="headerlink" title="另辟蹊径的方案"></a>另辟蹊径的方案</h1><p>其实也可以不必局限于 Eclipse 这款 IDE ，热爱 Vim 快捷键的同学可以考虑使用其它 IDE ，如 <a href="http://www.sublimetext.com/" target="_blank" rel="noopener">Sublime Text</a> ，可以原生完美支持 Vim 快捷键，配置如下：</p><blockquote><p>Preferences - Settings - User - “ignored_packages”: []</p></blockquote><p>去掉 [] 里面的 “Vintage” 即可。</p><p>在写 Python 代码时就感觉体验很好，值得一试。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GUN/Bash 系列（八）快捷键总结</title>
      <link href="2015/04/19/gnu-bash-shortcut-keys/"/>
      <url>2015/04/19/gnu-bash-shortcut-keys/</url>
      
        <content type="html"><![CDATA[<p>下面总结的是 GNU/Bash 中部分最实用的命令名称及默认情况下它们关联的快捷键。更多快捷键请参考 GNU/Bash 文档的 Readline 库。</p><h1 id="移动（Commands-for-Moving）"><a href="#移动（Commands-for-Moving）" class="headerlink" title="移动（Commands for Moving）"></a>移动（Commands for Moving）</h1><table><thead><tr><th>Shortcut</th><th>Command name</th><th>Description</th></tr></thead><tbody><tr><td><code>Ctrl + A</code></td><td>beginning-of-line</td><td>Move to the start of the current line.</td></tr><tr><td><code>Ctrl + E</code></td><td>end-of-line</td><td>Move to the end of the line.</td></tr><tr><td><code>Ctrl + F</code></td><td>forward-char</td><td>Move forward a character.</td></tr><tr><td><code>Ctrl + B</code></td><td>backward-char</td><td>Move back a character.</td></tr><tr><td><code>Alt + F</code></td><td>forward-word</td><td>Move forward to the end of the next word. Words are composed of alphanumeric characters (letters and digits).</td></tr><tr><td><code>Alt + B</code></td><td>backward-word</td><td>Move back to the start of the current or previous word. Words are composed of alphanumeric characters (letters and digits).</td></tr><tr><td><code>Ctrl + L</code></td><td>clear-screen</td><td>Clear the screen leaving the current line at the top of the screen. With an argument, refresh the current line without clearing the screen.</td></tr></tbody></table><h1 id="操纵历史行（Commands-for-Manipulating-the-History）"><a href="#操纵历史行（Commands-for-Manipulating-the-History）" class="headerlink" title="操纵历史行（Commands for Manipulating the History）"></a>操纵历史行（Commands for Manipulating the History）</h1><table><thead><tr><th>Shortcut</th><th>Command name</th><th>Description</th></tr></thead><tbody><tr><td><code>Ctrl + P</code></td><td>previous-history</td><td>Fetch the previous command from the history list, moving back in the list.</td></tr><tr><td><code>Ctrl + N</code></td><td>next-history</td><td>Fetch the next command from the history list, moving forward in the list.</td></tr><tr><td><code>Ctrl + R</code></td><td>reverse-search-history</td><td>Search backward starting at the current line and moving `up’ through the history as necessary. This is an incremental search.</td></tr><tr><td><code>Alt + Ctrl + Y</code></td><td>yank-nth-arg</td><td>Insert the first argument to the previous command (usually the second word on the previous line) at point. With an argument n, insert the nth word from the previous command (the words in the previous command begin with word 0). A negative argument inserts the nth word from the end of the previous command. Once the argument n is computed, the argument is extracted as if the “!n” history expansion had been specified.</td></tr></tbody></table><h1 id="改变文本（Commands-for-Changing-Text）"><a href="#改变文本（Commands-for-Changing-Text）" class="headerlink" title="改变文本（Commands for Changing Text）"></a>改变文本（Commands for Changing Text）</h1><table><thead><tr><th>Shortcut</th><th>Command name</th><th>Description</th></tr></thead><tbody><tr><td><code>Ctrl + D</code></td><td>delete-char</td><td>Delete the character at point. If point is at the beginning of the line, there are no characters in the line, and the last character typed was not bound to delete-char, then return EOF.</td></tr></tbody></table><h1 id="剪切和粘贴（Killing-and-Yanking）"><a href="#剪切和粘贴（Killing-and-Yanking）" class="headerlink" title="剪切和粘贴（Killing and Yanking）"></a>剪切和粘贴（Killing and Yanking）</h1><table><thead><tr><th>Shortcut</th><th>Command name</th><th>Description</th></tr></thead><tbody><tr><td><code>Ctrl + K</code></td><td>kill-line</td><td>Kill the text from point to the end of the line.</td></tr><tr><td><code>Ctrl + U</code></td><td>backward-kill-line</td><td>Kill backward from point to the beginning of the line.</td></tr><tr><td><code>Alt + D</code></td><td>kill-word</td><td>Kill from point to the end of the current word, or if between words, to the end of the next word. Word boundaries are the same as those used by forward-word.</td></tr><tr><td><code>Ctrl + W</code></td><td>backward-kill-word</td><td>Kill the word behind point, using white space as a word boundary. The killed text is saved on the kill-ring.</td></tr><tr><td><code>Ctrl + Y</code></td><td>yank</td><td>Yank the top of the kill ring into the buffer at point.</td></tr></tbody></table><h1 id="补全（Completing）"><a href="#补全（Completing）" class="headerlink" title="补全（Completing）"></a>补全（Completing）</h1><table><thead><tr><th>Shortcut</th><th>Command name</th><th>Description</th></tr></thead><tbody><tr><td><code>TAB</code></td><td>complete</td><td>Attempt to perform completion on the text before point. Bash attempts completion treating the text as a variable (if the text begins with $), username (if the text begins with ~), hostname (if the text begins with @), or command (including aliases and functions) in turn. If none of these produces a match, filename completion is attempted.</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="http://www.gnu.org/software/bash/manual/bashref.html#Bindable-Readline-Commands" target="_blank" rel="noopener">GNU/Bash Readline Commands</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GoDaddy 中配置无 www 前缀域名</title>
      <link href="2015/04/12/godaddy-cname-without-www/"/>
      <url>2015/04/12/godaddy-cname-without-www/</url>
      
        <content type="html"><![CDATA[<p>搭好博客后，在权威域名服务商 GoDaddy 注册了一个新域名使用。当配置无 www 前缀域名时，却遇到了一些配置问题。</p><h1 id="为什么要配置无-www-前缀的域名？"><a href="#为什么要配置无-www-前缀的域名？" class="headerlink" title="为什么要配置无 www 前缀的域名？"></a>为什么要配置无 www 前缀的域名？</h1><p>引述<a href="http://www.zhihu.com/question/20064691" target="_blank" rel="noopener">知乎</a>：</p><blockquote><p>www 是一个二级域名。无 www 才是一级域名。</p><p>拿掉它的原因有两个：</p><ol><li>遵循 Google 的关于域名长度的建议。</li><li>保证网站的某一个页面有且只有一个唯一的 URL 可以访问。</li></ol></blockquote><h1 id="CNAME-配置问题"><a href="#CNAME-配置问题" class="headerlink" title="CNAME 配置问题"></a>CNAME 配置问题</h1><p>@ 记录指没有主机名的域名部份，如 foo.com 。于是想通过 GoDaddy 的 DNS ZONE FILE 配置一条 Host 为 @ 的 CNAME 记录：</p><table><thead><tr><th>Host</th><th>Points To</th><th>TTL</th></tr></thead><tbody><tr><td>www</td><td>cynthia903.github.io</td><td>1 Hour</td></tr><tr><td>@</td><td>cynthia903.github.io</td><td>1 Hour</td></tr></tbody></table><p>保存修改时，却报错了：</p><blockquote><p>THESE RECORDS WERE NOT PROCESSED DUE TO ERRORS:</p><p>The specified record already exists.</p><p>CNAME - @</p></blockquote><p>原来按 <a href="http://www.ietf.org/rfc/rfc1034.txt" target="_blank" rel="noopener">rfc1034</a> 规定，是不能对 @ 记录做 CNAME 的，只能做 A 记录。</p><h1 id="301-重定向跳转"><a href="#301-重定向跳转" class="headerlink" title="301 重定向跳转"></a>301 重定向跳转</h1><p>经查询，常见做法是将 foo.com 做 301 重定向跳转到 <a href="http://www.foo.com" target="_blank" rel="noopener">www.foo.com</a> 。GoDaddy 的 Forwarding 配置可以实现该功能：</p><p>CNBLOG.ME</p><table><thead><tr><th>Forward to</th><th>Redirect</th><th>Type</th></tr></thead><tbody><tr><td><a href="http://www.cnblog.me" target="_blank" rel="noopener">http://www.cnblog.me</a></td><td>301 (Permanent)</td><td>Forward only</td></tr></tbody></table><h1 id="解析测试"><a href="#解析测试" class="headerlink" title="解析测试"></a>解析测试</h1><h2 id="301-重定向跳转测试"><a href="#301-重定向跳转测试" class="headerlink" title="301 重定向跳转测试"></a>301 重定向跳转测试</h2><p>使用 chrome 的开发者工具（F12 或 Ctrl+Shift+I 打开），访问 cnblog.me</p><table><thead><tr><th>Path</th><th>Method</th><th>Status</th></tr></thead><tbody><tr><td><a href="http://cnblog.me/" target="_blank" rel="noopener">http://cnblog.me/</a></td><td>GET</td><td>301 Moved Permanently</td></tr><tr><td><a href="http://www.cnblog.me/" target="_blank" rel="noopener">http://www.cnblog.me/</a></td><td>GET</td><td>200 OK</td></tr></tbody></table><h2 id="DNS-解析测试"><a href="#DNS-解析测试" class="headerlink" title="DNS 解析测试"></a>DNS 解析测试</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>使用 dig 命令测试，可见 <a href="http://www.cnblog.me" target="_blank" rel="noopener">www.cnblog.me</a> 已经成功 CNAME 到 cynthia903.github.io 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ dig -t cname www.cnblog.me</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.cnblog.me.                 IN      CNAME</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.cnblog.me.          3277    IN      CNAME   cynthia903.github.io.</span><br></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>使用 nslookup 命令测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup www.cnblog.me</span><br><span class="line">服务器:  cache-b.guangzhou.gd.cn</span><br><span class="line">Address:  202.96.128.166&#x2F;&#x2F; 当前使用的 DNS 服务器。如果无法解析，可以换用谷歌的试试（nslookup www.cnblog.me 8.8.8.8）</span><br><span class="line"></span><br><span class="line">非权威应答:</span><br><span class="line">名称:    github.map.fastly.net</span><br><span class="line">Address:  199.27.78.133</span><br><span class="line">Aliases:  www.cnblog.me</span><br><span class="line">          cynthia903.github.io</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《<a href="http://serverfault.com/questions/486406/configuring-cname-record-in-godaddy-control-panel" target="_blank" rel="noopener">Configuring “@” CNAME record in GoDaddy control panel</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> DNS </tag>
            
            <tag> 建站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器与内核总结</title>
      <link href="2015/04/06/broswer-kernel/"/>
      <url>2015/04/06/broswer-kernel/</url>
      
        <content type="html"><![CDATA[<p>工作中需要测试 JavaScript 浏览器兼容性，简单总结如下。</p><h1 id="内核介绍"><a href="#内核介绍" class="headerlink" title="内核介绍"></a>内核介绍</h1><table><thead><tr><th>内核</th><th>备注</th></tr></thead><tbody><tr><td>Trident</td><td>IE 内核，Trident 内核长期一家独大，很多国内浏览器使用。</td></tr><tr><td>Webkit</td><td>苹果公司自己的内核，也是苹果的 Safari 浏览器使用的内核。Chrome 也曾使用此内核。</td></tr><tr><td>Blink</td><td>2013年4月3日谷歌称将与苹果 Webkit 分道扬镳，将自主研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。</td></tr><tr><td>Gecko</td><td>Firefox 使用的内核。</td></tr><tr><td>Presto</td><td>Opera 前内核(已废弃)，现已改用 Webkit 内核。</td></tr></tbody></table><h1 id="浏览器及其内核"><a href="#浏览器及其内核" class="headerlink" title="浏览器及其内核"></a>浏览器及其内核</h1><table><thead><tr><th>浏览器</th><th>IE7</th><th>IE8</th><th>IE9</th><th>IE10</th><th>Webkit</th><th>Gecko</th><th>备注</th></tr></thead><tbody><tr><td>Internet Explorer 7</td><td>√</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Internet Explorer 8</td><td></td><td>√</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Internet Explorer 9</td><td></td><td></td><td>√</td><td></td><td></td><td></td><td></td></tr><tr><td>Internet Explorer 10</td><td></td><td></td><td></td><td>√</td><td></td><td></td><td></td></tr><tr><td>Google Chrome</td><td></td><td></td><td></td><td></td><td>√</td><td></td><td></td></tr><tr><td>Mozilla Firefox</td><td></td><td></td><td></td><td></td><td></td><td>√</td><td></td></tr><tr><td>Apple Safari</td><td></td><td></td><td></td><td></td><td>√</td><td></td><td></td></tr><tr><td>Opera</td><td></td><td></td><td></td><td></td><td>√</td><td></td><td>Opera 放弃自家 Presto 内核转投 WebKit</td></tr><tr><td>360极速浏览器</td><td>√</td><td></td><td></td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>360安全浏览器</td><td></td><td></td><td></td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>傲游云浏览器</td><td></td><td></td><td></td><td>√</td><td>√</td><td></td><td>通过菜单，切换浏览内核：兼容-&gt;极速 操作</td></tr><tr><td>QQ浏览器</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td><td>通过兼容性视图切到 IE7，通过启用扩展组件调用 Webkit 内核</td></tr><tr><td>搜狐高速浏览器</td><td>√</td><td></td><td></td><td></td><td>√</td><td></td><td>在地址栏点击切换“高速”或“兼容”模式</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>《<a href="http://www.feelcss.com/domestic-ie-core-browser-called-ie-version.html" target="_blank" rel="noopener">国内各IE内核浏览器所调用的IE版本</a>》</li><li>《<a href="http://castic.cyscc.org/help/browserdetecter/" target="_blank" rel="noopener">浏览器检测工具</a>》</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 启动失败问题处理</title>
      <link href="2015/04/03/docker-installation-problem/"/>
      <url>2015/04/03/docker-installation-problem/</url>
      
        <content type="html"><![CDATA[<p>Q1 参加了一场 Docker 技术分享后，发现了 Docker 这个好东西，回头动手安装，打算跑起来体验一番，却遇到了一些蛋疼的问题。</p><h1 id="如何安装-Docker"><a href="#如何安装-Docker" class="headerlink" title="如何安装 Docker"></a>如何安装 Docker</h1><p>Windows 如何安装 Docker？参考 <a href="https://docs.docker.com/installation/windows/" target="_blank" rel="noopener">官网安装教程</a> 。</p><p>由于 Docker 引擎使用了 Linux 特有的内核特性，因此在 Windows 中运行 Docker 需要使用一个轻量级的虚拟机。方便起见，Docker 团队设计了一个名为“Boot2Docker”的辅助程序用于安装所需的虚拟机并用于运行 Docker 进程。</p><p>此外，由于 Docker 对镜像（Image）的增删改查操作都是通过 Git ，因此在 Windows 下，还需要一个 MSYS-git 客户端。</p><p>因此，Boot2Docker 内置：</p><ul><li>Boot2Docker</li><li>Boot2Docker Management Tool</li><li><a href="https://www.virtualbox.org" target="_blank" rel="noopener">VirtualBox</a></li><li><a href="http://msysgit.github.io/" target="_blank" rel="noopener">MSYS-git</a></li></ul><p>需要注意，如果之前本地已经安装过 Git / GitHub for Windows 、VirtualBox ，则无需再安装内置的 MSYS-git、 VirtualBox 。</p><h1 id="VirtualBox-导致的启动失败问题"><a href="#VirtualBox-导致的启动失败问题" class="headerlink" title="VirtualBox 导致的启动失败问题"></a>VirtualBox 导致的启动失败问题</h1><h2 id="初始化（docker-init）失败问题处理"><a href="#初始化（docker-init）失败问题处理" class="headerlink" title="初始化（docker init）失败问题处理"></a>初始化（docker init）失败问题处理</h2><p>安装成功后，使用 Git Shell 运行启动脚本，结果却报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ start.sh</span><br><span class="line">copying initial boot2docker.iso (run &quot;boot2docker.exe download&quot; to update)</span><br><span class="line">initializing...</span><br><span class="line">error in run: Failed to initialize machine &quot;boot2docker-vm&quot;: exit status 1</span><br></pre></td></tr></table></figure><p>通过阅读 start.sh 脚本，发现卡在了 docker init 初始化这个步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &#39;initializing...&#39;</span><br><span class="line">.&#x2F;boot2docker.exe init</span><br></pre></td></tr></table></figure><p>这时候，通过错误日志或控制台输出排查错误就很关键了，<code>-v</code> 参数可以用于显示详细的命令调用过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v, --verbose&#x3D;false: display verbose command invocations.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ boot2docker.exe init -v</span><br><span class="line">Boot2Docker-cli version: v1.4.1</span><br><span class="line">Git commit: 43241cb</span><br><span class="line">2015&#x2F;04&#x2F;03 11:57:06 executing: E:\Developer\Oracle\VirtualBox\VBoxManage.exe showvminfo boot2docker-vm --machinereadable</span><br><span class="line">2015&#x2F;04&#x2F;03 11:57:06 executing: E:\Developer\Oracle\VirtualBox\VBoxManage.exe showvminfo boot2docker-vm --machinereadable</span><br><span class="line">2015&#x2F;04&#x2F;03 11:57:06 executing: E:\Developer\Oracle\VirtualBox\VBoxManage.exe list vms</span><br><span class="line">VBoxManage.exe: error: Failed to create the VirtualBox object!</span><br><span class="line">VBoxManage.exe: error: Code E_INVALIDARG (0x80070057) - One or more arguments are invalid (extended info not available)</span><br><span class="line">VBoxManage.exe: error: Most likely, the VirtualBox COM server is not running or failed to start.</span><br><span class="line">error in run: Failed to initialize machine &quot;boot2docker-vm&quot;: exit status 1</span><br></pre></td></tr></table></figure><p>通过控制台输出发现，VirtualBox 下的 <code>VBoxManage.exe</code> 运行出错了。</p><p>当时很疑惑，本地使用的是 Docker 内置 VirtualBox ，打开 <code>VirtualBox.exe</code>，同样会报错。</p><p>翻了下 VirtualBox 日志文件，Google 了一番输出错误，貌似跟什么 <a href="http://www.dotcoo.com/virtualbox-uxtheme" target="_blank" rel="noopener">Windows 破解主题的 DLL 文件</a>有关，折腾了一番没能解决。</p><p><a href="http://www.cnblogs.com/tanhangbo/p/4282605.html" target="_blank" rel="noopener">再次搜索</a>，最后发现了两个问题：</p><ol><li>程序兼容性问题导致 VirtualBox 无法打开；</li><li>VirtualBox 版本问题导致虚拟机无法启动；</li></ol><p>第一个问题，通过对 <code>VBoxManage.exe</code>、<code>VBoxManage.exe</code> 右键 - 勾选“以兼容模式运行这个程序”，至少保证打开程序不会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ Oracle&#x2F;VirtualBox&#x2F;VBoxManage.exe list vms</span><br><span class="line">&quot;centos&quot; &#123;440faef3-b83d-4daa-b7ce-3942c03dc580&#125;</span><br></pre></td></tr></table></figure><p>第二个问题，通过多个版本的安装/卸载尝试，最后发现在我的电脑使用 VirtualBox 4.3.10 能够正常启动虚拟机。</p><h2 id="启动（docker-start）失败问题处理"><a href="#启动（docker-start）失败问题处理" class="headerlink" title="启动（docker start）失败问题处理"></a>启动（docker start）失败问题处理</h2><p>Docker 成功初始化后，还遇到一个虚拟化失败导致的 VirtualBox 无法启动的问题，报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">VMSetError: VT-x is disabled in the BIOS.</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>打开 BIOS 的 Virtualization Technology (VTx/VTd) 开关，即可解决问题。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>再次运行 Docker 启动脚本，Docker 终于启动起来了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">connecting...</span><br><span class="line">                        ##        .</span><br><span class="line">                  ## ## ##       &#x3D;&#x3D;</span><br><span class="line">               ## ## ## ##      &#x3D;&#x3D;&#x3D;</span><br><span class="line">           &#x2F;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;\___&#x2F; &#x3D;&#x3D;&#x3D;</span><br><span class="line">      ~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~ ~ &#x2F;  &#x3D;&#x3D;&#x3D;- ~~~</span><br><span class="line">           \______ o          __&#x2F;</span><br><span class="line">             \    \        __&#x2F;</span><br><span class="line">              \____\______&#x2F;</span><br><span class="line"> _                 _   ____     _            _</span><br><span class="line">| |__   ___   ___ | |_|___ \ __| | ___   ___| | _____ _ __</span><br><span class="line">| &#39;_ \ &#x2F; _ \ &#x2F; _ \| __| __) &#x2F; _&#96; |&#x2F; _ \ &#x2F; __| |&#x2F; &#x2F; _ \ &#39;__|</span><br><span class="line">| |_) | (_) | (_) | |_ &#x2F; __&#x2F; (_| | (_) | (__|   &lt;  __&#x2F; |</span><br><span class="line">|_.__&#x2F; \___&#x2F; \___&#x2F; \__|_____\__,_|\___&#x2F; \___|_|\_\___|_|</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="http://www.cnblogs.com/tanhangbo/p/4282605.html" target="_blank" rel="noopener">virtualbox 打不开ubuntu解决</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GUN/Bash 系列（七）提示符（Prompting）</title>
      <link href="2015/04/01/gnu-bash-prompting/"/>
      <url>2015/04/01/gnu-bash-prompting/</url>
      
        <content type="html"><![CDATA[<p>在使用交互式 Bash 时，一个配置得当的命令提示符可以为用户带来不少便利，本文讲解如何配置命令提示符。</p><h1 id="默认提示符"><a href="#默认提示符" class="headerlink" title="默认提示符"></a>默认提示符</h1><p>命令提示符涉及到以下两个环境变量：</p><table><thead><tr><th>环境变量</th><th>描述</th></tr></thead><tbody><tr><td><code>PS1</code></td><td>主提示符，Bash 会在准备好读入一条命令时显示，默认值 <code>\s-\v\$</code></td></tr><tr><td><code>PS2</code></td><td>次提示符，Bash 会在需要更多的输入来完成一条命令时显示，默认值 <code>&gt;</code></td></tr></tbody></table><h1 id="定制提示符"><a href="#定制提示符" class="headerlink" title="定制提示符"></a>定制提示符</h1><p>Bash 允许通过插入一些反斜杠转义的特殊字符来定制这些提示符，常用的转义字符如下：</p><table><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td><code>\h</code></td><td>主机名，第一个 <code>.</code> 之前的部分</td></tr><tr><td><code>\H</code></td><td>主机名</td></tr><tr><td><code>\j</code></td><td>shell 当前管理的作业数量</td></tr><tr><td><code>\l</code></td><td>shell 的终端设备名的基本部分</td></tr><tr><td><code>\n</code></td><td>新行符</td></tr><tr><td><code>\r</code></td><td>回车</td></tr><tr><td><code>\s</code></td><td>shell 的名称， <code>$0</code> 的基本部分 (最后一个斜杠后面的部分)</td></tr><tr><td><code>\u</code></td><td>当前用户的用户名</td></tr><tr><td><code>\v</code></td><td>bash 的版本 (例如，4.3)</td></tr><tr><td><code>\w</code></td><td>当前工作目录</td></tr><tr><td><code>\W</code></td><td>当前工作目录的基本部分</td></tr><tr><td><code>\!</code></td><td>此命令的历史编号</td></tr><tr><td><code>\#</code></td><td>此命令的命令编号</td></tr><tr><td><code>\$</code></td><td>如果有效 UID 为 0，则显示 <code>#</code>, 否则 <code>$</code></td></tr><tr><td><code>\\</code></td><td>一个反斜杠</td></tr></tbody></table><p>除此之外，还有一些不太常用的日期转义字符：</p><table><thead><tr><th>转义字符</th><th>描述</th></tr></thead><tbody><tr><td><code>\d</code></td><td>当前日期，格式是 “星期 月份 日” (例如，”Tue May 26”)</td></tr><tr><td><code>\D{format}</code></td><td>自定义日期格式，花括号是必需的</td></tr><tr><td><code>\t</code></td><td>当前时间，采用 24 小时制的 <code>HH:MM:SS</code> 格式</td></tr><tr><td><code>\T</code></td><td>当前时间，采用 12 小时制的 <code>HH:MM:SS</code> 格式</td></tr><tr><td><code>\@</code></td><td>当前时间，采用 12 小时制上午/下午 <code>am/pm</code> 格式</td></tr><tr><td><code>\A</code></td><td>当前时间，采用 24 小时制上午/下午格式</td></tr></tbody></table><h2 id="如何定制"><a href="#如何定制" class="headerlink" title="如何定制"></a>如何定制</h2><p>由于 <code>PS1</code> 默认设置的 <code>\s-\v\$</code> 实在是太废毫无信息量可言，显示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash-4.3$</span><br></pre></td></tr></table></figure><p>因此可以通过修改 <code>~/.bash_profile</code> 文件来定制自己的命令提示符。例如，使用 CentOS 默认设置的 <code>[\u@\h \W]\$</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~&#x2F;.bash_profile</span><br><span class="line"></span><br><span class="line">export PS1&#x3D;&quot;[\u@\h \w]\$ &quot;</span><br></pre></td></tr></table></figure><p>定制后，能够知道当前用户、主机名、工作目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@BGP-BJ-C-5HL ~]$</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.gnu.org/software/bash/manual/bashref.html#Controlling-the-Prompt" target="_blank" rel="noopener">http://www.gnu.org/software/bash/manual/bashref.html#Controlling-the-Prompt</a></p><p>《<a href="http://www.cnblogs.com/lienhua34/p/5018119.html" target="_blank" rel="noopener">自定义shell终端提示符（例如颜色）</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GUN/Bash 系列（六）Shell 常用扩展总结</title>
      <link href="2015/03/16/gnu-bash-shell-expansions/"/>
      <url>2015/03/16/gnu-bash-shell-expansions/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell-扩展（Shell-Expansions）"><a href="#Shell-扩展（Shell-Expansions）" class="headerlink" title="Shell 扩展（Shell Expansions）"></a>Shell 扩展（Shell Expansions）</h1><p>命令行的扩展是在拆分成词之后进行的。共有七种类型的扩展：</p><ul><li>brace expansion</li><li>tilde expansion</li><li>parameter and variable expansion</li><li>command substitution</li><li>arithmetic expansion</li><li>word splitting</li><li>filename expansion</li></ul><p>常用的四种如下</p><h2 id="花括号扩展（Brace-Expansion）"><a href="#花括号扩展（Brace-Expansion）" class="headerlink" title="花括号扩展（Brace Expansion）"></a>花括号扩展（Brace Expansion）</h2><p>用于偷懒，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x&#123;a,b,cd&#125;y</span><br></pre></td></tr></table></figure><p>扩展为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xay xby xcdy</span><br></pre></td></tr></table></figure><p>再例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;src&#x2F;bash&#x2F;&#123;old,new,dist&#125;</span><br></pre></td></tr></table></figure><p>扩展为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;src&#x2F;bash&#x2F;old</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;src&#x2F;bash&#x2F;new</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;src&#x2F;bash&#x2F;dist</span><br></pre></td></tr></table></figure><h2 id="参数和变量扩展（Parameter-and-Variable-Expansion）"><a href="#参数和变量扩展（Parameter-and-Variable-Expansion）" class="headerlink" title="参数和变量扩展（Parameter and Variable Expansion）"></a>参数和变量扩展（Parameter and Variable Expansion）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;parameter&#125;</span></span><br></pre></td></tr></table></figure><h2 id="算术扩展（Arithmetic-Expansion）"><a href="#算术扩展（Arithmetic-Expansion）" class="headerlink" title="算术扩展（Arithmetic Expansion）"></a>算术扩展（Arithmetic Expansion）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(( expression ))</span><br></pre></td></tr></table></figure><h2 id="命令替换（Command-Substitution）"><a href="#命令替换（Command-Substitution）" class="headerlink" title="命令替换（Command Substitution）"></a>命令替换（Command Substitution）</h2><p>命令替换允许命令的输出替换命令本身。当命令被以下特殊字符包括时，将发生命令替换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">command</span>)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="built_in">command</span>`</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Expansions" target="_blank" rel="noopener">https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Expansions</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GUN/Bash 系列（五）Shell 内建命令总结</title>
      <link href="2015/03/15/gnu-bash-shell-builtin-commands/"/>
      <url>2015/03/15/gnu-bash-shell-builtin-commands/</url>
      
        <content type="html"><![CDATA[<p>GUN/Bash 提供了一些内建命令 (BUILTIN COMMANDS)，用于在命令行上方便使用：</p><h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1><p><code>echo</code> 显示一行文本或变量</p><p><code>unset</code> 取消变量</p><p><code>set</code> 查看所有变量（环境变量&amp;用户变量）</p><p><code>env</code> 查看所有环境变量（格式好看些）</p><p><code>export</code></p><ul><li>查看所有环境变量</li><li>将局部变量转成环境变量：<ul><li>可以利用 <code>export</code> 命令将局部变量转为环境变量，但是用户注销时值将丢失；</li><li>环境配置文件中，经常会用到 <code>export</code> 命令，相当于每次登录时系统都帮用户 <code>export</code> 一下所需环境变量；</li><li>环境变量在当前进程 fork 出来的子进程中也能被访问到；</li><li>目前发现安装软件时有用。</li></ul></li></ul><p><code>source</code> 或 <code>.</code></p><ul><li>加载环境配置文件（无须 <code>exit</code> 注销）</li><li>执行脚本（在父进程bash中执行，设置的变量都会保留）</li></ul><p><code>declare</code> 或 <code>typeset</code></p><ul><li><code>-a</code> 定义数组类型</li><li><code>-i</code> 定义整数类型</li><li><code>-x</code> 将用户变量转成环境变量（与 <code>export</code> 一样）</li><li><code>+x</code> 将环境变量降为用户变量</li><li><code>-r</code> 定义 readonly 类型</li></ul><p><code>read</code> 读取来自键盘输入的变量</p><ul><li><code>-p</code> 后接提示符</li><li><code>-t</code> 后接等待“秒数”</li></ul><p><code>test</code></p><ul><li><code>-e</code> 该文件名是否存在（exist）</li><li><code>-s</code> 该文件大小是否非 0</li><li><code>-z</code> 是否为空字符串（zero）</li><li><code>-f</code> 是否为文件（file）</li><li><code>-d</code> 是否为目录（directory）</li><li><code>-b</code> 是否为块特殊文件（block）</li><li><code>-L</code> 是否为连接文件（link）</li><li><code>-r</code> <code>-w</code> <code>-x</code> 是否可读、可写、可执行</li><li><code>-a</code> <code>-o</code> <code>!</code> 且、或、非</li><li><code>-eq</code> <code>-ne</code> <code>-gt</code> <code>-lt</code> <code>-ge</code> <code>-le</code> （判断2个整数）相等、不等、大于、小于、大于等于、小于等于</li></ul><p><code>[]</code></p><ul><li>中括号 <code>[]</code> 的使用方法与 <code>test</code> 命令几乎一模一样，只是中括号常用于条件判断式 <code>if…then…fi</code></li><li>中括号内的每个元素，都要有<strong>空格符</strong>分隔</li><li>中括号内的变量，最好都以<strong>双引号</strong>括起来</li><li>中括号内的常量（字符串），最好都以单引号 <code>&#39;&#39;</code> 或双引号 <code>&quot;&quot;</code> 括起来</li></ul><p><code>sh</code> 以 <code>sh</code> 方式执行，至少需要 <code>r</code> 权限；若以绝对路径方式执行，则需要 <code>r</code> 与 <code>x</code> 权限</p><ul><li><code>-n</code> 不执行 script，仅验证语法。若语法无误，则不显示任何信息。（貌似仅能验证关键字错误？）</li><li><code>-v</code> 在执行 script 前，先将 script 的内容输出到屏幕上</li><li><code>-x</code> 将 script 执行过程逐步输出到屏幕上</li></ul><h1 id="作业控制类"><a href="#作业控制类" class="headerlink" title="作业控制类"></a>作业控制类</h1><p>Bash 是一个多任务的 CLI ，有以下作业控制（Job Control）相关的命令：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td><code>jobs</code></td><td>显示（当前会话中的）后台作业表</td></tr><tr><td><code>fg</code></td><td>将后台作业调到前台执行（前台运行作业）</td></tr><tr><td><code>bg</code></td><td>继续执行指定的后台作业（后台运行作业）</td></tr><tr><td><code>Ctrl+Z</code></td><td>暂停/挂起目前的命令，转入后台运行。通过在命令后追加一个&amp;，可以将该命令转入后台运行</td></tr><tr><td><code>Ctrl+C</code></td><td>终止目前的命令</td></tr></tbody></table><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.gnu.org/software/bash/manual/bashref.html#Shell-Builtin-Commands" target="_blank" rel="noopener">http://www.gnu.org/software/bash/manual/bashref.html#Shell-Builtin-Commands</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GUN/Bash 系列（四）Shell 管道、重定向、序列、复合命令总结</title>
      <link href="2015/03/12/gnu-bash-shell-commands/"/>
      <url>2015/03/12/gnu-bash-shell-commands/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell-命令"><a href="#Shell-命令" class="headerlink" title="Shell 命令"></a>Shell 命令</h1><h2 id="简单命令（Simple-Commands）"><a href="#简单命令（Simple-Commands）" class="headerlink" title="简单命令（Simple Commands）"></a>简单命令（Simple Commands）</h2><p>即单个命令。</p><h2 id="管道（Pipelines）"><a href="#管道（Pipelines）" class="headerlink" title="管道（Pipelines）"></a>管道（Pipelines）</h2><p>pipeline（管道）是一个或多个命令的序列，用字符 | 分隔。管道的命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> [ | command2 ... ]</span><br></pre></td></tr></table></figure><p>管道的特点如下：</p><ul><li>管道是一个由“标准输入输出”链接起来的进程集合；</li><li>管道中的每个命令都作为单独的进程来执行（即在一个子 shell 中启动）；</li><li>每一个进程的输出（stdout）被直接作为下一个进程的输入（stdin）；</li><li>管道命令不处理 standard error output（stderr）；</li><li>管道的符号为：<code>|</code></li></ul><p>管道的处理流程如下图：</p><p><img src="/img/gnu-text-utilities/pipe.png" alt="pipe"></p><h2 id="重定向（Redirection）"><a href="#重定向（Redirection）" class="headerlink" title="重定向（Redirection）"></a>重定向（Redirection）</h2><p>在命令执行前，它的输入和输出可能被 redirected (重定向)，该功能可以用于如下场景：</p><ul><li>屏幕输出的信息很重要，而且需要将它存下来时；</li><li>一些运行命令的可能已知错误信息，想以 <code>2&gt; /dev/null</code> 将它丢掉；</li><li>一些系统的例行命令（例如写在 <code>/etc/crontab</code>）的运行结果，需要存下来时；</li><li>错误信息与正确信息需要分别输出时。</li></ul><p>例子：</p><p>快速创建带内容的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"hello world"</span> &gt; /tmp/file</span><br><span class="line">$ cat /tmp/file</span><br></pre></td></tr></table></figure><p>将已知错误信息丢弃</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find /tmp/ -name 2&gt; /dev/null</span><br></pre></td></tr></table></figure><h3 id="描述符（Descriptor-Number）"><a href="#描述符（Descriptor-Number）" class="headerlink" title="描述符（Descriptor Number）"></a>描述符（Descriptor Number）</h3><table><thead><tr><th>描述符</th><th>描述</th></tr></thead><tbody><tr><td><code>0</code></td><td>标准输入（stdin）</td></tr><tr><td><code>1</code></td><td>标准输出（stdout）</td></tr><tr><td><code>2</code></td><td>标准错误输出（stderr）</td></tr></tbody></table><h3 id="操作符（Operator）"><a href="#操作符（Operator）" class="headerlink" title="操作符（Operator）"></a>操作符（Operator）</h3><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td>重定向输入（Redirecting Input）</td></tr><tr><td><code>&gt;</code></td><td>重定向输出（Redirecting Output），与 <code>1&gt;</code> 等价</td></tr><tr><td><code>&gt;&gt;</code></td><td>追加到重定向输出（Appending Redirected Output）</td></tr><tr><td><code>2&gt;</code></td><td>重定向错误输出（Redirecting Error）</td></tr><tr><td><code>2&gt;&gt;</code></td><td>追加到重定向错误输出（Appending Redirected Error）</td></tr><tr><td><code>&amp;&gt;</code></td><td>重定向标准输出和标准错误输出（Redirecting Standard Output and Standard Error）。 <strong>推荐使用</strong>，它与 <code>&gt;word 2&gt;&amp;1</code> 在语义上等价</td></tr><tr><td><code>&gt;&amp;</code></td><td>同上，但不推荐使用</td></tr><tr><td><code>2&gt;&amp;1</code></td><td>将标准错误输出重定向到标准输出</td></tr></tbody></table><h2 id="序列（Lists-of-Commands）"><a href="#序列（Lists-of-Commands）" class="headerlink" title="序列（Lists of Commands）"></a>序列（Lists of Commands）</h2><p>list（序列）是一个或多个管道，用操作符 <code>;</code>、<code>&amp;</code>、<code>&amp;&amp;</code>、<code>||</code> 分隔的序列, 并且可以选择用 <code>;</code>、<code>&amp;</code>、<code>&lt;newline&gt;</code> 新行符结束。</p><table><thead><tr><th>操作符</th><th>例子</th><th>描述</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>command1 &amp;&amp; command2</td><td>一个 AND 序列。command2 只有在 command1 返回 0 时才被执行</td></tr><tr><td><code>&#124;&#124;</code></td><td>command1 &#124;&#124; command2</td><td>一个 OR 序列。command2 只有在 command1 返回非 0 状态时才被执行</td></tr><tr><td><code>;</code></td><td>command1; command2</td><td>结束一个序列。不考虑命令的退出状态，连续执行命令</td></tr><tr><td><code>&lt;newline&gt;</code></td><td>command&lt;newline&gt;</td><td>结束一个序列</td></tr><tr><td><code>&amp;</code></td><td>command1 &amp;</td><td>如果一个命令是由 &amp; 结束的, shell 将在后台的子 shell 中执行这个命令</td></tr></tbody></table><ul><li>AND 和 OR 序列的返回状态是序列中最后执行的命令的返回状态。</li><li>这些序列操作符中， <code>&amp;&amp;</code> 和 <code>||</code> 优先级相同， <code>;</code> 和 <code>&amp;</code> 优先级相同。</li></ul><h3 id="退出状态（Exit-Status）"><a href="#退出状态（Exit-Status）" class="headerlink" title="退出状态（Exit Status）"></a>退出状态（Exit Status）</h3><ul><li>从 shell 的角度看，一个命令退出状态是 0 意味着成功退出。 非零状态值表明失败。</li><li>如果没有找到命令，为执行它而创建的子进程返回 127。</li><li>如果找到了命令但是文件不可执行，返回状态是 126。</li><li>如果命令由于扩展或重定向错误而失败，退出状态大于零。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在某些情况下，很多命令我想要一次输入去运行，有两种方法：</p><ol><li>Shell Script</li><li>使用序列</li></ol><p>例如，一串无人值守源代码形式安装的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure><h2 id="复合命令（Compound-Commands）"><a href="#复合命令（Compound-Commands）" class="headerlink" title="复合命令（Compound Commands）"></a>复合命令（Compound Commands）</h2><p>compound command（复合命令）是如下情况之一：</p><ul><li><p><code>(list)</code></p></li><li><p><code>{ list; }</code></p></li><li><p><code>((expression))</code></p></li><li><p><code>[[ expression ]]</code></p></li><li><p><code>if list; then list; [ elif list; then list; ] ... [ else list; ] fi</code></p></li><li><p><code>case word in [ [(] pattern [ | pattern ]</code></p></li><li><p><code>while list; do list; done</code></p></li><li><p><code>until list; do list; done</code></p></li><li><p><code>for name [ in word ] ; do list ; done</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一个数组变量</span></span><br><span class="line">order_array=(</span><br><span class="line">  10000</span><br><span class="line">  10001</span><br><span class="line">  10002</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环打印与保存到文件</span></span><br><span class="line"><span class="keyword">for</span> id <span class="keyword">in</span> <span class="variable">$&#123;order_array[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"order is <span class="variable">$id</span>"</span> | tee -a result.txt</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p><code>for (( expr1 ; expr2 ; expr3 )) ; do list ; done</code></p></li><li><p><code>select name [ in word ] ; do list ; done</code></p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Arrays" target="_blank" rel="noopener">https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Arrays</a></p><p><a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Commands" target="_blank" rel="noopener">https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Commands</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GUN/Bash 系列（三）Shell 引用与参数总结</title>
      <link href="2015/03/10/gnu-bash-shell-quoting-and-params/"/>
      <url>2015/03/10/gnu-bash-shell-quoting-and-params/</url>
      
        <content type="html"><![CDATA[<h1 id="Shell-语法"><a href="#Shell-语法" class="headerlink" title="Shell 语法"></a>Shell 语法</h1><h2 id="引用（Quoting）"><a href="#引用（Quoting）" class="headerlink" title="引用（Quoting）"></a>引用（Quoting）</h2><p>引用用于：</p><ul><li>阻止对特殊字符的处理。</li><li>阻止保留字被识别。</li><li>阻止参数的扩展。</li></ul><p>三种引用机制：</p><table><thead><tr><th>引用符</th><th>描述</th></tr></thead><tbody><tr><td>转义字符 <code>\</code></td><td>保留其后下一个字符的字面意义</td></tr><tr><td>单引号 <code>&#39;&#39;</code></td><td>保留引用中所有字符的字面意义</td></tr><tr><td>双引号 <code>&quot;&quot;</code></td><td>保留引用中所有字符的字面意义，例外的情况是 $, `, 和 \</td></tr></tbody></table><p>单引号与双引号的使用区别：</p><p><img src="/img/gnu-linux/bash_quoting.png" alt="quoting"></p><p>注意，反引号 <code>`</code> 与单引号 <code>&#39;&#39;</code> 和双引号 <code>&quot;&quot;</code> 作用不同，是用于命令替换（Command Substitution），详见《Shell 常用扩展总结》。</p><h2 id="注释（Comments）"><a href="#注释（Comments）" class="headerlink" title="注释（Comments）"></a>注释（Comments）</h2><p>以 <code>#</code> 起始的词使得这个词和所有同一行上所有剩余的字符都被忽略。</p><h1 id="Shell-参数（Shell-Parameters）"><a href="#Shell-参数（Shell-Parameters）" class="headerlink" title="Shell 参数（Shell Parameters）"></a>Shell 参数（Shell Parameters）</h1><p><em>参数（Parameter）</em>是存储值的实体。它可以是以下三类：</p><ul><li>变量</li><li>位置参数</li><li>特殊参数</li></ul><h2 id="变量（Varialbe）"><a href="#变量（Varialbe）" class="headerlink" title="变量（Varialbe）"></a>变量（Varialbe）</h2><p>变量，即用<em>名称（name）</em>表示的参数，其具有<em>值（value）</em>以及零或多个<em>属性（attributes）</em>。</p><ul><li><p>通过 <code>$name</code> 引用，在双引号 <code>&quot;&quot;</code> 中可以被引用。</p></li><li><p>通过以下语句为变量赋值：<code>name=[value]</code>。如果变量未赋值，默认值为 <code>null</code> 字符串。</p></li><li><p>通过内建命令 <code>unset</code> 为取消变量。</p></li><li><p>通过内建命令 <code>declare</code> 为变量分配<em>属性（attributes）</em>。</p></li></ul><p>所有值都接受以下扩展：</p><ul><li>tilde expansion</li><li>parameter and variable expansion</li><li>command substitution</li><li>arithmetic expansion</li><li>quote removal</li></ul><h2 id="位置参数（Positional-Parameters）"><a href="#位置参数（Positional-Parameters）" class="headerlink" title="位置参数（Positional Parameters）"></a>位置参数（Positional Parameters）</h2><p><code>$n</code>：<code>$1</code> 表示第一个参数，<code>$2</code> 表示第二个参数，以此类推。</p><h2 id="特殊参数（Special-Parameters）"><a href="#特殊参数（Special-Parameters）" class="headerlink" title="特殊参数（Special Parameters）"></a>特殊参数（Special Parameters）</h2><p><code>$0</code>：表示脚本文件名</p><p><code>$#</code>：表示命令行参数的个数</p><p><code>$?</code>：前一个命令或函数的返回码，<code>0</code> 为成功，非 <code>0</code> 为错误/失败</p><p><code>$*</code>：以”参数1 参数2 … “ 的形式保存所有参数</p><p><code>$@</code>：以”参数1” “参数2” … 的形式保存所有参数</p><p><code>$$</code>：本程序的 PID（进程 ID 号）</p><p><code>$!</code>：最近执行的后台（即异步）命令的 PID</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.gnu.org/software/bash/manual/html_node/Quoting.html" target="_blank" rel="noopener">https://www.gnu.org/software/bash/manual/html_node/Quoting.html</a></p><p><a href="https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Parameters" target="_blank" rel="noopener">https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Parameters</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU/Bash 系列（二）Shell 启动流程</title>
      <link href="2015/03/05/gnu-bash-shell-invocation/"/>
      <url>2015/03/05/gnu-bash-shell-invocation/</url>
      
        <content type="html"><![CDATA[<p>了解完什么是 Shell，有哪些 Shell 类型之后，本文开始主要关注 Bash Shell。</p><h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h1><ol><li>/bin/login 程序首先会检查 <code>/etc/passwd</code> 文件，在这个文件里包含了用户名、密码和该用户的登录 shell，如 /bin/bash 。 /bin/login 在子进程里用 <code>execve</code> 调用了 /bin/bash 。</li><li>/bin/bash 读取 <strong>启动文件</strong> 并启动</li><li>/bin/bash 处理用户键入的命令</li></ol><ul><li>在执行磁盘上某个程序时，我们通常不会指定这个程序文件的绝对路径，比如要执行 <code>echo</code> 命令时，我们一般不会输入 <code>/bin/echo</code> ，而仅仅是输入 <code>echo</code> 。那为什么这样 bash 也能够找到 /bin/echo 呢？原因是 Linux 操作系统支持这样一种策略：shell 的一个环境变量 PATH 里头存放了程序的一些路径，当 shell 执行程序时会去这些目录下查找。</li><li><code>which</code> 作为 shell（这里特指 bash ）的一个内置命令，如果用户输入的命令是磁盘上的某个程序，它会返回这个文件的全路径。</li></ul><h1 id="启动文件"><a href="#启动文件" class="headerlink" title="启动文件"></a>启动文件</h1><h2 id="交互式-shell"><a href="#交互式-shell" class="headerlink" title="交互式 shell"></a>交互式 shell</h2><p>Bash 如何执行它的启动文件？交互式 shell（interactive shell）下需要区分两种情况：</p><h3 id="login-shell"><a href="#login-shell" class="headerlink" title="login shell"></a>login shell</h3><p>在下列情况下，我们可以获得一个 login shell：</p><ul><li>登录系统时获得的顶层 shell，无论是通过本地终端登录，还是通过网络 <code>ssh</code> 登录。这种情况下获得的 login shell 是一个交互式 shell。</li><li>在终端下使用 <code>--login</code> 选项调用 bash，可以获得一个交互式 login shell。</li><li>在脚本中使用 <code>--login</code> 选项调用 bash（比如在 shell 脚本第一行做如下指定：<code>#!/bin/bash --login</code>），此时得到一个非交互式的 login shell。</li><li>使用 <code>su -</code> 切换到指定用户时，获得此用户的 login shell。如果不使用 <code>-</code>，则获得 non-login shell。</li></ul><p>login shell 与 non-login shell 的主要区别在于它们启动时会读取不同的配置文件，从而导致环境不一样。login shell 启动时：</p><ul><li><p>首先读取全局配置：<code>/etc/profile</code></p></li><li><p>然后依次查找以下三个文件，读取第一个找到且可读的文件：</p><ul><li><code>~/.bash_profile</code></li><li><code>~/.bash_login</code></li><li><code>~/.profile</code></li></ul></li><li><p>退出时，读取：<code>~/.bash_logout</code></p></li></ul><h3 id="no-login-shell"><a href="#no-login-shell" class="headerlink" title="no login shell"></a>no login shell</h3><p>交互式的 non-login shell 启动时，会读取：</p><ul><li><code>~/.bashrc</code></li></ul><p>通常我们要定制一些配置时（例如 alias 别名），会将配置写在 <code>~/.bashrc</code> 中，然后在 <code>~/.bash_profile</code> 中读取 <code>~/.bashrc</code>，这样可以保证 login shell 和 non-login shell 得到相同的配置:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> -f ~/.bashrc &amp;&amp; . ~/.bashrc</span><br></pre></td></tr></table></figure><p>至于 <code>/etc/profile</code> 就不要轻易去改啦，毕竟会影响系统全局的配置。</p><h2 id="非交互式-shell"><a href="#非交互式-shell" class="headerlink" title="非交互式 shell"></a>非交互式 shell</h2><ul><li><p>当 Bash 以非交互的方式（non-interactive shell）启动时，<strong>例如在运行一个 shell 脚本时</strong>，它会查找环境变量 <code>BASH_ENV</code>，如果存在则将它的值展开，使用展开的值作为一个文件的名称，读取并执行。 Bash 运作的过程就如同执行了下列命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$BASH_ENV</span>"</span> ]; <span class="keyword">then</span> </span><br><span class="line">    . <span class="string">"<span class="variable">$BASH_ENV</span>"</span>; </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>其它情况：</p><blockquote><p>Aliases are not expanded when the shell is not interactive.</p><p>Functions are executed in the context of the current shell; no new process is created to interpret them (contrast this with the execution of a shell script).</p></blockquote></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>《<a href="http://www.gnu.org/software/bash/manual/bashref.html#Bash-Startup-Files" target="_blank" rel="noopener">Bash Startup Files</a>》</p><p>《<a href="http://www.gnu.org/software/bash/manual/bashref.html#Interactive-Shells" target="_blank" rel="noopener">Interactive Shells</a>》</p><p>《<a href="http://linux.chinaunix.net/techdoc/develop/2008/09/16/1032346.shtml" target="_blank" rel="noopener">使用$BASH_ENV来提权</a>》</p>]]></content>
      
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GNU/Bash 系列（一）什么是 Shell？</title>
      <link href="2015/03/01/what-is-shell/"/>
      <url>2015/03/01/what-is-shell/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是-Shell-？"><a href="#什么是-Shell-？" class="headerlink" title="什么是 Shell ？"></a>什么是 Shell ？</h1><ul><li>一个命令行解释器，用于将用户输入的命令转换为系统操作；</li><li>Shell 既是交互式命令语言（CMD），也是脚本编程语言（Script）；</li><li>Shell 有很多内置在其源代码中的命令。这些命令是内置的，所以 Shell 不必到磁盘上搜索它们，执行速度因此加快。不同的 Shell 内置命令有所不同；</li></ul><h1 id="有哪些-Shell-？"><a href="#有哪些-Shell-？" class="headerlink" title="有哪些 Shell ？"></a>有哪些 Shell ？</h1><h2 id="GUI-Graphical-User-Interface"><a href="#GUI-Graphical-User-Interface" class="headerlink" title="GUI (Graphical User Interface)"></a>GUI (Graphical User Interface)</h2><ul><li>GNOME</li><li>KDE</li><li>……</li></ul><h2 id="CLI-Command-Line-Interface"><a href="#CLI-Command-Line-Interface" class="headerlink" title="CLI (Command Line Interface)"></a>CLI (Command Line Interface)</h2><p>CLI 实际上是一个程序，比如 /bin/bash 。它是一个实实在在的程序，它打印提示符(PROMPT)，接受用户输入的命令，分析命令序列并执行然后返回结果。</p><ul><li>Bourne Shell (sh)<ul><li>即 sh，是影响最广的 shell 。 1977 年由 Stephen Bourne 在贝尔实验室编写。虽无明文规定，但已成为事实上的标准；</li><li>引入了 shell 通用的、基础的功能，例如管道、变量、条件判断、循环等；</li><li>全部类 Unix 系统，都至少有一个与 sh 兼容的shell；</li><li>sh 一般位于 /bin/sh。目前大部分系统，/bin/sh 都是一个链接，指向一个兼容 sh 的、功能更丰富的 shell，如 bash；</li></ul></li><li>C Shell (csh)<ul><li>即 csh，1978年由 Bill Joy 在伯克利大学毕业后编写；</li><li>Bill Joy，Sun 联合创始人，vi 作者，BSD 作者；</li><li>csh 更加注重交互式使用而非脚本应用，引入了历史功能、别名、目录栈、作业控制等功能；</li></ul></li><li>Bourne Again Shell (bash)<ul><li>即 bash，1989年由 Brian Fox 为 GNU 项目编写。</li><li>综合了 sh、csh、ksh 等各种 shell 的特性；</li><li>名字有双关含义，既是字面上的意思，用于替换 sh，也隐含为了 GNU 而 born again 的意思；</li><li>是 Mac OS X 和大部分 Linux 发行版的默认 shell；</li></ul></li><li>Korn Shell (ksh)</li><li>Z Shell (zsh)</li><li>TENEX C Shell (tcsh)</li><li>……</li></ul><h1 id="GUI-和-CLI-如何切换？"><a href="#GUI-和-CLI-如何切换？" class="headerlink" title="GUI 和 CLI 如何切换？"></a>GUI 和 CLI 如何切换？</h1><p>切换到 tty1 ~ tty6 终端：<code>Ctrl + Alt + [F1 ~ F6]</code></p><p>切换到 GUI：<code>Ctrl + Alt + [F7]</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> GNU/Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《软件随想录》读书笔记</title>
      <link href="2015/01/01/more-joel-on-software/"/>
      <url>2015/01/01/more-joel-on-software/</url>
      
        <content type="html"><![CDATA[<p>《<a href="https://item.jd.com/10063970.html?dist=jd" target="_blank" rel="noopener">软件随想录</a>》是一本有趣的技术书籍，阮一峰翻译的，值得一读。它总结了作者多年的从业经验，读完之后，感觉是从另一个更高的维度去提升了程序员的思维境界。</p><p>下面摘录整理了一些读书笔记：</p><h1 id="人员管理"><a href="#人员管理" class="headerlink" title="人员管理"></a>人员管理</h1><ol><li>不懂编程的人管理软件公司，就好像不懂冲浪的人硬要去冲浪。</li><li>如同所有行业中最好的人才一样，那些优秀的程序员是不会出现在招聘市场上的。通常优秀的程序员在整个职业生涯中，可能会有 4 次求职。</li><li>找到优秀的程序员的 3 个基本方法：<ol><li>走出去，不要只会上招聘网站</li><li>实习生</li><li>建立自己的社区（community）</li></ol></li><li>员工推荐：小心陷阱。谨记仍然要要求应聘者通过剩下的所有面试，坚持高标准不变。</li><li>Aeron 牌电脑椅，靠背和坐垫都被设计成网状形，空气可以自由流通，所以坐着不会捂汗。带有腰部支撑和后部平衡装置的顶级系列新型号，再加上尺寸如果正确，并且调节到最合适的位置，那么大多数人坐一整天都不会感到不舒服。</li><li>当一个程序员抱怨“人际关系复杂”时，他们的意思明白无误，就是指任何<strong>个人因素超过技术因素的环境</strong>。</li><li>互联网公司的三种管理方法：<ol><li><strong>军事化管理法</strong><ol><li>在软件开发团队中，每个人干的活都不一样，所以如果想进行微观管理，就会变成抽风式 （hit-and-run） 的管理（大多数时候管理层对程序员不闻不问，偶尔却心血来潮介入，追问一些及其微小的细节，或坚持一定要百分之百按照他们的方式或需求做出来）。</li></ol></li><li><strong>经济利益驱动法</strong><ol><li>如果你使用经济利益驱动法，你就是在鼓励程序员与制度博弈。经济利益驱动法的问题是，它将内部激励变成了外部激励。认同法的作用恰恰相反，是为了设法创造出内部激励。</li></ol></li><li><strong>认同法</strong><ol><li>认同法要求你创造一个有凝聚力的、像胶水一样粘在一起的团队，就好像家庭一样。这样一来，人们就会对他们的同事产生忠诚感和义务感。</li></ol></li></ol></li></ol><h1 id="写给未来程序员的建议"><a href="#写给未来程序员的建议" class="headerlink" title="写给未来程序员的建议"></a>写给未来程序员的建议</h1><ol><li>对于某些最激动人心的编程任务来说，指针仍然是非常重要的。比如说，如果不用指针，你根本没办法开发Linux的内核。如果你不是真正地理解了指针，你连一行Linux的代码也看不懂，说实话，任何操作系统的代码你都看不懂。</li><li>如果你不懂<strong>函数式编程</strong>，你就无法创造出 MapReduce，正是这种算法使得 Google 的可扩展性达到如此巨大的规模。术语“Map”（映射）和“Reduce”（化简）分别来自Lisp语言和函数式编程。</li><li>消灭软件代码中的缺陷是一件<strong>边际报酬递减</strong>（随着软件中的缺陷越来越少，修复每一个缺陷所带来的收益也在变小）的事情。</li><li>有一种恐怖的东西叫做“<strong>内部软件”（inhouse software）</strong>，做一个内部程序员（ in-house programmer ）糟透了：<ol><li>你永远无法用正确的方法、而是被迫用最保险的方法做事。</li><li>内部软件只要“能用了”就会停止开发，因此你永远做不出优秀的产品。但如果你开发的是一个商用软件，你就可以不断对它加工、打磨、优化和改良。</li><li>如果你在专业的软件公司中编程，你的工作与公司的主营业务直接相关，是能够为公司直接带来收入的。这至少意味着一件事情，就是管理层会想到你。也就是说，你能得到最好的福利、最舒适的办公环境和最佳的晋升机会。</li></ol></li><li>那些决定游戏规则的人都是<strong>善于写作的人</strong>。能不能清晰地写出技术内容的文章决定了你是一个口齿不清的程序员还是一个领袖。</li><li>读《微观经济学》，因为从经营一家公司的角度来看，比起那些不懂的程序员，一个理解基本商业规则的程序员将会更有价值，就是这么简单。</li></ol><h1 id="管理大型项目"><a href="#管理大型项目" class="headerlink" title="管理大型项目"></a>管理大型项目</h1><ol><li>网页设计师现在的处境，其实犹太人早在几十年前就体会到了，那就是所有人都同意遵守同一部法典并不能保证所有人的行为都符合同样的规范。因为法条太复杂、太深奥、太难懂了，想要完全正确地理解法条几乎是不可能的。</li><li>标准（如W3C）当然很重要的，但是你不能迷信标准，你必须理解由于人为犯错，所以标准有时候会引发误解、困惑、甚至是争议。</li><li>这是一个很好的例子，说明了“实用主义者”与“理想主义者”两大阵营之间存在的巨大鸿沟：用户升级新版IE后，无法“正常”浏览网站。他们不会为理想主义者那愚蠢的信仰叫好，不会理解为什么你们一定要网络浏览器符合某些神秘的、柏拉图式理想化的、实际上根本还没有实现的“标准”。他们不想听你们讲那些丑陋的Hack，他们只想要网络浏览器能够正常浏览现实中的网站。</li><li>理想主义者在大原则上是百分之百正确的。同样，实用主义者在现实中也是正确的。这场争论将精确地把世界分成两半，两大阵营之间的口水战将持续下去。</li><li>优秀的设计似乎是最容易复制的东西，但是做起来却又不是那么容易，因为做出优秀的设计本身就是一件“麻烦事”，实际上能够提供牢固得令人震惊的竞争优势。</li></ol><h1 id="编程建议"><a href="#编程建议" class="headerlink" title="编程建议"></a>编程建议</h1><ol><li>循证式日程规划(Evidence-Based Scheduling)<ol><li>循证式日程规划先收集历史数据，主要来源是过去的time sheet，然后统计分析，得到了一条概率分布曲线，显示在任一个给定日期你完成工作的可能性有多大。</li><li>蒙特卡洛方法(Monte Carlo method)模拟未来各种可能的结果。</li><li>将每个任务所需的时间控制在16小时之内，这就会迫使你好好地去规划你要造成的那个任务。</li><li>几条经验：<ol><li>只有第一线的程序员才能提出完成日期的估计值。任何管理层制定然后交给程序员去执行的日程规划，都注定会失败。只有真正负责开发的程序员才能估计出完成任务需要哪些步骤。</li><li>一发现错误就立即修正，将用时算入原始任务的用时之中。</li><li>防止管理层向程序员施加压力，被要求加快开发速度。如果程序员的进度落后于日程，就会感到惶惶不可终日，非常沮丧，这时再大的激励也是没用的。如果程序员的进度快于日程，则会感到欢欣鼓舞，工作效率非常高，这时根本不需要激励。日程规划并不是一个玩心理游戏的地方。</li><li>一份日程规划的好处之一，就是你会在工作开始之前，就被迫删去一些次要的或无用的功能，从而全力开发有用的或重要的功能。正是这种迫使你砍掉某些功能的压力，使得你最终做出一个更强大、更优秀的产品，它包括了很好的功能组合，而且能够在较早的日期完成。</li></ol></li><li>有效的日程规划是创造优秀软件的钥匙。它强迫你首先完成最重要的功能，让你做出正确的选择，思考要开发一个怎样的软件。这会使你的产品变得更出色，使你的老板感到更开心，使你的客户感到更满意，以及更重要的一点，那就是使你下午6点能够准时下班。</li></ol></li><li>战略问题<ol><li>从长远的观点来看，那些不关心效率、不关心程序是否臃肿、一个劲往软件中加入高级功能的程序员最终将拥有更好的产品。</li><li>过去的积累可能会变成＂历史包袱＂。</li></ol></li><li>编程<ol><li>将“循环操作”这个单独的步骤抽象出来，用任何你想用的方法完成这个步骤，其中就包括用额外的硬件将运算过程轻松地扩展（Scale）到多台服务器上。谷歌的许多应用程序都使用了这种MapReduce技术，所以一旦有人对底层的并行计算程序进行优化或消除bug，那么所有这些应用程序都会受益。</li><li>寻找一种代码的书写规范，让错误的代码变得容易被看出。让代码中的相关信息在显示屏上集中在一起，使你能够当场发现和改正某些种类的错误。</li><li>“应用型匈牙利命名法”（Apps Hungarian）是有价值的，它加强了代码之间的联结，使得代码更容易阅读、书写、除错和维护。最重要的是，它让错误的代码容易现形。</li></ol></li></ol><h1 id="开办软件公司"><a href="#开办软件公司" class="headerlink" title="开办软件公司"></a>开办软件公司</h1><ol><li>三点意见<ol><li>如果你说不清楚你的软件解决了什么棘手的问题，就不要去开软件公司。</li><li>不要独自一人创办公司。一个人创业十分孤独和压抑没有任何人与你交流思想，为你出谋划策。要是有两个人一起创业，你就会感到对你的合伙人负有义务，就会努力撑下去，渡过难关。</li><li>一开始不要抱有太高期望。</li></ol></li><li>为什么低成本的软件供应商就不能在软件业中生存下来呢？我们只雇用最便宜的程序员为什么就是不行？根本原因是软件的销售复制成本为 0。这意味着，程序员的劳动力成本分摊在你销售出去的所有软件中，对软件来说，如果销售量很大，质量的改进成本并不会造成单位软件成本的上升。相反，软件质量的改进还会创造出新价值，而且价值创造的速度要快于成本提升的速度。</li><li><strong>布鲁克斯法则（Brooks’ Law）</strong> ——向一个已经延误的软件项目增加人手，只会使它更加延误。一个优秀的程序员独自完成一项任务，就不需要额外的沟通和协调。如果同样的任务让 5 个程序员一起完成，他们之间就必须沟通和协调，这会花掉大量时间。开发团队越小，就越能获得额外的收益。人力与工时的互换只是一个神话。</li><li>用许多平庸的程序员取代少数优秀的程序员，这种做法的真正问题在于，不管平庸的程序员工作多长时间，他们做出来的东西都无法像优秀程序员做得那样好。</li><li>令人难过的是，内部软件很少重要到需要雇用巨星/优秀程序员来开发。这就是为什么最令人满意的职业生涯往往是在真正的软件公司里，而不是在银行担任 IT 技术人员。</li></ol><h1 id="经营软件公司"><a href="#经营软件公司" class="headerlink" title="经营软件公司"></a>经营软件公司</h1><ol><li>软件开发中，对你最重要、最关键的部分，一定要使用更原始的工具。至少也要使用<strong>开源/自由软件</strong>，这样至少出错的时候，你多多少少有机会解决问题，不会被解雇。</li><li>建立优质客服<ol><li>技术支持团队必须能够<strong>与开发团队直接沟通</strong>，这很关键，这意味着你不能把技术支持人员外包出去，他们必须与开发人员在同一个地址办公，必须有途径让问题得到直接和彻底的解决。</li><li>当软件每次发生问题都被彻底解决之后，所有常见和容易的问题都被消灭了，技术支持工作实际上就变成了处理疑难杂症，对程序来说这意味着要进行调试和除错。因此对技术支持人员的要求更高、培训力度要更大。</li><li>很多时候，为了避免冒犯客户，我们要求客户去检查某样东西，都可以这样表达：不是直接要求他们去检查某个设置，而是告诉他们先改变这个设置，然后再改回去，目的是“<strong>确保这个设置被成功保存</strong>”。</li><li>客户投诉的时候，人很容易就变得感情用事。解决方法是记住一些重要句子，不断练习把它们说出口。等到你需要用到它们的场合，你就会把冲动自动抛在脑后，转而让客户开心。</li><li>同客户争吵，你永远不会是赢家。</li></ol></li></ol><h1 id="挑选发布日期"><a href="#挑选发布日期" class="headerlink" title="挑选发布日期"></a>挑选发布日期</h1><ol><li>软件功能必须<strong>按照优先顺序</strong>排序，否则一切将会变糟。只要你一不注意，你手下的程序员就会按照趣味性的顺序开发各项功能，你就将因此无法按时发布软件，或者无法取消部署某项功能，因此你就会陷入很被动的局面。</li><li>市场分割，即根据你的客户愿意支付的价格将他们分成不同的组，从每个客户身上赚取最大的消费者剩余，是一种有效的定价手段。但是长远来看，这种价格歧视会对你的产品形象产生显著的负面影响。</li><li>当消费者对商品所知有限时，消费者通常就会认为比较贵的商品就是质量比较高。</li><li>当你在制定价格时，你就是在发出信号。</li></ol><h1 id="修订软件"><a href="#修订软件" class="headerlink" title="修订软件"></a>修订软件</h1><ol><li>如果通过测量某些无意义的静态指标来改进工作，那是无用的。我们真正需要的是一个能够不断改进工作质量的流程：先询问五个为什么，找到根本性的原因，告诉客户为了防止类似故障再次发生我们所采取的举措。书写一份标准、详细的操作流程和确认清单，所有操作步骤都严格按照流程一一操作。目标的：我们遇到的所有引起服务中断的故障都是真正由于极其罕见的、无法预料的＂黑天鹅因素＂而引起的。</li><li>不要开发那些销售人员无意间答应某个客户的功能，也不要因为＂反正迟早要做＂而先去开发那些不重要尽管有趣味性的功能。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《门后的秘密：卓越管理的故事》读书笔记</title>
      <link href="2014/05/01/secret-of-great-management/"/>
      <url>2014/05/01/secret-of-great-management/</url>
      
        <content type="html"><![CDATA[<p>《<a href="https://e.jd.com/30336925.html" target="_blank" rel="noopener">门后的秘密：卓越管理的故事</a>》是一本薄薄的书，前半部分，作者以讲故事、对话录的新颖形式生动地再现了软件行业技术管理工作的场景；后半部分，作者精心总结了各种工作的管理技巧和实用方法。不管你是管理新手还是老兵都可以学到一些管理技巧。</p><p>下面摘录整理了一些读书笔记：</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>差劲的经理好像总是忙忙碌碌，制造出高效率的假象；中等水平的经理能够完成工作，但却不一定是应该做的工作；卓越的经理不仅会达到工作目标，还能够培养员工。</li><li>敏捷项目团队可以管理自身的工作——为工作任务分配责任负责人、监控项目进展并且解决问题，这样经理就可以解放出来，将工作重点放在清除团队进程中的障碍、解决更加重大的问题上。</li><li>管理者会放大他人的工作结果，所以，失败的管理所耗费的人力资源成本甚至要高于经济成本。有些对组织至关重要的人选择离开团队，正是因为他们拒绝与差劲的经理共同工作，因为这些经理挫败团队士气、降低团队的工作效率。</li><li>管理者要与各种类型的人进行交流，这些人性格不同，技术水平不同，动机也不一样。因为这些交流大部分都是一对一的面谈，或者经理们聚集在会议室里关起门来讨论问题，所以其他人无法知晓这些工作是如何进行的。</li></ul><h1 id="了解部门成员和工作"><a href="#了解部门成员和工作" class="headerlink" title="了解部门成员和工作"></a>了解部门成员和工作</h1><ul><li><p>要想领导他人，首先要先了解他们。当你进入一个新的组织或开始新的工作时，首先要知道三件事：</p><ul><li>这些人是谁，他们的优点和兴趣是什么，他们正在从事什么工作；</li><li>团队的既定任务以及该团队如何产生价值；</li><li>你的团队是如何与整个组织机构相契合的。</li></ul></li><li><p>通过一对一的面谈，你的员工会了解你对他们的期待是什么。你肯花时间与他们相处，会让他们觉得你非常重视他们。</p></li><li><p>不建议大家整天坐在员工的办公室里监视他们的工作。这种做法，往好了说是令人生厌的微观管理法，往糟了说，是导致团队的生产效率下降的粗暴干预。</p></li><li><p>对下属进行人性化的关怀。当有人称赞在自己的上司时，说的第一句话就是：”它很有人情味，非常关心我。”</p></li><li><p>如果办不到，就不要主动提供帮助。</p></li><li><p>多重任务处理：</p><ul><li>同时进行两项相关的工作或任务时，工作效率和生产率可以得到提高。因为当一个人做一项工作的时候，可以将思维转到另一项工作上去。当他们做第二项工作时，其实思维还是会不自觉地停留在第一项工作上，这样就有可能会突然闪现出一个好的想法。人们同时进行两项细节大致相同的工作时，工作会更加有效率。因为他们不会闲坐着，而且两相类似的工作可以相互促进。</li><li>但是随着项目数量的增加，给工作效率就会降低。因为项目到项目之间的转变需要时间——人们需要时间归纳整理，弃旧迎新；需要时间来重新形成一连串的想法，并将想法重新组织和重新安置。项目越多，越来越多的时间就会花费在转变上，而不是用在有效率的工作上。</li></ul></li><li><p>你的团队很容易就会从事一些未经批准、无经费甚至毫无意义的工作，这种情况很常见。只有当你全盘了解团队的工作内容，已经清楚你的团队如何为该组织增加价值的时候，你才能决定工作的优先顺序，才能知道应该做什么，不应该做什么。</p></li><li><p>向每一位团队成员了解情况，了解他们到底在做什么，掌握他们的全部工作内容：</p><ul><li>项目工作：具备起点和终点，并且满足特定的组织目标。</li><li>临时性工作：起因无从说起，可能是由于一次危机、一个意外的要求，或者是计划外的其他工作。</li><li>持续性工作：指那些维持业务运转的工作。</li><li>周期性工作：在可知的时间段出现的工作。</li><li>管理工作：涉及剩余工作的计划和组织工作，如：招聘员工、员工发展以及留住人才，预算和报告工作，影响力通过团队工作创造价值。</li></ul></li></ul><h1 id="拨乱反正"><a href="#拨乱反正" class="headerlink" title="拨乱反正"></a>拨乱反正</h1><ul><li>了解每个人正在从事什么工作，分清工作的优先顺序，并且仅挑选那些帮助整个团队或组织实现最终目标的工作。</li><li>将项目归类。制定出完整饿项目列表后，参照部门目标，重新审视每一个项目，归为以下四类：<ul><li>确定要继续开展的项目和工作。</li><li>确定要停止的项目和工作——即”不做”名单。这些工作对组织中的任何人都无价值可言。即刻停止。</li><li>可能是重要的项目和工作，但并不适合你的团队。对这些工作，不能只是停下来，无人问津，需要将它们转交给其他更适合的团队。</li><li>你不知道适合哪一个团队去做的项目和工作。这类工作你不知道应该将其归在第二类还是第三类工作中。进行是深入调查，然后再决定是停止还是转交。</li><li>（就第三类和第四类工作，与你的上司进行讨论，并作出决定。与你的上司一起将不具有重要战略意义的工作——你不该做的工作——进行重新分配。是应该在他人接手前继续做这类工作，还是应该立刻停止？与你的上司和其他需要知道此情况的人就此进行交流，慎重地作出决定。）</li></ul></li><li>提供反馈信息。有时候人们工作表现欠佳，但没有人告诉他们。如果没有人提醒他们，他们根本就不知道需要做出改变，就更不用说在哪些方面做出改变了。不要急着下结论说某人工作表现不好，而要先检查自己的工作有没有做到位。你有没有明确的期望值，确定在某一合理的时间内可交付的成果，并且有没有就结果的质量表明你的态度：满意，或者不满意。</li><li>员工的表现还会收到环境和管理水平的影响。在你下结论认为某人”工作表现欠佳”之前，请先审视自己是否提供了这名员工成功所具备的环境。请思考以下问题。<ul><li>我是否向这名员工说明哪些工作要优先去做，这样他才能合理地安排工作顺序？</li><li>我是否让这名员工用自己的语言重复我的期望，以确保他确实明白了我的意思？</li><li>分配工作时，我是否清楚的表达出这项工作的约束条件和特定界限？</li><li>我是否给出了明确具体的反馈信息来帮助他根据我的期望做出改变？</li><li>我是否和他讨论过应该学习一些必要的技术，并为此提供选择？</li><li>（假如这些工作你都做了，这名员工还是不能给出你想要的结果，那就再看看环境方面的因素——工作程序、工作方法和奖金，还有系统问题。）</li></ul></li><li>设计行为描述问题。“当你⋯⋯的时候，是怎样的情况”，这种行为描述问题可以帮助应聘者描述之前的的工作情，而不是阐明他们想要如何工作。而“如果发生某某情况，你会怎样做”这类假设性问题，应聘者给出的答案实际上并不是他们应对此种情况时的真实反应。</li><li>团队成员知道他们要做什么工作，然后就去做。他们不需要也不想要上司每天都来指挥他们工作。上司的主要职责是去铲除障碍、对员工进行辅导以及开发团队的潜力。这不是魔术，如果上司使用某些技巧帮助员工认清工作状态——计划中的工作、进行中的工作和完成的工作，员工就知道应该做什么工作，然后去做。</li></ul><h1 id="团队建设"><a href="#团队建设" class="headerlink" title="团队建设"></a>团队建设</h1><ul><li>针对工作上的低效表现，或者敏感的人际关系问题给出反馈意见，是非常困难的。为此种谈话做准备会让我们感到非常紧张。但无论如何，这项工作是管理人士必须要做的。因为不能成功地给出反馈信息所造成的损失，要远远超出给出意见时暂时的不舒服。不能成功给予反馈信息的管理者会丧失信任，将工作效率，问题会恶化，同时也树立了仇恨。</li><li>及时给出反馈意见：<ul><li>人们都想要把工作做好，只是很多人并不知道该做什么或者如何做。这时，就需要有人进行指点，告诉他们哪些工作是正确的，哪些是并不奏效的。。你的反馈信息可以帮助他们改进工作。</li><li>尽可能及时地给出反馈信息。等到年底的工作总结时再给出反馈意见并不能起到帮助作用。即使是等到季度末或月末，也不妥当。如果你总是等待给出反馈意见的正式机会，那就说明你给出反馈意见的频率不够。经常给出反馈意见不会让人出于意料，而人们很讨厌这种出其不意的反馈。</li><li>描述行为或者结果。交谈时，你选择的言辞会极大地影响到对方能否真正理解你的意思。在进行纠正或者加强反馈意见时，语言要具有描述性，“好样的”或者“不错”这类言语，并不能告诉人们哪些工作是正确的。概括性词语并不能帮助你阐明自己的观点——只能让对方感到难过。人们更愿意接受详细的信息，用详细信息来开始对话。不要说“你的工作非常马虎”，可以说“我注意到在上一次的发布记录中，出现了很多拼写和打字错误”。</li></ul></li></ul><h1 id="逐日管理"><a href="#逐日管理" class="headerlink" title="逐日管理"></a>逐日管理</h1><ul><li>员工清楚地知道公司和部门的任务和目标后，才能确立合理的个人目标。如果不知晓这一大前提，在制定个人目标时，很容易就会只考虑个人利益和喜好，而忽略了整个组织的需要。</li><li>就团队目标而言，跟进执行效果会让下属知道这个目标是非常重要的。如果你对行动计划的执行过程不闻不问，那么其他人就会认为这个目标和行动计划并不重要。</li><li>指导是一种帮助。对下属进行指导，不单单意味着给他们解决问题。通过你的指导，下属应该可以看到更多解决问题的方法，并从中选择出最终方案。你的指导应该可以帮助他们培养新的能力。</li><li>要讨论利益，而不是立场。在谈话前，你可能已经想好了某种解决方案。但不要在谈话一开始就向对方阐明你的解决方案，要首先向对方说明解决此问题后，会给你们双方带来什么利益。一种解决方案代表一种立场；你的目的——你想要实现的目标——只能代表你的利益。应该找到双方的共识，这样你就可以谈论你们的利益。反过来也是一样。通过对利益进行讨论，可以找到双方的共识。</li><li>做一个出气筒：<ul><li>确定一个处理过激情绪的过程模式：询问详细的事实情况和对此情况的理解；询问可能出现的正面结果。明确说明，向组织里的其他人发牢骚、发表评论是起不到任何作用的。</li><li>你可以说“我听说这件事让你感到非常生气”来表明你已知道对方的感受。这种同情的方式没有必要表达出你的赞同、看法或者你自己的诠释。</li><li>但是如果情绪的发泄成为一种固定模式（总是对某一个人或者某件事不满），这就是另一个问题了。要对此提供反馈意见，并指导该员工这样做会造成怎样的影响。如果有需要，可以建议他求助专业咨询意见。</li></ul></li></ul><h1 id="发现潜在问题"><a href="#发现潜在问题" class="headerlink" title="发现潜在问题"></a>发现潜在问题</h1><ul><li><p>可持续的步伐</p><ul><li>不管表面现象是什么，当工作任务太多，时间不够充裕，以及员工（技术人员或者管理人员）想要一下子完成所有工作的时候，他们就会筋疲力尽。这种状态，特别是管理人员筋疲力尽的状态，会拖垮整个团队。</li><li>避免筋疲力尽的方法就是一次只做一项工作——杜绝同时处理多项任务，并以可持续的步伐工作。</li><li>大多数人每周可以工作40～45小时，来保证以可持续的步伐工作。偶尔一两周的周工作时间超过40小时是可以的，但这种情况不要超过两个星期，否则你就会感到筋疲力尽，不断地犯错误，工作效率也会下降。不要认为周40小时是娇气的表现。这是一个聪明的商业决策。你有责任保证以克持续的步伐工作。</li></ul></li><li><p>我们应该确定工作的优先顺序，这样就不会接到一件工作，就立刻去做，也没必要力争完成每件工作。确定工作的优先顺序，做到要事优先，对合理地配置员工是十分重要的。更重要的是，他可以使我们专注于正确的工作——对促进公司发展更具价值的工作。</p></li></ul><h1 id="能力培养"><a href="#能力培养" class="headerlink" title="能力培养"></a>能力培养</h1><ul><li>如何分配工作？<ul><li>决定可分排的工作。对管理者来说，分派工作是初级技术。首先思考分派技术类工作。分派完技术类工作后，再看管理类工作：看看哪些工作是全局战略性工作，哪些是策略性工作。举个例子，做管理报告的时候，选择衡量指标就是战略性工作；收集数据信息就是策略性工作。策略性工作适合用来进行分派。</li><li>寻找有能力完成工作的人。思考团队成员的技术和抱负，找到与待分派工作相匹配的员工。思考发展机会：如果团队中的某名成员想要担任领导角色，那这些策略性工作可能会是了解管理角色的好机会。（大部分的管理工作都属于全局战略性工作，但就有志于做经理的员工来说，从策略性工作做起，慢慢开始从事更多的战略性工作可以减少学习过程中走的弯路。）如果你的下属中，没有人具备完成此项工作的技术或者兴趣，那就考虑是否需要更多人手。</li><li>把分派任务看成是一种投资。分派任务的结果不是立即就会显现出来的。不要期待别人接受新工作时，一下就能达到百分之百的工作效率。除非这名员工具有此类工作的相关经验，，否则他可能不知道如何处理这项工作中的某部分内容。这时，你就应该进行指导。最终，你的这项投资（指导）会提高这名团队成员的能力，并降低失败的风险，因为他对这项工作的内容已经充分了解了。</li><li>思考你想要的具体结果。你心里可能有某个想要的具体结果，或者在某一范围内的结果你都可以接受。你应该与接手工作任务的员工沟通任务参数，包括时间和质量。注意，要关注结果，而不是方法。指导员工如何工作是一种微观管理法。将你的工作分派给其他人是需要勇气的，同时也需要信任。你必须相信对方能够很好地完成工作，即使他做的没你那么好，或没你那么准确。</li><li>检察工作进程。要定期检查工作进程。对经验尚少的员工，可以经常进行工作检查；对经验丰富的员工，就可以降低检查的频率。要对他们的工作给予鼓励，提供反馈信息，如果有需要，还应提供帮助。</li></ul></li><li>人们取得成绩时，都希望被别人注意到，并渴望得到赞许。别说“这是他们应该做的工作”，工作很艰难，所以当下属表现优秀时，让他们知道你注意到了。定期的赞许是留住最佳员工的重要因素。每周都要关注每名员工的工作，并对他们的成绩表示赞许。</li><li>很多刚刚成为经理的管理人士都是身兼二职：承担管理职责的同时，继续从事技术工作。他们不可避免地在管理类工作和技术类工作之间挣扎斗争。这样，对于经理本身和这个团队而言，失败的可能性就会大大增加。</li><li>为团队成员提供职业发展的指导？<ul><li>杰出的经理会为每一名员工的职业发展提供帮助。帮助员工发展技能以及实现他们的目标，可以提高整个组织的能力。支持员工的职业发展，可以让他们知道你关心他们，而不是只关心他们生产出来的产品。</li><li>当你帮助员工实现了他的职业目标后，即使他离开你的部门很久之后，都还是会记得你。我们帮助过的人，反过来给我们做过很好的工作，而且其中很多人已经成为了受人尊重的同事。相反，如果你阻碍员工的发展，他们也会记得——而且时间更长。</li><li>不要阻碍员工的发展。有时候，你无法使员工成功转型到另一个角色——在你的部门里不存在这个角色。如果是这样，这名员工可能会调到另一个部门工作，甚至会跳槽到另一家公司，你要做好准备。不要阻碍员工的发展，也不要等待另一个人来填补这个职位。职业培训有时意味着帮助员工找到一个新的职位。如果你为了方便自己的工作，而阻碍员工的发展，那么从长远角度看，结果往往是事与愿违的。</li></ul></li></ul><h1 id="有效地应对变化，不折腾"><a href="#有效地应对变化，不折腾" class="headerlink" title="有效地应对变化，不折腾"></a>有效地应对变化，不折腾</h1><ul><li>有时候我们会自己给自己制造麻烦。我们不想激怒上司，因此不敢直接说“不”。避免给自己挖坑，考虑以下几种可能的答复方式：<ul><li>对明知无法达成的任务，我无法给出承诺。我想某某工作是我们可以完成的。</li><li>我会和团队一起努力，看看我们能做到什么程度。</li><li>我们会首先攻克最重要的功能，每个月向你汇报我们的成果。</li><li>（这样说，接下来的谈话气氛很可能会不太和谐。但是你和你的上司都会面对现实。如果迟迟不讲明现实，只会暂时推迟痛苦，为达成商业目标可供选择的方法数量也会减少。）</li></ul></li><li>组织里的高层或者其他团队可能会希望你表现得像个英雄。但是接受超出你能力范围的工作并不是英雄主义，是殉难。当你接受无法应对的工作时，你就承担了所有的危险（总的来说，没有任何回报）。</li><li>避免仓促的决定。当高层通知你计划有了180度的大转变时，他们往往会希望你立刻就答复说可以按新计划完成工作，而你也很容易就会冒这个险。一些“简单”的答案——增加人手、加班工作、同时进行几个项目、“打破常规”⋯⋯都不会奏效。在你和团队成员进行讨论之前，不要给出任何承诺。</li><li>重新考虑选择余地，尽早做出回复。尽量在一两天内给出答复。对于一个正在承受巨大压力的高层来说，这样的期限已经是极限了。要承诺在这个期限内给出你团队的讨论结果。</li><li>用事实代替流言。当你听到某个流言，而它又影响到你的团队时，一定要调查清楚。不要任凭大家处于焦虑之中，或者用他们的担忧来填补缺失的信息。一旦你了解到事实后，就马上告诉你的团队，并带领团队努力适应改变。</li><li>什么是管理？<ul><li>坚持进行易理解但难操作的管理练习。</li><li>给员工以人文关怀。</li><li>与其他经理共同合作，作为一个团队来工作。</li><li>树立共同目标。</li><li>阐释目标。</li><li>为成功下定义。</li><li>处理高优先级的工作。</li><li>帮助大家有效率地合作。</li><li>制造信任的气氛。</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《自我训练》读书笔记</title>
      <link href="2014/03/14/self-coaching/"/>
      <url>2014/03/14/self-coaching/</url>
      
        <content type="html"><![CDATA[<p>读完了《<a href="https://item.jd.com/11122849.html?dist=jd" target="_blank" rel="noopener">自我训练</a>》，是一本帮助认识焦虑的好书。它教人学会接受自己的不完美，坦然面对情绪，逐步放松心情。每个人都值得一读。</p><p>下面摘录整理了一些读书笔记：</p><ol><li>安全感始于你相信自己的意愿（<strong>期待定律</strong>）。</li><li>缺乏耐心，就像消极情绪一样，会将你吞噬，两者都是毒药。</li><li>区别“想要”和“必须要”的不同：<ol><li>“想要”受自我满足的愿望所驱动，并非是任何外在的、控制所驱动的动机。</li><li>“必须要”受不安全感所驱动。是强迫性的、顽固的努力，想要尽一切努力让自己感觉更有控制力。</li></ol></li><li>四种人格特征：<ol><li>刺猬型人格（敌意）</li><li>乌龟型人格（逃避）</li><li>变色龙型人格（操控）</li><li>完美主义型人格（过分要求）<ol><li>完美主义通常并不是渴求完美，只是为了<strong>避免不完美</strong>。如果不完美让你感觉焦虑，那么你的生活有可能受到了条件反射式的思维的控制。</li><li>狂热型完美主义所追求的是通过消除所有的错误，而使自己变得没有弱点，而且对生活中的每一个方面都具有典型的强迫症状、做事过头。一个小故障、一次失言、一次挫折都会让你沮丧和焦虑 ，想要赶忙重新控制自己的领域——要是不完美，就永远都不会快乐了（<strong>非此即彼的思维</strong>）。</li></ol></li></ol></li><li>孩子气的特点是受到威胁的时候就会强化自己的破坏作用。因此，评估你心中的孩子气在什么年龄段，这很有用 。</li><li>所有的事情都是有选择的，要学会如何发挥你的意志。</li><li><strong>不安全感＋控制＝毒药混合剂</strong><ol><li>不安全感会导致人想要对生活有所掌控。但消除焦虑和抑郁（不安全感）的关键不是更多的控制，而是培养自信，相信自己可以应付生活展示在我们面前的各种挑战。</li><li>焦虑和抑郁都是生长在不安全感这片肥沃土地上的杂草。它是一种由于不安全感而滋生出来的习惯，这种习惯会歪曲你对生活的看法和体验，逐渐耗尽你体内的化学成分。</li><li>并不是生活带给我们的种种挑战导致了临床上的焦虑或是抑郁，而是我们在面对挑战时所做出的反应导致的。</li><li>生命不是用来控制的，而是用来释放的。越没安全感，越怀疑生活，就越想控制生活，而不是去信任生活。</li></ol></li><li>不安全感的三种声音：<ol><li>怀疑</li><li>恐惧</li><li>消极</li></ol></li><li>常见的思维陷阱：<ol><li>“要是怎样”的预见思维</li><li>“不得不做”的强迫思维</li><li>“非此即彼”的冲动思维</li><li>“ 读心术 ”般的主观臆想</li></ol></li><li>强迫症（OCD）<ol><li>是由不安全感所引发的，不相信自己，不相信自己的行为和思维，所以也无法相信自己的记忆，觉得不安全（不能够掌控），并造成焦虑。</li><li>两个要素：<strong>反复出现，持续不断</strong>。侵入脑海的想法使得焦虑增加，让人感觉非要重复某个行为，或是反复出现某个念头，才能重新获得对生活的掌控，这稍微舒缓了自己的焦虑，但却没什么满足感。</li></ol></li><li>自我交谈的3个步骤：<ol><li>将事实与想象分开，学会倾听内心。 （ 焦虑和抑郁都不是以事实为基础的，而是由于错误和歪曲的认知而产生了捏造的想象。）</li><li>摆脱条件反射式的思维模式。</li><li>随它去 （Let it go）。当情绪来袭，不要被胡思乱想，或是说服自己非要做些什么（控制念头），可以尝试转移注意力。活在当下，感受各种感觉、印象、声音、味道和景象，想得更少，感受更多，这就是“随它去”的方法。你会及时地感受到越来越多的头脑之外的生活。</li></ol></li><li>自我训练的10个原则：<ol><li>每个人都会有不安全感。</li><li>想法先于感觉、焦虑和抑郁。</li><li>焦虑和抑郁是被误导的、想要控制生活的尝试。</li><li>控制是假象，不是解决问题的办法。</li><li>缺乏安全感是一种习惯，任何习惯都可以改变。</li><li>健康的思维方式是一种选择。</li><li>一个好的教练也是一个好的激励者。</li><li>你必须要挑战“别的人才能拯救我”的荒唐想法。</li><li>你必须承担起改变的责任。</li><li>你必须深信，自己真的有选择。</li></ol></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《佐藤可士和的超整理术》读书笔记</title>
      <link href="2014/01/13/packing/"/>
      <url>2014/01/13/packing/</url>
      
        <content type="html"><![CDATA[<p>这本日本设计师写的书，从空间 &gt; 信息 &gt; 思考的三个维度逐步递进的介绍了一些整理之道。薄薄的一本书，有些观点还挺有意思的，可以一读。</p><p>下面摘录整理了一些读书笔记：</p><h1 id="解决问题的“超级”整理术"><a href="#解决问题的“超级”整理术" class="headerlink" title="解决问题的“超级”整理术"></a>解决问题的“超级”整理术</h1><ol><li>当思绪没有任何阴霾，焦点凝聚于目的，逻辑自然畅通无阻。</li><li>若能向对方条理分明地阐述自己采用该设计的心路历程，彻底整理自己的<strong>思考路径</strong>，作品自然不再混乱不清。</li><li>整理时，不可失去客观的角度。如果不与标的保持距离，冷静详察，就无法针对大量要素设定<strong>优先次序，毅然舍弃多余内容</strong>，逐步将焦点凝聚于重要的关键，细细琢磨，成为简练利索的有形之物。</li><li>要创造一个设计，就必须彻底整理目标对象，找出最重要的关键——本质，再将它化为有形之物。</li><li>本书阐述的“整理术”，并非为了整理而整理，而是一种“如何享受舒适生活”的根本方法论。</li></ol><h1 id="一切从整理开始"><a href="#一切从整理开始" class="headerlink" title="一切从整理开始"></a>一切从整理开始</h1><ol><li><p>整理术三阶段：</p><ol><li>空间（学会如何设定优先排序，认清重要事务）</li><li>信息（导入观点，掌握信息之间的因果关系）</li><li>思考（整理人类思绪，引导并组合，最终可视化）</li></ol></li><li><p>整理术步骤：</p><ol><li><p>掌握状况</p><ol><li>信息不可视的状态</li><li>将信息可视化</li><li>列出信息</li></ol></li><li><p>导入观点</p><ol><li>设定优先排序</li><li>理清因果关系，找出本质</li></ol></li><li><p>设定课题</p><ol><li>本质是正面的，则琢磨使之发亮，强调原本任其埋没的优势</li><li>本质是负面的，则进行反向思考，将负面扭转为正面，找出魅力所在。</li></ol></li></ol></li><li><p>掌握状况之后，为了查明问题本质，必须理清信息的因果关系。在掌握状况的阶段，各种信息呈现混乱不清的堆积状态，务必将这些信息相互对调，设定<strong>优先排序，舍弃多余信息</strong>，排除含糊暧昧的部分，找出<strong>关联性</strong>，整理成具有整合性的信息。</p></li><li><p>基于宏观视野理清信息的因果关系，就能认清前进的方向。</p></li><li><p>认清混沌的现状，保持解决问题的心理准备。同时，随时保持穷究问题本质的积极态度，才是整理术的最大前提。</p></li></ol><h1 id="第一阶段：“空间”整理术——设定优先排序"><a href="#第一阶段：“空间”整理术——设定优先排序" class="headerlink" title="第一阶段：“空间”整理术——设定优先排序"></a>第一阶段：“空间”整理术——设定优先排序</h1><ol><li>定期更新→防止东西增加。</li><li>决定物品的固定位置， 使用后立即物归原位→保持作业环境清爽。</li><li>决定“外框”，统一规格，成为某种套件→简单明了地进行分类。通过决定外框、统一规格，让分类更加简单明了。如此不但可将不同种类的东西收拾干净，而且是容易掌握的简约系统。</li></ol><h1 id="第二阶段：“信息”整理术——导入个人观点"><a href="#第二阶段：“信息”整理术——导入个人观点" class="headerlink" title="第二阶段：“信息”整理术——导入个人观点"></a>第二阶段：“信息”整理术——导入个人观点</h1><ol><li>退一步客观检视。</li><li>舍弃自以为是、想当然 。</li><li>转换观点，从各种角度观察。</li></ol><h1 id="第三阶段：“思考”整理术——将思绪信息化"><a href="#第三阶段：“思考”整理术——将思绪信息化" class="headerlink" title="第三阶段：“思考”整理术——将思绪信息化"></a>第三阶段：“思考”整理术——将思绪信息化</h1><ol><li>将自己和对方的思绪置换成语言。</li><li>建立假说，大胆向对方提问。</li><li>思考时要对于别人的事情视如己出。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
