<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> Java 常用类型系列（五）Java 8 时区处理总结 · Qida's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Java 常用类型系列（五）Java 8 时区处理总结 - Qida's Blog"><meta name="keywords"><meta name="author" content="Qida's Blog"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://qidawu.github.io/atom.xml" title="Qida's Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><a href="/" class="title-link">Qida's Blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">Java 常用类型系列（五）Java 8 时区处理总结</h1><div class="post-info">2018-04-06<a href="/tags/Java/" title="Java" class="post-demo">Java</a></div><div class="post-content"><p>本文介绍时区处理的两种方式。时区涉及的接口及实现类如下：</p>
<p><img src="/img/java/time/classes_of_time_zone.png" alt="classes_of_time_zone"></p>
<p>（上图简化掉了 <code>Serializable</code> 接口、<code>Comparable</code> 接口及 <code>FunctionalInterface</code> 注解）</p>
<h1 id="推荐方式"><a href="#推荐方式" class="headerlink" title="推荐方式"></a>推荐方式</h1><h2 id="ZoneId"><a href="#ZoneId" class="headerlink" title="ZoneId"></a>ZoneId</h2><p>时区的处理是新版日期与时间 API 新增的重要功能，且 API 被极大简化。新的 <code>java.time.ZoneId</code> 类是老版本 <code>java.util.TimeZone</code> 类的替代品。它的设计目标就是要让用户无需为时区处理的复杂和繁琐而操心，比如处理夏令时（DST）问题。</p>
<p>每个特定的 <code>ZoneId</code> 对象都有一个地区 ID 标识。地区 ID 格式为“<code>{区域}/{城市}</code>”，这些地区集合的设定都由 <a href="https://www.iana.org/time-zones" target="_blank" rel="noopener">IANA  的时区数据库</a>提供。静态工厂方法构造如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取服务器所在时区的 ZoneId，例如 Asia/Shanghai 为 UTC+8</span></span><br><span class="line">ZoneId currentZone = ZoneId.systemDefault();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定城市的 ZoneId，即 UTC+1</span></span><br><span class="line">ZoneId zoneId = ZoneId.of(<span class="string">"Europe/Paris"</span>);</span><br></pre></td></tr></table></figure>

<p>一旦得到一个 <code>ZoneId</code> 对象，就可以与 <code>LocalDate</code>、<code>LocalDateTime</code>、<code>Instant</code> 对象整合起来，构造一个 <code>ZonedDateTime</code> 实例，它代表了<strong>相对于指定时区的时间点</strong>。</p>
<h2 id="ZonedDateTime"><a href="#ZonedDateTime" class="headerlink" title="ZonedDateTime"></a>ZonedDateTime</h2><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><code>ZonedDateTime</code> 的底层实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ZonedDateTime</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Temporal</span>, <span class="title">ChronoZonedDateTime</span>&lt;<span class="title">LocalDate</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The local date-time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LocalDateTime dateTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The offset from UTC/Greenwich.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZoneOffset offset;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The time-zone.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZoneId zone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ZonedDateTime</code> 的实例如下图：</p>
<p><img src="/img/java/time/instance_of_ZonedDateTime.png" alt="instance_of_ZonedDateTime"></p>
<p>图中可见，原本 <code>LocalDateTime</code> 对象作为一个<strong>本地</strong>日期与时间，是不包含时区信息的，即没有时区概念。而在结合了 <code>ZoneId</code> 构造成一个 <code>ZonedDateTime</code> 实例之后，才有了时区概念。它代表了<strong>相对于指定时区的时间点</strong>。</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1970-01-01</span></span><br><span class="line">LocalDate date = LocalDate.ofEpochDay(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 1970-01-01T00:00</span></span><br><span class="line">LocalDateTime dateTime = date.atStartOfDay();</span><br><span class="line"><span class="comment">// 1970-01-01T00:00:00Z</span></span><br><span class="line">Instant instant = Instant.ofEpochSecond(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1970-01-01T00:00+01:00[Europe/Paris]，底层调用 ZonedDateTime.of(this, zoneId)</span></span><br><span class="line">ZonedDateTime zonedDateTime = date.atStartOfDay(zoneId);</span><br><span class="line"><span class="comment">// 1970-01-01T00:00+01:00[Europe/Paris]，底层调用 ZonedDateTime.of(this, zoneId)</span></span><br><span class="line">ZonedDateTime zonedDateTime1 = dateTime.atZone(zoneId);</span><br><span class="line"><span class="comment">// 1970-01-01T01:00+01:00[Europe/Paris]，底层调用 ZonedDateTime.ofInstant(this, zoneId)</span></span><br><span class="line">ZonedDateTime zonedDateTime2 = instant.atZone(zoneId);</span><br><span class="line"><span class="comment">// 2015-12-03T10:15:30+08:00[Asia/Shanghai]</span></span><br><span class="line">ZonedDateTime zonedDateTime3 = ZonedDateTime.parse(<span class="string">"2015-12-03T10:15:30+05:30[Asia/Shanghai]"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="LocalDateTime-与-Instant-互转"><a href="#LocalDateTime-与-Instant-互转" class="headerlink" title="LocalDateTime 与 Instant 互转"></a>LocalDateTime 与 Instant 互转</h3><p>通过 <code>ZoneId</code> 可以将 <code>LocalDateTime</code> 和 <code>Instant</code> 进行互转，公式为 UTC + 时区差（东正西负）= 本地时间。</p>
<p><code>LocalDateTime</code> &gt; <code>Instant</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 东八区的 1970-01-01T00:00，等于 UTC+0 的 1969-12-31T16:00:00Z</span></span><br><span class="line">Instant instant2 = dateTime.atZone(ZoneId.systemDefault()).toInstant();</span><br></pre></td></tr></table></figure>

<p><code>Instant</code> &gt; <code>LocalDateTime</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1970-01-01T00:00</span></span><br><span class="line">LocalDateTime dateTime2 = LocalDateTime.ofInstant(instant2, ZoneId.systemDefault());</span><br><span class="line"><span class="comment">// 1970-01-01T08:00</span></span><br><span class="line">LocalDateTime dateTime3 = instant.atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br></pre></td></tr></table></figure>

<h1 id="不推荐方式"><a href="#不推荐方式" class="headerlink" title="不推荐方式"></a>不推荐方式</h1><h2 id="ZoneOffset"><a href="#ZoneOffset" class="headerlink" title="ZoneOffset"></a>ZoneOffset</h2><p>另一种比较通用的表达时区的方式是利用当前时区和 UTC/格林尼治的固定偏差。可以使用 <code>ZoneOffset</code> 类，它是 <code>ZoneId</code> 的一个子类，表示的是当前时间和 UTC 的偏差：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZoneOffset newYorkOffset = ZoneOffset.of(<span class="string">"-05:00"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="OffsetDateTime"><a href="#OffsetDateTime" class="headerlink" title="OffsetDateTime"></a>OffsetDateTime</h2><h3 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h3><p><code>ZoneOffset</code> 类可用于构造 <code>OffsetDateTime</code> 实例。<code>OffsetDateTime</code> 的底层实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OffsetDateTime</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Temporal</span>, <span class="title">TemporalAdjuster</span>, <span class="title">Comparable</span>&lt;<span class="title">OffsetDateTime</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The local date-time.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LocalDateTime dateTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The offset from UTC/Greenwich.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZoneOffset offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1970-01-01T00:00-05:00</span></span><br><span class="line">OffsetDateTime dateTimeInNewYork = OffsetDateTime.of(dateTime1, newYorkOffset); </span><br><span class="line"><span class="comment">// 1970-01-01T00:00-05:00</span></span><br><span class="line">OffsetDateTime dateTimeInNewYork2 = dateTime1.atOffset(newYorkOffset);</span><br></pre></td></tr></table></figure>

<p>“-05:00” 的偏差实际上对应的是美国东部标准时间。注意，使用这种方式定义的 <code>ZoneOffset</code> 并未考虑任何夏令时的影响，所以在大多数情况下，不推荐使用。</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="java-sql-Timestamp"><a href="#java-sql-Timestamp" class="headerlink" title="java.sql.Timestamp"></a>java.sql.Timestamp</h2><p>有时开发会使用 <code>java.sql.Timestamp</code> 作为 PO 实体类的时间字段，<code>java.sql.Timestamp</code> 底层实现使用<strong>格里历（公历）</strong>，并使用<strong>本地时区</strong>（即服务器默认时区），并受该时区影响。</p>
<p>这里看一段代码，以 2021-01-04 00:00:00 为例演示转换过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.parse(</span><br><span class="line">  <span class="string">"2021-01-04 00:00:00"</span>, </span><br><span class="line">  DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">);</span><br><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, ZoneId.of(<span class="string">"Asia/Jakarta"</span>));</span><br><span class="line"></span><br><span class="line">Timestamp.from(zonedDateTime.toInstant());</span><br><span class="line">Timestamp.valueOf(localDateTime);</span><br></pre></td></tr></table></figure>

<p>这里试验两个时区：</p>
<table>
<thead>
<tr>
<th></th>
<th>Europe/London (UTC)</th>
<th>Asia/Shanghai (UTC+8)</th>
</tr>
</thead>
<tbody><tr>
<td><code>ZoneId.systemDefault()</code></td>
<td>Europe/London (UTC)</td>
<td>Asia/Shanghai (UTC+8)</td>
</tr>
<tr>
<td><code>TimeZone.getDefaultRef()</code></td>
<td>Europe/London (UTC)</td>
<td>Asia/Shanghai (UTC+8)</td>
</tr>
</tbody></table>
<p>下面分别看下 <code>java.sql.Timestamp</code> 两个 API 会有什么问题：</p>
<h3 id="valueOf-LocalDateTime"><a href="#valueOf-LocalDateTime" class="headerlink" title="#valueOf(LocalDateTime)"></a>#valueOf(LocalDateTime)</h3><p>转换过程：本地时间 &gt; 系统时区的时间 &gt; UTC-0 时区的时间戳</p>
<table>
<thead>
<tr>
<th>Europe/London (UTC)</th>
<th>Asia/Shanghai (UTC+8)</th>
</tr>
</thead>
<tbody><tr>
<td>2021-01-04T00:00 (<code>LocalDateTime</code>) → <br/>2021-01-04T00:00:00.000Z / 1609718400000 (<code>Timestamp</code>)</td>
<td>2021-01-04T00:00 (<code>LocalDateTime</code>) → <br/>2021-01-04T00:00:00.000+0800 / 1609689600000 (<code>Timestamp</code>)</td>
</tr>
</tbody></table>
<p>可见，由于 <code>LocalDateTime</code> 本身不含时区信息，在经由 <code>Timestamp#valueOf(LocalDateTime)</code> 转换时，源码中使用了 <code>TimeZone.getDefaultRef()</code> 并<strong>受系统默认时区的影响，导致结果前后不一致</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the reference to the default TimeZone object. This</span></span><br><span class="line"><span class="comment"> * method doesn't create a clone.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> TimeZone <span class="title">getDefaultRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TimeZone defaultZone = defaultTimeZone;</span><br><span class="line">    <span class="keyword">if</span> (defaultZone == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Need to initialize the default time zone.</span></span><br><span class="line">        defaultZone = setDefaultZone();</span><br><span class="line">        <span class="keyword">assert</span> defaultZone != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Don't clone here.</span></span><br><span class="line">    <span class="keyword">return</span> defaultZone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="from-Instant"><a href="#from-Instant" class="headerlink" title="#from(Instant)"></a>#from(Instant)</h3><p>转换过程：本地时间 &gt; 指定时区的时间 &gt; UTC-0 时区的时间戳</p>
<table>
<thead>
<tr>
<th>Europe/London (UTC)</th>
<th>Asia/Shanghai (UTC+8)</th>
</tr>
</thead>
<tbody><tr>
<td>2021-01-04T00:00 (<code>LocalDateTime</code>) → <br/>2021-01-04T00:00+07:00[Asia/Jakarta] (<code>ZonedDateTime</code>) → <br/>2021-01-03T17:00:00Z / 1609693200 (<code>Instant</code>) →<br/>2021-01-03T17:00:00.000Z / 1609693200000(<code>Timestamp</code>)</td>
<td>2021-01-04T00:00 (<code>LocalDateTime</code>) → <br/>2021-01-04T00:00+07:00[Asia/Jakarta] (<code>ZonedDateTime</code>) → <br/>2021-01-03T17:00:00Z / 1609693200 (<code>Instant</code>) →<br/>2021-01-04T01:00:00.000+0800 / 1609693200000 (<code>Timestamp</code>)</td>
</tr>
</tbody></table>
<p>这里看似结果没有问题，<code>Instant</code> 和 <code>Timestamp</code> 对象在不同时区下都是相同时间戳。</p>
<p>但有一种场景，就是<strong>应用服务器与数据库的时区不一致导致的问题</strong>。假如应用服务器时区为 <code>Asia/Shanghai (UTC+8)</code>，数据库时区为 <code>Europe/London (UTC)</code>，当把上表 <code>Timestamp</code> 对象保存到 MySQL 数据库的 <code>datetime</code> 字段时，如果未经时区转换，会导致错误结果。</p>
<p>这里参考 <a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java" target="_blank" rel="noopener">mysql-connector-java-5.1.42.jar</a> 源码如下，重点看 <code>java.sql.PreparedStatement#setTimestamp</code> 的方法实现，其使用了 <code>SimpleDateFormat</code> 将 <code>Timestamp</code> 对象格式化成字符串，<strong>如果未经时区转换，结果如下表，导致前后不一致</strong>：</p>
<table>
<thead>
<tr>
<th>格式化前</th>
<th>格式化后</th>
</tr>
</thead>
<tbody><tr>
<td>2021-01-03T17:00:00.000Z</td>
<td>2021-01-03 17:00:00</td>
</tr>
<tr>
<td>2021-01-04T01:00:00.000+0800</td>
<td>2021-01-04 01:00:00</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set a parameter to a java.sql.Timestamp value. The driver converts this</span></span><br><span class="line"><span class="comment"> * to a SQL TIMESTAMP value when it sends it to the database.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parameterIndex</span></span><br><span class="line"><span class="comment"> *            the first parameter is 1, the second is 2, ...</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> *            the parameter value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tz</span></span><br><span class="line"><span class="comment"> *            the timezone to use</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> *             if a database-access error occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setTimestampInternal</span><span class="params">(<span class="keyword">int</span> parameterIndex, Timestamp x, Calendar targetCalendar, TimeZone tz, <span class="keyword">boolean</span> rollForward)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    x = TimeUtil.changeTimezone(<span class="keyword">this</span>.connection, sessionCalendar, targetCalendar, x, tz, <span class="keyword">this</span>.connection.getServerTimezoneTZ(), rollForward);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.tsdf == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.tsdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"''yyyy-MM-dd HH:mm:ss"</span>, Locale.US);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    StringBuffer buf = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                    buf.append(<span class="keyword">this</span>.tsdf.format(x));</span><br><span class="line">                    </span><br><span class="line">                    ...</span><br><span class="line">                    </span><br><span class="line">                    setInternal(parameterIndex, buf.toString());</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法内部调用了 <code>com.mysql.jdbc.TimeUtil#changeTimezone</code> 方法，源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Change the given timestamp from one timezone to another</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment"> *            the current connection to the MySQL server</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tstamp</span></span><br><span class="line"><span class="comment"> *            the timestamp to change</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fromTz</span></span><br><span class="line"><span class="comment"> *            the timezone to change from</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> toTz</span></span><br><span class="line"><span class="comment"> *            the timezone to change to</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the timestamp changed to the timezone 'toTz'</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Timestamp <span class="title">changeTimezone</span><span class="params">(MySQLConnection conn, Calendar sessionCalendar, Calendar targetCalendar, Timestamp tstamp, TimeZone fromTz,</span></span></span><br><span class="line"><span class="function"><span class="params">        TimeZone toTz, <span class="keyword">boolean</span> rollForward)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((conn != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="comment">// 开启 useTimezone=true，才能进入下面的时区转换逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (conn.getUseTimezone()) &#123;</span><br><span class="line">            <span class="comment">// Convert the timestamp from GMT to the server's timezone</span></span><br><span class="line">            Calendar fromCal = Calendar.getInstance(fromTz);</span><br><span class="line">            fromCal.setTime(tstamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> fromOffset = fromCal.get(Calendar.ZONE_OFFSET) + fromCal.get(Calendar.DST_OFFSET);</span><br><span class="line">            Calendar toCal = Calendar.getInstance(toTz);</span><br><span class="line">            toCal.setTime(tstamp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> toOffset = toCal.get(Calendar.ZONE_OFFSET) + toCal.get(Calendar.DST_OFFSET);</span><br><span class="line">            <span class="keyword">int</span> offsetDiff = fromOffset - toOffset;</span><br><span class="line">            <span class="keyword">long</span> toTime = toCal.getTime().getTime();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rollForward) &#123;</span><br><span class="line">                toTime += offsetDiff;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                toTime -= offsetDiff;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Timestamp changedTimestamp = <span class="keyword">new</span> Timestamp(toTime);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> changedTimestamp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (conn.getUseJDBCCompliantTimezoneShift()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (targetCalendar != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                Timestamp adjustedTimestamp = <span class="keyword">new</span> Timestamp(jdbcCompliantZoneShift(sessionCalendar, targetCalendar, tstamp));</span><br><span class="line"></span><br><span class="line">                adjustedTimestamp.setNanos(tstamp.getNanos());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> adjustedTimestamp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tstamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 JDBC 连接参数未配置 <code>useTimezone=true</code>（默认值 <code>false</code>），会导致目标时区转换失效，从而产生上述问题。<strong>而如果开启之后，不管应用服务器设置什么时区，都能保证正确转换为数据库目标时区的时间值，反之亦然（数据库 -&gt; 应用服务器）。</strong>这里给两个例子，如下表：</p>
<table>
<thead>
<tr>
<th></th>
<th>时区转换前</th>
<th>时区转换后</th>
</tr>
</thead>
<tbody><tr>
<td>UTC+2</td>
<td>2021-01-03T19:00:00.000+0200 / 1609693200</td>
<td>2021-01-03T17:00:00.000Z / 1609693200</td>
</tr>
<tr>
<td>UTC+8</td>
<td>2021-01-04T01:00:00.000+0800 / 1609693200</td>
<td>2021-01-03T17:00:00.000Z / 1609693200</td>
</tr>
</tbody></table>
<p><img src="/img/java/time/after_convert_time_zone+2.png" alt="after_convert_time_zone+2"></p>
<p><img src="/img/java/time/after_convert_time_zone+8.png" alt="after_convert_time_zone+8"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>《Java 8 实战》</li>
<li>Java SE Docs</li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6" target="_blank" rel="noopener">协调世界时（UTC） - 维基百科</a></li>
<li><a href="https://www.zeitverschiebung.net/cn/" target="_blank" rel="noopener">时区转换器：计算世界各个时区的时差</a></li>
<li><a href="https://time.is/UTC" target="_blank" rel="noopener">https://time.is/UTC</a></li>
<li><a href="http://www.timezoneconverter.com/cgi-bin/zoneinfo" target="_blank" rel="noopener">Time Zone Converter</a></li>
<li><a href="https://www.coder.work/article/6269420" target="_blank" rel="noopener">《Java时区数据库与IANA数据》</a></li>
<li><a href="https://segmentfault.com/q/1010000000262788" target="_blank" rel="noopener">《Mysql JDBC里的useTimezone参数是做什么用的？》</a></li>
</ul>
</div></article></div><div class="right-container"><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/DNS/" style="font-size: 12.5px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GNU-Linux/" style="font-size: 16.67px;">GNU/Linux</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 19.17px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 11.67px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10.83px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15.83px;">Spring</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 18.33px;">前端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">响应式编程</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 12.5px;">安全</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">并发编程</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 13.33px;">建站</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 12.5px;">管理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.17px;">读书笔记</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 12.5px;">金融</a></div></div><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2018/04/08/java-enum/" class="prev">PREV</a><a href="/2018/04/05/java8-time/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2021 <a href="https://github.com/qidawu" target="_blank">Qida's Blog</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>