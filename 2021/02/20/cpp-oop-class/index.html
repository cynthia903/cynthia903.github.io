<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> C/C++ 语言系列（九）面向对象编程之类、类模板、类指针 · Qida's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="C/C++ 语言系列（九）面向对象编程之类、类模板、类指针 - Qida's Blog"><meta name="keywords"><meta name="author" content="Qida's Blog"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://qidawu.github.io/atom.xml" title="Qida's Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><a href="/" class="title-link">Qida's Blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">C/C++ 语言系列（九）面向对象编程之类、类模板、类指针</h1><div class="post-info">2021-02-20<a href="/tags/C-C/" title="C/C++" class="post-demo">C/C++</a></div><div class="post-content"><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>类的声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">class_name</span> &#123;</span></span><br><span class="line">  access_specifier_1:</span><br><span class="line">    member1;</span><br><span class="line">  access_specifier_2:</span><br><span class="line">    member2;</span><br><span class="line">  ...</span><br><span class="line">&#125; object_names;</span><br></pre></td></tr></table></figure>

<p><img src="/img/cpp/cpp-classes-objects.png" alt=""></p>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><ul>
<li><code>private</code> members of a class are accessible only from within other members of the same class (or from their <code>friend</code>). By default, all members of a class have private access for all its members.</li>
<li><code>protected</code> members are accessible from other members of the same class (or from their <code>friend</code>), but also from members of their derived classes.</li>
<li>Finally, <code>public</code> members are accessible from anywhere where the object is visible.</li>
</ul>
<h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><p>在 C++ 中，每一个对象都能通过 <code>this</code> 指针来访问自己的地址。<code>this</code> 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。</p>
<p>友元函数没有 <code>this</code> 指针，因为友元不是类的成员。只有成员函数才有 <code>this</code> 指针。</p>
<h2 id="静态成员（static）"><a href="#静态成员（static）" class="headerlink" title="静态成员（static）"></a>静态成员（static）</h2><p><img src="/img/cpp/cpp-static-members.png" alt=""></p>
<p><code>static</code> 关键字用于修饰静态成员变量或函数。限制如下：</p>
<ul>
<li>无法访问类的非静态成员变量或函数；</li>
<li>无法使用 <code>this</code> 指针。</li>
</ul>
<p>静态成员的引用方式：<code>Runoob:runoob_age</code></p>
<h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>有两种方式定义类的成员函数：</p>
<ul>
<li>内联成员函数（<em>inline</em> member function）</li>
<li>普通成员函数（not-inline member function）</li>
</ul>
<p>两种方式并不会导致行为上的差异，而只会导致可能的编译器优化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// classes example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// declaration of a member function within the class</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_values</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="comment">// defining a member function completely within the class definition</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">width</span>*<span class="built_in">height</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// definition of a member function of a class outside the class itself.</span></span><br><span class="line"><span class="comment">// The scope operator (::) specifies the class to which the member being defined belongs, granting exactly the same scope properties as if this function definition was directly included within the class definition.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Rectangle::set_values</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">width</span> = x;</span><br><span class="line">  <span class="built_in">height</span> = y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  Rectangle <span class="built_in">rect</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// public members of object can be accessed by dot operator (.)</span></span><br><span class="line">  <span class="built_in">rect</span>.set_values (<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"area: "</span> &lt;&lt; <span class="built_in">rect</span>.area() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h3><p>To specify that a member is a <code>const</code> member, the <code>const</code> keyword shall follow the function prototype, after the closing parenthesis for its parameters:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;        <span class="comment">// const member function</span></span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>类的<strong>构造函数</strong>是类的一种特殊的成员函数，构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回<code>void</code>。它会在每次创建类的新对象时执行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用有参构造函数</span></span><br><span class="line"><span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;	<span class="comment">// Object is being created, width=1, height=2</span></span><br><span class="line"><span class="comment">// 调用默认构造函数</span></span><br><span class="line">Rectangle rectb;      <span class="comment">// Object is being created</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数重载"><a href="#构造函数重载" class="headerlink" title="构造函数重载"></a>构造函数重载</h3><blockquote>
<p>Overloading constructors</p>
<p>Like any other function, a constructor can also be overloaded with different versions taking different parameters: with a different number of parameters and/or parameters of different types. The compiler will automatically call the one whose parameters match the arguments:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明一个无参构造函数</span></span><br><span class="line">    Rectangle();</span><br><span class="line">    <span class="comment">// 声明一个有参构造函数</span></span><br><span class="line">    Rectangle(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个无参构造函数</span></span><br><span class="line">Rectangle::Rectangle() &#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个有参构造函数</span></span><br><span class="line">Rectangle::Rectangle(<span class="keyword">int</span> <span class="built_in">width</span>, <span class="keyword">int</span> <span class="built_in">height</span>) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;<span class="built_in">width</span> = <span class="built_in">width</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;<span class="built_in">height</span> = <span class="built_in">height</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created, width="</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">width</span> &lt;&lt; <span class="string">", height="</span> &lt;&lt; <span class="keyword">this</span>-&gt;<span class="built_in">height</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>This example introduces a special kind constructor: the <em>default constructor</em>. The <em>default constructor</em> is the constructor that takes no parameters, and it is special because it is called when an object is declared but is not initialized with any arguments. In the example above, the <em>default constructor</em> is called for <code>rectb</code>. Note how <code>rectb</code> is not even constructed with an empty set of parentheses - in fact, empty parentheses cannot be used to call the default constructor:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rectangle rectb;   <span class="comment">// ok, default constructor called</span></span><br><span class="line"><span class="function">Rectangle <span class="title">rectc</span><span class="params">()</span></span>; <span class="comment">// oops, default constructor NOT called, empty parentheses interpreted as a function declaration</span></span><br></pre></td></tr></table></figure>

<p>This is because the empty set of parentheses would make of <code>rectc</code> a function declaration instead of an object declaration: It would be a function that takes no arguments and returns a value of type <code>Rectangle</code>.</p>
</blockquote>
<h3 id="在构造函数中初始化成员变量"><a href="#在构造函数中初始化成员变量" class="headerlink" title="在构造函数中初始化成员变量"></a>在构造函数中初始化成员变量</h3><p>使用构造函数初始化其他成员变量时，有下面两种方式：</p>
<blockquote>
<p>Member initialization in constructors</p>
<p>When a constructor is used to initialize other members, these other members can be initialized directly, without resorting to statements in its body. This is done by inserting, before the constructor’s body, a colon (<code>:</code>) and a list of initializations for class members. For example, consider a class with the following declaration:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line"> <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Rectangle(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">width</span>*<span class="built_in">height</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The constructor for this class could be defined, as usual, as:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rectangle::Rectangle(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123; <span class="built_in">width</span>=x; <span class="built_in">height</span>=y; &#125;</span><br></pre></td></tr></table></figure>

<p>But it could also be defined using <em>member initialization</em> as:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rectangle::Rectangle(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : <span class="built_in">width</span>(x), <span class="built_in">height</span>(y) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>Or even:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rectangle::Rectangle(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : Shape(x, y) &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>Note how in this last case, the constructor does nothing else than initialize its members, hence it has an empty function body.</p>
</blockquote>
<h2 id="析构函数（-）"><a href="#析构函数（-）" class="headerlink" title="析构函数（~）"></a>析构函数（~）</h2><p>类的<strong>析构函数</strong>是类的一种特殊的成员函数，它会在每次删除对象时执行，有助于在跳出程序前释放资源（比如关闭文件、释放内存等）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Rectangle();</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~Rectangle();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Rectangle::Rectangle()&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being created"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Rectangle::~Rectangle()&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Object is being deleted"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>析构函数要点：</p>
<ul>
<li>析构函数名称与类的名称完全相同，前缀使用关键字 <code>~</code>；</li>
<li>一个类中只能声明一个析构函数（destructor cannot be redeclared）；</li>
<li>析构函数无参数（destructor cannot have any parameters）；</li>
<li>析构函数无返回值（destructor cannot have a return type）；</li>
<li>不可重载。</li>
</ul>
<h2 id="友元函数（friend）"><a href="#友元函数（friend）" class="headerlink" title="友元函数（friend）"></a>友元函数（friend）</h2><p>类的友元函数（<code>friend</code> 关键字），有权访问类的所有私有（<code>private</code>）和保护（<code>protected</code>）成员变量。尽管友元函数在类中声明，但是<strong>友元函数并不是类的成员函数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">(Rectangle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(Rectangle <span class="built_in">rect</span>)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">rect</span>.<span class="built_in">height</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">(Rectangle <span class="built_in">rect</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">rect</span>.<span class="built_in">width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Rectangle <span class="title">rect1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"width: "</span> &lt;&lt; getWidth(rect1) &lt;&lt; <span class="string">" height: "</span> &lt;&lt; getHeight(rect1) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// width: 1 height: 2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>友元函数破坏了类的封装性，实践中不建议使用。</p>
<h2 id="重载（overload）"><a href="#重载（overload）" class="headerlink" title="重载（overload）"></a>重载（overload）</h2><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>一、支持重载的运算符：</p>
<p>C++ allows most operators to be overloaded so that their behavior can be defined for just about any type, including classes. Here is a list of all the operators that can be overloaded:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+    -    *    &#x2F;    &#x3D;    &lt;    &gt;    +&#x3D;   -&#x3D;   *&#x3D;   &#x2F;&#x3D;   &lt;&lt;   &gt;&gt;</span><br><span class="line">&lt;&lt;&#x3D;  &gt;&gt;&#x3D;  &#x3D;&#x3D;   !&#x3D;   &lt;&#x3D;   &gt;&#x3D;   ++   --   %    &amp;    ^    !    |</span><br><span class="line">~    &amp;&#x3D;   ^&#x3D;   |&#x3D;   &amp;&amp;   ||   %&#x3D;   []   ()   ,    -&gt;*  -&gt;   new </span><br><span class="line">delete    new[]     delete[]</span><br></pre></td></tr></table></figure>

<p>Operators are overloaded by means of <code>operator</code> functions, which are regular functions with special names: their name begins by the <code>operator</code> keyword followed by the <em>operator sign</em> that is overloaded. The syntax is: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">type <span class="keyword">operator</span> <span class="title">sign</span> <span class="params">(parameters)</span> </span>&#123; <span class="comment">/*... body ...*/</span> &#125;</span><br></pre></td></tr></table></figure>

<p>二、重载运算符的不同形式：</p>
<p>There is a table with a summary of the parameters needed for each of the different operators than can be overloaded (please, replace <code>@</code> by the operator in each case):</p>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Operator</th>
<th>Member function</th>
<th>Non-member function</th>
</tr>
</thead>
<tbody><tr>
<td><code>@a</code></td>
<td><code>+ - * &amp; ! ~ ++ --</code></td>
<td><code>A::operator@()</code></td>
<td><code>operator@(A)</code></td>
</tr>
<tr>
<td><code>a@</code></td>
<td><code>++ --</code></td>
<td><code>A::operator@(int)</code></td>
<td><code>operator@(A,int)</code></td>
</tr>
<tr>
<td><code>a@b</code></td>
<td><code>+ - * / % ^ &amp; | &lt; &gt; == != &lt;= &gt;= &lt;&lt; &gt;&gt; &amp;&amp; || ,</code></td>
<td><code>A::operator@(B)</code></td>
<td><code>operator@(A,B)</code></td>
</tr>
<tr>
<td><code>a@b</code></td>
<td><code>= += -= *= /= %= ^= &amp;= |= &lt;&lt;= &gt;&gt;= []</code></td>
<td><code>A::operator@(B)</code></td>
<td>-</td>
</tr>
<tr>
<td><code>a(b,c...)</code></td>
<td><code>()</code></td>
<td><code>A::operator()(B,C...)</code></td>
<td>-</td>
</tr>
<tr>
<td><code>a-&gt;b</code></td>
<td><code>-&gt;</code></td>
<td><code>A::operator-&gt;()</code></td>
<td>-</td>
</tr>
<tr>
<td><code>(TYPE) a</code></td>
<td><code>TYPE</code></td>
<td><code>A::operator TYPE()</code></td>
<td>-</td>
</tr>
</tbody></table>
<p>Where <code>a</code> is an object of class <code>A</code>, <code>b</code> is an object of class <code>B</code> and <code>c</code> is an object of class <code>C</code>. <code>TYPE</code> is just any type (that operators overloads the conversion to type <code>TYPE</code>).</p>
<p>Notice that some operators may be overloaded in two forms: either as a member function or as a non-member function.</p>
<p>三、例子：</p>
<p>For example, <em>cartesian vectors</em> are sets of two coordinates: <code>x</code> and <code>y</code>. The addition operation of two <em>cartesian vectors</em> is defined as the addition both <code>x</code> coordinates together, and both <code>y</code> coordinates together. For example, adding the <em>cartesian vectors</em> <code>(3,1)</code> and <code>(1,2)</code> together would result in <code>(3+1,1+2) = (4,3)</code>. This could be implemented in C++ with the following code:</p>
<p><img src="/img/cpp/overloading_operators.png" alt="Overloading operators"></p>
<p>The function <code>operator+</code> of class <code>CVector</code> overloads the addition operator (<code>+</code>) for that type. Once declared, this function can be called either implicitly using the operator, or explicitly using its functional name:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called either implicitly using the operator</span></span><br><span class="line">c = a + b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or explicitly using its functional name</span></span><br><span class="line">c = a.<span class="keyword">operator</span>+ (b);</span><br></pre></td></tr></table></figure>

<p>Both expressions are equivalent.</p>
<p>四、注意点：</p>
<blockquote>
<p>Attention</p>
<p>The operator overloads are just regular functions which can have any behavior; there is actually no requirement that the operation performed by that overload bears a relation to the mathematical or usual meaning of the operator, although it is strongly recommended. For example, a class that overloads <code>operator+</code> to actually subtract or that overloads <code>operator==</code> to fill the object with zeros, is perfectly valid, although using such a class could be challenging.</p>
</blockquote>
<h2 id="函数重定义（redefine）"><a href="#函数重定义（redefine）" class="headerlink" title="函数重定义（redefine）"></a>函数重定义（redefine）</h2><p>即 Java 语言中的方法重写（rewrite）。</p>
<h1 id="类指针"><a href="#类指针" class="headerlink" title="类指针"></a>类指针</h1><p>Objects can also be pointed to by pointers: Once declared, a class becomes a valid type, so it can be used as the type pointed to by a pointer. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a pointer to an object of class Rectangle.</span></span><br><span class="line">Rectangle * prect;</span><br></pre></td></tr></table></figure>

<p>Similarly as with plain data structures, the members of an object can be accessed directly from a pointer by using the arrow operator (<code>-&gt;</code>). Here is an example with some possible combinations:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pointer to classes example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Rectangle(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : <span class="built_in">width</span>(x), <span class="built_in">height</span>(y) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">width</span> * <span class="built_in">height</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">Rectangle <span class="title">obj</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">  Rectangle * foo, * bar;  <span class="comment">// 类指针（Pointers to classes）</span></span><br><span class="line">  foo = &amp;obj;</span><br><span class="line">  bar = <span class="keyword">new</span> Rectangle (<span class="number">5</span>, <span class="number">6</span>);  <span class="comment">// 参考：http://www.cplusplus.com/doc/tutorial/dynamic/</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"obj's area: "</span> &lt;&lt; obj.area() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"*foo's area: "</span> &lt;&lt; foo-&gt;area() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"*foo's area: "</span> &lt;&lt; (*foo).area() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"*bar's area: "</span> &lt;&lt; bar-&gt;area() &lt;&lt; <span class="string">'\n'</span>;    </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"*bar's area: "</span> &lt;&lt; (*bar).area() &lt;&lt; <span class="string">'\n'</span>;    </span><br><span class="line">  <span class="keyword">delete</span> bar;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This example makes use of several operators to operate on objects and pointers (operators <code>*</code>, <code>&amp;</code>, <code>.</code>, <code>-&gt;</code>). They can be interpreted as:</p>
<table>
<thead>
<tr>
<th>expression</th>
<th>can be read as</th>
</tr>
</thead>
<tbody><tr>
<td><code>*x</code></td>
<td>pointed to by <code>x</code></td>
</tr>
<tr>
<td><code>&amp;x</code></td>
<td>address of <code>x</code></td>
</tr>
<tr>
<td><code>x.y</code></td>
<td>member <code>y</code> of object <code>x</code></td>
</tr>
<tr>
<td><code>x-&gt;y</code></td>
<td>member <code>y</code> of object pointed to by <code>x</code></td>
</tr>
<tr>
<td><code>(*x).y</code></td>
<td>member <code>y</code> of object pointed to by <code>x</code> (equivalent to the previous one)</td>
</tr>
</tbody></table>
<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>模板是<strong>泛型</strong>编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。</p>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// function templates</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">getmax</span> <span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  T retval;</span><br><span class="line">  retval = a &gt; b ? a : b;</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> maxInt = getmax(<span class="number">100</span>, <span class="number">75</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; maxInt &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> maxDouble = getmax(<span class="number">3.3</span>, <span class="number">2.18</span>);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; maxDouble &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 3.3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// no matching function for call to 'getmax'</span></span><br><span class="line">  <span class="comment">// char maxChar = getmax('a', 1.99);</span></span><br><span class="line">  <span class="comment">// cout &lt;&lt; maxChar &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>Just like we can create <em>function templates</em>, we can also create <em>class templates</em>, allowing classes to have members that use <em>template parameters</em> as types. For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class templates</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">MyPair</span> &#123;</span></span><br><span class="line">    T a, b;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    MyPair (T first, T second)</span><br><span class="line">      &#123;a=first; b=second;&#125;</span><br><span class="line">    <span class="function">T <span class="title">getmax</span> <span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// In case that a member function is defined outside the defintion of the class template, it shall be preceded with the template &lt;...&gt; prefix</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">MyPair</span>&lt;T&gt;:</span>:getmax ()</span><br><span class="line">&#123;</span><br><span class="line">  T retval;</span><br><span class="line">  retval = a &gt; b ? a : b;</span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">MyPair&lt;<span class="keyword">int</span>&gt; <span class="title">myobject</span><span class="params">(<span class="number">100</span>, <span class="number">75</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; myobject.getmax() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">  <span class="function">MyPair&lt;<span class="keyword">double</span>&gt; <span class="title">myfloats</span><span class="params">(<span class="number">3.3</span>, <span class="number">2.18</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; myfloats.getmax() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 3.3</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// implicit conversion from 'double' to 'char' changes value from 1.99 to 1</span></span><br><span class="line">  <span class="comment">// MyPair&lt;char&gt; mychars('a', 1.99);</span></span><br><span class="line">  <span class="comment">// cout &lt;&lt; mychars.getmax() &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Notice the syntax of the definition of member function <code>getmax</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">mypair</span>&lt;T&gt;:</span>:getmax ()</span><br></pre></td></tr></table></figure>

<p>There are three <code>T</code>‘s in this declaration: The first one is the template parameter. The second <code>T</code> refers to the type returned by the function. And the third <code>T</code> (the one between angle brackets) is also a requirement: It specifies that this function’s template parameter is also the class template parameter.</p>
<h2 id="模板类"><a href="#模板类" class="headerlink" title="模板类"></a>模板类</h2><p>模板类是类模板实例化后的一个产物。</p>
<p>It is possible to define a different implementation for a template when a specific type is passed as template argument. This is called a <em>template specialization</em>.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// template specialization</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class template:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">mycontainer</span> &#123;</span></span><br><span class="line">    T element;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    mycontainer (T arg) &#123;element=arg;&#125;</span><br><span class="line">    <span class="function">T <span class="title">increase</span> <span class="params">()</span> </span>&#123;<span class="keyword">return</span> ++element;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class template specialization:</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span> &lt;char&gt; &#123;</span></span><br><span class="line">    <span class="keyword">char</span> element;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    mycontainer (<span class="keyword">char</span> arg) &#123;element=arg;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">uppercase</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ((element&gt;=<span class="string">'a'</span>)&amp;&amp;(element&lt;=<span class="string">'z'</span>))</span><br><span class="line">      element+=<span class="string">'A'</span>-<span class="string">'a'</span>;</span><br><span class="line">      <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">mycontainer&lt;<span class="keyword">int</span>&gt; <span class="title">myint</span> <span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">  <span class="function">mycontainer&lt;<span class="keyword">char</span>&gt; <span class="title">mychar</span> <span class="params">(<span class="string">'j'</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; myint.increase() &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 8</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; mychar.uppercase() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// J</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This is the syntax used for the class template specialization:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span> &lt;char&gt; &#123;</span> ... &#125;;</span><br></pre></td></tr></table></figure>

<p>First of all, notice that we precede the class name with <code>template&lt;&gt;</code> , including an empty parameter list. This is because all types are known and no template arguments are required for this specialization, but still, it is the specialization of a class template, and thus it requires to be noted as such.</p>
<p>But more important than this prefix, is the <code>&lt;char&gt;</code> specialization parameter after the class template name. This specialization parameter itself identifies the type for which the template class is being specialized (<code>char</code>). Notice the differences between the generic class template and the specialization:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">mycontainer</span> &#123;</span> ... &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">mycontainer</span> &lt;char&gt; &#123;</span> ... &#125;;</span><br></pre></td></tr></table></figure>

<p>The first line is the <em>generic template</em>, and the second one is the <em>specialization</em>.</p>
<p>When we declare specializations for a template class, we must also define all its members, even those identical to the generic template class, because there is no “inheritance” of members from the generic template to the specialization.</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cplusplus.com/doc/tutorial/classes/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/classes/</a></p>
<p><a href="http://www.cplusplus.com/doc/tutorial/templates/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/templates/</a></p>
<p><a href="http://www.cplusplus.com/doc/tutorial/classes2/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/classes2/</a></p>
<p><a href="https://www.cplusplus.com/doc/oldtutorial/templates/" target="_blank" rel="noopener">https://www.cplusplus.com/doc/oldtutorial/templates/</a></p>
<p><a href="https://www.runoob.com/cplusplus/cpp-classes-objects.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-classes-objects.html</a></p>
<p><a href="https://www.runoob.com/cplusplus/cpp-templates.html" target="_blank" rel="noopener">https://www.runoob.com/cplusplus/cpp-templates.html</a></p>
</div></article></div><div class="right-container"><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/DNS/" style="font-size: 12.5px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GNU-Linux/" style="font-size: 16.67px;">GNU/Linux</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 19.17px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 11.67px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10.83px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15.83px;">Spring</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 18.33px;">前端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">响应式编程</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 12.5px;">安全</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">并发编程</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 13.33px;">建站</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 12.5px;">管理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.17px;">读书笔记</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 12.5px;">金融</a></div></div><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2021/02/25/cpp-oop-inheritance-and-polymorphism/" class="prev">PREV</a><a href="/2021/02/18/cpp-type-aliases/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2021 <a href="https://github.com/qidawu" target="_blank">Qida's Blog</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>