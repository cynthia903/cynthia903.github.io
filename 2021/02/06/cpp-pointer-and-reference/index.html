<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> C/C++ 语言系列（四）复合数据类型之指针、引用 · Qida's Blog</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="C/C++ 语言系列（四）复合数据类型之指针、引用 - Qida's Blog"><meta name="keywords"><meta name="author" content="Qida's Blog"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://qidawu.github.io/atom.xml" title="Qida's Blog"><meta name="generator" content="Hexo 4.2.1"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><a href="/" class="title-link">Qida's Blog</a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">C/C++ 语言系列（四）复合数据类型之指针、引用</h1><div class="post-info">2021-02-06<a href="/tags/C-C/" title="C/C++" class="post-demo">C/C++</a></div><div class="post-content"><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>引用是一个别名，也就是说，它是某个已存在变量的另一个名字。修改引用等同于修改被引用变量自身。</p>
<p>一个变量可以有多个引用。</p>
<h2 id="声明引用"><a href="#声明引用" class="headerlink" title="声明引用"></a>声明引用</h2><p>不存在<strong>空引用</strong>。声明引用的同时，必须初始化，否则报编译错误如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;ref;  <span class="comment">// declaration of reference variable 'ref' requires an initializer</span></span><br></pre></td></tr></table></figure>

<p>引用一旦初始化，就不能再指向另一个变量。修改引用等同于修改被引用变量本身。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。</p>
<h2 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h2><p>一元运算符 <code>*</code> 用于声明一个指针变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span>   *bp;    <span class="comment">// 声明一个布尔型的空指针</span></span><br><span class="line"><span class="keyword">char</span>   *ch;    <span class="comment">// 声明一个字符型的空指针</span></span><br><span class="line"><span class="keyword">int</span>    *ip;    <span class="comment">// 声明一个整型的空指针</span></span><br><span class="line"><span class="keyword">double</span> *dp;    <span class="comment">// 声明声明一个 double 型的空指针</span></span><br><span class="line"><span class="keyword">float</span>  *fp;    <span class="comment">// 声明一个浮点型的空指针</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以声明空指针。</li>
<li>除了常指针，其它指针可以在任何时间被初始化。</li>
<li>所有指针的值的实际数据类型，不管是布尔型、字符型、整型、浮点型，还是其它的数据类型，都是一样的，其值都是一个<strong>代表内存地址</strong>的<strong>十六进制数</strong>。</li>
<li>不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同，<strong>因此执行递增或递减时的步长不同</strong>。</li>
</ul>
<h2 id="获取指针大小"><a href="#获取指针大小" class="headerlink" title="获取指针大小"></a>获取指针大小</h2><table>
<thead>
<tr>
<th>操作系统</th>
<th>指针变量的存储大小</th>
</tr>
</thead>
<tbody><tr>
<td>32 位</td>
<td>4 个字节</td>
</tr>
<tr>
<td>64 位</td>
<td>8 个字节</td>
</tr>
</tbody></table>
<p>本机为 64 位操作系统，验证如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">bool</span>*)  <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">char</span>*)  <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">int</span>*)    <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">float</span>*)  <span class="comment">// 8</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">double</span>*) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h2 id="指针的算数运算"><a href="#指针的算数运算" class="headerlink" title="指针的算数运算"></a>指针的算数运算</h2><p>可以对指针进行四种算术运算：<code>++</code>、<code>--</code>、<code>+</code>、<code>-</code>。运算后，指针保存新的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> * p = &amp;a;</span><br><span class="line"></span><br><span class="line">p = &amp;b;</span><br><span class="line">p += <span class="number">1</span>;</span><br><span class="line">p -= <span class="number">1</span>;</span><br><span class="line">p++;</span><br><span class="line">p--;</span><br><span class="line">++p;</span><br><span class="line">--p;</span><br></pre></td></tr></table></figure>

<h2 id="重点考点"><a href="#重点考点" class="headerlink" title="重点考点"></a>重点考点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常指针</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向常量的指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向常量的常指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p = &amp;a;</span><br></pre></td></tr></table></figure>

<h3 id="常指针"><a href="#常指针" class="headerlink" title="常指针"></a>常指针</h3><p>顾名思义，指针本身是个常量，不能修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表达式必须是可修改的左值</span></span><br><span class="line"><span class="comment">// cannot assign to variable 'p' with const-qualified type 'int *const'</span></span><br><span class="line">p = &amp;b;</span><br><span class="line">p += <span class="number">1</span>;</span><br><span class="line">p -= <span class="number">1</span>;</span><br><span class="line">p++;</span><br><span class="line">p--;</span><br><span class="line">++p;</span><br><span class="line">--p;</span><br></pre></td></tr></table></figure>

<p>常见的常指针，例如：</p>
<ul>
<li>数组名</li>
</ul>
<h3 id="指向常量的指针"><a href="#指向常量的指针" class="headerlink" title="指向常量的指针"></a>指向常量的指针</h3><p>顾名思义，指针指向的是常量，不能修改其值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针本身可以重新赋值</span></span><br><span class="line">p = &amp;b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但不能修改指针指向的常量的值，否则报编译错误：</span></span><br><span class="line"><span class="comment">// 表达式必须是可修改的左值</span></span><br><span class="line"><span class="comment">// read-only variable is not assignable</span></span><br><span class="line">*p += <span class="number">1</span>;</span><br><span class="line">*p -= <span class="number">1</span>;</span><br><span class="line">(*p)++;</span><br><span class="line">(*p)--;</span><br><span class="line">++(*p);</span><br><span class="line">--(*p);</span><br></pre></td></tr></table></figure>

<h3 id="指向常量的常指针"><a href="#指向常量的常指针" class="headerlink" title="指向常量的常指针"></a>指向常量的常指针</h3><p>结合了上述两种特性。</p>
<h2 id="常见指针"><a href="#常见指针" class="headerlink" title="常见指针"></a>常见指针</h2><h3 id="字符串指针"><a href="#字符串指针" class="headerlink" title="字符串指针"></a>字符串指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串指针（指向一个常量字符串，它被存放在程序的静态数据区，一旦定义就不能改变）</span></span><br><span class="line"><span class="keyword">char</span> * str = <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arrayName[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// &amp;arrayName = 0x7ffee7376620</span></span><br><span class="line"><span class="keyword">int</span> * p = arrayName;  <span class="comment">// // 数组指针（Pointers to array，即指向数组中第一个元素的地址）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 0x7ffee7376620 0x7ffee7376624 0x7ffee7376628 0x7ffee737662c 0x7ffee7376630</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; *p++ &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">product apple;</span><br><span class="line"><span class="comment">// 结构体指针（Pointers to struct）</span></span><br><span class="line">product * p = &amp;apple;</span><br><span class="line"><span class="comment">// The arrow operator (-&gt;) is a dereference operator that is used exclusively with pointers to objects that have members. This operator serves to access the member of an object directly from its address.</span></span><br><span class="line">p-&gt;weight;</span><br><span class="line"><span class="comment">// equivalent to:</span></span><br><span class="line">(*p).weight;</span><br></pre></td></tr></table></figure>

<h3 id="类指针"><a href="#类指针" class="headerlink" title="类指针"></a>类指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rectangle <span class="title">rect</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="comment">// 类指针（Pointers to classes），主要用于多态性</span></span><br><span class="line">Shape * p = &amp;<span class="built_in">rect</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member y of object x</span></span><br><span class="line"><span class="built_in">rect</span>.area();  <span class="comment">// 12</span></span><br><span class="line"><span class="comment">// member y of object pointed to by x</span></span><br><span class="line">p-&gt;area();    <span class="comment">// 12</span></span><br><span class="line"><span class="comment">// equivalent to:</span></span><br><span class="line">(*p).area();  <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<h1 id="引用与指针对比"><a href="#引用与指针对比" class="headerlink" title="引用与指针对比"></a>引用与指针对比</h1><p>常见问题，下列代码的区别？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*p</span><br><span class="line">&amp;p</span><br><span class="line">*&amp;p</span><br><span class="line">&amp;*p</span><br></pre></td></tr></table></figure>

<p>要解决这个问题，首先需要了解这两个运算符的区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>在赋值运算符左侧</th>
<th>在赋值运算符右侧</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>表示声明指针</td>
<td>表示<strong>取值运算符</strong></td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>表示声明引用</td>
<td>表示<strong>取址运算符</strong></td>
</tr>
</tbody></table>
<p>代码示例如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; b = a;</span><br><span class="line"><span class="keyword">int</span>* p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="string">", &amp;a = "</span> &lt;&lt; &amp;a &lt;&lt; <span class="string">", *&amp;a = "</span> &lt;&lt; *&amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="string">", &amp;b = "</span> &lt;&lt; &amp;b &lt;&lt; <span class="string">", *&amp;b = "</span> &lt;&lt; *&amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"p = "</span> &lt;&lt; p &lt;&lt; <span class="string">", &amp;p = "</span> &lt;&lt; &amp;p &lt;&lt; <span class="string">", *p = "</span> &lt;&lt; *p &lt;&lt; <span class="string">", &amp;*p = "</span> &lt;&lt; &amp;*p &lt;&lt; <span class="string">", *&amp;p = "</span> &lt;&lt; *&amp;p &lt;&lt; <span class="built_in">endl</span></span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 10, &amp;a &#x3D; 0x7ffee483763c, *&amp;a &#x3D; 10</span><br><span class="line">b &#x3D; 10, &amp;b &#x3D; 0x7ffee483763c, *&amp;b &#x3D; 10</span><br><span class="line">p &#x3D; 0x7ffee483763c, &amp;p &#x3D; 0x7ffee4837628, *p &#x3D; 10, &amp;*p &#x3D; 0x7ffee483763c, *&amp;p &#x3D; 0x7ffee483763c</span><br></pre></td></tr></table></figure>

<p>总结如下：</p>
<table>
<thead>
<tr>
<th>指针变量</th>
<th>结果</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>p</code></td>
<td>0x7ffee483763c</td>
<td>返回指针变量 <code>p</code> 保存的地址</td>
</tr>
<tr>
<td><code>*p</code></td>
<td>10</td>
<td>返回指针变量 <code>p</code> 保存的地址的实际值</td>
</tr>
<tr>
<td><code>&amp;p</code></td>
<td>0x7ffee4837628</td>
<td>返回指针变量 <code>p</code> 自身的地址</td>
</tr>
<tr>
<td><code>&amp;*p</code></td>
<td>0x7ffee483763c</td>
<td>返回指针变量 <code>p</code> 保存的地址的实际值的地址</td>
</tr>
<tr>
<td><code>*&amp;p</code></td>
<td>0x7ffee483763c</td>
<td>返回指针变量 <code>p</code> 自身的地址的实际值</td>
</tr>
</tbody></table>
<p>引用与指针的区别，如下图：</p>
<p><img src="/img/cpp/pointer_and_reference.png" alt="引用与指针对比"></p>
<h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配<strong>堆内存（memory heap）</strong>，这会返回所分配的空间<strong>地址</strong>。</p>
<p>动态内存分配使用 <code>new</code> 运算符，后面跟上一个数据类型，语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allocate memory to contain one single element of specified type</span></span><br><span class="line">pointer = <span class="keyword">new</span> type</span><br><span class="line">  </span><br><span class="line"><span class="comment">// allocate a block (an array) of elements of specified type, where `number_of_elements` is an integer value representing the amount of these.</span></span><br><span class="line"><span class="comment">// it returns a pointer to the beginning of the new block of memory allocated.</span></span><br><span class="line">pointer = <span class="keyword">new</span> type [number_of_elements]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * bar = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">5</span>); <span class="comment">// int bar = 5</span></span><br><span class="line"><span class="keyword">int</span> * foo = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]; <span class="comment">// int foo[5]</span></span><br></pre></td></tr></table></figure>

<p><img src="/img/cpp/dynamic_memory.png" alt=""></p>
<blockquote>
<p>In this case, the system dynamically allocates space for five elements of type <code>int</code> and returns a pointer to the first element of the sequence, which is assigned to <code>foo</code> (a pointer). Therefore, <code>foo</code> now points to a valid block of memory with space for five elements of type <code>int</code>.</p>
<p>Here, <code>foo</code> is a pointer, and thus, the first element pointed to by <code>foo</code> can be accessed either with the expression <code>foo[0]</code> or the expression <code>*foo</code> (both are equivalent). The second element can be accessed either with <code>foo[1]</code> or <code>*(foo+1)</code>, and so on…</p>
</blockquote>
<p>由于使用动态内存分配机制，因此 <code>number_of_elements</code> 可以是一个变量，变量值在运行时才决定，例如：<code>p = new int[i];</code>。</p>
<hr>
<p>声明普通数组与使用 <code>new</code> 分配动态内存的区别：</p>
<blockquote>
<p>There is a substantial difference between declaring a normal array and allocating dynamic memory for a block of memory using <code>new</code>. The most important difference is that the size of a regular array needs to be a <em>constant expression</em>, and thus its size has to be determined at the moment of designing the program, before it is run, whereas the dynamic memory allocation performed by <code>new</code> allows to assign memory during runtime using any variable value as size.</p>
</blockquote>
<hr>
<p>C++ 提供了两种标准机制来检查堆内存分配是否成功：</p>
<blockquote>
<p>The dynamic memory requested by our program is allocated by the system from the memory heap. However, computer memory is a limited resource, and it can be exhausted. Therefore, there are no guarantees that all requests to allocate memory using operator <code>new</code> are going to be granted by the system.</p>
<p>C++ provides two standard mechanisms to check if the allocation was successful:</p>
</blockquote>
<p>机制一：异常机制</p>
<blockquote>
<p>One is by handling exceptions. Using this method, an exception of type <code>bad_alloc</code> is thrown when the allocation fails. If this exception is thrown and it is not handled by a specific handler, the program execution is terminated.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">5</span>];  <span class="comment">// if allocation fails, an exception is thrown</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>机制二：返回空指针</p>
<blockquote>
<p>The other method is known as <code>nothrow</code>, and what happens when it is used is that when a memory allocation fails, instead of throwing a <code>bad_alloc</code> exception or terminating the program, the pointer returned by <code>new</code> is a <em>null pointer</em>, and the program continues its execution normally.</p>
<p>This method can be specified by using a special object called <code>nothrow</code>, declared in header <a href="http://www.cplusplus.com/%3Cnew%3E" target="_blank" rel="noopener"><code>&lt;new&gt;</code></a>, as argument for <code>new</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span> [<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>In this case, if the allocation of this block of memory fails, the failure can be detected by checking if <code>foo</code> is a null pointer:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * foo;</span><br><span class="line">foo = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span> [<span class="number">5</span>];</span><br><span class="line"><span class="keyword">if</span> (foo == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// error assigning memory. Take measures.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>This <code>nothrow</code> method is likely to produce less efficient code than exceptions, since it implies explicitly checking the pointer value returned after each and every allocation. Therefore, the exception mechanism is generally preferred, at least for critical allocations. But <code>nothrow</code> mechanism is more simplicity.</p>
<p>It is considered good practice for programs to always be able to handle failures to allocate memory, either by checking the pointer value (if <code>nothrow</code>) or by catching the proper exception.</p>
</blockquote>
<h2 id="动态内存回收"><a href="#动态内存回收" class="headerlink" title="动态内存回收"></a>动态内存回收</h2><p>如果您不再需要动态分配的内存空间，可以使用 <code>delete</code> 运算符，删除之前由 <code>new</code> 运算符分配的内存，以便该内存可再次用于其它动态内存分配。语法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// releases the memory of a single element allocated using new</span></span><br><span class="line"><span class="keyword">delete</span> bar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// releases the memory allocated for arrays of elements using new and a size in brackets ([])</span></span><br><span class="line"><span class="keyword">delete</span> [] foo; <span class="comment">// 不管所删除数组的维数多少，指针名前只用一对方括号 []</span></span><br></pre></td></tr></table></figure>

<h2 id="Dynamic-memory-in-C"><a href="#Dynamic-memory-in-C" class="headerlink" title="Dynamic memory in C"></a>Dynamic memory in C</h2><blockquote>
<p>C++ integrates the operators <code>new</code> and <code>delete</code> for allocating dynamic memory. But these were not available in the C language; instead, it used a library solution, with the functions <code>malloc</code>, <code>calloc</code>, <code>realloc</code> and <code>free</code>, defined in the header <a href="http://www.cplusplus.com/%3Ccstdlib%3E" target="_blank" rel="noopener"><code>&lt;cstdlib&gt;</code></a> (known as <code>&lt;stdlib.h&gt;</code> in C). The functions are also available in C++ and can also be used to allocate and deallocate dynamic memory.</p>
<p>Note, though, that the memory blocks allocated by these functions are not necessarily compatible with those returned by <code>new</code>, so they should not be mixed; each one should be handled with its own set of functions or operators.</p>
</blockquote>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cplusplus.com/doc/tutorial/pointers/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/pointers/</a></p>
<p><a href="http://www.cplusplus.com/doc/tutorial/dynamic/" target="_blank" rel="noopener">http://www.cplusplus.com/doc/tutorial/dynamic/</a></p>
<p><a href="https://stackoverflow.com/questions/4995899/difference-between-pointer-and-reference-in-c" target="_blank" rel="noopener">Difference between pointer and reference in C ?</a></p>
<p><a href="https://cdlwhm1217096231.github.io/C/C-%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%BC%A0%E5%80%BC%E3%80%81%E4%BC%A0%E5%9C%B0%E5%9D%80%E3%80%81%E4%BC%A0%E5%BC%95%E7%94%A8%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener">C++ 中的参数传递方式：传值、传地址、传引用总结</a></p>
<p><a href="https://www.crucial.cn/learn-with-crucial/memory/how-much-memory-does-your-windows-support" target="_blank" rel="noopener">32/64 位系统支持多大内存？</a></p>
</div></article></div><div class="right-container"><div class="widget"><div class="tagcloud"><h4>标签云</h4><a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/DNS/" style="font-size: 12.5px;">DNS</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/GNU-Linux/" style="font-size: 16.67px;">GNU/Linux</a> <a href="/tags/Git/" style="font-size: 17.5px;">Git</a> <a href="/tags/Java/" style="font-size: 20px;">Java</a> <a href="/tags/MySQL/" style="font-size: 19.17px;">MySQL</a> <a href="/tags/Nginx/" style="font-size: 11.67px;">Nginx</a> <a href="/tags/Redis/" style="font-size: 10.83px;">Redis</a> <a href="/tags/Spring/" style="font-size: 15.83px;">Spring</a> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">函数式编程</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 18.33px;">前端</a> <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">响应式编程</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 12.5px;">安全</a> <a href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 11.67px;">并发编程</a> <a href="/tags/%E5%BB%BA%E7%AB%99/" style="font-size: 13.33px;">建站</a> <a href="/tags/%E7%AE%A1%E7%90%86/" style="font-size: 12.5px;">管理</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 14.17px;">读书笔记</a> <a href="/tags/%E9%87%91%E8%9E%8D/" style="font-size: 12.5px;">金融</a></div></div><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2021/02/10/cpp-array/" class="prev">PREV</a><a href="/2021/02/04/cpp-function/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2021 <a href="https://github.com/qidawu" target="_blank">Qida's Blog</a></p><p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="/scripts/jquery-1.8.2.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>